'From Pharo5.0 of 16 April 2015 [Latest update: #50750] on 4 May 2016 at 2:43:21.824129 pm'!----QUIT----2016-05-04T14:43:21.828046+02:00 Pharo-50750.image priorSource: 0!----QUIT/NOSAVE----2016-05-04T14:44:40.111696+02:00 Pharo-50750.image priorSource: 93!----QUIT----2016-05-04T15:07:41.813729+02:00 Pharo-50750.image priorSource: 93!----QUIT----2016-05-06T09:32:23.845174+02:00 Pharo.image priorSource: 261!----QUIT----2016-05-06T09:32:27.065047+02:00 Pharo.image priorSource: 342!----QUIT----2016-05-06T09:32:32.006829+02:00 Pharo.image priorSource: 418!----QUIT----2016-05-08T10:49:37.375428+02:00 Pharo.image priorSource: 494!----QUIT----2016-05-08T10:49:40.17698+02:00 Pharo.image priorSource: 570!----QUIT----2016-05-08T10:49:45.070557+02:00 Pharo.image priorSource: 646!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/5/2016 23:02' prior: 57333776!commentForCurrentUpdate ^ '18167 NewValueHolder class>value: should use rawValue:	https://pharo.fogbugz.com/f/cases/18167'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/5/2016 23:02'!script50751	^ 'AST-Core-TheIntegrator.416.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.200.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.140.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1251.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.127.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.10.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.73.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-GuillermoPolito.363.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.262.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.15.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/5/2016 23:02'!update50751	"self new update50751"	self withUpdateLog: '18167 NewValueHolder class>value: should use rawValue:	https://pharo.fogbugz.com/f/cases/18167'.	self loadTogether: self script50751 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50750!ScriptLoader removeSelector: #script50750!"ScriptLoader50"!!NewValueHolder class methodsFor: 'instance creation' stamp: 'StephanEggermont 5/5/2016 11:14' prior: 50957654!value: contents	^ self new		rawValue: contents;		yourself! !"NewValueHolder"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.952.mcz') load.ScriptLoader new update50751.!----End fileIn----!----QUIT----2016-05-09T09:16:09.389032+02:00 Pharo.image priorSource: 721!----QUIT----2016-05-09T09:16:12.32598+02:00 Pharo.image priorSource: 18126!----QUIT----2016-05-09T09:16:17.504795+02:00 Pharo.image priorSource: 18202!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/9/2016 09:52' prior: 33555320!commentForCurrentUpdate ^ '18178 Some methods comments in FileReference	https://pharo.fogbugz.com/f/cases/1817818174 Delete the second " of the template method break the image	https://pharo.fogbugz.com/f/cases/1817418168 Add Tooltip to describe Rubric options	https://pharo.fogbugz.com/f/cases/18168'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/9/2016 09:53'!script50752	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.140.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.127.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.10.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.73.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-GuillermoPolito.363.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.262.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.15.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/9/2016 09:53'!update50752	"self new update50752"	self withUpdateLog: '18178 Some methods comments in FileReference	https://pharo.fogbugz.com/f/cases/1817818174 Delete the second " of the template method break the image	https://pharo.fogbugz.com/f/cases/1817418168 Add Tooltip to describe Rubric options	https://pharo.fogbugz.com/f/cases/18168'.	self loadTogether: self script50752 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50751!ScriptLoader removeSelector: #script50751!"ScriptLoader50"!!NautilusAnnotationDisplayer methodsFor: 'submorphs-accessing' stamp: 'CyrilFerlicot 5/6/2016 00:49' prior: 50667866!formatAsYouReadMorph	^ (CheckboxMorph on: self selected: #formatAsYouRead changeSelected: #toggleFormatAsYouRead)		getLabelSelector: #formatAsYouReadLabel;		labelClickable: true;		vResizing: #shrinkWrap;		hResizing: #shrinkWrap;		setBalloonText:			'Autoformat code without editing. Useful when reading some old/unformatted code. You can configure your own format in the settings browser.';		yourself! !!NautilusAnnotationDisplayer methodsFor: 'submorphs-accessing' stamp: 'CyrilFerlicot 5/6/2016 00:42' prior: 50668440!lineAnnotationMorph	^ (RubTextFieldArea new		withoutAnyDecorator;		backgroundColor: Color transparent;		font: self fontToUse;		beReadOnly;		textColor: self textColor)		setBalloonText: 'Current line number/Total line number [Current character number]';		yourself! !!NautilusAnnotationDisplayer methodsFor: 'submorphs-accessing' stamp: 'CyrilFerlicot 5/6/2016 00:46' prior: 50666530!lineNumbersDisplayLabelMorph	^ (StringMorph contents: self lineNumbersDisplayLabel font: self fontToUse)		setBalloonText: 'Let you decide if the code pane should show the line numbers at the left of the code pane or not. +L: Click to add the lines number/L: Click to hide them.';		yourself! !!NautilusAnnotationDisplayer methodsFor: 'submorphs-accessing' stamp: 'CyrilFerlicot 5/6/2016 00:44' prior: 50662265!wrappingPolicyLabelMorph	^ (StringMorph contents: self wrappingPolicyLabel font: self fontToUse)		setBalloonText:			'Let you decide if the code pane should automaticaly wrap lines if a line reach the end of the line. W: Wrap / NW: Add a scrollbar.';		yourself! !!AbstractFileReference methodsFor: 'delegated' stamp: 'AlexandreBergel 5/7/2016 18:41' prior: 16833596!exists	"Return true if the file reference exist (e.g., if there is a file on the hard disk pointed by the file reference)		E.g., (if you are on Unix or OSX)	'/tmp/' asFileReference exists => true	'/tmp/zorkbar' asFileReference exists => false	"	^ self resolve exists! !!RBParser class methodsFor: 'parsing' stamp: 'NicolaiHess 5/8/2016 16:36' prior: 54366838!parseMethod: aString onError: aBlock 	| parser |	parser := self new.	parser errorBlock: aBlock.	parser initializeParserWith: aString.	^ [ parser parseMethod: aString ]		on: ReparseAfterSourceEditing		do: [ :exception | self parseMethod: exception newSource onError: aBlock ]! !"AST-Core"!"FileSystem-Core"!"Nautilus"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.956.mcz') load.ScriptLoader new update50752.!----End fileIn----!----QUIT----2016-05-09T10:03:56.519402+02:00 Pharo.image priorSource: 18279!----QUIT----2016-05-09T10:03:59.448854+02:00 Pharo.image priorSource: 38380!----QUIT----2016-05-09T10:04:04.416367+02:00 Pharo.image priorSource: 38458!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/10/2016 09:13' prior: 33572880!commentForCurrentUpdate ^ '18188 localHostName is not guarded against uninitialized network	https://pharo.fogbugz.com/f/cases/18188'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/10/2016 09:13'!script50753	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.140.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.130.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.10.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.73.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-GuillermoPolito.363.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.262.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.15.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/10/2016 09:14'!update50753	"self new update50753"	self withUpdateLog: '18188 localHostName is not guarded against uninitialized network	https://pharo.fogbugz.com/f/cases/18188'.	self loadTogether: self script50753 merge: false.	self flushCaches.self cleanRepositories.! !ScriptLoader removeSelector: #update50752!ScriptLoader removeSelector: #script50752!"ScriptLoader50"!!NetNameResolver class methodsFor: 'lookups' stamp: 'HenrikSperreJohansen 5/9/2016 11:06' prior: 50837885!localHostName	"Return the local name of this host."	"NetNameResolver localHostName"	^ [ | hostName |	self initializeNetwork.	hostName := String new: self primHostNameSize.	self primHostNameResult: hostName.	hostName ]		on: PrimitiveFailed		do: [ self loopBackName ]! !!Socket methodsFor: 'initialize-destroy' stamp: 'HenrikSperreJohansen 5/9/2016 11:08'!bindTo: anAddress port: aPort	^self primSocket: socketHandle bindTo: anAddress port: aPort ! !!Socket methodsFor: 'primitives' stamp: 'HenrikSperreJohansen 5/9/2016 11:11'!primSocket: socketID bindTo: anAddress port: aPort 	"Bind socket to provided IPv4 address and port"	<primitive: 'primitiveSocketBindToPort' module: 'SocketPlugin'>	^self primitiveFailed! !"Network-Kernel"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.957.mcz') load.ScriptLoader new update50753.!----End fileIn----!----QUIT----2016-05-10T09:16:10.918677+02:00 Pharo.image priorSource: 38536!----QUIT----2016-05-10T09:16:13.831462+02:00 Pharo.image priorSource: 56658!----QUIT----2016-05-10T09:16:18.655617+02:00 Pharo.image priorSource: 56736!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/10/2016 17:11' prior: 33593138!commentForCurrentUpdate ^ '18153 Failing on CI on Windows: SocketTest.testUDPBroadcastError (from Network-Tests)	https://pharo.fogbugz.com/f/cases/18153'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/10/2016 17:11'!script50754	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.140.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.13.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.73.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-GuillermoPolito.363.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.262.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.15.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/10/2016 17:11'!update50754	"self new update50754"	self withUpdateLog: '18153 Failing on CI on Windows: SocketTest.testUDPBroadcastError (from Network-Tests)	https://pharo.fogbugz.com/f/cases/18153'.	self loadTogether: self script50754 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50753!ScriptLoader removeSelector: #script50753!"ScriptLoader50"!!SocketTest methodsFor: 'mocks' stamp: 'HenrikNergaard 5/10/2016 11:33'!faultyUDPSocket	| cls |		cls := Socket newAnonymousSubclass .		"the mock socket is not sending anything, so there is nothing to wait for"	cls compile: 'waitForSendDoneFor: aNumber ^ true'.		"compile the primitive to not send, but return a 0 count for any send"	cls compile: 'primSocket: socketID sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber startIndex: startIndex count: count ^ 0'.		^ cls newUDP! !!SocketTest methodsFor: 'tests' stamp: 'HenrikSperreJohansen 5/9/2016 09:49' prior: 58415898!testUDPBroadcastError	"Test that we get a specific error when failure is due to sending to a broadcast address without SO_BROADCAST set"	"Use 255.255.255.255 for testing, which in RFC 919 is defined as 'denoting a broadcast on a local hardware network, which must not be forwarded. 	This address may be used, for example, by hosts that do not know their network number and are asking some server for it.'"	self		should: [ 			Socket newUDP				setOption: 'SO_BROADCAST' value: false;				sendUDPData: #[] toHost: #[255 255 255 255] port: 1950 ]		raise: NoBroadcastAllowed.	self		shouldnt: [ 			Socket newUDP				setOption: 'SO_BROADCAST' value: true;				sendUDPData: #[] toHost: #[255 255 255 255] port: 1 ]		raise: NoBroadcastAllowed! !!SocketTest methodsFor: 'tests' stamp: 'HenrikNergaard 5/10/2016 11:35'!testUDPFaultySend	| socket host |		socket := self faultyUDPSocket.		host := #[1 2 3 4].		"Check that sending is not caught in a infinite loop"	self should: [ 				self 			deny: (socket isBroadcastAddress: host);			should: [socket sendUDPData: #[123] toHost: host port: 1 ] raise: NetworkError.					host := #[ 255 255 255 255].				self 			assert: (socket isBroadcastAddress: host);			should: [ socket sendUDPData: #[123] toHost: host port: 1 ] raise: NoBroadcastAllowed.					socket setOption: 'SO_BROADCAST' value: true.				self should: [ socket sendUDPData: #[123] toHost: host port: 1 ] raise: NetworkError.			] notTakeMoreThanMilliseconds: 20 .	socket destroy.! !!Socket methodsFor: 'private - errors' stamp: 'HenrikSperreJohansen 5/9/2016 08:53'!broadcastError: hostAddress	^ (NoBroadcastAllowed new		messageText: 'Sending to ' , hostAddress printString , ' without SO_BROADCAST set')		signal! !!Socket methodsFor: 'private - errors' stamp: 'HenrikSperreJohansen 5/10/2016 16:05'!broadcastMisconfiguredForSendingTo: hostAddress	^ (self isBroadcastAddress: hostAddress)		and: [ ((self getOption: 'SO_BROADCAST') last = 0) ]! !!Socket methodsFor: 'private - errors' stamp: 'HenrikSperreJohansen 5/9/2016 09:23' prior: 58337998!errorSending: data startingAt: startIndex count: aCount toHost: hostAddress port: portNumber	"If there are known primitive failure reasons when sending that can be specified using more exact errors, discern them here""Only applicable to UDP sockets, TCP does not have broadcast"	(self broadcastMisconfiguredForSendingTo: hostAddress)		ifTrue: [ ^ self broadcastError: hostAddress ].		^ self primitiveFailed: thisContext sender selector! !!Socket methodsFor: 'datagrams' stamp: 'HenrikSperreJohansen 5/9/2016 09:51' prior: 58351092!sendUDPData: aStringOrByteArray toHost: hostAddress port: portNumber	"Send a UDP packet containing the given data to the specified host/port."	| bytesToSend bytesSent count |	bytesToSend := aStringOrByteArray size.	bytesSent := 0.	[		(self waitForSendDoneFor: 20)			ifFalse: [ConnectionTimedOut signal: 'send data timeout; data not sent'].		count := self primSocket: socketHandle			sendUDPData: aStringOrByteArray			toHost: hostAddress			port: portNumber			startIndex: bytesSent + 1			count: bytesToSend - bytesSent.		count = 0 ifTrue: 			["Usually broadcast fails in primitive without the proper option set, 			but some platforms simply return count=0"			(self broadcastMisconfiguredForSendingTo: hostAddress)				ifTrue: [ ^ self broadcastError: hostAddress ].			bytesToSend ~= count 				ifTrue: [ ^NetworkError signal: 'failed to send data']].		bytesSent := bytesSent + count.		bytesSent < bytesToSend] whileTrue.	^ bytesSent! !"Network-Kernel"!"Network-Tests"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.958.mcz') load.ScriptLoader new update50754.!----End fileIn----!----QUIT----2016-05-10T17:12:58.119405+02:00 Pharo.image priorSource: 56814!----QUIT----2016-05-10T17:13:01.033114+02:00 Pharo.image priorSource: 78312!----QUIT----2016-05-10T17:13:06.252828+02:00 Pharo.image priorSource: 78390!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/11/2016 16:47' prior: 33611416!commentForCurrentUpdate ^ '18023 add a WelcomeHelp page to open a Help Browser on it when starting	https://pharo.fogbugz.com/f/cases/18023'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/11/2016 16:47'!script50755	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.13.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.20.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.262.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.15.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/11/2016 16:47'!update50755	"self new update50755"	self withUpdateLog: '18023 add a WelcomeHelp page to open a Help Browser on it when starting	https://pharo.fogbugz.com/f/cases/18023'.	self loadTogether: self script50755 merge: false.	PharoWelcomePage openForRelease.	self flushCaches.! !ScriptLoader removeSelector: #update50754!ScriptLoader removeSelector: #script50754!"ScriptLoader50"!!PharoWelcomePage commentStamp: 'PavelKrivanek 4/22/2016 17:18' prior: 0!Pharo 5.0=========Welcome to Pharo, an immersive live programming environment."Pharo 5.0 already comes pre-loaded with a rich set of packages that you can use to explore the system and develop your own applications. However there is also a huge library of user contributed projects that you can also load using the 'Configurations Browser' by executing:"MetacelloConfigurationBrowser open."This browser is also accessible from the World | Tools menu (just click the desktop, select Tools, and then Configuration Browser).You can find information about Pharo on http://www.pharo.org. Some useful starting points are:- Joining us and getting help http://www.pharo.org/get-help- Getting the Pharo By Example book (available as a free PDF): http://www.pharobyexample.org- Browser the documentation http://www.pharo.org/documentation- Reporting problems http://www.pharo.org/get-involvedAbout this release---------------------------There are more than 1600 issues treated in this release. Sumarized issues for 4.0:=========================New stuff---------- GTools (Playground, Inspector, Spotter)- Slots model instance variables as first class enities and enable meta-programming on this level.- ShoreLine reporter: submit information automatically when errors happen- TxModel, a modern text model who works with Athens (Preview)- OSWindow, a new way to handle windows and input events (Preview)- Glamour, a mature declarative browser builder- Dark themeUpdated stuff-------------- Zinc/Zodiac- Fuel- VersionnerAnd a lot more!!You can check a more detailed explanation here: https://github.com/pharo-project/pharo-changelogs/blob/master/Pharo40ChangeLogs.md"!!WelcomeHelp commentStamp: '<historical>' prior: 0!I'm the help page for welcoming new users. I pass through basic concepts to getting started with Pharo.!!RubFindReplaceService commentStamp: 'StephaneDucasse 6/13/2015 14:25' prior: 56085045!RubFindReplaceService default newDialog openInWorldRubFindReplaceService !!PharoWelcomePage class methodsFor: 'opening' stamp: 'EstebanLorenzano 5/10/2016 11:58'!open	| group welcome help zen about window |	welcome := WelcomeHelp open.	help := HelpBrowser open.	zen := TextModel new			text: ProfStef pharoZenValuesContents;			title: 'Pharo Zen';			aboutText: ProfStef aboutPharoZen;			beForText;			openWithSpec.				about := TextModel new			text: Smalltalk systemInformationString withCRs;			title: 'About Pharo';			beForText;			openWithSpec.	group := GroupWindowMorph new.	group addWindow: welcome window.	group addWindow: help window.	group addWindow: SettingBrowser open.	group addWindow: KeymapBrowser new openWithSpec window.	group addWindow: zen window.	group addWindow: about window.	window := (group openInWindowLabeled: self title translated)		extent: welcome window extent;		yourself.			group tabGroup selectedPageIndex: 1.	^ window! !!PharoWelcomePage class methodsFor: 'opening' stamp: 'EstebanLorenzano 4/22/2016 17:48'!openForRelease	| window |		World submorphs 		detect: [ :each | (each isKindOf: SystemWindow) and: [ each label = self title ] ] 		ifFound: [ :oldWindow | oldWindow delete ].	window := self open.	window extent: 750@400.	window center: Display extent / 2! !!PharoWelcomePage class methodsFor: 'accessing' stamp: 'EstebanLorenzano 4/22/2016 17:44'!title	^ 'Welcome to Pharo 5.0'! !!PharoEnvironmentHelp class methodsFor: 'help-text' stamp: 'EstebanLorenzano 5/10/2016 12:02' prior: 52713451!wikiStyleHelp	<wikiStyleHelp: #' Pharo Environment Help'>		^ self comment! !!RubScrolledTextMorph methodsFor: 'initialize-release' stamp: 'EstebanLorenzano 4/19/2016 16:29'!beForSmalltalkCodeWithDefaultFont	self textArea beForSmalltalkCodeWithDefaultFont.	self withTextSegmentIcons! !!RubScrolledTextMorph methodsFor: 'accessing' stamp: 'EstebanLorenzano 4/19/2016 16:31'!beForSmalltalkScriptingWithDefaultFont    self textArea beForSmalltalkScriptingWithDefaultFont! !!RubEditingArea methodsFor: 'initialize-release' stamp: 'EstebanLorenzano 4/19/2016 14:35'!beForSmalltalkCodeWithDefaultFont	self editingMode: RubSmalltalkCodeMode new.	self font: StandardFonts defaultFont! !!RubEditingArea methodsFor: 'public accessing' stamp: 'EstebanLorenzano 4/19/2016 16:29'!beForSmalltalkScriptingWithDefaultFont	self editingMode: RubSmalltalkScriptingMode new.	self font: StandardFonts defaultFont! !!ProfStef class methodsFor: 'cleanup' stamp: 'EstebanLorenzano 4/19/2016 15:01'!cleanUp	self reset! !!ProfStef class methodsFor: 'navigating' stamp: 'StephaneDucasse 7/28/2015 17:17' prior: 53487663!goToNextLesson  self next! !!HelpBrowser class methodsFor: 'ui' stamp: 'EstebanLorenzano 4/21/2016 15:51'!menuOn: aBuilder	<HelpBrowserContextMenu>		(aBuilder item: #'Do it' translated)		keyText: 'd';		selector: #doIt;		help: nil;		icon: (Smalltalk ui icons iconNamed: #smallDoIt).	(aBuilder item: #'Print it' translated)		keyText: 'p';		selector: #printIt;		help: nil;		icon: (Smalltalk ui icons iconNamed: #smallPrintIt).	(aBuilder item: #'Inspect it' translated)		keyText: 'i';		selector: #inspectIt;		help: nil;		icon: (Smalltalk ui icons iconNamed: #smallInspectIt).! !!HelpBrowser methodsFor: 'ui' stamp: 'EstebanLorenzano 4/19/2016 16:30' prior: 27864611!initWindow	| toolbar dock contentMorph |	window := (Smalltalk at: #StandardWindow) new.	window model: self.	window title: 'Help Browser'.	toolbar := window		newToolbar:			{window				newButtonFor: self				getState: nil				action: #refresh				arguments: nil				getEnabled: nil				labelForm: (Smalltalk ui icons refreshIcon)				help: 'Refresh' translated}.	dock := window newToolDockingBar.	dock addMorphBack: toolbar.	window addMorph: dock fullFrame: ((0 @ 0 corner: 1 @ 0) asLayoutFrame bottomOffset: dock minExtent y).	"Tree"	treeMorph := PluggableTreeMorph new.	treeMorph		model: self;		setSelectedSelector: #onItemClicked:.	window addMorph: treeMorph fullFrame: ((0 @ 0 corner: 0.3 @ 1) asLayoutFrame topOffset: dock minExtent y).	"Text"	contentMorph := self sourceTextModel newScrolledText		beForSmalltalkScriptingWithDefaultFont;		beWrapped;		yourself.	contentMorph menuProvider: self selector: #shoutMorphFillMenu:.	window addMorph: contentMorph fullFrame: ((0.3 @ 0 corner: 1 @ 1) asLayoutFrame topOffset: dock minExtent y)! !!HelpBrowser methodsFor: 'ui' stamp: 'EstebanLorenzano 4/21/2016 15:50' prior: 27867071!menu	^ (PragmaMenuBuilder pragmaKeyword: #HelpBrowserContextMenu model: self) menu.! !!HelpBrowser methodsFor: 'accessing' stamp: 'EstebanLorenzano 4/19/2016 17:06'!selectedClassOrMetaClass	^ nil! !!HelpBrowser methodsFor: 'accessing' stamp: 'PavelKrivanek 4/22/2016 16:25'!window	^ window! !!LessonView class methodsFor: 'gui' stamp: 'EstebanLorenzano 4/21/2016 15:52'!menuOn: aBuilder	<LessonViewContextMenu>		(aBuilder item: #'Do it' translated)		keyText: 'd';		selector: #doIt;		help: nil;		icon: (Smalltalk ui icons iconNamed: #smallDoIt).	(aBuilder item: #'Print it' translated)		keyText: 'p';		selector: #printIt;		help: nil;		icon: (Smalltalk ui icons iconNamed: #smallPrintIt).	(aBuilder item: #'Inspect it' translated)		keyText: 'i';		selector: #inspectIt;		help: nil;		icon: (Smalltalk ui icons iconNamed: #smallInspectIt).! !!LessonView methodsFor: 'gui' stamp: 'EstebanLorenzano 4/19/2016 14:51' prior: 29392129!buildText	| scrolledText |	scrolledText := self sourceTextModel newScrolledText		beForSmalltalkScripting;		beWrapped;		yourself.	scrolledText textArea font: StandardFonts codeFont.	^ scrolledText! !!LessonView methodsFor: 'gui' stamp: 'EstebanLorenzano 4/21/2016 15:52' prior: 29391757!menu	^ (PragmaMenuBuilder pragmaKeyword: #LessonViewContextMenu model: self) menu.! !!LessonView methodsFor: 'accessing' stamp: 'StephaneDucasse 7/10/2015 16:46' prior: 29391189!sourceTextModel	^ sourceTextModel ifNil: [ sourceTextModel := RubScrolledTextModel new interactionModel: self ].! !!WelcomeHelp class methodsFor: 'accessing' stamp: 'EstebanLorenzano 5/10/2016 12:05'!bookName	"the character zero is a hack to display it always first"	^ (Character value: 0) asString, 'Welcome'! !!WelcomeHelp class methodsFor: 'pages' stamp: 'EstebanLorenzano 4/19/2016 14:40'!changeLog	^ HelpTopic 		title: 'ChangeLog'		contents: 'TODO'! !!WelcomeHelp class methodsFor: 'pages' stamp: 'EstebanLorenzano 5/10/2016 11:38'!documentation	^ HelpTopic 		title: 'More documentation'		contents: 'The most important documentation is the one you can get by exploring the system, reading class comments and looking for examples. You can find "in image" help by highlighting the next line and selecting [Do it] from the context menu:HelpBrowser open.This browser is also accessible from the World>Help>Help Browser menu (just click the desktop, select Help, and then Help Browser).A compendium of Pharo documentation can be found at: http://pharo.org/documentationThere you can find:- Pharo books: http://books.pharo.org- Screencasts: https://www.youtube.com/channel/UCp3mNigANqkesFzdm058bvw- Presentations: http://www.slideshare.net/pharoproject/'! !!WelcomeHelp class methodsFor: 'pages' stamp: 'EstebanLorenzano 5/10/2016 11:32'!exploreEnvironment	^ HelpTopic 		title: 'Explore Pharo Environment'		contents: 'The best way to learn Pharo is to explore it by your self. This is live objects all the way down: they can be inspected, browsed, changed... everything in the environment you have in your hands.But sometimes it can be hard to getting you started with the tools and capabilities the environment gives you.The most complete and updated guide for the Pharo environment can be found at "Updated Pharo by Example" free book. It is still a work in progress, but most of it is already done. You can find the book here: https://github.com/SquareBracketAssociates/UpdatedPharoByExampleOne particular chapter that is interesting is the one that gisves you a quick tour for all the environment: https://ci.inria.fr/pharo-contribution/job/UpdatedPharoByExample/lastSuccessfulBuild/artifact/book-result/PharoTour/PharoTour.pdf '! !!WelcomeHelp class methodsFor: 'pages' stamp: 'EstebanLorenzano 5/10/2016 11:38'!gettingHelp	^ HelpTopic 		title: 'Getting help'		contents: 'Pharo has a vibrant community that shares knowledge in different ways: - The "Pharo Users" mailing list: http://lists.pharo.org/mailman/listinfo/pharo-users_lists.pharo.org- The "Pharo Slack Team": http://slack4pharo.trentosur.com/- The "Pharo IRC Channel": irc.freenode.net, #pharo channel You can find more information, lists to browse/suscribe and places to share code at: http://pharo.org/community'! !!WelcomeHelp class methodsFor: 'pages' stamp: 'EstebanLorenzano 5/10/2016 11:31'!learn	^ HelpTopic 		title: 'Learn Pharo Smalltalk'		contents: 'You can learn Pharo by highlighting the next line and selecting [Do it] from the context menu:ProfStef go.Pharo has also an excellent MOOC (Massive Open Online Course). You can find more indormation here: http://mooc.pharo.orgThere are also several free Pharo books that can be download here: http://books.pharo.orgA very interesting starting point would be looking into the "Updated Pharo by Example" free book. It is still a work in progress, but most of it is already done. You can find the book here: https://github.com/SquareBracketAssociates/UpdatedPharoByExample'! !!WelcomeHelp class methodsFor: 'showing' stamp: 'EstebanLorenzano 4/19/2016 16:00'!open	^ (HelpBrowser openOn: self) next! !!WelcomeHelp class methodsFor: 'showing' stamp: 'EstebanLorenzano 4/19/2016 16:10'!openForRelease	| browser window findBlock |		findBlock := [ :each | (each isKindOf: SystemWindow) and: [ each label = self bookName ] ]. 	World submorphs 		detect: findBlock 		ifFound: [ :oldWindow | oldWindow delete ].	browser := self open.	window := browser dependents detect: findBlock.	window extent: 700@400.	window center: Display extent / 2! !!WelcomeHelp class methodsFor: 'accessing' stamp: 'EstebanLorenzano 4/19/2016 14:39'!pages	^ #(welcome changeLog learn exploreEnvironment useExternalPackages documentation gettingHelp)! !!WelcomeHelp class methodsFor: 'pages' stamp: 'EstebanLorenzano 5/10/2016 11:39'!useExternalPackages	^ HelpTopic 		title: 'Use external packages'		contents: 'Pharo 5.0 already comes pre-loaded with a rich set of packages that you can use to explore the system and develop your own applications. However there is also a huge library of user contributed projects that you can also load using the "Catalog Browser" by highlighting the next line and selecting [Do it] from the context menu:CatalogBrowser open.This browser is also accessible from the World>Tools>Catalog Browser menu (just click the desktop, select Tools, and then Catalog Browser).Catalog projects can also be browsed online: http://catalog.pharo.orgYou can also have a rough list (not very friendly) of many packages available stored in smalltalkhub repository:http://smalltalkhub.com/list(this list is not a compendium of packages for Pharo but is a good place to start if looking for something in particular and is not in the catalog)'! !!WelcomeHelp class methodsFor: 'pages' stamp: 'EstebanLorenzano 5/10/2016 11:29'!welcome	^ HelpTopic 		title: 'Welcome to Pharo 5.0'		contents: 'Pharo 5.0=========Welcome to Pharo, an immersive live programming environment.Pharo is a pure object-oriented programming language and a powerful environment, focused on simplicity and immediate feedback (think IDE and OS rolled into one).For more information, please visite here: http://pharo.org'! !!RubTextAreaExamples class methodsFor: 'examples' stamp: 'EstebanLorenzano 4/19/2016 14:33' prior: 56341649!smalltalkCodeWrappedTo400	"self smalltalkCodeWrappedTo400"	| area |	ModelForShout := self.	area := RubEditingArea new		beWrapped;		model: self;		width: 400;		beForSmalltalkCodeWithDefaultFont;		updateTextWith: self someSmalltalkCode.	area openInWorld.	^ area! !"HelpSystem-Core"!"Pharo-Help"!"ProfStef-Core"!"Rubric"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.959.mcz') load.ScriptLoader new update50755.!----End fileIn----!----QUIT----2016-05-11T16:50:04.778482+02:00 Pharo.image priorSource: 78468!----QUIT----2016-05-11T16:50:08.074507+02:00 Pharo.image priorSource: 110002!----QUIT----2016-05-11T16:50:13.413083+02:00 Pharo.image priorSource: 110080!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/12/2016 11:59' prior: 33633070!commentForCurrentUpdate ^ '18203 Welcome window does not show content at startup	https://pharo.fogbugz.com/f/cases/1820318204 typo in Explore Pharo Environment chapter	https://pharo.fogbugz.com/f/cases/1820418205 typo in chapter "Learn Pharo Smalltalk"	https://pharo.fogbugz.com/f/cases/18205'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/12/2016 11:59'!script50756	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.13.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.23.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.262.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.15.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/12/2016 11:59'!update50756	"self new update50756"	self withUpdateLog: '18203 Welcome window does not show content at startup	https://pharo.fogbugz.com/f/cases/1820318204 typo in Explore Pharo Environment chapter	https://pharo.fogbugz.com/f/cases/1820418205 typo in chapter "Learn Pharo Smalltalk"	https://pharo.fogbugz.com/f/cases/18205'.	self loadTogether: self script50756 merge: false.	PharoWelcomePage openForRelease.100 timesRepeat: [10 milliSecond wait. World doOneCycle. Processor yield. ].3 timesRepeat: [Smalltalk garbageCollect].	self flushCaches.! !ScriptLoader removeSelector: #update50755!ScriptLoader removeSelector: #script50755!"ScriptLoader50"!!WelcomeHelp class methodsFor: 'pages' stamp: 'PavelKrivanek 5/12/2016 09:39' prior: 33658941!exploreEnvironment	^ HelpTopic 		title: 'Explore Pharo Environment'		contents: 'The best way to learn Pharo is to explore it by your self. This is live objects all the way down: they can be inspected, browsed, changed... everything in the environment you have in your hands.But sometimes it can be hard to getting you started with the tools and capabilities the environment gives you.The most complete and updated guide for the Pharo environment can be found at "Updated Pharo by Example" free book. It is still a work in progress, but most of it is already done. You can find the book here: https://github.com/SquareBracketAssociates/UpdatedPharoByExampleOne particular chapter that is interesting is the one that gives you a quick tour for all the environment: https://ci.inria.fr/pharo-contribution/job/UpdatedPharoByExample/lastSuccessfulBuild/artifact/book-result/PharoTour/PharoTour.pdf '! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PavelKrivanek 5/12/2016 09:44' prior: 33660496!learn	^ HelpTopic 		title: 'Learn Pharo Smalltalk'		contents: 'You can learn Pharo by highlighting the next line and selecting [Do it] from the context menu:ProfStef go.Pharo has also an excellent MOOC (Massive Open Online Course). You can find more information here: http://mooc.pharo.orgThere are also several free Pharo books that can be download here: http://books.pharo.orgA very interesting starting point would be looking into the "Updated Pharo by Example" free book. It is still a work in progress, but most of it is already done. You can find the book here: https://github.com/SquareBracketAssociates/UpdatedPharoByExample'! !"Pharo-Help"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.960.mcz') load.ScriptLoader new update50756.!----End fileIn----!----QUIT----2016-05-12T12:01:28.25231+02:00 Pharo.image priorSource: 110159!----QUIT----2016-05-12T12:01:31.348977+02:00 Pharo.image priorSource: 129652!----QUIT----2016-05-12T12:01:36.707369+02:00 Pharo.image priorSource: 129730!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/12/2016 15:02' prior: 33664762!commentForCurrentUpdate ^ '18203 Welcome window does not show content at startup	https://pharo.fogbugz.com/f/cases/1820318208 Add changelog to welcome browser	https://pharo.fogbugz.com/f/cases/18208'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/12/2016 15:02'!script50757	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.13.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.25.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.262.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/12/2016 15:02'!update50757	"self new update50757"	self withUpdateLog: '18203 Welcome window does not show content at startup	https://pharo.fogbugz.com/f/cases/1820318208 Add changelog to welcome browser	https://pharo.fogbugz.com/f/cases/18208'.	self loadTogether: self script50757 merge: false.	PharoWelcomePage openForRelease..	self flushCaches.! !ScriptLoader removeSelector: #update50756!ScriptLoader removeSelector: #script50756!"ScriptLoader50"!!WelcomeHelp class methodsFor: 'pages' stamp: 'EstebanLorenzano 5/12/2016 14:42' prior: 33657971!changeLog	^ HelpTopic 		title: 'ChangeLog'		contents: 'New Stuff in Pharo 5.0----------------------- The PharoVM is now based on Spur, the new memory management, and it brings with it a 35% speedup!!- A new unified foreign function interface (UFFI) replaced NativeBoost to provide a strong Spur-compatible framework for interfacing with the outside world.- The Glamorous Toolkit now includes the GTDebugger to offer a moldable infrastructure that allows the developer to customize the debugger deeply.- The underlying Reflectivity mechanism has reached maturity with multiple pieces coming together to empower developers to instrument their own systems. For example, we now have breakpoints implemented as just a simple extension of this mechanism.- QualityAssistant is now part of the image to provide live feedback during development.All Issues----------Many changes have been made to support the generation of a more modular system. This release integrates  a quite large number of fixes and enhancements: more than 2450!! List is so big that we cannot put it here  (it would have any sense), but you can review all issues at FogBugz issue tracker (https://pharo.fogbugz.com) (you will need an account there, sorry).You can see the Pharo 5.0 changelog at: https://github.com/pharo-project/pharo-changelogs/blob/master/Pharo50ChangeLogs.md'! !!ImageCleaner methodsFor: 'api' stamp: 'EstebanLorenzano 5/12/2016 14:19' prior: 28189911!cleanUpForRelease	"self new cleanUpForRelease"	Author fullName: 'Mr.Cleaner'.	self cleanUpMethods.		FreeTypeFontProvider current initialize.	EmbeddedFreeTypeFontInstaller initialize.	#MetacelloProjectRegistration asClassIfPresent: [ :class | class resetRegistry ].	SystemNavigation new		allObjectsDo: [ :each | 			((each respondsTo: #releaseCachedState) and: [ (each isKindOf: RubAbstractTextArea) not ])				ifTrue: [ each releaseCachedState ] ].		self removeEmptyCategories.	self removeEmptyPackages.	Smalltalk organization sortCategories.	Smalltalk garbageCollect.	Smalltalk cleanOutUndeclared. 	Smalltalk fixObsoleteReferences.	Smalltalk cleanUp: true except: #() confirming: false.		Author reset! !"Pharo-Help"!"Tool-ImageCleaner"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.961.mcz') load.ScriptLoader new update50757.!----End fileIn----!----QUIT----2016-05-12T15:04:01.115517+02:00 Pharo.image priorSource: 129809!----QUIT----2016-05-12T15:04:04.55159+02:00 Pharo.image priorSource: 149536!----QUIT----2016-05-12T15:04:09.715449+02:00 Pharo.image priorSource: 149615!----QUIT----2016-05-14T14:56:45.122151+02:00 Pharo.image priorSource: 149693!----QUIT----2016-05-14T14:56:47.970827+02:00 Pharo.image priorSource: 149772!----QUIT----2016-05-14T14:56:52.955784+02:00 Pharo.image priorSource: 149851!----QUIT----2016-05-25T13:37:54.884983+02:00 Pharo.image priorSource: 149930!----QUIT----2016-05-25T13:37:57.748359+02:00 Pharo.image priorSource: 150009!----QUIT----2016-05-25T13:38:03.199623+02:00 Pharo.image priorSource: 150088!!ScriptLoader methodsFor: 'public' stamp: 'EstebanLorenzano 5/25/2016 14:07' prior: 33684412!commentForCurrentUpdate ^ '18284 SmallFloat64 identityHash is answering bad value	https://pharo.fogbugz.com/f/cases/18284'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'EstebanLorenzano 5/25/2016 14:07'!script50758	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.13.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.25.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.262.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'EstebanLorenzano 5/25/2016 14:07'!update50758	"self new update50758"	self withUpdateLog: '18284 SmallFloat64 identityHash is answering bad value	https://pharo.fogbugz.com/f/cases/18284'.	self loadTogether: self script50758 merge: false.	SmallFloat64 tryPrimitive: 161 withArgs: #(4 true).HashedCollection rehashAll.	self flushCaches.self cleanRepositories.! !ScriptLoader removeSelector: #update50757!ScriptLoader removeSelector: #script50757!"ScriptLoader50"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-EstebanLorenzano.964.mcz') load.ScriptLoader new update50758.!----End fileIn----!----QUIT----2016-05-25T14:11:52.008264+02:00 Pharo.image priorSource: 150167!----QUIT----2016-05-25T14:11:54.948107+02:00 Pharo.image priorSource: 167499!----QUIT----2016-05-25T14:11:59.831777+02:00 Pharo.image priorSource: 167578!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/25/2016 15:02' prior: 33704773!commentForCurrentUpdate ^ '18212 PharoTutorial class missing	https://pharo.fogbugz.com/f/cases/1821218259 Error in Spec MorphicTextAdapter	https://pharo.fogbugz.com/f/cases/18259'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/25/2016 15:02'!script50759	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.243.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2290.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.13.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.28.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.266.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/25/2016 15:02'!update50759	"self new update50759"	self withUpdateLog: '18212 PharoTutorial class missing	https://pharo.fogbugz.com/f/cases/1821218259 Error in Spec MorphicTextAdapter	https://pharo.fogbugz.com/f/cases/18259'.	self loadTogether: self script50759 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50758!ScriptLoader removeSelector: #script50758!"ScriptLoader50"!!PharoEnvironmentHelp commentStamp: 'CyrilFerlicot 5/24/2016 20:50' prior: 52705640!This is introductory help for the Pharo environment and tools. !! Keyboard ShortcutsPharo has a variety of useful keyboard shortcuts that help you navigate its environment without always using a mouse.!!!! Browser ShortcutsThere are many keyboard shortcuts available in Pharo:- A full list is available in the System Browser by clicking the window menu button (the triangle) at the top right of the browser title, and selecting the 'Shortcuts Description' menu item.  Alternatively you can evaluate (cmd-d) the following code now:KMDescription new categories: #(NautilusGlobalShortcuts); openWithSpec.- Shortcuts are typically multi-key combinations, where you hold a modifier key and press the listed secondary key. For example if something is listed as CMD-F, CMD-C you would press and hold the CMD key while typing  F and then C- The modifier key varies between platforms: - Windows = ALT - Mac/OSX = CMD - Linux = CTRL!!!! Spotter/Global searchSimilar to the Spotlight search on OSX, or the Windows Search charm - Pharo has a global code search tool that is activated using:  Shift+EnterThis search tool shows a popup window on the center of the screen where you can incrementally search for classes, packages, symbols,  pragmas, files, folders and many other types of data.  As you type a search query  all available searches are performed at the same time and results are displayed as they are discovered and grouped based on the type of the search.You can cursor/keyboard navigate through the results, or press enter to spawn a new tool to examine the selected result.The following shortcuts are available:	Ctrl+Arrow_right dives in and restricts the available types of searches only to the selected element.	Ctrl+Shift+Arrow_right dives in and shows all the rearch results from a category.	Ctrl+Arrow_left dives out to the previous search	Ctrl+p toggles the preview pane	Enter  spawns a new tool to examine the selected result	Ctrl+Shift+Arrow_down/Ctrl+Shift+Arrow_down navigatew through different types of searches	Shift highlights all butons from the UI (only works with newer VMs)!!!! Visual ExplorationA useful way of discovering how things work in Pharo, is to point your mouse cursor at something on the screen (e.g. a browser button) and invoke a visual Halo selection by pressing:   Alt+Shift + left mouse clickIf you continue clicking the left mouse button (while holding Alt+Shift), the halo will expand it's selection to the current item's parent. This is useful for traversing the lineage of graphical Morph's to see what contains what.The halo has a series of icons, which if you hover over them will give you some balloon help about their operation. For exploring, the spanner icon is useful for letting you inspect or browse the current item to locate where the actual code is implemented.To remove the halo,  simply click anywhere outside of the current halo.It is possible to directly explore a visual object and bypass using the halo mechanism by pressing:  Ctrl+Shift + left mouse clickThis will give you a menu for the current item with options to inspect, debug etc.!! Browsing and Navigating CodeFinding and navigating through code in Pharo is an important part of developing programs in Smalltalk.!!!! System Browser (Nautilus)The System Browser (available in the desktop World menu), is the primary way of viewing your source code. This browser framework has been rewritten in Pharo and is often referred to as Nautilus (see the other top level help item for more technical details)!!!!!! Showing HierarchiesNautilus defaults to a simple 'Flat' display of the list of classes that are in the currently selected package (far left). If you want to see the hierarchy of a particular class, first select it and then press (toggle) the 'Flat' button, to show show its 'Hierarchy'. Pressing this button again will toggle back to the 'Flat' model.!!!!!! Browser HistoryThe browser records the history of methods and classes you have visited similar to a Web Browser. The dropdown list in the middle right of the panes (above the lower text pane) shows this history, and clicking on one of its items will navigate to that item. This is convenient if you have clicked on a different package, or navigated to superclass and want to return back to where you were. !!!!!! CustomisingThe system browser can also be configured with a different title as well as optional plugins. These are all available in the window dropdown menu in the top right of the title bar (normally a small triangle).!!!! SpotterUse the Shift+Enter global keystroke to activate a popup window that lets you incrementally search for methods, classes, packages, pragmas, files, folders and many other types of data.!!!! Finder The code Finder browswer is available from the World | Tools menu. The Finder lets you enter some general text in top edit field and then categorize it as either text, or language construct in the dropdown list to refine your search. There are more detailed instructions in the bottom pane of the browser detailing the different options.!!!! WorkspaceIn any workspace you can type or select any text and then perform an 'code search' (context menu item) that will look for matching senders, implementors, references or method source.!! IconsThere are many icons that are visible in the envionment, each with different meanings.!!!! GeneralAn orange smudge in the top right of any editable text field indicatest that the field has been modified and should be saved with CMD+S.!!!! Class PaneIn the System Browser class pane, you will see the following icons appear next to specific types of class objects:- Red exclamation mark: a missing class comment. The pharo team reccommend that all classes should describe their intent with a comment. - Gray dot: a TestCase - Yellow Lightening bolt: an Exception - 3 Coloured Balls: a Collection - Blue Speech bubble: an Announcement - Blue Paragraph symbol: a String - Gray Epsilon symbol: a Magniture - Blue Matrix box: a graphcial Morph - Purple Ball with T: a Trait!!!! Protocol PaneIn the System Browser protocol pane, you will see the following icons appear next to specific types of protocol objects:- Yellow diamond: initialisation methods- Red Square: private methods!!!! Method PaneIn the System Browser methods pane, you will see the following icons appear next to specific types of method objects:- Green Up Arrow: indicates this method overrides a method in a super class- Green Down Arrow: indicates this method is overriden in a subclass!!!! Source PaneIn the System Browser lower code source pane, you will see the following icons appear which have the following meaning:- Orange Smudge top right: the source has changed and should be saved- Yellow Stripe right margin: a long or complicated method that needs refactoring- Yellow Padlock top right: when locked, indicates the current method source will be displayed stacked with other locked methods in the source pane!! Getting More HelpIf you need more detailed help, here are some additional places to look.!!!! Pharo TutorialTry using the Pharo Smalltalk tutorial by evaluating (CMD+D) the code below: 	ProfStef go.!!!! Online ResourcesYou can find more information about Pharo by visiting: 	http://www.pharo.orgIn particular, you may also be interested in:- Joining discussions and getting help at: http://pharo.org/community - The Pharo By Example book (available as a free PDF): http://www.pharobyexample.org- Browsing the online documentation: http://www.pharo.org/documentation- Reporting problems: http://pharo.org/contribute!!MorphicTextAdapter methodsFor: 'widget API' stamp: 'EricVeltenDeMelo 5/19/2016 20:24' prior: 33483241!setScrollValue: aValue	self		widgetDo: [ :w | 			w scrollPane				hScrollbarValue: aValue x;				vScrollbarValue: aValue y ]! !"Pharo-Help"!"Spec-MorphicAdapters"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.965.mcz') load.ScriptLoader new update50759.!----End fileIn----!----QUIT----2016-05-25T15:04:08.153741+02:00 Pharo.image priorSource: 167657!----QUIT----2016-05-25T15:04:11.38136+02:00 Pharo.image priorSource: 193066!----QUIT----2016-05-25T15:04:16.506542+02:00 Pharo.image priorSource: 193145!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/3/2016 15:36' prior: 33722260!commentForCurrentUpdate ^ '18324 Spelling mistakes in Pharo	https://pharo.fogbugz.com/f/cases/18324'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/3/2016 15:37'!script50760	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2293.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-TheIntegrator.45.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-TheIntegrator.13.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.57.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/3/2016 15:37'!update50760	"self new update50760"	self withUpdateLog: '18324 Spelling mistakes in Pharo	https://pharo.fogbugz.com/f/cases/18324'.	self loadTogether: self script50760 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50759!ScriptLoader removeSelector: #script50759!"ScriptLoader50"!!WorldModel commentStamp: 'NicolaiHess 5/25/2016 21:39' prior: 64018446!I am a model representing Pharo World.This way, every spec application can be opened as the Pharo system window as window, to simulate native a application.!!OrderedCollection commentStamp: 'NicolaiHess 5/25/2016 21:36' prior: 52002587!I am one of the most common collection. I can grow, and elements can be added sequentially by the user.  Description -------------------I am more general than Array; my size grows on demand. I store data inside an Array and remember the first and last index. If I need, I can replace this Array by a larger one.I am usually used to store an unknown amount of objects. When my contents size will not move, one can send me the #asArray message to get better performances, but I cannot grow anymore (add: and remove: are not supported on Array).Public API and Key Messages-------------------	- #new / #withAll: aCollection / #with: anObject 	are common constructors- #add: anObject / #at: anIndex put: anObject / #at: anIndex ifAbsentPut: anObject 	allow to add new elements to myself.- #remove: anObject / #removeIndex: anIndex 	allow to remove an element.	- #do: aBlock / #collect: aBlock / #select: aBlock / #reject: aBlock 	are common iterators.Examples-------------------			"There is many ways to create an OrderedCollection, here are some:"	ordCol := OrderedCollection new.	ordCol		add: 'one';		add: 'two';		addFirst: 'zero';		addLast: 'three'.	ordCol.		"returns: an OrderedCollection('zero' 'one' 'two' 'three')"	"or"	ordCol := OrderedCollection with: 'one' with: 'two' with: 'three'.	ordCol.		"returns: an OrderedCollection('one' 'two' 'three')"	"or from an other collection"	ordCol := OrderedCollection withAll: #('one' 'two' 'three').	ordCol.		"returns: an OrderedCollection('one' 'two' 'three')"	"or"	#('one' 'two' 'three') asOrderedCollection.	"Some manipulations"	ordCol := OrderedCollection ofSize: 2.	ordCol		at: 1 put: 'one';		at: 2 put: 'two';		at: 2 ifAbsentPut: 'three'.	ordCol.		"returns: an OrderedCollection('one' 'two')"	ordCol		remove: 'two';		removeIndex: 1.	ordCol.		"returns:  an OrderedCollection()"	"A last one"	ordCol := OrderedCollection with: $b with: $c with: $a.	ordCol sort: [ :first :second | first < second ].		"returns: an OrderedCollection($a $b $c)"	ordCol collect: [ :element | element asUppercase ].		"returns:  an OrderedCollection($A $B $C)"	ordCol select: [ :element | element >= $b ].		"returns:  an OrderedCollection($b $c)"	ordCol do: [ :element | element inspect ].	ordCol asArray		"returns: #($a $b $c)"			 Internal Representation and Key Implementation Points.-------------------	    Instance Variables	array:			<Array> 		An Array where I store my elements. If I need a bigger one I can remove this one and create a new one.	firstIndex:		<Integer> 	The index of my first element.	lastIndex:		<Integer> 	The index of my last element.Istore my elements inside an array. This array is ATLEAST of the size of my elements. If someone adds an element and my array is not large enough, I remove it and I create a new one larger with the same elements (usually, the size double).!!Number methodsFor: 'mathematical functions' stamp: 'NicolaiHess 5/25/2016 21:35' prior: 51008065!squared	"Answer the receiver multiplied by itself."	^self * self! !!WelcomeHelp class methodsFor: 'pages' stamp: 'NicolaiHess 5/25/2016 21:34' prior: 33663022!welcome	^ HelpTopic 		title: 'Welcome to Pharo 5.0'		contents: 'Pharo 5.0=========Welcome to Pharo, an immersive live programming environment.Pharo is a pure object-oriented programming language and a powerful environment, focused on simplicity and immediate feedback (think IDE and OS rolled into one).For more information, please visit here: http://pharo.org'! !"Collections-Sequenceable"!"Kernel"!"Pharo-Help"!"Spec-MorphicAdapters"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.968.mcz') load.ScriptLoader new update50760.!----End fileIn----!----QUIT----2016-06-03T15:39:01.676326+02:00 Pharo.image priorSource: 193223!----QUIT----2016-06-03T15:39:06.386544+02:00 Pharo.image priorSource: 214317!----QUIT----2016-06-03T15:39:14.753308+02:00 Pharo.image priorSource: 214396!----QUIT----2016-06-11T10:54:59.292776+02:00 Pharo.image priorSource: 214475!----QUIT----2016-06-11T10:55:02.246772+02:00 Pharo.image priorSource: 214554!----QUIT----2016-06-11T10:55:07.348308+02:00 Pharo.image priorSource: 214633!----QUIT----2016-06-21T12:36:36.28281+02:00 Pharo.image priorSource: 214712!----QUIT----2016-06-21T12:36:39.483485+02:00 Pharo.image priorSource: 214791!----QUIT----2016-06-21T12:36:45.259159+02:00 Pharo.image priorSource: 214869!----QUIT----2016-06-21T17:42:12.510336+02:00 Pharo-50760.image priorSource: 214948!----QUIT----2016-07-28T18:13:45.378046+02:00 Pharo.image priorSource: 215027!----QUIT----2016-07-28T18:13:50.542723+02:00 Pharo.image priorSource: 215112!----QUIT----2016-07-28T18:13:51.323634+02:00 Pharo.image priorSource: 215191!!ScriptLoader methodsFor: 'public' stamp: 'EstebanLorenzano 7/29/2016 10:51' prior: 33747825!commentForCurrentUpdate ^ '18757 Simple Shell Command Eval for 5.0	https://pharo.fogbugz.com/f/cases/1875718676 Endless loop parsing e-mail addresses containing an ampersand	https://pharo.fogbugz.com/f/cases/18676'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'EstebanLorenzano 7/29/2016 10:51'!script50761	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2293.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-EstebanLorenzano.47.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-EstebanLorenzano.15.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.70.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'EstebanLorenzano 7/29/2016 10:51'!update50761	"self new update50761"	self withUpdateLog: '18757 Simple Shell Command Eval for 5.0	https://pharo.fogbugz.com/f/cases/1875718676 Endless loop parsing e-mail addresses containing an ampersand	https://pharo.fogbugz.com/f/cases/18676'.	self loadTogether: self script50761 merge: false.	self flushCaches.self cleanRepositories.! !ScriptLoader removeSelector: #update50760!ScriptLoader removeSelector: #script50760!"ScriptLoader50"!!LibC class methodsFor: 'fuctions' stamp: 'SeanDeNigris 7/12/2016 16:49'!system: command	"LibC system: 'sleep 3'"		^ self ffiCall: #(int system #(char * command)) module: self! !!MailAddressParserTest methodsFor: 'tests' stamp: 'BernhardPieber 7/2/2016 21:03' prior: 30697581!testAddressesIn	| testString correctAnswer |	testString := 'joe@lama.com, joe2@lama.com joe3@lama.com joe4 , Not an Address <joe5@address>, joe.(annoying (nested) comment)literal@[1.2.3.4], "an annoying" group : joe1@groupie, joe2@groupie, "Joey" joe3@groupy, "joe6"."joe8"@group.com;,  Lex''s email account <lex>'.correctAnswer := #('joe@lama.com' 'joe2@lama.com' 'joe3@lama.com' 'joe4' 'joe5@address' 'joe.literal@[1.2.3.4]' 'joe1@groupie' 'joe2@groupie' '"Joey"' 'joe3@groupy' '"joe6"."joe8"@group.com' 'lex') asOrderedCollection.	self assert: (MailAddressParser addressesIn: testString) equals:  correctAnswer! !!MailAddressParserTest methodsFor: 'tests' stamp: 'BernhardPieber 7/2/2016 21:05'!testAmpersand	| testString correctAnswer |	testString := '&@example.com, romeo&julia@verona.it'.	correctAnswer := #('&@example.com' 'romeo&julia@verona.it') asOrderedCollection.	self assert: (MailAddressParser addressesIn: testString) equals: correctAnswer! !!MailAddressTokenizer class methodsFor: 'initialization' stamp: 'BernhardPieber 6/26/2016 20:02' prior: 30703143!initialize	"Initalize class variables using   MailAddressTokenizer initialize"	| atomChars |	CSParens := CharacterSet empty.	CSParens addAll: '()'.	CSSpecials := CharacterSet empty.	CSSpecials addAll: '()<>@,;:\".[]'.	CSNonSeparators := CharacterSet separators complement.	"(from RFC 2822)"	atomChars := CharacterSet empty.	atomChars addAll: ($A to: $Z).	atomChars addAll: ($a to: $z).	atomChars addAll: ($0 to: $9).	atomChars addAll: '!!#$%&''*+-/=?^_`{|}~'.	CSNonAtom :=  atomChars complement.! !"Network-Mail"!"Network-Tests"!"UnifiedFFI"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-EstebanLorenzano.975.mcz') load.ScriptLoader new update50761.!----End fileIn----!----QUIT----2016-07-29T12:18:23.980837+02:00 Pharo.image priorSource: 215270!----QUIT----2016-07-29T12:18:29.473484+02:00 Pharo.image priorSource: 234661!----QUIT----2016-08-01T11:36:53.920534+02:00 Pharo-50761.image priorSource: 234740!----QUIT----2016-08-01T11:37:06.163657+02:00 Pharo-50761.image priorSource: 234819!----QUIT----2016-08-06T23:06:44.784459+02:00 Pharo.image priorSource: 234904!----QUIT----2016-08-06T23:06:50.030292+02:00 Pharo.image priorSource: 234989!----QUIT----2016-08-06T23:06:50.906972+02:00 Pharo.image priorSource: 235068!----QUIT----2016-08-09T15:17:53.216211+02:00 Pharo-50761.image priorSource: 235147!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 10/25/2016 10:07' prior: 33769876!commentForCurrentUpdate ^ '19205 [Backport] Pharo 5: Enable / Disable options in context Menu in FastTable	https://pharo.fogbugz.com/f/cases/19205'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 10/25/2016 10:07'!script50762	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-TudorGirba.322.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2293.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-EstebanLorenzano.47.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-EstebanLorenzano.15.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.70.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 10/25/2016 10:07'!update50762	"self new update50762"	self withUpdateLog: '19205 [Backport] Pharo 5: Enable / Disable options in context Menu in FastTable	https://pharo.fogbugz.com/f/cases/19205'.	self loadTogether: self script50762 merge: false.	self loadConfiguration: 'GlamourCore' version: '4.19.1'.self flushCaches.! !ScriptLoader removeSelector: #update50761!ScriptLoader removeSelector: #script50761!"ScriptLoader50"!!ConfigurationOfGlamourCore methodsFor: 'baselines' stamp: 'PavelKrivanek 6/3/2016 11:03' prior: 20479297!baseline33: spec	<version: '3.3-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'Load FastTable renderer for Glamour'.		spec repository: 'http://smalltalkhub.com/mc/Moose/Glamour/main'.				spec project: 'Rubric' with: [				spec					className: #ConfigurationOfRubric;					versionString: #'development';					repository: 'http://www.smalltalkhub.com/mc/Pharo/Rubric/main' ].		spec project: 'FastTable' with: [				spec					className: #ConfigurationOfFastTable;					versionString: #'development';					repository: 'http://smalltalkhub.com/mc/estebanlm/FastTable/main/' ].		spec 			package: 'Glamour-Announcements';			package: 'Glamour-Helpers';			package: 'Glamour-FastTable' with: [				spec requires: #('FastTable' 'Glamour-Examples' 'Glamour-Core' 'Glamour-Morphic-Renderer' 'Glamour-Tests-Morphic'). ];			package: 'Glamour-Core' with: [				spec requires: #('Glamour-Helpers' 'Glamour-Announcements' ). ];			package: 'Glamour-Presentations' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Browsers' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Examples' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Morphic-Brick' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Morphic-Brick-Tests' with: [				spec requires: #('Glamour-Morphic-Brick' ). ];			package: 'Glamour-Tests-Core';			package: 'Glamour-Tests-Resources';			package: 'Glamour-Morphic-Theme' with: [				spec requires: #('Rubric' ). ];			package: 'Glamour-Morphic-Widgets' with: [				spec requires: #('Rubric' 'Glamour-Morphic-Brick' ). ];			package: 'Glamour-Morphic-Renderer' with: [				spec requires: #('Glamour-Morphic-Widgets' 'Glamour-Core' ). ];			package: 'Glamour-Morphic-Pager' with: [				spec requires: #('Glamour-Morphic-Renderer' 'Glamour-Morphic-Brick' ). ];			package: 'Glamour-Tests-Morphic' with: [				spec requires: #('Glamour-Morphic-Renderer' 'Glamour-Morphic-Brick' 'Glamour-Morphic-Pager' ). ];			package: 'Glamour-Rubric-Presentations' with: [				spec requires: #('Rubric' 'Glamour-Presentations' ). ];			package: 'Glamour-Tests-Rubric' with: [				spec requires: #('Glamour-Tests-Morphic' 'Glamour-Rubric-Presentations' ). ].		spec 			group: 'Core' with: #('Glamour-Announcements' 'Glamour-Helpers' 'Glamour-Core' 'Glamour-Presentations' 'Glamour-Browsers' 'Glamour-Examples' 'Glamour-Rubric-Presentations' );			group: 'Morphic' with: #('Glamour-Morphic-Brick' 'Glamour-Morphic-Widgets' 'Glamour-Morphic-Renderer' 'Glamour-Morphic-Theme' 'Glamour-Morphic-Pager' 'Glamour-FastTable' );			group: 'Tests' with: #('Glamour-Tests-Core' 'Glamour-Tests-Morphic' 'Glamour-Tests-Rubric' 'Glamour-Tests-Resources' 'Glamour-Morphic-Brick-Tests' );			group: 'default' with: #('Core' 'Morphic' 'Tests' ). ].! !!ConfigurationOfGlamourCore methodsFor: 'baselines' stamp: 'AndreiChis 6/24/2016 09:10'!baseline34: spec	<version: '3.4-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'Removed Rubric dependency'.		spec repository: 'http://smalltalkhub.com/mc/Moose/Glamour/main'.				spec project: 'FastTable' with: [				spec					className: #ConfigurationOfFastTable;					versionString: #'development';					repository: 'http://smalltalkhub.com/mc/estebanlm/FastTable/main/' ].		spec 			package: 'Glamour-Announcements';			package: 'Glamour-Helpers';			package: 'Glamour-FastTable' with: [				spec requires: #('FastTable' 'Glamour-Examples' 'Glamour-Core' 'Glamour-Morphic-Renderer' 'Glamour-Tests-Morphic'). ];			package: 'Glamour-Core' with: [				spec requires: #('Glamour-Helpers' 'Glamour-Announcements' ). ];			package: 'Glamour-Presentations' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Browsers' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Examples' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Morphic-Brick' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Morphic-Brick-Tests' with: [				spec requires: #('Glamour-Morphic-Brick' ). ];			package: 'Glamour-Tests-Core';			package: 'Glamour-Tests-Resources';			package: 'Glamour-Morphic-Theme';			package: 'Glamour-Morphic-Widgets' with: [				spec requires: #('Glamour-Morphic-Brick' ). ];			package: 'Glamour-Morphic-Renderer' with: [				spec requires: #('Glamour-Morphic-Widgets' 'Glamour-Core' ). ];			package: 'Glamour-Morphic-Pager' with: [				spec requires: #('Glamour-Morphic-Renderer' 'Glamour-Morphic-Brick' ). ];			package: 'Glamour-Tests-Morphic' with: [				spec requires: #('Glamour-Morphic-Renderer' 'Glamour-Morphic-Brick' 'Glamour-Morphic-Pager' ). ];			package: 'Glamour-Rubric-Presentations' with: [				spec requires: #('Glamour-Presentations' ). ];			package: 'Glamour-Tests-Rubric' with: [				spec requires: #('Glamour-Tests-Morphic' 'Glamour-Rubric-Presentations' ). ].		spec 			group: 'Core' with: #('Glamour-Announcements' 'Glamour-Helpers' 'Glamour-Core' 'Glamour-Presentations' 'Glamour-Browsers' 'Glamour-Examples' 'Glamour-Rubric-Presentations' );			group: 'Morphic' with: #('Glamour-Morphic-Brick' 'Glamour-Morphic-Widgets' 'Glamour-Morphic-Renderer' 'Glamour-Morphic-Theme' 'Glamour-Morphic-Pager' 'Glamour-FastTable' );			group: 'Tests' with: #('Glamour-Tests-Core' 'Glamour-Tests-Morphic' 'Glamour-Tests-Rubric' 'Glamour-Tests-Resources' 'Glamour-Morphic-Brick-Tests' );			group: 'default' with: #('Core' 'Morphic' 'Tests' ). ].! !!ConfigurationOfGlamourCore methodsFor: 'baselines' stamp: 'TudorGirba 8/17/2016 07:43'!baseline40: spec	<version: '4.0-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'For Pharo 6.0'.		spec repository: 'http://smalltalkhub.com/mc/Moose/Glamour/main'.				spec project: 'FastTable' with: [				spec					className: #ConfigurationOfFastTable;					versionString: #'development';					repository: 'http://smalltalkhub.com/mc/estebanlm/FastTable/main/' ].		spec 			package: 'Glamour-Announcements';			package: 'Glamour-Helpers';			package: 'Glamour-FastTable' with: [				spec requires: #('FastTable' 'Glamour-Examples' 'Glamour-Core' 'Glamour-Morphic-Renderer' 'Glamour-Tests-Morphic'). ];			package: 'Glamour-Core' with: [				spec requires: #('Glamour-Helpers' 'Glamour-Announcements' ). ];			package: 'Glamour-Presentations' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Browsers' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Examples' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Morphic-Brick' with: [				spec requires: #('Glamour-Core' ). ];			package: 'Glamour-Morphic-Brick-Tests' with: [				spec requires: #('Glamour-Morphic-Brick' ). ];			package: 'Glamour-Tests-Core';			package: 'Glamour-Tests-Resources';			package: 'Glamour-Morphic-Theme';			package: 'Glamour-Morphic-Widgets' with: [				spec requires: #('Glamour-Morphic-Brick' ). ];			package: 'Glamour-Morphic-Renderer' with: [				spec requires: #('Glamour-Morphic-Widgets' 'Glamour-Core' ). ];			package: 'Glamour-Morphic-Pager' with: [				spec requires: #('Glamour-Morphic-Renderer' 'Glamour-Morphic-Brick' ). ];			package: 'Glamour-Tests-Morphic' with: [				spec requires: #('Glamour-Morphic-Renderer' 'Glamour-Morphic-Brick' 'Glamour-Morphic-Pager' ). ];			package: 'Glamour-Rubric-Presentations' with: [				spec requires: #('Glamour-Presentations' ). ];			package: 'Glamour-Tests-Rubric' with: [				spec requires: #('Glamour-Tests-Morphic' 'Glamour-Rubric-Presentations' ). ].		spec 			group: 'Core' with: #('Glamour-Announcements' 'Glamour-Helpers' 'Glamour-Core' 'Glamour-Presentations' 'Glamour-Browsers' 'Glamour-Examples' 'Glamour-Rubric-Presentations' );			group: 'Morphic' with: #('Glamour-Morphic-Brick' 'Glamour-Morphic-Widgets' 'Glamour-Morphic-Renderer' 'Glamour-Morphic-Theme' 'Glamour-Morphic-Pager' 'Glamour-FastTable' );			group: 'Tests' with: #('Glamour-Tests-Core' 'Glamour-Tests-Morphic' 'Glamour-Tests-Rubric' 'Glamour-Tests-Resources' 'Glamour-Morphic-Brick-Tests' );			group: 'default' with: #('Core' 'Morphic' 'Tests' ). ].! !!ConfigurationOfGlamourCore methodsFor: 'symbolic versions' stamp: 'AndreiChis 10/4/2016 12:00' prior: 20526478!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: '4.0-baseline'.	spec for: #'pharo4.x' version: '3.1.4.Moose51'.	spec for: #'pharo5.x' version: '4.19'.	spec for: #'pharo6.x' version: '4.0-baseline'.! !!ConfigurationOfGlamourCore methodsFor: 'symbolic versions' stamp: 'PabloTesone 10/20/2016 16:17' prior: 20555380!stable: spec	<symbolicVersion: #'stable'>	spec for: #'common' version: '4.23'.	spec for: #'pharo3.x' version: '3.0.7'.	spec for: #'pharo4.x' version: '3.1.4.Moose51'.	spec for: #'pharo5.x' version: '4.19.1'.	spec for: #'pharo6.x' version: '4.23'.! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'AndreiChis 5/31/2016 15:10'!version415: spec	<version: '4.15' imports: #('3.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Glamour version 4.15'.		spec author: 'AndreiChis'.		spec timestamp: '5/31/2016 15:02'.		spec 			project: 'Rubric' with: '2.19.3';			project: 'FastTable' with: '0.10.2'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-TudorGirba.322';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-TudorGirba.303';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-AndreiChis.421';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-TheIntegrator.14';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-CyrilFerlciot.112';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-HenrikNergaard.222';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-AndreiChis.195';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-AndreiChis.349';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-TheIntegrator.54';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'PavelKrivanek 6/6/2016 16:08'!version416: spec	<version: '4.16' imports: #('3.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Glamour version 4.16'.		spec author: 'PavelKrivanek'.		spec timestamp: '6/5/2016 16:02'.		spec 			project: 'Rubric' with: '2.19.3';			project: 'FastTable' with: '0.10.2'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-TudorGirba.322';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-TudorGirba.303';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-AndreiChis.421';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-TheIntegrator.14';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-PavelKrivanek.113';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-HenrikNergaard.222';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-AndreiChis.195';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-AndreiChis.349';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-TheIntegrator.54';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'AndreiChis 6/27/2016 12:09'!version417: spec	<version: '4.17' imports: #('3.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'GToolkit Version 3.23'.		spec author: 'AndreiChis'.		spec timestamp: '6/27/2016 12:09'.		spec project: 'FastTable' with: '0.10.2'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-EstebanLorenzano.323';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-TudorGirba.307';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-HenrikNergaard.424';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-TheIntegrator.14';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-PavelKrivanek.113';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-TheIntegrator.224';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-EstebanLorenzano.197';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-EstebanLorenzano.350';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-TheIntegrator.54';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'JurajKubelka 7/21/2016 17:44'!version418: spec	<version: '4.18' imports: #('3.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Integration for case 18773.Fixes these issues:- case 18691- case 18471- case 18244- case 18708Apart from the issues:- GT-InspectorExtensions: only show methods for the current class, added basic example for RBCondition- Uses Pragma>>#methodSelector instead of Pragma>>#selector (case 18665).- Uses Behavior>>#classLayout instead of Behavior>>#layout (case 16636).- Uses CompiledMethod>>#sourceCode instead of CompiledMethod>>#getSource (case 18694).- GT-EventRecorder: Add a basic recorder event'.		spec author: 'JurajKubelka'.		spec timestamp: '7/13/2016 10:05'.		spec project: 'FastTable' with: '0.10.2'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-EstebanLorenzano.323';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-TheIntegrator.309';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-JurajKubelka.428';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-JurajKubelka.15';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-PavelKrivanek.113';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-TheIntegrator.224';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-EstebanLorenzano.197';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-EstebanLorenzano.350';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-TheIntegrator.54';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'PabloTesone 10/20/2016 16:16'!version4191: spec	<version: '4.19.1' imports: #('3.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Stable version for Pharo 5.0.'.		spec author: 'JurajKubelka'.		spec timestamp: '7/14/2016 13:46'.		spec 			project: 'Rubric' with: '2.19.3';			project: 'FastTable' with: '0.10.2'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-EstebanLorenzano.323';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-TudorGirba.303';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-GuillermoPolito.418';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-TheIntegrator.14';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-AndreiChis.111';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-HenrikNergaard.222';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-AndreiChis.195';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-AndreiChis.349';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-AndreiChis.52';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'JurajKubelka 7/14/2016 13:46'!version419: spec	<version: '4.19' imports: #('3.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Stable version for Pharo 5.0.'.		spec author: 'JurajKubelka'.		spec timestamp: '7/14/2016 13:46'.		spec 			project: 'Rubric' with: '2.19.3';			project: 'FastTable' with: '0.10.2'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-TudorGirba.322';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-TudorGirba.303';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-GuillermoPolito.418';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-TheIntegrator.14';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-AndreiChis.111';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-HenrikNergaard.222';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-AndreiChis.195';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-AndreiChis.349';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-AndreiChis.52';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'JurajKubelka 7/21/2016 18:13'!version420: spec	<version: '4.20' imports: #('3.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Prevent infinite loop in GLMScrollListBrick>>#preventOverscrolling - in some cases it was moving band to the top and to the bottom.'.		spec author: 'JurajKubelka'.		spec timestamp: '7/21/2016 18:05'.		spec project: 'FastTable' with: #stable.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-EstebanLorenzano.323';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-TheIntegrator.309';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-JurajKubelka.429';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-JurajKubelka.15';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-PavelKrivanek.113';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-TheIntegrator.224';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-EstebanLorenzano.197';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-EstebanLorenzano.350';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-TheIntegrator.54';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'AndreiChis 8/25/2016 12:26'!version421: spec	<version: '4.21' imports: #('4.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 4.12'.		spec author: 'AndreiChis'.		spec timestamp: '8/25/2016 12:26'.		spec project: 'FastTable' with: '0.10.3'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-EstebanLorenzano.323';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-MarcusDenker.310';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-JurajKubelka.429';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-JurajKubelka.15';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-PavelKrivanek.113';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-TheIntegrator.224';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-EstebanLorenzano.197';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-EstebanLorenzano.351';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-TheIntegrator.54';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'AndreiChis 9/22/2016 23:31'!version422: spec	<version: '4.22' imports: #('4.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'GToolkit Version 3.28'.		spec author: 'AndreiChis'.		spec timestamp: '9/22/2016 23:31'.		spec project: 'FastTable' with: '0.10.4'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-EstebanLorenzano.323';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-MarcusDenker.310';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-MarcusDenker.430';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-JurajKubelka.15';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-PavelKrivanek.113';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-TheIntegrator.227';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-EstebanLorenzano.197';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-EstebanLorenzano.351';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-TheIntegrator.54';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !!ConfigurationOfGlamourCore methodsFor: 'versions' stamp: 'AndreiChis 10/4/2016 12:00'!version423: spec	<version: '4.23' imports: #('4.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'GToolkit Version 3.29'.		spec author: 'AndreiChis'.		spec timestamp: '10/4/2016 12:00'.		spec project: 'FastTable' with: '0.10.4'.		spec 			package: 'Glamour-Announcements' with: 'Glamour-Announcements-AndreiChis.8';			package: 'Glamour-Helpers' with: 'Glamour-Helpers-TudorGirba.40';			package: 'Glamour-FastTable' with: 'Glamour-FastTable-AndreiChis.59';			package: 'Glamour-Core' with: 'Glamour-Core-EstebanLorenzano.323';			package: 'Glamour-Presentations' with: 'Glamour-Presentations-AndreiChis.186';			package: 'Glamour-Browsers' with: 'Glamour-Browsers-AndreiChis.112';			package: 'Glamour-Examples' with: 'Glamour-Examples-MarcusDenker.310';			package: 'Glamour-Morphic-Brick' with: 'Glamour-Morphic-Brick-MarcusDenker.430';			package: 'Glamour-Morphic-Brick-Tests' with: 'Glamour-Morphic-Brick-Tests-JurajKubelka.15';			package: 'Glamour-Tests-Core' with: 'Glamour-Tests-Core-PavelKrivanek.113';			package: 'Glamour-Tests-Resources' with: 'Glamour-Tests-Resources-AndreiChis.5';			package: 'Glamour-Morphic-Theme' with: 'Glamour-Morphic-Theme-TheIntegrator.229';			package: 'Glamour-Morphic-Widgets' with: 'Glamour-Morphic-Widgets-EstebanLorenzano.197';			package: 'Glamour-Morphic-Renderer' with: 'Glamour-Morphic-Renderer-EstebanLorenzano.351';			package: 'Glamour-Morphic-Pager' with: 'Glamour-Morphic-Pager-GuillermoPolito.110';			package: 'Glamour-Tests-Morphic' with: 'Glamour-Tests-Morphic-TudorGirba.137';			package: 'Glamour-Rubric-Presentations' with: 'Glamour-Rubric-Presentations-TheIntegrator.56';			package: 'Glamour-Tests-Rubric' with: 'Glamour-Tests-Rubric-AndreiChis.35'. ].! !"ConfigurationOfGlamourCore"!!GLMPresentation methodsFor: 'scripting actions' stamp: 'EstebanLorenzano 6/17/2016 11:09'!selectionAct: aBlock entitled: aString enabledWhen: conditionBlock	 	self 		addSelectionAction: 			((GLMGenericAction new) 				action: aBlock; 				title: aString;				enabledCondition: conditionBlock; 				yourself)! !!GLMAction methodsFor: 'accessing' stamp: 'EstebanLorenzano 6/17/2016 11:12'!enabledCondition	^ enabledCondition ifNil: [ true ]! !!GLMAction methodsFor: 'accessing' stamp: 'EstebanLorenzano 6/17/2016 11:05'!enabledCondition: anObject	enabledCondition := anObject! !!GLMAction methodsFor: 'testing' stamp: 'EstebanLorenzano 6/17/2016 11:15'!isEnabledOn: aPresentation	^ self enabledCondition glamourValueWithArgs: 			(Array 				with: aPresentation 				withAll: aPresentation entity asGlamorousArray)! !"Glamour-Core"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.976.mcz') load.ScriptLoader new update50762.!----End fileIn----!----QUIT----2016-10-25T10:09:35.559139+02:00 Pharo.image priorSource: 235226!----QUIT----2016-10-25T10:09:40.959669+02:00 Pharo.image priorSource: 281774!----QUIT----2016-10-30T01:04:00.175059+02:00 Pharo.image priorSource: 281853!----QUIT----2016-10-30T01:04:05.851847+02:00 Pharo.image priorSource: 281932!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 11/22/2016 11:34' prior: 33789836!commentForCurrentUpdate ^ '18918 Typo on welcome screen	https://pharo.fogbugz.com/f/cases/18918'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 11/22/2016 11:34'!script50763	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-EstebanLorenzano.323.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2293.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.546.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-EstebanLorenzano.47.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-EstebanLorenzano.15.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.70.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 11/22/2016 11:34'!update50763	"self new update50763"	self withUpdateLog: '18918 Typo on welcome screen	https://pharo.fogbugz.com/f/cases/18918'.	self loadTogether: self script50763 merge: false.	(World windowsSatisfying: [ :window | 	(window label = 'Welcome to Pharo 5.0')]) do: #close.WelcomeHelp openForRelease.	self flushCaches.! !ScriptLoader removeSelector: #update50762!ScriptLoader removeSelector: #script50762!"ScriptLoader50"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.977.mcz') load.ScriptLoader new update50763.!----End fileIn----!----QUIT----2016-11-22T11:36:48.190434+01:00 Pharo.image priorSource: 282011!----QUIT----2016-11-22T11:36:59.50574+01:00 Pharo.image priorSource: 299311!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 11/25/2016 16:36' prior: 33836615!commentForCurrentUpdate ^ '19361 Morph>>#showActions broken	https://pharo.fogbugz.com/f/cases/19361'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 11/25/2016 16:36'!script50764	^ 'AST-Core-TheIntegrator.418.mczAST-FFI-Pharo50Compatibility-TheIntegrator.2.mczAST-Tests-Core-TheIntegrator.95.mczAlien-eem.32.mczAnnouncements-Core-TheIntegrator.68.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.31.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-NicolaiHess.123.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-EstebanLorenzano.63.mczAthens-Text-NicolaiHess.16.mczBalloon-TheIntegrator.132.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfFileTree-ThierryGoubier.15.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfQualityAssistant-YuriyTymchuk.46.mczBaselineOfRenraku-YuriyTymchuk.5.mczBlueInk-Core-TheIntegrator.24.mczBlueInk-Extras-TheIntegrator.10.mczBlueInk-Tests-TheIntegrator.12.mczChroma-CubeHelix-TheIntegrator.2.mczCodeExport-TheIntegrator.19.mczCodeImport-TheIntegrator.88.mczCodeImportCommandLineHandlers-TheIntegrator.7.mczCollections-Abstract-TheIntegrator.313.mczCollections-Arithmetic-TheIntegrator.20.mczCollections-Atomic-TheIntegrator.16.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.246.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.188.mczCollections-Strings-TheIntegrator.415.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.49.mczCollections-Unordered-TheIntegrator.232.mczCollections-Weak-TheIntegrator.102.mczCompiler-TheIntegrator.602.mczCompression-TheIntegrator.176.mczCompression-Tests-TheIntegrator.2.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.4.mczDebuggerActions-TheIntegrator.85.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.126.mczDeprecated50-TheIntegrator.59.mczEmbeddedFreeType-TheIntegrator.26.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczFFI-Kernel-JanVanDeSandt.40.mczFFI-Pools-eem.3.mczFileSystem-Core-TheIntegrator.202.mczFileSystem-Disk-TheIntegrator.97.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.95.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.417.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-TheIntegrator.17.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.14.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.742.mczFreeType-Tests-TheIntegrator.2.mczFuel-MaxLeske.825.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-TheIntegrator.62.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.411.mczFuelTools-Debugger-TheIntegrator.10.mczGT-BytecodeDebugger-TudorGirba.31.mczGT-Debugger-AndreiChis.350.mczGT-EventRecorder-TheIntegrator.68.mczGT-EventRecorder-Tests-JurajKubelka.37.mczGT-Inspector-AndreiChis.421.mczGT-InspectorExtensions-Core-TheIntegrator.214.mczGT-Playground-DenisKudryashov.124.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-TudorGirba.397.mczGT-Spotter-EventRecorder-GuillermoPolito.112.mczGT-SpotterExtensions-Core-VincentBlondeau.203.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-StefanReichhart.56.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AliakseiSyrel.17.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-EstebanLorenzano.323.mczGlamour-Examples-TudorGirba.303.mczGlamour-FastTable-AndreiChis.59.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-GuillermoPolito.418.mczGlamour-Morphic-Brick-Tests-TheIntegrator.14.mczGlamour-Morphic-Pager-GuillermoPolito.110.mczGlamour-Morphic-Renderer-AndreiChis.349.mczGlamour-Morphic-Theme-HenrikNergaard.222.mczGlamour-Morphic-Widgets-AndreiChis.195.mczGlamour-Presentations-AndreiChis.186.mczGlamour-Rubric-Presentations-AndreiChis.52.mczGlamour-Tests-Core-AndreiChis.111.mczGlamour-Tests-Morphic-TudorGirba.137.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.35.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.6.mczGraphics-Display Objects-TheIntegrator.175.mczGraphics-Files-TheIntegrator.76.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.189.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.80.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.41.mczHelpSystem-Core-TheIntegrator.144.mczHelpSystem-Tests-TheIntegrator.32.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.90.mczImportingResource-Help-TheIntegrator.4.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.28.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2293.mczKernel-Rules-TheIntegrator.2.mczKernel-Tests-TheIntegrator.65.mczKeymapping-Core-TheIntegrator.198.mczKeymapping-KeyCombinations-TheIntegrator.62.mczKeymapping-Pragmas-TheIntegrator.54.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.105.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.166.mczManifest-Core-TheIntegrator.239.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.51.mczMenuRegistration-TheIntegrator.78.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.824.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-EstebanLorenzano.733.mczMetacello-PharoCommonPlatform-TheIntegrator.22.mczMetacello-Platform-EstebanLorenzano.3.mczMetacello-ProfStef-EstebanLorenzano.18.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.7.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform.squeakCommon-EstebanLorenzano.23.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-EstebanLorenzano.148.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1132.mczMonticello-OldDataStreamCompatibility-TheIntegrator.8.mczMonticello-Tests-TheIntegrator.35.mczMonticelloConfigurations-TheIntegrator.72.mczMonticelloFileServices-TheIntegrator.6.mczMonticelloFileTree-Core-TheIntegrator.141.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.30.mczMonticelloGUI-TheIntegrator.415.mczMonticelloMocks-TheIntegrator.4.mczMonticelloRemoteRepositories-TheIntegrator.15.mczMoose-Algos-Graph-vincentBlondeau.31.mczMorphic-Base-TheIntegrator.548.mczMorphic-Core-TheIntegrator.278.mczMorphic-Examples-TheIntegrator.50.mczMorphic-Tests-TheIntegrator.11.mczMorphic-Widgets-Basic-TheIntegrator.86.mczMorphic-Widgets-ColorPicker-TheIntegrator.19.mczMorphic-Widgets-Extra-TheIntegrator.27.mczMorphic-Widgets-FastTable-StephanEggermont.177.mczMorphic-Widgets-List-TheIntegrator.21.mczMorphic-Widgets-NewList-TheIntegrator.9.mczMorphic-Widgets-Pluggable-TheIntegrator.66.mczMorphic-Widgets-PolyTabs-TheIntegrator.2.mczMorphic-Widgets-Scrolling-TheIntegrator.32.mczMorphic-Widgets-Tabs-TheIntegrator.20.mczMorphic-Widgets-Taskbar-TheIntegrator.21.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.50.mczMorphic-Widgets-Windows-TheIntegrator.97.mczMultilingual-Encodings-TheIntegrator.61.mczMultilingual-Languages-TheIntegrator.55.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.81.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.244.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1253.mczNautilus-GroupManager-TheIntegrator.20.mczNautilus-GroupManagerUI-TheIntegrator.31.mczNautilus-Tests-TheIntegrator.37.mczNautilusCommon-TheIntegrator.305.mczNautilusGroupAutoBuilder-TheIntegrator.11.mczNautilusRefactoring-TheIntegrator.272.mczNetwork-Kernel-TheIntegrator.133.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-EstebanLorenzano.47.mczNetwork-Protocols-TheIntegrator.103.mczNetwork-Tests-EstebanLorenzano.15.mczNetwork-UUID-TheIntegrator.44.mczNetwork-Url-MarcusDenker.99.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.55.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-RonieSalgado.107.mczOSWindow-SDL2-RonieSalgado.96.mczOSWindow-SDL2-Examples-RonieSalgado.13.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOpalCompiler-Core-TheIntegrator.799.mczOpalCompiler-Tests-TheIntegrator.334.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.31.mczPolymorph-TaskbarIcons-TheIntegrator.46.mczPolymorph-Widgets-TheIntegrator.1338.mczPragmaCollector-TheIntegrator.12.mczProfStef-Core-TheIntegrator.77.mczProfStef-Help-TheIntegrator.16.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.101.mczQualityAssistantRecording-YuriyTymchuk.20.mczRPackage-Core-TheIntegrator.430.mczRPackage-Tests-TheIntegrator.181.mczRandom-Core-TheIntegrator.4.mczRandom-Tests-TheIntegrator.4.mczRecentSubmissions-TheIntegrator.238.mczRefactoring-Changes-TheIntegrator.67.mczRefactoring-Core-TheIntegrator.298.mczRefactoring-Critics-TheIntegrator.261.mczRefactoring-Environment-TheIntegrator.76.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.131.mczRefactoring-Tests-Critics-TheIntegrator.38.mczRefactoring-Tests-Environment-TheIntegrator.23.mczReflectivity-TheIntegrator.297.mczReflectivity-Examples-TheIntegrator.28.mczReflectivity-Tests-TheIntegrator.202.mczReflectivity-Tools-TheIntegrator.24.mczReflectivity-Tools-Tests-TheIntegrator.11.mczRegex-Core-TheIntegrator.38.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.31.mczRenraku-YuriyTymchuk.111.mczRenraku-Test-YuriyTymchuk.19.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.237.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.90.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.364.mczRubric-Rules-YuriyTymchuk.3.mczSTON-Core-PavelKrivanek.73.mczSTON-Tests-SvenVanCaekenberghe.64.mczSUnit-Core-TheIntegrator.169.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.3.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-EstebanLorenzano.138.mczSUnit-UITesting-TheIntegrator.32.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.92.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TommasoDalSasso.3.mczShoreLine-Report-UI-TommasoDalSasso.17.mczShout-TheIntegrator.291.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.742.mczSlot-Tests-TheIntegrator.89.mczSmartSuggestions-TheIntegrator.234.mczSmartSuggestions-Tests-TheIntegrator.33.mczSpec-Core-TheIntegrator.465.mczSpec-Debugger-TheIntegrator.263.mczSpec-Examples-TheIntegrator.108.mczSpec-Help-TheIntegrator.10.mczSpec-Inspector-TheIntegrator.258.mczSpec-Layout-TheIntegrator.69.mczSpec-MorphicAdapters-TheIntegrator.269.mczSpec-PolyWidgets-TheIntegrator.66.mczSpec-Tests-TheIntegrator.63.mczSpec-Tools-TheIntegrator.324.mczStartupPreferences-TheIntegrator.149.mczSystem-Announcements-TheIntegrator.108.mczSystem-BasicCommandLineHandler-TheIntegrator.18.mczSystem-Caching-TheIntegrator.26.mczSystem-CachingTests-TheIntegrator.16.mczSystem-Changes-TheIntegrator.292.mczSystem-Changes-FileServices-TheIntegrator.2.mczSystem-Clipboard-TheIntegrator.40.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.4.mczSystem-CommandLineHandler-TheIntegrator.18.mczSystem-FileRegistry-TheIntegrator.50.mczSystem-Finalization-TheIntegrator.32.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.106.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.4.mczSystem-OSEnvironments-TheIntegrator.31.mczSystem-Object Events-TheIntegrator.25.mczSystem-Platforms-TheIntegrator.81.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.27.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.337.mczSystem-Settings-Tests-TheIntegrator.11.mczSystem-Sound-StephaneDucasse.18.mczSystem-Sources-TheIntegrator.50.mczSystem-Support-TheIntegrator.1215.mczSystem-SupportTests-TheIntegrator.2.mczSystem-VMEvents-TheIntegrator.17.mczTests-TheIntegrator.755.mczText-Core-TheIntegrator.50.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.114.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.140.mczTool-Catalog-GuillermoPolito.32.mczTool-CriticBrowser-TheIntegrator.21.mczTool-DependencyAnalyser-ChristopheDemarey.28.mczTool-DependencyAnalyser-Test-ChristopheDemarey.11.mczTool-DependencyAnalyser-UI-ChristopheDemarey.43.mczTool-Diff-TheIntegrator.31.mczTool-ExternalBrowser-TheIntegrator.49.mczTool-FileList-TheIntegrator.62.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.65.mczTool-ImageCleaner-TheIntegrator.17.mczTool-ProcessBrowser-TheIntegrator.20.mczTool-Profilers-TheIntegrator.22.mczTool-SystemReporter-TheIntegrator.15.mczTool-Transcript-TheIntegrator.25.mczTool-TxWorkspace-NicolaiHess.7.mczTool-Workspace-TheIntegrator.37.mczTools-TheIntegrator.1525.mczTools-Test-TheIntegrator.16.mczTraits-TheIntegrator.907.mczTranscript-TheIntegrator.50.mczTxText-Athens-GuillermoPolito.53.mczTxText-AthensTests-SeanDeNigris.10.mczTxText-Model-SeanDeNigris.61.mczTxText-Styler-MarcusDenker.17.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.187.mczUnicode-Initialization-TheIntegrator.15.mczUnifiedFFI-EstebanLorenzano.70.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.25.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-VincentBlondeau.32.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-StephaneDucasse.64.mczVersionner-Core-DependenciesModel-ChristopheDemarey.105.mczVersionner-Core-Model-ChristopheDemarey.52.mczVersionner-Spec-Browser-PabloTesone.189.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczZinc-Character-Encoding-Core-TheIntegrator.48.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.27.mczZinc-FileSystem-SvenVanCaekenberghe.12.mczZinc-HTTP-SvenVanCaekenberghe.448.mczZinc-Resource-Meta-Core-TheIntegrator.58.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.36.mczZinc-Tests-SvenVanCaekenberghe.236.mczZinc-Zodiac-TheIntegrator.37.mczZodiac-Core-SvenVanCaekenberghe.42.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.13.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 11/25/2016 16:36'!update50764	"self new update50764"	self withUpdateLog: '19361 Morph>>#showActions broken	https://pharo.fogbugz.com/f/cases/19361'.	self loadTogether: self script50764 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update50763!ScriptLoader removeSelector: #script50763!"ScriptLoader50"!!MorphicEventHandler methodsFor: 'access' stamp: 'PhilippeBack 11/17/2016 13:55' prior: 33438176!methodRefList	"Return a MethodReference for each message I can send."	| list |	list := OrderedCollection new.	subscriptions do: [		:subscriptionSet |				subscriptionSet do: [ 	 :s | 			s  ifNotNil: [list						add: (RGMethodDefinition								realClass: (s recipient class whichClassIncludesSelector: s selector)								selector: s selector)]							]		].	^ list! !"Morphic-Base"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo50/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader50-TheIntegrator.978.mcz') load.ScriptLoader new update50764.!----End fileIn----!----QUIT----2016-11-25T16:38:05.412728+01:00 Pharo.image priorSource: 299390!----QUIT----2016-11-25T16:38:20.375238+01:00 Pharo.image priorSource: 317065!----SNAPSHOT----2016-11-30T00:43:27.979029+01:00 Pillar.image priorSource: 317144!!ConfigurationOfPillar commentStamp: '<historical>' prior: 0!I describe Pillar's dependencies and versions.!!ConfigurationOfPillar class methodsFor: 'development support' stamp: 'DamienCassou 10/7/2013 11:10'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfPillar class methodsFor: 'private' stamp: 'DamienCassou 10/7/2013 11:10'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfPillar class methodsFor: 'metadata' stamp: 'DamienCassou 12/19/2013 13:34'!catalogChangeLog	^ 'nothing'! !!ConfigurationOfPillar class methodsFor: 'metadata' stamp: 'DamienCassou 10/12/2015 13:25'!catalogContactInfo	^ 'The original creator of Pillar (formerly known as ''''the syntax behind the Pier CMS'''') is Lukas Renggli. Nevertheless, *Damien Cassou>damien.cassou@inria.fr* is now the maintainer. The website is at *http://www.smalltalkhub.com/#!!/~Pier/Pillar*. Issues should be reported to *https://github.com/pillar-markup/pillar/issues*'! !!ConfigurationOfPillar class methodsFor: 'metadata' stamp: 'DamienCassou 10/12/2015 13:26'!catalogDescription	^ 'Pillar is a wiki-like syntax, its document model, a parser for it, and a set of exporters (e.g., HTML, LaTeX, Markdown...). Pillar is primarily used as the wiki syntax behind the *Pier CMS>http://piercms.com*. Pillar is also being used to write books: e.g., *the Enterprise Pharo book>http://books.pharo.org/*.'! !!ConfigurationOfPillar class methodsFor: 'metadata' stamp: 'LukasKomarek 4/5/2016 17:38'!catalogKeyClassesAndExample	^ 'The key classes are:- ==PRDocumentItem== and all its subclasses (e.g., ==PRLink==, ==PRParagraph==, ==PRHeader==, ==PRDocument==). These classes represent the document model.- ==PRDocumentParser== which takes a pillar-formatted string as input and produces a ==PRDocument== (i.e., the document model) as output. Its main public method is its ==parse:== method on class-side to start the parsing process.- ==PRVisitor== which provides all the functionality to navigate the document model.- ==PRTransformer== is a set of visitor which will transform the document to improve it before the export.- ==PRDocumentWriter== is the superclass of all classes supposed to output a pier document model to a text file. Its subclasses include one to output a LaTeX document and one to output an HTML webpage.From Pharo, you can create an HTML out of a Pillar-formatted string by writing a code similar to:[[[language=SmalltalkPRHTMLWriter defaultConfiguration	outputDirectory: FileLocator imageDirectory;    inputString: ''Some text with *a link to Pharo>http://www.pharo.org*.'';    outputFile: (RelativePath from: ''foo.html'');    export]]]Executing this code will result in the creation of a ==myFirstPillarExport.html== file with this content:[[[language=html<p>Some text with <a href="http://www.pharo.org">a link to Pharo</a>.</p>]]]'! !!ConfigurationOfPillar class methodsFor: 'metadata' stamp: 'DamienCassou 10/12/2015 13:25'!catalogKeywords	^ #(pier book wiki html latex markdown document)! !!ConfigurationOfPillar class methodsFor: 'private' stamp: 'DamienCassou 10/7/2013 11:10'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfPillar class methodsFor: 'private' stamp: 'DamienCassou 10/7/2013 11:10'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfPillar class methodsFor: 'metacello tool support' stamp: 'DamienCassou 10/7/2013 11:10'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfPillar class methodsFor: 'loading' stamp: 'DamienCassou 10/7/2013 11:10'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfPillar class methodsFor: 'loading' stamp: 'DamienCassou 10/7/2013 11:10'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfPillar class methodsFor: 'loading' stamp: 'DamienCassou 10/7/2013 11:10'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfPillar class methodsFor: 'loading' stamp: 'DamienCassou 4/3/2015 13:46'!loadStable	"Load the #stable version defined for this platform.."	"self loadStable"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfPillar class methodsFor: 'accessing' stamp: 'DamienCassou 10/7/2013 11:10'!project	^self new project! !!ConfigurationOfPillar class methodsFor: 'development support' stamp: 'DamienCassou 10/7/2013 11:10'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'DamienCassou 2/19/2014 11:07'!baseline010: spec	<version: '0.10-baseline'>	spec		for: #common		do: [ 			spec				blessing: #baseline;				repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/';				package: 'Pillar-Model' with: [ spec requires: #('Grease') ];				package: 'Pillar-ExporterCore' with: [ spec requires: #('Pillar-Model' 'Mustache' 'STON') ];				package: 'Pillar-Tests-Model' with: [ spec requires: #('Pillar-Model') ];				package: 'Pillar-Tests-ExporterCore' with: [ spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore') ];				package: 'Pillar-ExporterHTML' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterHTML' with: [ spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-ExporterLaTeX' with: [ spec requires: 'Pillar-ExporterCore' ];				package: 'Pillar-Tests-ExporterLaTeX'					with: [ spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-ExporterMarkdown' with: [ spec requires: 'Pillar-ExporterCore' ];				package: 'Pillar-Tests-ExporterMarkdown'					with: [ spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore') ].			spec				group: 'html' with: 'Pillar-ExporterHTML';				group: 'html tests' with: 'Pillar-Tests-ExporterHTML';				group: 'latex' with: 'Pillar-ExporterLaTeX';				group: 'latex tests' with: 'Pillar-Tests-ExporterLaTeX';				group: 'markdown' with: 'Pillar-ExporterMarkdown';				group: 'markdown tests' with: 'Pillar-Tests-ExporterMarkdown';				group: 'All exporters' with: #('html' 'latex' 'markdown');				group: 'All exporter tests' with: #('html tests' 'latex tests' 'markdown tests');				group: 'All tests' with: #('All exporter tests' 'Pillar-Tests-Model' 'Pillar-Tests-ExporterCore');				group: 'All but tests' with: #('All exporters');				group: 'ALL' with: #('All tests' 'All but tests').			self				grease: spec;				mustache: spec;				ston: spec ].	spec		for: #'pharo3.x'		do: [ 			spec package: 'Pillar-Cli' with: [ spec requires: 'Pillar-ExporterCore' ].			spec group: 'All but tests' with: #('Pillar-Cli') ]! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'DamienCassou 3/6/2014 10:37'!baseline011: spec	<version: '0.11-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/'.			self				grease: spec;				mustache: spec;				ston: spec.			spec				package: 'Pillar-Model' with: [ spec requires: #('Grease') ];				package: 'Pillar-Tests-Model'					with: [ spec requires: #('Pillar-Model' 'Pillar-ExporterPillar' 'Pillar-ExporterText') ];				package: 'Pillar-ExporterCore' with: [ spec requires: #('Pillar-Model' 'Mustache' 'STON') ];				package: 'Pillar-ExporterMarkdown' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterLaTeX' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterHTML' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterPillar' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterText' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterCore' with: [ spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterMarkdown'					with: [ spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterLaTeX'					with: [ spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterHTML' with: [ spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterPillar'					with: [ spec requires: #('Pillar-ExporterPillar' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterText' with: [ spec requires: #('Pillar-ExporterText' 'Pillar-Tests-ExporterCore') ].			spec				group: 'html exporter' with: #('Pillar-ExporterHTML');				group: 'html exporter tests' with: #('Pillar-Tests-ExporterHTML');				group: 'latex exporter' with: #('Pillar-ExporterLaTeX');				group: 'latex exporter tests' with: #('Pillar-Tests-ExporterLaTeX');				group: 'markdown exporter' with: #('Pillar-ExporterMarkdown');				group: 'markdown exporter tests' with: #('Pillar-Tests-ExporterMarkdown');				group: 'pillar exporter' with: #('Pillar-ExporterPillar');				group: 'pillar exporter tests' with: #('Pillar-Tests-ExporterPillar');				group: 'text exporter' with: #('Pillar-ExporterText');				group: 'text exporter tests' with: #('Pillar-Tests-ExporterText');				group: 'All exporters'					with: #('html exporter' 'latex exporter' 'markdown exporter' 'pillar exporter' 'text exporter');				group: 'All exporter tests'					with:						#('html exporter tests' 'latex exporter tests' 'markdown exporter tests' 'pillar exporter tests' 'text exporter tests');				group: 'All tests' with: #('All exporter tests' 'Pillar-Tests-Model' 'Pillar-Tests-ExporterCore');				group: 'All but tests' with: #('All exporters');				group: 'ALL' with: #('All tests' 'All but tests') ].	spec		for: #'pharo3.x'		do: [ 			spec				package: 'Pillar-PharoInspector' with: [ spec requires: #('Pillar-Model' 'Pillar-ExporterPillar') ];				package: 'Pillar-Cli' with: [ spec requires: 'Pillar-ExporterCore' ];				group: 'All but tests' with: #('Pillar-Cli' 'Pillar-PharoInspector') ]! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'DamienCassou 6/6/2014 17:01'!baseline012: spec	<version: '0.12-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/'.			self				grease: spec;				mustache: spec;				ston: spec.			spec				package: 'Pillar-Model' with: [ spec requires: #('Grease') ];				package: 'Pillar-Tests-Model'					with: [ spec requires: #('Pillar-Model' 'Pillar-ExporterPillar' 'Pillar-ExporterText') ];				package: 'Pillar-ExporterCore' with: [ spec requires: #('Pillar-Model' 'Mustache' 'STON') ];				package: 'Pillar-ExporterMarkdown' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterLaTeX' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterHTML' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterPillar' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterText' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterCore' with: [ spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterMarkdown'					with: [ spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterLaTeX'					with: [ spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterHTML' with: [ spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterPillar'					with: [ spec requires: #('Pillar-ExporterPillar' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterText' with: [ spec requires: #('Pillar-ExporterText' 'Pillar-Tests-ExporterCore') ].			spec				group: 'html exporter' with: #('Pillar-ExporterHTML');				group: 'html exporter tests' with: #('Pillar-Tests-ExporterHTML');				group: 'latex exporter' with: #('Pillar-ExporterLaTeX');				group: 'latex exporter tests' with: #('Pillar-Tests-ExporterLaTeX');				group: 'markdown exporter' with: #('Pillar-ExporterMarkdown');				group: 'markdown exporter tests' with: #('Pillar-Tests-ExporterMarkdown');				group: 'pillar exporter' with: #('Pillar-ExporterPillar');				group: 'pillar exporter tests' with: #('Pillar-Tests-ExporterPillar');				group: 'text exporter' with: #('Pillar-ExporterText');				group: 'text exporter tests' with: #('Pillar-Tests-ExporterText');				group: 'All exporters'					with: #('html exporter' 'latex exporter' 'markdown exporter' 'pillar exporter' 'text exporter');				group: 'All exporter tests'					with:						#('html exporter tests' 'latex exporter tests' 'markdown exporter tests' 'pillar exporter tests' 'text exporter tests');				group: 'All tests' with: #('All exporter tests' 'Pillar-Tests-Model' 'Pillar-Tests-ExporterCore');				group: 'All but tests' with: #('All exporters');				group: 'ALL' with: #('All tests' 'All but tests') ].	spec		for: #pharo		do: [ 			spec				package: 'Pillar-PharoInspector' with: [ spec requires: #('Pillar-Model' 'Pillar-ExporterPillar') ];				package: 'Pillar-Cli' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-GitBook' with: [ spec requires: #('Pillar-Cli' 'markdown exporter' 'text exporter') ];				group: 'All but tests' with: #('Pillar-Cli' 'Pillar-PharoInspector' 'Pillar-GitBook') ]! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'DiegoLont 2/7/2014 10:24'!"protocol: accessing"baseline01: spec	<version: '0.1-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/'.			spec package: 'Pillar-Model' with: [ spec requires: #('Grease') ].			spec package: 'Pillar-Tests-Model' with: [ spec requires: #('Pillar-Model') ].			spec package: 'Pillar-ExporterHTML' with: [ spec requires: #('Pillar-Model') ].			spec package: 'Pillar-Tests-ExporterHTML' with: [ spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-Model') ].			spec package: 'Pillar-ExporterLaTeX' with: [ spec requires: 'Pillar-Model' ].			spec package: 'Pillar-Tests-ExporterLaTeX' with: [ spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-Model') ].			spec package: 'Pillar-ExporterMarkdown' with: [ spec requires: 'Pillar-Model' ].			spec package: 'Pillar-Tests-ExporterMarkdown' with: [ spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-Model') ].			spec group: 'ALL' with: #('Pillar-Tests-ExporterLaTeX' 'Pillar-Tests-ExporterHTML' 'Pillar-Tests-ExporterMarkdown' ).			self grease: spec ]! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'TorstenBergmann 3/6/2015 02:05'!baseline020: spec	<version: '0.20-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/'.			self				grease: spec;				mustache: spec;				ston: spec.			spec				package: 'Pillar-Model' with: [ spec requires: #('Grease') ];				package: 'Pillar-Tests-Model'					with: [ spec requires: #('Pillar-Model' 'Pillar-ExporterPillar' 'Pillar-ExporterText') ];				package: 'Pillar-ExporterCore' with: [ spec requires: #('Pillar-Model' 'Mustache' 'STON') ];				package: 'Pillar-ExporterMarkdown' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterLaTeX' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterHTML' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterPillar' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterText' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterCore' with: [ spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterMarkdown'					with: [ spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterLaTeX'					with: [ spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterHTML' with: [ spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterPillar'					with: [ spec requires: #('Pillar-ExporterPillar' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterText' with: [ spec requires: #('Pillar-ExporterText' 'Pillar-Tests-ExporterCore') ].			spec				group: 'html exporter' with: #('Pillar-ExporterHTML');				group: 'html exporter tests' with: #('Pillar-Tests-ExporterHTML');				group: 'latex exporter' with: #('Pillar-ExporterLaTeX');				group: 'latex exporter tests' with: #('Pillar-Tests-ExporterLaTeX');				group: 'markdown exporter' with: #('Pillar-ExporterMarkdown');				group: 'markdown exporter tests' with: #('Pillar-Tests-ExporterMarkdown');				group: 'pillar exporter' with: #('Pillar-ExporterPillar');				group: 'pillar exporter tests' with: #('Pillar-Tests-ExporterPillar');				group: 'text exporter' with: #('Pillar-ExporterText');				group: 'text exporter tests' with: #('Pillar-Tests-ExporterText');				group: 'All exporters'					with: #('html exporter' 'latex exporter' 'markdown exporter' 'pillar exporter' 'text exporter');				group: 'All exporter tests'					with:						#('html exporter tests' 'latex exporter tests' 'markdown exporter tests' 'pillar exporter tests' 'text exporter tests');				group: 'All tests' with: #('All exporter tests' 'Pillar-Tests-Model' 'Pillar-Tests-ExporterCore');				group: 'All but tests' with: #('All exporters');				group: 'ALL' with: #('All tests' 'All but tests') ].	spec		for: #pharo		do: [ 			spec				package: 'Pillar-Pharo-Tools' with: [ spec requires: #('Pillar-Model' 'Pillar-ExporterPillar') ];				package: 'Pillar-Cli' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-GitBook' with: [ spec requires: #('Pillar-Cli' 'markdown exporter' 'text exporter') ];				group: 'All but tests' with: #('Pillar-Cli' 'Pillar-Pharo-Tools' 'Pillar-GitBook') ]! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'CyrilFerlicot 4/1/2015 18:08'!baseline021: spec	<version: '0.21-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/'.			self				grease: spec;				mustache: spec;				cocoon: spec.			spec				package: 'Pillar-Model' with: [ spec requires: #('Grease') ];				package: 'Pillar-Tests-Model'					with: [ spec requires: #('Pillar-Model' 'Pillar-ExporterPillar' 'Pillar-ExporterText') ];				package: 'Pillar-ExporterCore' with: [ spec requires: #('Pillar-Model' 'Mustache' 'Cocoon') ];				package: 'Pillar-ExporterMarkdown' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterLaTeX' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterHTML' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterPillar' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterText' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterCore' with: [ spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterMarkdown'					with: [ spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterLaTeX'					with: [ spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterHTML' with: [ spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterPillar'					with: [ spec requires: #('Pillar-ExporterPillar' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterText' with: [ spec requires: #('Pillar-ExporterText' 'Pillar-Tests-ExporterCore') ].			spec				group: 'html exporter' with: #('Pillar-ExporterHTML');				group: 'html exporter tests' with: #('Pillar-Tests-ExporterHTML');				group: 'latex exporter' with: #('Pillar-ExporterLaTeX');				group: 'latex exporter tests' with: #('Pillar-Tests-ExporterLaTeX');				group: 'markdown exporter' with: #('Pillar-ExporterMarkdown');				group: 'markdown exporter tests' with: #('Pillar-Tests-ExporterMarkdown');				group: 'pillar exporter' with: #('Pillar-ExporterPillar');				group: 'pillar exporter tests' with: #('Pillar-Tests-ExporterPillar');				group: 'text exporter' with: #('Pillar-ExporterText');				group: 'text exporter tests' with: #('Pillar-Tests-ExporterText');				group: 'All exporters'					with: #('html exporter' 'latex exporter' 'markdown exporter' 'pillar exporter' 'text exporter');				group: 'All exporter tests'					with:						#('html exporter tests' 'latex exporter tests' 'markdown exporter tests' 'pillar exporter tests' 'text exporter tests');				group: 'All tests' with: #('All exporter tests' 'Pillar-Tests-Model' 'Pillar-Tests-ExporterCore');				group: 'All but tests' with: #('All exporters');				group: 'ALL' with: #('All tests' 'All but tests') ].	spec		for: #pharo		do: [ 			spec				package: 'Pillar-Pharo-Tools' with: [ spec requires: #('Pillar-Model' 'Pillar-ExporterPillar') ];				package: 'Pillar-Cli' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-GitBook' with: [ spec requires: #('Pillar-Cli' 'markdown exporter' 'text exporter') ];				group: 'All but tests' with: #('Pillar-Cli' 'Pillar-Pharo-Tools' 'Pillar-GitBook') ]! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'DamienCassou 6/20/2015 14:03'!baseline022: spec	<version: '0.22-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/'.			self				grease: spec;				mustache: spec;				cocoon: spec.			spec				package: 'Pillar-Model' with: [ spec requires: #('Grease') ];				package: 'Pillar-Tests-Model'					with: [ spec requires: #('Pillar-Model' 'Pillar-ExporterPillar' 'Pillar-ExporterText') ];				package: 'Pillar-ExporterCore' with: [ spec requires: #('Pillar-Model' 'Mustache' 'Cocoon') ];				package: 'Pillar-ExporterMarkdown' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterLaTeX' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterBeamer' with: [ spec requires: #('Pillar-ExporterLaTeX') ];				package: 'Pillar-ExporterHTML' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterPillar' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterText' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterCore' with: [ spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterMarkdown'					with: [ spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterLaTeX'					with: [ spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterBeamer'					with: [ spec requires: #('Pillar-ExporterBeamer' 'Pillar-Tests-ExporterLaTeX') ];				package: 'Pillar-Tests-ExporterHTML' with: [ spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterPillar'					with: [ spec requires: #('Pillar-ExporterPillar' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterText' with: [ spec requires: #('Pillar-ExporterText' 'Pillar-Tests-ExporterCore') ].			spec				group: 'html exporter' with: #('Pillar-ExporterHTML');				group: 'html exporter tests' with: #('Pillar-Tests-ExporterHTML');				group: 'latex exporter' with: #('Pillar-ExporterLaTeX');				group: 'latex exporter tests' with: #('Pillar-Tests-ExporterLaTeX');				group: 'beamer exporter' with: #('Pillar-ExporterBeamer');				group: 'beamer exporter tests' with: #('Pillar-Tests-ExporterBeamer');				group: 'markdown exporter' with: #('Pillar-ExporterMarkdown');				group: 'markdown exporter tests' with: #('Pillar-Tests-ExporterMarkdown');				group: 'pillar exporter' with: #('Pillar-ExporterPillar');				group: 'pillar exporter tests' with: #('Pillar-Tests-ExporterPillar');				group: 'text exporter' with: #('Pillar-ExporterText');				group: 'text exporter tests' with: #('Pillar-Tests-ExporterText');				group: 'All exporters'					with: #('html exporter' 'latex exporter' 'beamer exporter' 'markdown exporter' 'pillar exporter' 'text exporter');				group: 'All exporter tests'					with:						#('html exporter tests' 'latex exporter tests' 'beamer exporter tests' 'markdown exporter tests' 'pillar exporter tests' 'text exporter tests');				group: 'All tests' with: #('All exporter tests' 'Pillar-Tests-Model' 'Pillar-Tests-ExporterCore');				group: 'All but tests' with: #('All exporters');				group: 'ALL' with: #('All tests' 'All but tests') ].	spec		for: #pharo		do: [ 			spec				package: 'Pillar-Pharo-Tools' with: [ spec requires: #('Pillar-Model' 'All exporters') ];				package: 'Pillar-Cli' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-GitBook' with: [ spec requires: #('Pillar-Cli' 'markdown exporter' 'text exporter') ];				group: 'All but tests' with: #('Pillar-Cli' 'Pillar-Pharo-Tools' 'Pillar-GitBook') ]! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'DamienCassou 6/20/2015 14:02'!baseline023: spec	<version: '0.23-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/'.			self				grease: spec;				mustache: spec;				cocoon: spec.			spec				package: 'Pillar-Model' with: [ spec requires: #('Grease') ];				package: 'Pillar-Tests-Model'					with: [ spec requires: #('Pillar-Model' 'Pillar-ExporterPillar' 'Pillar-ExporterText') ];				package: 'Pillar-ExporterCore' with: [ spec requires: #('Pillar-Model' 'Mustache' 'Cocoon') ];				package: 'Pillar-ExporterMarkdown' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterLaTeX' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterBeamer' with: [ spec requires: #('Pillar-ExporterLaTeX') ];				package: 'Pillar-ExporterDeckJS' with: [ spec requires: #('Pillar-ExporterHTML') ];				package: 'Pillar-ExporterHTML' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterPillar' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterText' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterCore' with: [ spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterMarkdown'					with: [ spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterLaTeX'					with: [ spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterBeamer'					with: [ spec requires: #('Pillar-ExporterBeamer' 'Pillar-Tests-ExporterLaTeX') ];				package: 'Pillar-Tests-ExporterDeckJS'					with: [ spec requires: #('Pillar-ExporterDeckJS' 'Pillar-Tests-ExporterHTML') ];				package: 'Pillar-Tests-ExporterHTML' with: [ spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterPillar'					with: [ spec requires: #('Pillar-ExporterPillar' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterText' with: [ spec requires: #('Pillar-ExporterText' 'Pillar-Tests-ExporterCore') ].			spec				group: 'html exporter' with: #('Pillar-ExporterHTML');				group: 'html exporter tests' with: #('Pillar-Tests-ExporterHTML');				group: 'latex exporter' with: #('Pillar-ExporterLaTeX');				group: 'latex exporter tests' with: #('Pillar-Tests-ExporterLaTeX');				group: 'beamer exporter' with: #('Pillar-ExporterBeamer');				group: 'beamer exporter tests' with: #('Pillar-Tests-ExporterBeamer');				group: 'deckjs exporter' with: #('Pillar-ExporterDeckJS');				group: 'deckjs exporter tests' with: #('Pillar-Tests-ExporterDeckJS');				group: 'markdown exporter' with: #('Pillar-ExporterMarkdown');				group: 'markdown exporter tests' with: #('Pillar-Tests-ExporterMarkdown');				group: 'pillar exporter' with: #('Pillar-ExporterPillar');				group: 'pillar exporter tests' with: #('Pillar-Tests-ExporterPillar');				group: 'text exporter' with: #('Pillar-ExporterText');				group: 'text exporter tests' with: #('Pillar-Tests-ExporterText');				group: 'All exporters'					with: #('html exporter' 'latex exporter' 'beamer exporter' 'deckjs exporter' 'markdown exporter' 'pillar exporter' 'text exporter');				group: 'All exporter tests'					with:						#('html exporter tests' 'latex exporter tests' 'beamer exporter tests' 'deckjs exporter tests' 'markdown exporter tests' 'pillar exporter tests' 'text exporter tests');				group: 'All tests' with: #('All exporter tests' 'Pillar-Tests-Model' 'Pillar-Tests-ExporterCore');				group: 'All but tests' with: #('All exporters');				group: 'ALL' with: #('All tests' 'All but tests') ].	spec		for: #pharo		do: [ 			spec				package: 'Pillar-Pharo-Tools' with: [ spec requires: #('Pillar-Model' 'All exporters') ];				package: 'Pillar-Cli' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-GitBook' with: [ spec requires: #('Pillar-Cli' 'markdown exporter' 'text exporter') ];				group: 'All but tests' with: #('Pillar-Cli' 'Pillar-Pharo-Tools' 'Pillar-GitBook') ]! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'CyrilFerlicot 8/10/2015 15:10'!baseline024: spec	<version: '0.24-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/'.			self				grease: spec;				mustache: spec;				cocoon: spec.			spec				package: 'Pillar-Model' with: [ spec requires: #('Grease') ];				package: 'Pillar-Tests-Model'					with: [ spec requires: #('Pillar-Model' 'Pillar-ExporterPillar' 'Pillar-ExporterText') ];				package: 'Pillar-ExporterCore' with: [ spec requires: #('Pillar-Model' 'Mustache' 'Cocoon') ];				package: 'Pillar-ExporterMarkdown' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterLaTeX' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterBeamer' with: [ spec requires: #('Pillar-ExporterLaTeX') ];				package: 'Pillar-ExporterDeckJS' with: [ spec requires: #('Pillar-ExporterHTML') ];				package: 'Pillar-ExporterHTML' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterPillar' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterText' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterCore' with: [ spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterMarkdown'					with: [ spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterLaTeX'					with: [ spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterBeamer'					with: [ spec requires: #('Pillar-ExporterBeamer' 'Pillar-Tests-ExporterLaTeX') ];				package: 'Pillar-Tests-ExporterDeckJS'					with: [ spec requires: #('Pillar-ExporterDeckJS' 'Pillar-Tests-ExporterHTML') ];				package: 'Pillar-Tests-ExporterHTML' with: [ spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterPillar'					with: [ spec requires: #('Pillar-ExporterPillar' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterText' with: [ spec requires: #('Pillar-ExporterText' 'Pillar-Tests-ExporterCore') ].			spec				group: 'html exporter' with: #('Pillar-ExporterHTML');				group: 'html exporter tests' with: #('Pillar-Tests-ExporterHTML');				group: 'latex exporter' with: #('Pillar-ExporterLaTeX');				group: 'latex exporter tests' with: #('Pillar-Tests-ExporterLaTeX');				group: 'beamer exporter' with: #('Pillar-ExporterBeamer');				group: 'beamer exporter tests' with: #('Pillar-Tests-ExporterBeamer');				group: 'deckjs exporter' with: #('Pillar-ExporterDeckJS');				group: 'deckjs exporter tests' with: #('Pillar-Tests-ExporterDeckJS');				group: 'markdown exporter' with: #('Pillar-ExporterMarkdown');				group: 'markdown exporter tests' with: #('Pillar-Tests-ExporterMarkdown');				group: 'pillar exporter' with: #('Pillar-ExporterPillar');				group: 'pillar exporter tests' with: #('Pillar-Tests-ExporterPillar');				group: 'text exporter' with: #('Pillar-ExporterText');				group: 'text exporter tests' with: #('Pillar-Tests-ExporterText');				group: 'All exporters'					with: #('html exporter' 'latex exporter' 'beamer exporter' 'deckjs exporter' 'markdown exporter' 'pillar exporter' 'text exporter');				group: 'All exporter tests'					with:						#('html exporter tests' 'latex exporter tests' 'beamer exporter tests' 'deckjs exporter tests' 'markdown exporter tests' 'pillar exporter tests' 'text exporter tests');				group: 'All tests' with: #('All exporter tests' 'Pillar-Tests-Model' 'Pillar-Tests-ExporterCore');				group: 'All but tests' with: #('All exporters');				group: 'ALL' with: #('All tests' 'All but tests') ].				spec for: #'pharo3.x' do: [ 		spec			package: 'Pillar-ExporterCore' with: [ spec requires: #('Pillar-Model' 'Mustache' 'Cocoon' 'Pillar-Pharo30-Core') ];			package: 'Pillar-Pharo30-Core'.	].				spec		for: #pharo		do: [ 			spec				package: 'Pillar-Pharo-Tools' with: [ spec requires: #('Pillar-Model' 'All exporters') ];				package: 'Pillar-Cli' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-GitBook' with: [ spec requires: #('Pillar-Cli' 'markdown exporter' 'text exporter') ];				group: 'All but tests' with: #('Pillar-Cli' 'Pillar-Pharo-Tools' 'Pillar-GitBook') ]					! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'DamienCassou 9/2/2015 11:32'!baseline025: spec	<version: '0.25-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/'.			self				grease: spec;				mustache: spec;				petitParser: spec;				petitParserTest: spec;				cocoon: spec.			spec				package: 'Pillar-Model' with: [ spec requires: #('Grease') ];				package: 'Pillar-Tests-Model'					with: [ spec requires: #('Pillar-Model' 'Pillar-ExporterPillar' 'Pillar-ExporterText') ];				package: 'Pillar-PetitPillar' with: [ spec requires: #('PetitParser' 'Pillar-Model') ];				package: 'Pillar-ExporterCore' with: [ spec requires: #('Pillar-Model' 'Mustache' 'Cocoon') ];				package: 'Pillar-ExporterMarkdown' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterLaTeX' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterBeamer' with: [ spec requires: #('Pillar-ExporterLaTeX') ];				package: 'Pillar-ExporterDeckJS' with: [ spec requires: #('Pillar-ExporterHTML') ];				package: 'Pillar-ExporterHTML' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterPillar' with: [ spec requires: #('Pillar-ExporterCore' 'Pillar-PetitPillar') ];				package: 'Pillar-ExporterText' with: [ spec requires: #('Pillar-ExporterCore') ];			   flag: #todo; "Add PetitPillar tests back when they start working"				"package: 'Pillar-Tests-PetitPillar'					with: [ spec requires: #('PetitParserTest' 'Pillar-PetitPillar') ];"				package: 'Pillar-Tests-ExporterCore' with: [ spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterMarkdown'					with: [ spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterLaTeX'					with: [ spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterBeamer'					with: [ spec requires: #('Pillar-ExporterBeamer' 'Pillar-Tests-ExporterLaTeX') ];				package: 'Pillar-Tests-ExporterDeckJS'					with: [ spec requires: #('Pillar-ExporterDeckJS' 'Pillar-Tests-ExporterHTML') ];				package: 'Pillar-Tests-ExporterHTML' with: [ spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterPillar'					with: [ spec requires: #('Pillar-ExporterPillar' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterText' with: [ spec requires: #('Pillar-ExporterText' 'Pillar-Tests-ExporterCore') ].			spec				group: 'html exporter' with: #('Pillar-ExporterHTML');				group: 'html exporter tests' with: #('Pillar-Tests-ExporterHTML');				group: 'latex exporter' with: #('Pillar-ExporterLaTeX');				group: 'latex exporter tests' with: #('Pillar-Tests-ExporterLaTeX');				group: 'beamer exporter' with: #('Pillar-ExporterBeamer');				group: 'beamer exporter tests' with: #('Pillar-Tests-ExporterBeamer');				group: 'deckjs exporter' with: #('Pillar-ExporterDeckJS');				group: 'deckjs exporter tests' with: #('Pillar-Tests-ExporterDeckJS');				group: 'markdown exporter' with: #('Pillar-ExporterMarkdown');				group: 'markdown exporter tests' with: #('Pillar-Tests-ExporterMarkdown');				group: 'pillar exporter' with: #('Pillar-ExporterPillar');				group: 'pillar exporter tests' with: #('Pillar-Tests-ExporterPillar');				group: 'text exporter' with: #('Pillar-ExporterText');				group: 'text exporter tests' with: #('Pillar-Tests-ExporterText');				group: 'All exporters'					with: #('html exporter' 'latex exporter' 'beamer exporter' 'deckjs exporter' 'markdown exporter' 'pillar exporter' 'text exporter');				group: 'All exporter tests'					with:						#('html exporter tests' 'latex exporter tests' 'beamer exporter tests' 'deckjs exporter tests' 'markdown exporter tests' 'pillar exporter tests' 'text exporter tests');				group: 'All tests' with: #('All exporter tests' 'Pillar-Tests-Model' "'Pillar-Tests-PetitPillar'" 'Pillar-Tests-ExporterCore');				group: 'All but tests' with: #('All exporters');				group: 'ALL' with: #('All tests' 'All but tests') ].				spec		for: #pharo		do: [ 			spec				package: 'Pillar-Pharo-Tools' with: [ spec requires: #('Pillar-Model' 'All exporters') ];				package: 'Pillar-Cli' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-GitBook' with: [ spec requires: #('Pillar-Cli' 'markdown exporter' 'text exporter') ];				group: 'All but tests' with: #('Pillar-Cli' 'Pillar-Pharo-Tools' 'Pillar-GitBook') ]					! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'DamienCassou 9/7/2015 06:58'!baseline026: spec	<version: '0.26-baseline'>	spec		for: #common		do:			[ 			spec blessing: #baseline.			spec repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/'.			self				grease: spec;				mustache: spec;				petitParser: spec;				petitParserTest: spec;				cocoon: spec.			spec				package: 'Pillar-Model' with: [ spec requires: #('Grease') ];				package: 'Pillar-Tests-Model' with: [ spec requires: #('Pillar-Model' 'Pillar-ExporterPillar' 'Pillar-ExporterText') ];				package: 'Pillar-PetitPillar' with: [ spec requires: #('PetitParser' 'Pillar-Model') ];				package: 'Pillar-ExporterCore' with: [ spec requires: #('Pillar-Model' 'Mustache' 'Cocoon') ];				package: 'Pillar-ExporterMarkdown' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterLaTeX' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterBeamer' with: [ spec requires: #('Pillar-ExporterLaTeX') ];				package: 'Pillar-ExporterDeckJS' with: [ spec requires: #('Pillar-ExporterHTML') ];				package: 'Pillar-ExporterHTML' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-ExporterPillar' with: [ spec requires: #('Pillar-ExporterCore' 'Pillar-PetitPillar') ];				package: 'Pillar-ExporterText' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-Pharo-Tools' with: [ spec requires: #('Pillar-Model' 'All exporters') ];				package: 'Pillar-Cli' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-GitBook' with: [ spec requires: #('Pillar-Cli' 'markdown exporter' 'text exporter') ];				package: 'Pillar-Tests-ExporterCore' with: [ spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterMarkdown' with: [ spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterLaTeX' with: [ spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterBeamer' with: [ spec requires: #('Pillar-ExporterBeamer' 'Pillar-Tests-ExporterLaTeX') ];				package: 'Pillar-Tests-ExporterDeckJS' with: [ spec requires: #('Pillar-ExporterDeckJS' 'Pillar-Tests-ExporterHTML') ];				package: 'Pillar-Tests-ExporterHTML' with: [ spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterPillar' with: [ spec requires: #('Pillar-ExporterPillar' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-Tests-ExporterText' with: [ spec requires: #('Pillar-ExporterText' 'Pillar-Tests-ExporterCore') ];				group: 'html exporter' with: #('Pillar-ExporterHTML');				group: 'html exporter tests' with: #('Pillar-Tests-ExporterHTML');				group: 'latex exporter' with: #('Pillar-ExporterLaTeX');				group: 'latex exporter tests' with: #('Pillar-Tests-ExporterLaTeX');				group: 'beamer exporter' with: #('Pillar-ExporterBeamer');				group: 'beamer exporter tests' with: #('Pillar-Tests-ExporterBeamer');				group: 'deckjs exporter' with: #('Pillar-ExporterDeckJS');				group: 'deckjs exporter tests' with: #('Pillar-Tests-ExporterDeckJS');				group: 'markdown exporter' with: #('Pillar-ExporterMarkdown');				group: 'markdown exporter tests' with: #('Pillar-Tests-ExporterMarkdown');				group: 'pillar exporter' with: #('Pillar-ExporterPillar');				group: 'pillar exporter tests' with: #('Pillar-Tests-ExporterPillar');				group: 'text exporter' with: #('Pillar-ExporterText');				group: 'text exporter tests' with: #('Pillar-Tests-ExporterText');				group: 'All exporters'					with:					#('html exporter' 'latex exporter' 'beamer exporter' 'deckjs exporter' 'markdown exporter' 'pillar exporter' 'text exporter');				group: 'All exporter tests'					with:					#('html exporter tests' 'latex exporter tests' 'beamer exporter tests' 'deckjs exporter tests' 'markdown exporter tests' 'pillar exporter tests' 'text exporter tests');				group: 'All tests' with: #('All exporter tests' 'Pillar-Tests-Model' 'Pillar-Tests-ExporterCore');				group: 'All but tests' with: #('All exporters' 'Pillar-Cli' 'Pillar-Pharo-Tools' 'Pillar-GitBook');				group: 'ALL' with: #('All tests' 'All but tests') ]! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'DamienCassou 9/7/2015 15:48'!baseline027: spec	<version: '0.27-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/'.		spec 			project: 'Grease' with: [				spec					className: #ConfigurationOfGrease;					versionString: #'stable';					loads: #('Core' );					repository: 'http://www.smalltalkhub.com/mc/Seaside/MetacelloConfigurations/main' ];			project: 'Mustache' with: [				spec					className: #ConfigurationOfMustache;					versionString: #'stable';					loads: #('Core' );					repository: 'http://www.smalltalkhub.com/mc/NorbertHartl/Mustache/main' ];			project: 'PetitParser' with: [				spec					className: #ConfigurationOfPetitParser;					versionString: #'stable';					loads: #('Tests' );					repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main' ];			project: 'PetitParserTest' with: [				spec					className: #ConfigurationOfPetitParser;					versionString: #'stable';					loads: #('Tests' );					repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main' ];			project: 'Cocoon' with: [				spec					className: #ConfigurationOfCocoon;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/PharoExtras/Cocoon/main' ].		spec 			package: 'Pillar-Model' with: [				spec requires: #('Grease' ). ];			package: 'Pillar-PetitPillar' with: [				spec requires: #('PetitParser' 'Pillar-Model' ). ];			package: 'Pillar-ExporterCore' with: [				spec requires: #('Pillar-Model' 'Mustache' 'Cocoon' ). ];			package: 'Pillar-ExporterMarkdown' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-ExporterLaTeX' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-ExporterBeamer' with: [				spec requires: #('Pillar-ExporterLaTeX' ). ];			package: 'Pillar-ExporterHTML' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-ExporterDeckJS' with: [				spec requires: #('Pillar-ExporterHTML' ). ];			package: 'Pillar-ExporterPillar' with: [				spec requires: #('Pillar-ExporterCore' 'Pillar-PetitPillar' ). ];			package: 'Pillar-ExporterText' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-Tests-Model' with: [				spec requires: #('Pillar-Model' 'Pillar-ExporterPillar' 'Pillar-ExporterText' ). ];			package: 'Pillar-Cli' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterCore' with: [				spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterMarkdown' with: [				spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterLaTeX' with: [				spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterBeamer' with: [				spec requires: #('Pillar-ExporterBeamer' 'Pillar-Tests-ExporterLaTeX' ). ];			package: 'Pillar-Tests-ExporterHTML' with: [				spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterDeckJS' with: [				spec requires: #('Pillar-ExporterDeckJS' 'Pillar-Tests-ExporterHTML' ). ];			package: 'Pillar-Tests-ExporterPillar' with: [				spec requires: #('Pillar-ExporterPillar' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterText' with: [				spec requires: #('Pillar-ExporterText' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-GitBook' with: [				spec requires: #('Pillar-Cli' 'markdown exporter' 'text exporter' ). ];			package: 'Pillar-Pharo-Tools' with: [				spec requires: #('Pillar-Model' 'All exporters' ). ];			package: #'Pillar-Tests-Cli' with: [				spec requires: #('Pillar-Cli' ). ].		spec 			group: 'html exporter' with: #('Pillar-ExporterHTML' );			group: 'html exporter tests' with: #('Pillar-Tests-ExporterHTML' );			group: 'latex exporter' with: #('Pillar-ExporterLaTeX' );			group: 'latex exporter tests' with: #('Pillar-Tests-ExporterLaTeX' );			group: 'beamer exporter' with: #('Pillar-ExporterBeamer' );			group: 'beamer exporter tests' with: #('Pillar-Tests-ExporterBeamer' );			group: 'deckjs exporter' with: #('Pillar-ExporterDeckJS' );			group: 'deckjs exporter tests' with: #('Pillar-Tests-ExporterDeckJS' );			group: 'markdown exporter' with: #('Pillar-ExporterMarkdown' );			group: 'markdown exporter tests' with: #('Pillar-Tests-ExporterMarkdown' );			group: 'pillar exporter' with: #('Pillar-ExporterPillar' );			group: 'pillar exporter tests' with: #('Pillar-Tests-ExporterPillar' );			group: 'text exporter' with: #('Pillar-ExporterText' );			group: 'text exporter tests' with: #('Pillar-Tests-ExporterText' );			group: 'All exporters' with: #('html exporter' 'latex exporter' 'beamer exporter' 'deckjs exporter' 'markdown exporter' 'pillar exporter' 'text exporter' );			group: 'All exporter tests' with: #('html exporter tests' 'latex exporter tests' 'beamer exporter tests' 'deckjs exporter tests' 'markdown exporter tests' 'pillar exporter tests' 'text exporter tests' );			group: 'All tests' with: #('All exporter tests' 'Pillar-Tests-Model' 'Pillar-Tests-ExporterCore' #'Pillar-Tests-Cli' );			group: 'All but tests' with: #('All exporters' 'Pillar-Cli' 'Pillar-Pharo-Tools' 'Pillar-GitBook' );			group: 'ALL' with: #('All tests' 'All but tests' ). ].! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'DamienCassou 10/3/2015 07:30'!baseline028: spec	<version: '0.28-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/'.		spec 			project: 'Grease' with: [				spec					className: #ConfigurationOfGrease;					versionString: #'stable';					loads: #('Core' );					repository: 'http://www.smalltalkhub.com/mc/Seaside/MetacelloConfigurations/main' ];			project: 'Mustache' with: [				spec					className: #ConfigurationOfMustache;					versionString: #'stable';					loads: #('Core' );					repository: 'http://www.smalltalkhub.com/mc/NorbertHartl/Mustache/main' ];			project: 'PetitParser' with: [				spec					className: #ConfigurationOfPetitParser;					versionString: #'stable';					loads: #('Tests' );					repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main' ];			project: 'PetitParserTest' with: [				spec					className: #ConfigurationOfPetitParser;					versionString: #'stable';					loads: #('Tests' );					repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main' ];			project: 'Cocoon' with: [				spec					className: #ConfigurationOfCocoon;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/PharoExtras/Cocoon/main' ].		spec 			package: 'Pillar-Model' with: [				spec requires: #('Grease' ). ];			package: 'Pillar-PetitPillar' with: [				spec requires: #('PetitParser' 'Pillar-Model' ). ];			package: 'Pillar-ExporterCore' with: [				spec requires: #('Pillar-Model' 'Mustache' 'Cocoon' ). ];			package: 'Pillar-ExporterMarkdown' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-ExporterLaTeX' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-ExporterBeamer' with: [				spec requires: #('Pillar-ExporterLaTeX' ). ];			package: 'Pillar-ExporterHTML' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-ExporterDeckJS' with: [				spec requires: #('Pillar-ExporterHTML' ). ];			package: 'Pillar-ExporterPillar' with: [				spec requires: #('Pillar-ExporterCore' 'Pillar-PetitPillar' ). ];			package: 'Pillar-ExporterText' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-Tests-Model' with: [				spec requires: #('Pillar-Model' 'Pillar-ExporterPillar' 'Pillar-ExporterText' ). ];			package: 'Pillar-Cli' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterCore' with: [				spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterMarkdown' with: [				spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterLaTeX' with: [				spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterBeamer' with: [				spec requires: #('Pillar-ExporterBeamer' 'Pillar-Tests-ExporterLaTeX' ). ];			package: 'Pillar-Tests-ExporterHTML' with: [				spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterDeckJS' with: [				spec requires: #('Pillar-ExporterDeckJS' 'Pillar-Tests-ExporterHTML' ). ];			package: 'Pillar-Tests-ExporterPillar' with: [				spec requires: #('Pillar-ExporterPillar' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterText' with: [				spec requires: #('Pillar-ExporterText' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-GitBook' with: [				spec requires: #('Pillar-Cli' 'markdown exporter' 'text exporter' ). ];			package: 'Pillar-Pharo-Tools' with: [				spec requires: #('Pillar-Model' 'All exporters' ). ];			package: #'Pillar-Tests-Cli' with: [				spec requires: #('Pillar-Cli' ). ].		spec 			group: 'html exporter' with: #('Pillar-ExporterHTML' );			group: 'html exporter tests' with: #('Pillar-Tests-ExporterHTML' );			group: 'latex exporter' with: #('Pillar-ExporterLaTeX' );			group: 'latex exporter tests' with: #('Pillar-Tests-ExporterLaTeX' );			group: 'beamer exporter' with: #('Pillar-ExporterBeamer' );			group: 'beamer exporter tests' with: #('Pillar-Tests-ExporterBeamer' );			group: 'deckjs exporter' with: #('Pillar-ExporterDeckJS' );			group: 'deckjs exporter tests' with: #('Pillar-Tests-ExporterDeckJS' );			group: 'markdown exporter' with: #('Pillar-ExporterMarkdown' );			group: 'markdown exporter tests' with: #('Pillar-Tests-ExporterMarkdown' );			group: 'pillar exporter' with: #('Pillar-ExporterPillar' );			group: 'pillar exporter tests' with: #('Pillar-Tests-ExporterPillar' );			group: 'text exporter' with: #('Pillar-ExporterText' );			group: 'text exporter tests' with: #('Pillar-Tests-ExporterText' );			group: 'All exporters' with: #('html exporter' 'latex exporter' 'beamer exporter' 'deckjs exporter' 'markdown exporter' 'pillar exporter' 'text exporter' );			group: 'All exporter tests' with: #('html exporter tests' 'latex exporter tests' 'beamer exporter tests' 'deckjs exporter tests' 'markdown exporter tests' 'pillar exporter tests' 'text exporter tests' );			group: 'All tests' with: #('All exporter tests' 'Pillar-Tests-Model' 'Pillar-Tests-ExporterCore' #'Pillar-Tests-Cli');			group: 'All but tests' with: #('All exporters' 'Pillar-Cli' 'Pillar-Pharo-Tools' 'Pillar-GitBook' );			group: 'ALL' with: #('All tests' 'All but tests' ). ].! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'DamienCassou 10/3/2015 07:31'!baseline029: spec	<version: '0.29-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/'.		spec 			project: 'Grease' with: [				spec					className: #ConfigurationOfGrease;					versionString: #'stable';					loads: #('Core' );					repository: 'http://www.smalltalkhub.com/mc/Seaside/MetacelloConfigurations/main' ];			project: 'Mustache' with: [				spec					className: #ConfigurationOfMustache;					versionString: #'stable';					loads: #('Core' );					repository: 'http://www.smalltalkhub.com/mc/NorbertHartl/Mustache/main' ];			project: 'PetitParser' with: [				spec					className: #ConfigurationOfPetitParser;					versionString: #'stable';					loads: #('Tests' );					repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main' ];			project: 'PetitParserTest' with: [				spec					className: #ConfigurationOfPetitParser;					versionString: #'stable';					loads: #('Tests' );					repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main' ];			project: 'Cocoon' with: [				spec					className: #ConfigurationOfCocoon;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/PharoExtras/Cocoon/main' ].		spec 			package: 'Pillar-Model' with: [				spec requires: #('Grease' ). ];			package: 'Pillar-PetitPillar' with: [				spec requires: #('PetitParser' 'Pillar-Model' ). ];			package: 'Pillar-ExporterCore' with: [				spec requires: #('Pillar-Model' 'Mustache' 'Cocoon' ). ];			package: 'Pillar-ExporterMarkdown' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-ExporterLaTeX' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-ExporterBeamer' with: [				spec requires: #('Pillar-ExporterLaTeX' ). ];			package: 'Pillar-ExporterHTML' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-ExporterDeckJS' with: [				spec requires: #('Pillar-ExporterHTML' ). ];			package: 'Pillar-ExporterPillar' with: [				spec requires: #('Pillar-ExporterCore' 'Pillar-PetitPillar' ). ];			package: 'Pillar-ExporterText' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-Tests-Model' with: [				spec requires: #('Pillar-Model' 'Pillar-ExporterPillar' 'Pillar-ExporterText' ). ];			package: 'Pillar-Tests-PetitPillar'					with: [ spec requires: #('PetitParserTest' 'Pillar-PetitPillar') ];			package: 'Pillar-Cli' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterCore' with: [				spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterMarkdown' with: [				spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterLaTeX' with: [				spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterBeamer' with: [				spec requires: #('Pillar-ExporterBeamer' 'Pillar-Tests-ExporterLaTeX' ). ];			package: 'Pillar-Tests-ExporterHTML' with: [				spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterDeckJS' with: [				spec requires: #('Pillar-ExporterDeckJS' 'Pillar-Tests-ExporterHTML' ). ];			package: 'Pillar-Tests-ExporterPillar' with: [				spec requires: #('Pillar-ExporterPillar' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterText' with: [				spec requires: #('Pillar-ExporterText' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-GitBook' with: [				spec requires: #('Pillar-Cli' 'markdown exporter' 'text exporter' ). ];			package: 'Pillar-Pharo-Tools' with: [				spec requires: #('Pillar-Model' 'All exporters' ). ];			package: #'Pillar-Tests-Cli' with: [				spec requires: #('Pillar-Cli' ). ].		spec 			group: 'html exporter' with: #('Pillar-ExporterHTML' );			group: 'html exporter tests' with: #('Pillar-Tests-ExporterHTML' );			group: 'latex exporter' with: #('Pillar-ExporterLaTeX' );			group: 'latex exporter tests' with: #('Pillar-Tests-ExporterLaTeX' );			group: 'beamer exporter' with: #('Pillar-ExporterBeamer' );			group: 'beamer exporter tests' with: #('Pillar-Tests-ExporterBeamer' );			group: 'deckjs exporter' with: #('Pillar-ExporterDeckJS' );			group: 'deckjs exporter tests' with: #('Pillar-Tests-ExporterDeckJS' );			group: 'markdown exporter' with: #('Pillar-ExporterMarkdown' );			group: 'markdown exporter tests' with: #('Pillar-Tests-ExporterMarkdown' );			group: 'pillar exporter' with: #('Pillar-ExporterPillar' );			group: 'pillar exporter tests' with: #('Pillar-Tests-ExporterPillar' );			group: 'text exporter' with: #('Pillar-ExporterText' );			group: 'text exporter tests' with: #('Pillar-Tests-ExporterText' );			group: 'All exporters' with: #('html exporter' 'latex exporter' 'beamer exporter' 'deckjs exporter' 'markdown exporter' 'pillar exporter' 'text exporter' );			group: 'All exporter tests' with: #('html exporter tests' 'latex exporter tests' 'beamer exporter tests' 'deckjs exporter tests' 'markdown exporter tests' 'pillar exporter tests' 'text exporter tests' );			group: 'All tests' with: #('All exporter tests' 'Pillar-Tests-Model' 'Pillar-Tests-ExporterCore' #'Pillar-Tests-Cli' 'Pillar-Tests-PetitPillar');			group: 'All but tests' with: #('All exporters' 'Pillar-Cli' 'Pillar-Pharo-Tools' 'Pillar-GitBook' );			group: 'ALL' with: #('All tests' 'All but tests' ). ].! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'DiegoLont 2/7/2014 10:24'!baseline02: spec	"protocol: accessing"	<version: '0.2-baseline'>	spec		for: #common		do: [ 			spec				blessing: #baseline;				repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/';				package: 'Pillar-Model' with: [ spec requires: #('Grease') ];				package: 'Pillar-ExporterCore' with: [ spec requires: #('Pillar-Model' 'Mustache' 'STON') ];				package: 'Pillar-Tests-Model' with: [ spec requires: #('Pillar-Model') ];				package: 'Pillar-Tests-ExporterCore' with: [ spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore') ];				package: 'Pillar-ExporterHTML' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterHTML' with: [ spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-ExporterLaTeX' with: [ spec requires: 'Pillar-ExporterCore' ];				package: 'Pillar-Tests-ExporterLaTeX'					with: [ spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-ExporterMarkdown' with: [ spec requires: 'Pillar-ExporterCore' ];				package: 'Pillar-Tests-ExporterMarkdown'					with: [ spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore') ].			spec group: 'ALL' with: #('Pillar-Tests-ExporterLaTeX' 'Pillar-Tests-ExporterHTML' 'Pillar-Tests-ExporterMarkdown').			self				grease: spec;				mustache: spec;				ston: spec ].! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'YannDubois 6/6/2016 09:52'!baseline030: spec	<version: '0.30-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/'.		spec 			project: 'Grease' with: [				spec					className: #ConfigurationOfGrease;					versionString: #'stable';					loads: #('Core' );					repository: 'http://www.smalltalkhub.com/mc/Seaside/MetacelloConfigurations/main' ];			project: 'Mustache' with: [				spec					className: #ConfigurationOfMustache;					versionString: #'stable';					loads: #('Core' );					repository: 'http://www.smalltalkhub.com/mc/NorbertHartl/Mustache/main' ];			project: 'PetitParser' with: [				spec					className: #ConfigurationOfPetitParser;					versionString: #'stable';					loads: #('Tests' );					repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main' ];			project: 'PetitParserTest' with: [				spec					className: #ConfigurationOfPetitParser;					versionString: #'stable';					loads: #('Tests' );					repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main' ];			project: 'Cocoon' with: [				spec					className: #ConfigurationOfCocoon;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/PharoExtras/Cocoon/main' ].		spec 			package: 'Pillar-Model' with: [				spec requires: #('Grease' ). ];			package: 'Pillar-PetitPillar' with: [				spec requires: #('PetitParser' 'Pillar-Model' ). ];			package: 'Pillar-ExporterCore' with: [				spec requires: #('Pillar-Model' 'Mustache' 'Cocoon' ). ];			package: 'Pillar-ExporterMarkdown' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-ExporterLaTeX' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-ExporterBeamer' with: [				spec requires: #('Pillar-ExporterLaTeX' ). ];			package: 'Pillar-ExporterHTML' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-ExporterDeckJS' with: [				spec requires: #('Pillar-ExporterHTML' ). ];			package: 'Pillar-ExporterPillar' with: [				spec requires: #('Pillar-ExporterCore' 'Pillar-PetitPillar' ). ];			package: 'Pillar-ExporterText' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-Tests-Model' with: [				spec requires: #('Pillar-Model' 'Pillar-ExporterPillar' 'Pillar-ExporterText' ). ];			package: 'Pillar-Tests-PetitPillar' with: [				spec requires: #('PetitParserTest' 'Pillar-PetitPillar' ). ];			package: 'Pillar-Cli' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterCore' with: [				spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterMarkdown' with: [				spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterLaTeX' with: [				spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterBeamer' with: [				spec requires: #('Pillar-ExporterBeamer' 'Pillar-Tests-ExporterLaTeX' ). ];			package: 'Pillar-Tests-ExporterHTML' with: [				spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterDeckJS' with: [				spec requires: #('Pillar-ExporterDeckJS' 'Pillar-Tests-ExporterHTML' ). ];			package: 'Pillar-Tests-ExporterPillar' with: [				spec requires: #('Pillar-ExporterPillar' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterText' with: [				spec requires: #('Pillar-ExporterText' 'Pillar-Tests-ExporterCore' ). ];			package: #'Pillar-Tests-Cli' with: [				spec requires: #('Pillar-Cli' ). ];			package: 'Pillar-GitBook' with: [				spec requires: #('Pillar-Cli' 'markdown exporter' 'text exporter' ). ];			package: 'Pillar-Pharo-Tools' with: [				spec requires: #('Pillar-Model' 'All exporters' ). ];			package: #'Pillar-ExporterAsciiDoc' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: #'Pillar-Tests-ExporterAsciiDoc' with: [				spec requires: #(#'Pillar-ExporterAsciiDoc' 'Pillar-Tests-ExporterCore' ). ].		spec 			group: 'html exporter' with: #('Pillar-ExporterHTML' );			group: 'html exporter tests' with: #('Pillar-Tests-ExporterHTML' );			group: 'latex exporter' with: #('Pillar-ExporterLaTeX' );			group: 'latex exporter tests' with: #('Pillar-Tests-ExporterLaTeX' );			group: 'beamer exporter' with: #('Pillar-ExporterBeamer' );			group: 'beamer exporter tests' with: #('Pillar-Tests-ExporterBeamer' );			group: 'deckjs exporter' with: #('Pillar-ExporterDeckJS' );			group: 'deckjs exporter tests' with: #('Pillar-Tests-ExporterDeckJS' );			group: 'markdown exporter' with: #('Pillar-ExporterMarkdown' );			group: 'markdown exporter tests' with: #('Pillar-Tests-ExporterMarkdown' );			group: 'parser' with: #('Pillar-PetitPillar' );			group: 'parser tests' with: #('Pillar-Tests-PetitPillar' );			group: 'pillar exporter' with: #('Pillar-ExporterPillar' );			group: 'pillar exporter tests' with: #('Pillar-Tests-ExporterPillar' );			group: 'text exporter' with: #('Pillar-ExporterText' );			group: 'text exporter tests' with: #('Pillar-Tests-ExporterText' );			group: 'All exporters' with: #('html exporter' 'latex exporter' 'beamer exporter' 'deckjs exporter' 'markdown exporter' 'pillar exporter' 'text exporter' 'asciidoc exporter' );			group: 'All exporter tests' with: #('html exporter tests' 'latex exporter tests' 'beamer exporter tests' 'deckjs exporter tests' 'markdown exporter tests' 'pillar exporter tests' 'text exporter tests' 'asciidoc exporter tests' );			group: 'All tests' with: #('All exporter tests' 'Pillar-Tests-Model' 'Pillar-Tests-ExporterCore' #'Pillar-Tests-Cli' 'parser tests' );			group: 'All but tests' with: #('All exporters' 'Pillar-Cli' 'Pillar-Pharo-Tools' 'Pillar-GitBook' 'parser' );			group: 'ALL' with: #('All tests' 'All but tests' );			group: 'asciidoc exporter' with: #(#'Pillar-ExporterAsciiDoc' );			group: 'asciidoc exporter tests' with: #(#'Pillar-Tests-ExporterAsciiDoc' ). ].! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'ThibaultArloing 7/11/2016 16:47'!baseline031: spec	<version: '0.31-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/'.		spec 			project: 'Cocoon' with: [				spec					className: #ConfigurationOfCocoon;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/PharoExtras/Cocoon/main' ];			project: 'JSON' with: [				spec					className: #ConfigurationOfJSON;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/PharoExtras/JSON/main/' ];			project: 'LightPhaser' with: [				spec					className: #ConfigurationOfLightPhaser;					versionString: #'bleedingEdge';					repository: 'http://smalltalkhub.com/mc/Pier/LightPhaser/main/' ];			project: 'PetitParser' with: [				spec					className: #ConfigurationOfPetitParser;					versionString: #'stable';					loads: #('Tests' );					repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main' ];			project: 'PetitParserTest' with: [				spec					className: #ConfigurationOfPetitParser;					versionString: #'stable';					loads: #('Tests' );					repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main' ].		spec 			package: 'Pillar-Cli' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: #'Pillar-ExporterAsciiDoc' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-ExporterBeamer' with: [				spec requires: #('Pillar-ExporterLaTeX' ). ];			package: 'Pillar-ExporterCore' with: [				spec requires: #('Pillar-Model' 'Cocoon' 'JSON' 'LightPhaser' ). ];			package: 'Pillar-ExporterDeckJS' with: [				spec requires: #('Pillar-ExporterHTML' ). ];			package: #'Pillar-ExporterEPub' with: [				spec requires: #('Pillar-ExporterCore' 'Pillar-ExporterHTML' ). ];			package: 'Pillar-ExporterHTML' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-ExporterLaTeX' with: [				spec requires: #('Pillar-ExporterCore' 'Pillar-ExporterPillar' ). ];			package: 'Pillar-ExporterMarkdown' with: [				spec requires: #('Pillar-ExporterCore' 'Pillar-ExporterHTML' ). ];			package: 'Pillar-ExporterPillar' with: [				spec requires: #('Pillar-ExporterCore' 'Pillar-PetitPillar' ). ];			package: 'Pillar-ExporterText' with: [				spec requires: #('Pillar-ExporterCore' ). ];			package: 'Pillar-GitBook' with: [				spec requires: #('Pillar-Cli' 'markdown exporter' 'text exporter' ). ];			package: 'Pillar-Model';			package: 'Pillar-PetitPillar' with: [				spec requires: #('PetitParser' 'Pillar-Model' ). ];			package: 'Pillar-Pharo-Tools' with: [				spec requires: #('Pillar-Model' 'All exporters' ). ];			package: #'Pillar-Tests-Cli' with: [				spec requires: #('Pillar-Cli' ). ];			package: #'Pillar-Tests-ExporterAsciiDoc' with: [				spec requires: #(#'Pillar-ExporterAsciiDoc' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterBeamer' with: [				spec requires: #('Pillar-ExporterBeamer' 'Pillar-Tests-ExporterLaTeX' ). ];			package: 'Pillar-Tests-ExporterCore' with: [				spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterDeckJS' with: [				spec requires: #('Pillar-ExporterDeckJS' 'Pillar-Tests-ExporterHTML' ). ];			package: #'Pillar-Tests-ExporterEPub' with: [				spec requires: #(#'Pillar-ExporterEPub' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterHTML' with: [				spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterLaTeX' with: [				spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterMarkdown' with: [				spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore' 'Pillar-Tests-ExporterHTML' ). ];			package: 'Pillar-Tests-ExporterPillar' with: [				spec requires: #('Pillar-ExporterPillar' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-ExporterText' with: [				spec requires: #('Pillar-ExporterText' 'Pillar-Tests-ExporterCore' ). ];			package: 'Pillar-Tests-Model' with: [				spec requires: #('Pillar-Model' 'Pillar-ExporterPillar' 'Pillar-ExporterText' ). ];			package: 'Pillar-Tests-PetitPillar' with: [				spec requires: #('PetitParserTest' 'Pillar-PetitPillar' ). ].		spec 			group: 'ALL' with: #('All tests' 'All but tests' );			group: 'All but tests' with: #('All exporters' 'Pillar-Cli' 'Pillar-Pharo-Tools' 'Pillar-GitBook' 'parser' );			group: 'All exporter tests' with: #('html exporter tests' 'latex exporter tests' 'beamer exporter tests' 'deckjs exporter tests' 'markdown exporter tests' 'pillar exporter tests' 'text exporter tests' 'asciidoc exporter tests' 'ePub exporter tests' );			group: 'All exporters' with: #('html exporter' 'latex exporter' 'beamer exporter' 'deckjs exporter' 'markdown exporter' 'pillar exporter' 'text exporter' 'asciidoc exporter' 'ePub exporter' );			group: 'All tests' with: #('All exporter tests' 'Pillar-Tests-Model' 'Pillar-Tests-ExporterCore' #'Pillar-Tests-Cli' 'parser tests' );			group: 'asciidoc exporter' with: #(#'Pillar-ExporterAsciiDoc' );			group: 'asciidoc exporter tests' with: #(#'Pillar-Tests-ExporterAsciiDoc' 'ePub exporter' );			group: 'beamer exporter' with: #('Pillar-ExporterBeamer' );			group: 'beamer exporter tests' with: #('Pillar-Tests-ExporterBeamer' );			group: 'deckjs exporter' with: #('Pillar-ExporterDeckJS' );			group: 'deckjs exporter tests' with: #('Pillar-Tests-ExporterDeckJS' );			group: 'ePub exporter' with: #(#'Pillar-ExporterEPub' );			group: 'ePub exporter tests' with: #(#'Pillar-Tests-ExporterEPub' );			group: 'html exporter' with: #('Pillar-ExporterHTML' );			group: 'html exporter tests' with: #('Pillar-Tests-ExporterHTML' );			group: 'latex exporter' with: #('Pillar-ExporterLaTeX' );			group: 'latex exporter tests' with: #('Pillar-Tests-ExporterLaTeX' );			group: 'markdown exporter' with: #('Pillar-ExporterMarkdown' 'parser' );			group: 'markdown exporter tests' with: #('Pillar-Tests-ExporterMarkdown' );			group: 'parser' with: #('Pillar-PetitPillar' );			group: 'parser tests' with: #('Pillar-Tests-PetitPillar' );			group: 'pillar exporter' with: #('Pillar-ExporterPillar' );			group: 'pillar exporter tests' with: #('Pillar-Tests-ExporterPillar' );			group: 'text exporter' with: #('Pillar-ExporterText' );			group: 'text exporter tests' with: #('Pillar-Tests-ExporterText' ). ].! !!ConfigurationOfPillar methodsFor: 'baselines' stamp: 'DiegoLont 2/7/2014 10:24'!baseline03: spec	"protocol: accessing"	<version: '0.3-baseline'>	spec		for: #common		do: [ 			spec				blessing: #baseline;				repository: 'http://smalltalkhub.com/mc/Pier/Pillar/main/';				package: 'Pillar-Model' with: [ spec requires: #('Grease') ];				package: 'Pillar-ExporterCore' with: [ spec requires: #('Pillar-Model' 'Mustache' 'STON') ];				package: 'Pillar-Tests-Model' with: [ spec requires: #('Pillar-Model') ];				package: 'Pillar-Tests-ExporterCore' with: [ spec requires: #('Pillar-Tests-Model' 'Pillar-ExporterCore') ];				package: 'Pillar-ExporterHTML' with: [ spec requires: #('Pillar-ExporterCore') ];				package: 'Pillar-Tests-ExporterHTML' with: [ spec requires: #('Pillar-ExporterHTML' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-ExporterLaTeX' with: [ spec requires: 'Pillar-ExporterCore' ];				package: 'Pillar-Tests-ExporterLaTeX'					with: [ spec requires: #('Pillar-ExporterLaTeX' 'Pillar-Tests-ExporterCore') ];				package: 'Pillar-ExporterMarkdown' with: [ spec requires: 'Pillar-ExporterCore' ];				package: 'Pillar-Tests-ExporterMarkdown'					with: [ spec requires: #('Pillar-ExporterMarkdown' 'Pillar-Tests-ExporterCore') ].			spec				group: 'html' with: 'Pillar-ExporterHTML';				group: 'html tests' with: 'Pillar-Tests-ExporterHTML';				group: 'latex' with: 'Pillar-ExporterLaTeX';				group: 'latex tests' with: 'Pillar-Tests-ExporterLaTeX';				group: 'markdown' with: 'Pillar-ExporterMarkdown';				group: 'markdown tests' with: 'Pillar-Tests-ExporterMarkdown';				group: 'All exporters' with: #('html' 'latex' 'markdown');				group: 'All exporter tests' with: #('html tests' 'latex tests' 'markdown tests');				group: 'All tests' with: #('All exporter tests' 'Pillar-Tests-Model' 'Pillar-Tests-ExporterCore');				group: 'All but tests' with: #('All exporters');				group: 'ALL' with: #('All tests' 'All but tests').			self				grease: spec;				mustache: spec;				ston: spec ].	spec		for: #'pharo3.x'		do: [ 			spec package: 'Pillar-Cli' with: [ spec requires: 'Pillar-ExporterCore' ].			spec group: 'All but tests' with: #('Pillar-Cli') ]! !!ConfigurationOfPillar methodsFor: 'dependencies' stamp: 'CyrilFerlicot 4/1/2015 18:10'!cocoon: spec	spec		project: 'Cocoon'		with: [ 			spec				className: 'ConfigurationOfCocoon';				versionString: #stable;				repository: 'http://smalltalkhub.com/mc/PharoExtras/Cocoon/main' ]! !!ConfigurationOfPillar methodsFor: 'accessing' stamp: 'DamienCassou 10/7/2013 11:10'!customProjectAttributes	 "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes"	^ #().! !!ConfigurationOfPillar methodsFor: 'symbolic versions' stamp: 'YannDubois 7/27/2016 16:09'!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: '0.31-baseline'.	spec for: #'pharo3.x' version: '0.24-baseline'.	spec for: #'pharo4.x' version: '3.0.3'.! !!ConfigurationOfPillar methodsFor: 'dependencies' stamp: 'DiegoLont 2/7/2014 10:24'!grease: spec	spec		project: 'Grease'		with: [ 			spec				className: 'ConfigurationOfGrease';				versionString: #stable;				loads: #('Core');				repository: 'http://www.smalltalkhub.com/mc/Seaside/MetacelloConfigurations/main' ]! !!ConfigurationOfPillar methodsFor: 'dependencies' stamp: 'DiegoLont 2/7/2014 10:24'!mustache: spec	spec		project: 'Mustache'		with: [ 			spec				className: 'ConfigurationOfMustache';				versionString: #stable;				loads: #('Core');				repository: 'http://www.smalltalkhub.com/mc/NorbertHartl/Mustache/main' ]! !!ConfigurationOfPillar methodsFor: 'dependencies' stamp: 'CyrilFerlicot 8/19/2015 17:03'!petitParser: spec	spec		project: 'PetitParser'		with: [ 			spec				className: 'ConfigurationOfPetitParser';				versionString: #stable;				loads: #('Core');				loads: #('Tests');				repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main' ]! !!ConfigurationOfPillar methodsFor: 'dependencies' stamp: 'CyrilFerlicot 8/19/2015 17:04'!petitParserTest: spec	spec		project: 'PetitParserTest'		with: [ 			spec				className: 'ConfigurationOfPetitParser';				versionString: #stable;				loads: #('Tests');				repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main' ]! !!ConfigurationOfPillar methodsFor: 'symbolic versions' stamp: 'StephanEggermont 1/18/2016 15:38'!pier: spec	<symbolicVersion: #'pier'>	spec for: #'common' version: '1.1.3'.! !!ConfigurationOfPillar methodsFor: 'accessing' stamp: 'DamienCassou 10/7/2013 11:10'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		project := MetacelloMCProject new projectAttributes: self customProjectAttributes. 		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self project: project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfPillar methodsFor: 'symbolic versions' stamp: 'YannDubois 8/9/2016 14:48'!stable: spec	<symbolicVersion: #'stable'>	spec for: #'common' version: '4.0.4'.	spec for: #'pharo3.x' version: '0.60'.	spec for: #'pharo4.x' version: '3.0.4'.! !!ConfigurationOfPillar methodsFor: 'dependencies' stamp: 'DiegoLont 2/7/2014 10:24'!ston: spec	spec		project: 'STON'		with: [ 			spec				className: 'ConfigurationOfSton';				versionString: #stable;				loads: #('Core');				repository: 'http://smalltalkhub.com/mc/SvenVanCaekenberghe/STON/main' ]! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DamienCassou 2/19/2014 11:14'!version010: spec	<version: '0.10' imports: #('0.10-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.10'.		spec author: 'DamienCassou'.		spec timestamp: '2/19/2014 11:08'.		spec 			project: 'Grease' with: '1.1.5';			project: 'Mustache' with: '0.48';			project: 'STON' with: '0.7'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.63';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.71';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.39';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.42';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.37';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.27';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienPollet.46';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.30';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.54';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.13'. ].	spec for: #'pharo3.x' do: [		spec package: 'Pillar-Cli' with: 'Pillar-Cli-BenjaminVanRyseghem.7'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DamienCassou 3/24/2014 16:33'!version011: spec	<version: '0.11' imports: #('0.11-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.11'.		spec author: 'DamienCassou'.		spec timestamp: '3/24/2014 16:25'.		spec 			project: 'Grease' with: '1.1.6';			project: 'Mustache' with: '0.50';			project: 'STON' with: '0.7'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.75';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.51';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.79';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.57';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.50';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.38';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.9';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.4';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.51';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.15';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.36';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.30';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.4';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.4'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'Pillar-PharoInspector' with: 'Pillar-PharoInspector-DamienCassou.1';			package: 'Pillar-Cli' with: 'Pillar-Cli-BenjaminVanRyseghem.7'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DamienCassou 4/15/2014 11:33'!version012: spec	<version: '0.12' imports: #('0.11-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.12'.		spec author: 'DamienCassou'.		spec timestamp: '4/15/2014 11:29'.		spec 			project: 'Grease' with: '1.1.6';			project: 'Mustache' with: '0.50';			project: 'STON' with: '0.7'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.75';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.51';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.80';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.57';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.50';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.39';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.9';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.4';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.51';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.15';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.36';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.30';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.4';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.4'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'Pillar-PharoInspector' with: 'Pillar-PharoInspector-DamienCassou.1';			package: 'Pillar-Cli' with: 'Pillar-Cli-BenjaminVanRyseghem.7'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DiegoLont 5/13/2014 10:54'!version013: spec	<version: '0.13' imports: #('0.11-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.13'.		spec author: 'DamienCassou'.		spec timestamp: '4/18/2014 17:44'.		spec 			project: 'Grease' with: #'release1.1';			project: 'Mustache' with: '0.50';			project: 'STON' with: '0.8'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.75';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.51';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.80';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.57';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.50';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.40';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.9';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.4';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.51';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.15';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.36';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.31';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.4';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.4'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'Pillar-PharoInspector' with: 'Pillar-PharoInspector-DamienCassou.1';			package: 'Pillar-Cli' with: 'Pillar-Cli-BenjaminVanRyseghem.7'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DamienCassou 6/3/2014 18:03'!version014: spec	<version: '0.14' imports: #('0.11-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.14'.		spec author: 'DamienCassou'.		spec timestamp: '6/3/2014 17:49'.		spec 			project: 'Grease' with: #'release1.1';			project: 'Mustache' with: '0.60';			project: 'STON' with: '0.9'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.81';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.97';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.82';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.58';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.53';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.44';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.9';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.4';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.52';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.16';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.82';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.32';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.5';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.6'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-PharoInspector' with: 'Pillar-PharoInspector-DamienCassou.1';			package: 'Pillar-Cli' with: 'Pillar-Cli-BenjaminVanRyseghem.7'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DamienCassou 6/5/2014 14:38'!version015: spec	<version: '0.15' imports: #('0.11-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.15'.		spec author: 'DamienCassou'.		spec timestamp: '6/5/2014 14:36'.		spec 			project: 'Grease' with: #'release1.1';			project: 'Mustache' with: '0.60';			project: 'STON' with: '0.9'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.82';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.97';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.84';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-BenComan.59';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-BenComan.54';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-BenComan.45';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.9';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.4';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.56';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-BenComan.83';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-BenComan.7'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-PharoInspector' with: 'Pillar-PharoInspector-DamienCassou.1';			package: 'Pillar-Cli' with: 'Pillar-Cli-BenjaminVanRyseghem.7'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DamienCassou 6/6/2014 17:38'!version016: spec	<version: '0.16' imports: #('0.12-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.16'.		spec author: 'DamienCassou'.		spec timestamp: '6/6/2014 17:38'.		spec 			project: 'Grease' with: #'release1.1';			project: 'Mustache' with: '0.60';			project: 'STON' with: '0.9'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.83';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.97';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.84';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-BenComan.59';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-BenComan.54';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.46';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.9';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.5';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.56';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-BenComan.83';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-PharoInspector' with: 'Pillar-PharoInspector-DamienCassou.1';			package: 'Pillar-Cli' with: 'Pillar-Cli-BenjaminVanRyseghem.7';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DamienCassou 12/9/2014 15:17'!version017: spec	<version: '0.17' imports: #('0.12-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.17'.		spec author: 'DamienCassou'.		spec timestamp: '12/9/2014 15:17'.		spec 			project: 'Grease' with: '1.1.11';			project: 'Mustache' with: '0.60';			project: 'STON' with: '0.9'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.86';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-JohnCBorden.100';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.84';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-BenComan.59';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.57';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.48';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.9';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.5';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.56';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-BenComan.83';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-PharoInspector' with: 'Pillar-PharoInspector-DamienCassou.1';			package: 'Pillar-Cli' with: 'Pillar-Cli-BenjaminVanRyseghem.7';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DamienCassou 1/30/2015 10:10'!version018: spec	<version: '0.18' imports: #('0.12-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.18'.		spec author: 'DamienCassou'.		spec timestamp: '1/30/2015 10:10'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'STON' with: '0.9'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.86';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-JohnCBorden.100';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.84';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-BenComan.59';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.58';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.48';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.9';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.5';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.56';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.84';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-PharoInspector' with: 'Pillar-PharoInspector-DamienCassou.1';			package: 'Pillar-Cli' with: 'Pillar-Cli-TorstenBergmann.8';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DamienCassou 11/28/2013 13:58'!version01: spec	"protocol: accessing"	<version: '0.1' imports: #('0.1-baseline')>	spec		for: #common		do: [ 			spec				blessing: #release;				package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.34';				package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.18';				package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.23';				package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.27';				package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.24';				package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.13';				package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.15';				package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.3' ]! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'TorstenBergmann 3/6/2015 12:57'!version020: spec	<version: '0.20' imports: #('0.20-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.20 for Pharo 4'.		spec author: 'TorstenBergmann'.		spec timestamp: '3/5/2015 10:10'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'STON' with: '0.10'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-TorstenBergmann.87';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-JohnCBorden.100';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-TorstenBergmann.85';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-BenComan.59';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-TorstenBergmann.59';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.48';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-TorstenBergmann.10';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-TorstenBergmann.6';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.56';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.84';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-TorstenBergmann.6';			package: 'Pillar-Cli' with: 'Pillar-Cli-TorstenBergmann.8';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 3/31/2015 18:27'!version021: spec	<version: '0.21' imports: #('0.20-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.21'.		spec author: 'CyrilFerlicot'.		spec timestamp: '3/31/2015 18:27'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'STON' with: '0.10'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-TorstenBergmann.87';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-JohnCBorden.100';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.86';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-BenComan.59';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-TorstenBergmann.59';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.48';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-TorstenBergmann.10';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-TorstenBergmann.6';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.57';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.84';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-TorstenBergmann.6';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.9';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/1/2015 18:12'!version022: spec	<version: '0.22' imports: #('0.21-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.22'.		spec author: 'CyrilFerlicot'.		spec timestamp: '4/1/2015 11:24'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.7'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-TorstenBergmann.87';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-JohnCBorden.100';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.86';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-BenComan.59';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-TorstenBergmann.59';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.48';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-TorstenBergmann.10';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-TorstenBergmann.6';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.57';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.84';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-TorstenBergmann.6';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.9';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/2/2015 09:51'!version023: spec	<version: '0.23' imports: #('0.21-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.23'.		spec author: 'CyrilFerlicot'.		spec timestamp: '4/1/2015 18:21'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.7'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-TorstenBergmann.87';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-JohnCBorden.100';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.90';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-BenComan.59';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-TorstenBergmann.59';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.48';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-TorstenBergmann.10';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-TorstenBergmann.6';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.59';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.84';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-TorstenBergmann.6';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/2/2015 09:51'!version024: spec	<version: '0.24' imports: #('0.21-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.24 - Adaptation of the tests to the new configuration system.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '4/2/2015 09:49'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.7'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-TorstenBergmann.87';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-JohnCBorden.100';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.90';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-BenComan.59';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-TorstenBergmann.59';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.48';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-TorstenBergmann.10';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-TorstenBergmann.6';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.60';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.84';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-TorstenBergmann.6';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DamienCassou 4/3/2015 13:45'!version025: spec	<version: '0.25' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.25 - Add Beamer (experimental export).'.		spec author: 'DamienCassou'.		spec timestamp: '2015/04/03 13:39'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.7'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-TorstenBergmann.87';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-JohnCBorden.100';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.93';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-BenComan.59';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.61';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.48';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-TorstenBergmann.10';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-TorstenBergmann.6';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.60';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.84';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.7';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DamienCassou 4/6/2015 22:17'!version026: spec	<version: '0.26' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.26 - Add transformers.'.		spec author: 'DamienCassou'.		spec timestamp: '2015/04/06 22:12'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.7'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.96';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.106';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.95';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.60';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.62';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.49';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.15';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.62';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.84';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/7/2015 14:32'!version027: spec	<version: '0.27' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.26 - Equals and Hash added into PRScript.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/07 14:13'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.9'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.98';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.108';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.95';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.60';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.62';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.49';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.15';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.62';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.84';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/8/2015 13:00'!version028: spec	<version: '0.28' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.28 - ScriptLanguage improvement. Correction of failure on a test.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/08 12:58'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.9'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.100';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.109';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.95';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.60';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.62';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.49';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.15';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.62';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.84';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/8/2015 13:15'!version029: spec	<version: '0.29' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.29 - Adaptability to windows.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/08 13:14'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.9'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.102';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.110';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.95';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.60';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.62';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.49';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.15';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.62';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'BenjaminVanRyseghem 1/9/2014 22:48'!version02: spec	<version: '0.2' imports: #('0.2-baseline')>	spec		for: #common		do: [ 			spec				blessing: #release;				package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.37';				package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.19';				package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.20';				package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.29';				package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.30';				package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.27';				package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-BenjaminVanRyseghem.31';				package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.13';				package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.16';				package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.3' ]! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/8/2015 14:37'!version030: spec	<version: '0.30' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.30 - More test.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/08 13:31'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.9'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.103';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.112';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.95';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.60';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.62';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.49';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.15';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.62';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/9/2015 10:54'!version031: spec	<version: '0.31' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.31 - Exporters now works again.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/09 10:53'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.9'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.104';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.112';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.95';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.60';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.62';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.49';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.15';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.62';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/9/2015 13:45'!version032: spec	<version: '0.32' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.32 - Inclusion Tag: ${inputFile:myFile.pillar}$'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/09 13:44'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.9'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.105';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.112';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.96';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.60';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.62';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.49';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.15';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.62';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/9/2015 14:32'!version033: spec	<version: '0.33' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.33 - Test correction. ExporterPillar with InupuFileAnnotation.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/09 14:31'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.9'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.106';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.112';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.96';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.60';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.62';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.49';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.16';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.62';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/9/2015 14:52'!version034: spec	<version: '0.34' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.34 - Recursion on the includes.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/09 14:51'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.9'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.107';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.112';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.96';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.60';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.62';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.49';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.16';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.62';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/10/2015 14:17'!version035: spec	<version: '0.35' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.35 - Now the inputFile annotation keep the configuration. Some refactoring.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/09 14:15'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.10'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.108';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.113';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.97';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.60';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.62';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.49';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.17';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.63';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/14/2015 10:27'!version036: spec	<version: '0.36' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.36 - Refactoring. Now the parameters are in a Dictionary instead of an associative array.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/14 10:06'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.10'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.109';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.114';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.98';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.61';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.63';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.52';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.18';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.64';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/14/2015 13:16'!version037: spec	<version: '0.37' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.37 - Correction of a problem with the inputFile tag. baseDirectory was the memory root.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/14 13:16'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.10'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.110';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.114';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.99';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.61';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.63';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.52';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.18';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.64';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/14/2015 14:45'!version038: spec	<version: '0.38' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.38 - modification about the parameters of the annotations'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/14 14:30'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.10'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.111';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.117';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.99';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.61';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.63';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.52';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.18';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.64';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/16/2015 13:27'!version039: spec	<version: '0.39' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.39 - Refactoring of the templates'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/16 13:25'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.11'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.115';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.118';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.100';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.61';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.63';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.52';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.18';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.65';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DamienCassou 1/8/2014 15:30'!version03: spec	<version: '0.3' imports: #('0.3-baseline')>	spec		for: #common		do: [ 			spec				blessing: #release;				package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.39';				package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.44';				package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.25';				package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.30';				package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.34';				package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.27';				package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.27';				package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.19';				package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.17';				package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.4' ].	spec		for: #'pharo3.x'		do: [ 			spec package: 'Pillar-Cli' with: 'Pillar-Cli-DamienCassou.5'.			 ]! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/17/2015 10:14'!version040: spec	<version: '0.40' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.40 - More More tests. Correction of the inclusion.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/17 10h10'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.11'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.116';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.119';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.102';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.61';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.63';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.52';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.18';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.65';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/21/2015 16:55'!version041: spec	<version: '0.41' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.41 - New Cocoon version'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/21 16h55'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.12'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.116';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.119';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.102';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.61';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.63';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.52';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.18';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.65';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/22/2015 16:12'!version042: spec	<version: '0.42' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.41 - Better errors and some improvement on the configurations'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/22 16h10'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.14'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.125';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.123';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.109';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.61';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.63';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.52';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.18';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.67';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/23/2015 13:38'!version043: spec	<version: '0.43' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.43 - LineNumber on script added.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/23 13h36'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.14'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.127';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.124';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.111';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.62';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.64';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.52';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.18';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.67';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/23/2015 14:58'!version044: spec	<version: '0.44' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.44 - little correction.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/23 14h58'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.14'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.128';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.125';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.111';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.62';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.64';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.52';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.18';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.67';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/24/2015 11:32'!version045: spec	<version: '0.45' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.45 - bug correction.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/24 11h30'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.14'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.133';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.125';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.113';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.62';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.64';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.52';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.18';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.68';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/24/2015 14:09'!version046: spec	<version: '0.46' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.46 - bug correction.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/24 14h09'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.14'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.134';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.126';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.115';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.62';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.64';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.52';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.18';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.68';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/24/2015 15:14'!version047: spec	<version: '0.47' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.47 - better output management.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/24 15h14'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.14'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.134';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.126';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.117';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.62';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.64';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.52';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.18';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.69';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/24/2015 17:50'!version048: spec	<version: '0.48' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.48 - correction on script evaluation.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/24 15h14'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.14'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.135';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.127';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.117';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.62';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.64';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.52';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.18';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.69';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/27/2015 10:51'!version049: spec	<version: '0.49' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.49 - new version of cocoon and change about that.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/27 10h50'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.15'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.136';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.127';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.118';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.62';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.64';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.52';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.18';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-DamienCassou.7';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.69';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-BenComan.18';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.85';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DamienCassou 1/13/2014 11:25'!version04: spec	<version: '0.4' imports: #('0.3-baseline')>	spec		for: #common		do: [ 			spec				blessing: #release;				package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.47';				package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.57';				package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.30';				package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.33';				package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.47';				package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.31';				package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.34';				package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.24';				package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.20';				package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.9' ].	spec		for: #'pharo3.x'		do: [ 			spec package: 'Pillar-Cli' with: 'Pillar-Cli-BenjaminVanRyseghem.7'.			 ]! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/29/2015 10:24'!version050: spec	<version: '0.50' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.50 - References and Figure added. Refactoring of the Link.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/29 10h19'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.15'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.140';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.128';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.120';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.64';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.66';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.54';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.21';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.9';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.70';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.19';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.86';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 4/29/2015 11:24'!version051: spec	<version: '0.51' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.51 - Correction: Reference had a problem for some parses.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/04/29 11h24'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.15'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.143';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.129';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.120';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.64';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.66';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.54';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.21';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.9';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.70';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.19';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.86';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 5/2/2015 01:32'!version052: spec	<version: '0.52' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.52 - New version of STON/Cocoon + new transformer: ScriptFromFile.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/05/01 20h00'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.16'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.151';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.133';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.124';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.64';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.66';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.54';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.21';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.9';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.70';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.19';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.86';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 5/5/2015 09:49'!version053: spec	<version: '0.53' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.53 - Pillar is now good for Pharo 5.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/05/02 09h48'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.16'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.155';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.133';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.124';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.64';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.66';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.54';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.21';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.9';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.70';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.19';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.86';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'GuillermoPolito 5/8/2015 18:55'!version054: spec	<version: '0.54' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.54-moved document initialization to initializelike that we can use the pillar parser to easily skip properties-fixed date parsing that mixed dates and strings-flattening of pillar.conf into mustache template'.		spec author: 'GuillermoPolito'.		spec timestamp: '5/8/2015 18:55'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.16'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-GuillermoPolito.156';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.133';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-GuillermoPolito.125';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.64';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.66';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.54';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.21';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.9';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.70';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.19';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.86';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 5/14/2015 21:52'!version055: spec	<version: '0.55' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.55-Correction of a problem of dependency-The numerator is now global and work for separates output files.-The configuration startNumberingAtHeaderLevel is now at 1 by default.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '5/14/2015 21:47'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.16'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.157';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.133';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.130';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.64';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.66';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.54';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.21';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.9';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.73';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.19';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.86';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-BenComan.33';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-BenComan.6';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.8'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 5/22/2015 17:51'!version056: spec	<version: '0.56' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.56- Modification of the Numerator- Changed the syntax of anchors- Inter files links added'.		spec author: 'CyrilFerlicot'.		spec timestamp: '5/22/2015 17:47'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.16'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.163';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.133';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.149';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.69';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.71';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.61';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.22';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.9';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.92';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.25';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.92';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-CyrilFerlicot.39';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-CyrilFerlicot.13';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'GuillermoPolito 6/8/2015 14:42'!version057: spec	<version: '0.57' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.57- Updated to new version of cocoon'.		spec author: 'GuillermoPolito'.		spec timestamp: '2015-06-08T14:42:09.704219+02:00'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.18'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.163';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.133';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.149';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.69';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.71';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.61';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.22';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.9';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.92';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.25';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.92';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-CyrilFerlicot.39';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-CyrilFerlicot.13';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 6/9/2015 10:43'!version058: spec	<version: '0.58' imports: #('0.22-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.58 - document properties are inherited'.		spec author: 'GuillermoPolito'.		spec timestamp: '2015-06-08T14:42:09.704219+02:00'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.19'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.163';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.133';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.149';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.69';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.71';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.4';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.61';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.22';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.9';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.92';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.25';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.92';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.1';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-CyrilFerlicot.39';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-CyrilFerlicot.13';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-DamienCassou.8';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.10';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 7/20/2015 15:22'!version059: spec	<version: '0.59' imports: #('0.23-baseline')>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.59:- Beamer/DeckJS exporter- Configuration now use Magritte- Removed the Pillar interpreter (now magritte do it)- Cleaning the configuration, no private protocols anymore- Now templates are inherit on the sub configurations- Improved the speed of the export- Export is now divided into phases- Now we can generate the documentation of the transformers- Replaced Dictionary by GRSmallDictionary for parameters - Use Magritte to manage annotations''s parameters- Minor changes'.		spec author: 'CyrilFerlicot'.		spec timestamp: '20/07/2015 14:03'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.21'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.211';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.200';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.69';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.79';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.75';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.25';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.159';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.119';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.26';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.93';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-CyrilFerlicot.13';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-CyrilFerlicot.41';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-CyrilFerlicot.13';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.11';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DiegoLont 2/7/2014 10:26'!version05: spec	<version: '0.5' imports: #('0.3-baseline')>	spec		for: #common		do: [ 			spec				blessing: #release;				package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.47';				package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.58';				package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.30';				package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.34';				package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.47';				package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.31';				package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.34';				package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.24';				package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.21';				package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.9' ].	spec		for: #'pharo3.x'		do: [ 			spec package: 'Pillar-Cli' with: 'Pillar-Cli-BenjaminVanRyseghem.7'.			 ]! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 8/3/2015 11:08'!version060: spec	<version: '0.60' imports: #('0.23-baseline')>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.60: Correction of problems as a problem of sub configurations. Improvement of the export time.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '03/08/2015 11:03'.		spec 			project: 'Grease' with: '1.1.13';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.24'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.213';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.208';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.70';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.80';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.76';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.25';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.159';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.119';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.26';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.93';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-CyrilFerlicot.13';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-CyrilFerlicot.41';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-CyrilFerlicot.13';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.11';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 8/27/2015 13:37'!version061: spec	<version: '0.61' imports: #('0.23-baseline')>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.61: Let''s get rid of scripts !!- Added "defaultExporters" parameter- Added "latexCommand" parameter- Added "support" parameter- --to is not required anymore- Improvement of outputFile and outputDirectory- Generation of a script during a LaTeX export '.		spec author: 'CyrilFerlicot'.		spec timestamp: '25/08/2015 16:55'.		spec 			project: 'Grease' with: '1.2.0';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.27'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.223';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.243';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.70';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.80';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.77';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.31';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';						package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.160';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.128';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.26';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.93';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-CyrilFerlicot.13';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-CyrilFerlicot.41';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-CyrilFerlicot.14';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.15';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'CyrilFerlicot 8/31/2015 01:32'!version062: spec	<version: '0.62' imports: #('0.23-baseline')>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.62: Fix handling of sub-configurations'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/08/28 13:55'.		spec 			project: 'Grease' with: '1.2.0';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.28'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.223';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.247';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.70';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.80';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.77';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.31';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';						package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.160';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.130';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.26';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.93';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-CyrilFerlicot.13';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-CyrilFerlicot.41';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-CyrilFerlicot.14';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.16';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DiegoLont 2/7/2014 10:26'!version06: spec	<version: '0.6' imports: #('0.3-baseline')>	spec		for: #common		do: [ 			spec				blessing: #release;				package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.50';				package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.68';				package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.34';				package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.35';				package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.48';				package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.31';				package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.37';				package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.24';				package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.21';				package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.9' ].	spec		for: #'pharo3.x'		do: [ 			spec package: 'Pillar-Cli' with: 'Pillar-Cli-BenjaminVanRyseghem.7'.			 ]! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DiegoLont 2/7/2014 10:26'!version07: spec	<version: '0.7' imports: #('0.3-baseline')>	spec		for: #common		do: [ 			spec				blessing: #release;				package: 'Pillar-Model' with: 'Pillar-Model-BenjaminVanRyseghem.51';				package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-BenjaminVanRyseghem.70';				package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.36';				package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.42';				package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.54';				package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.33';				package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.41';				package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.27';				package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.27';				package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.13' ].	spec		for: #'pharo3.x'		do: [ 			spec package: 'Pillar-Cli' with: 'Pillar-Cli-BenjaminVanRyseghem.7'.			 ]! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DiegoLont 2/7/2014 10:29'!version08: spec	<version: '0.8' imports: #('0.3-baseline')>	spec		for: #common		do: [ 			spec				description: 'To be filled out.'; 				blessing: #release.							spec				project: 'Grease' with: '1.1.5';				project: 'Mustache' with: '0.48';				project: 'STON' with: '0.7'.							spec				package: 'Pillar-Model' with: 'Pillar-Model-BenjaminVanRyseghem.51';				package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-BenjaminVanRyseghem.70';				package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.36';				package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.43';				package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.54';				package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.33';				package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.41';				package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.27';				package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.28';				package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.13' ].	spec		for: #'pharo3.x'		do: [ 			spec package: 'Pillar-Cli' with: 'Pillar-Cli-BenjaminVanRyseghem.7'.			 ]! !!ConfigurationOfPillar methodsFor: 'versions (0.x)' stamp: 'DamienCassou 2/18/2014 18:17'!version09: spec	<version: '0.9' imports: #('0.3-baseline')>	spec		for: #common		do: [ 			spec				blessing: #release.							spec				project: 'Grease' with: '1.1.5';				project: 'Mustache' with: '0.48';				project: 'STON' with: '0.7'.							spec				package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.62';				package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.71';				package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.37';				package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienPollet.46';				package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.54';				package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.39';				package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.42';				package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.27';				package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.30';				package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.13' ].	spec		for: #'pharo3.x'		do: [ 			spec package: 'Pillar-Cli' with: 'Pillar-Cli-BenjaminVanRyseghem.7'.			 ]! !!ConfigurationOfPillar methodsFor: 'versions (1.x.x)' stamp: 'CyrilFerlicot 8/31/2015 18:07'!version100: spec	<version: '1.0.0' imports: #('0.23-baseline')>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.0.0: First realese (nothing new since 0.62)'.		spec author: 'CyrilFerlicot'.		spec timestamp: '2015/08/31 18:07'.		spec 			project: 'Grease' with: '1.2.0';			project: 'Mustache' with: '0.71';			project: 'Cocoon' with: '1.28'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.223';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.247';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.70';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-CyrilFerlicot.80';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-CyrilFerlicot.77';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.31';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';						package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.160';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.130';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.26';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.93';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-CyrilFerlicot.13';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-CyrilFerlicot.41';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-CyrilFerlicot.14';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13'. ].	spec for: #'pharo' do: [		spec 			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.16';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (1.x.x)' stamp: 'DamienCassou 9/7/2015 15:59'!version110: spec	<version: '1.1.0' imports: #('0.26-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.1.0- add shebang to generated pillarPostExport.sh- improve pillarPostExport.sh messages a little- HTML exporter  - output a <figure> if and only if the Pillar figure has both a    caption and a label- LaTeX exporter  - output a \begin{figure} if and only if the Pillar figure has both    a caption and a label'.		spec author: 'DamienCassou'.		spec timestamp: '9/7/2015 09:39'.		spec 			project: 'Grease' with: '1.2.1';			project: 'Mustache' with: '0.71';			project: 'PetitParser' with: '1.13';			project: 'PetitParserTest' with: '1.13';			project: 'Cocoon' with: '1.28'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.227';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.167';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-CyrilFerlicot.99';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.250';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.70';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.81';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.79';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.31';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.16';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.134';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.27';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.96';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.15';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.42';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.15';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13'. ].! !!ConfigurationOfPillar methodsFor: 'versions (1.x.x)' stamp: 'DamienCassou 9/7/2015 15:59'!version111: spec	<version: '1.1.1' imports: #('0.27-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.1.1- fix #66: Pillar was eating ''-'' and ''='' characters while reading command-line parameters'.		spec author: 'DamienCassou'.		spec timestamp: '9/7/2015 15:59'.		spec 			project: 'Grease' with: '1.2.1';			project: 'Mustache' with: '0.71';			project: 'PetitParser' with: '1.13';			project: 'PetitParserTest' with: '1.13';			project: 'Cocoon' with: '1.28'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.227';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-CyrilFerlicot.99';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.250';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.70';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.81';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.79';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.31';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.167';			package: 'Pillar-Cli' with: 'Pillar-Cli-DamienCassou.17';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.134';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.27';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.96';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.15';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.42';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.15';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (1.x.x)' stamp: 'DamienCassou 9/7/2015 16:23'!version112: spec	<version: '1.1.2' imports: #('0.27-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.1.2- fix #67: Pillar was slow choosing which files from support to copy to outputDirectory'.		spec author: 'DamienCassou'.		spec timestamp: '9/7/2015 16:23'.		spec 			project: 'Grease' with: '1.2.1';			project: 'Mustache' with: '0.71';			project: 'PetitParser' with: '1.13';			project: 'PetitParserTest' with: '1.13';			project: 'Cocoon' with: '1.28'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.227';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-CyrilFerlicot.99';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.251';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.70';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.81';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.79';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.31';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.167';			package: 'Pillar-Cli' with: 'Pillar-Cli-DamienCassou.17';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.134';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.27';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.96';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.15';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.42';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.15';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (1.x.x)' stamp: 'StephanEggermont 1/18/2016 16:00'!version113: spec	<version: '1.1.3' imports: #('0.27-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.1.3		version for pier3'.		spec author: 'StephanEggermont'.		spec timestamp: '1/18/2016 15:40'.		spec 			project: 'Grease' with: #'release1.2';			project: 'Mustache' with: #stable;			project: 'PetitParser' with: #stable;			project: 'PetitParserTest' with: #stable;			project: 'Cocoon' with: #'pier'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.227';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-CyrilFerlicot.99';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.251';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.70';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.81';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.79';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.31';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.167';			package: 'Pillar-Cli' with: 'Pillar-Cli-DamienCassou.17';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.134';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.27';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.96';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.15';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.42';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.15';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (2.x.x)' stamp: 'CyrilFerlicot 9/11/2015 12:04'!version200: spec	<version: '2.0.0' imports: #('0.28-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 2.0.0- Use PetitPillar instead of the old parser.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '9/11/2015 11:41'.		spec 			project: 'Grease' with: '1.2.1';			project: 'Mustache' with: '0.71';			project: 'PetitParser' with: '1.13';			project: 'PetitParserTest' with: '1.13';			project: 'Cocoon' with: '1.28'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.232';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-CyrilFerlicot.116';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.252';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.70';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.81';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.79';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-CyrilFerlicot.36';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';			package: 'Pillar-Cli' with: 'Pillar-Cli-DamienCassou.17';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.171';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-CyrilFerlicot.19';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.135';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.28';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-CyrilFerlicot.97';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.15';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.42';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.15';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (2.x.x)' stamp: 'DamienCassou 10/7/2015 11:10'!version201: spec	<version: '2.0.1' imports: #('0.28-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 2.0.1- bug fixing'.		spec author: 'DamienCassou'.		spec timestamp: '9/28/2015 13:26'.		spec 			project: 'Grease' with: '1.2.1';			project: 'Mustache' with: '0.72';			project: 'PetitParser' with: '1.13';			project: 'PetitParserTest' with: '1.13';			project: 'Cocoon' with: '1.28'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.232';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-DamienCassou.121';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.254';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.70';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.83';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.79';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.37';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.173';			package: 'Pillar-Cli' with: 'Pillar-Cli-DamienCassou.18';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.135';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.28';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.101';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.16';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.42';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.15';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (2.x.x)' stamp: 'DamienCassou 10/7/2015 11:08'!version202: spec	<version: '2.0.2' imports: #('0.29-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 2.0.2'.		spec author: 'DamienCassou'.		spec timestamp: '10/7/2015 11:08'.		spec 			project: 'Grease' with: '1.2.1';			project: 'Mustache' with: '0.72';			project: 'PetitParser' with: '1.13';			project: 'PetitParserTest' with: '1.13';			project: 'Cocoon' with: '1.28'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.233';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-DamienCassou.129';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.254';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.70';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.84';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.79';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.37';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.174';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-DamienCassou.23';			package: 'Pillar-Cli' with: 'Pillar-Cli-DamienCassou.18';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.135';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.28';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.101';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.16';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.42';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.15';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (2.x.x)' stamp: 'DamienCassou 10/8/2015 16:33'!version203: spec	<version: '2.0.3' imports: #('0.29-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 2.0.3Ignore spaces after list markup.'.		spec author: 'DamienCassou'.		spec timestamp: '10/8/2015 16:33'.		spec 			project: 'Grease' with: '1.2.1';			project: 'Mustache' with: '0.72';			project: 'PetitParser' with: '1.13';			project: 'PetitParserTest' with: '1.13';			project: 'Cocoon' with: '1.28'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.233';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-DamienCassou.130';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.254';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.70';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.84';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.79';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.37';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.176';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-DamienCassou.23';			package: 'Pillar-Cli' with: 'Pillar-Cli-DamienCassou.18';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.135';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.28';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.101';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.16';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.42';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.15';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (2.x.x)' stamp: 'DamienCassou 10/8/2015 16:44'!version204: spec	<version: '2.0.4' imports: #('0.29-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 2.0.4Fix test in Pharo 5'.		spec author: 'DamienCassou'.		spec timestamp: '10/8/2015 16:44'.		spec 			project: 'Grease' with: '1.2.1';			project: 'Mustache' with: '0.72';			project: 'PetitParser' with: '1.13';			project: 'PetitParserTest' with: '1.13';			project: 'Cocoon' with: '1.28'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.233';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-DamienCassou.130';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-DamienCassou.254';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.70';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.84';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.79';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.37';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-DamienCassou.176';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-DamienCassou.23';			package: 'Pillar-Cli' with: 'Pillar-Cli-DamienCassou.18';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.136';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.28';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.101';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.16';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.42';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.15';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (2.x.x)' stamp: 'CyrilFerlicot 1/24/2016 19:48'!version205: spec	<version: '2.0.5' imports: #('0.29-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 2.0.5	- Correction of issue 94 (https://github.com/pillar-markup/pillar/issues/94	- Remove old parser	- Rename PRCocoonConfiguration into PRPillarConfiguration	- Use PetitCompiler'.		spec author: 'CyrilFerlicot'.		spec timestamp: '01/24/2016 18:53'.		spec 			project: 'Grease' with: '1.2.1';			project: 'Mustache' with: '0.72';			project: 'PetitParser' with: '1.13';			project: 'PetitParserTest' with: '1.13';			project: 'Cocoon' with: #stable.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-CyrilFerlicot.240';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-DamienCassou.138';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.256';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.70';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.84';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.79';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.37';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.178';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-DamienCassou.23';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.20';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.139';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.28';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.101';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.17';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.42';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.15';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (2.x.x)' stamp: 'DamienCassou 2/4/2016 17:04'!version206: spec	<version: '2.0.6' imports: #('0.29-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 2.0.6	- Add Pillar as a listing language	- Add missing \usepackage{xcolor} in default LaTeX template'.		spec author: 'DamienCassou'.		spec timestamp: '2/4/2016 17:00'.		spec 			project: 'Grease' with: '1.2.6';			project: 'Mustache' with: '0.72';			project: 'PetitParser' with: '1.14';			project: 'PetitParserTest' with: '1.14';			project: 'Cocoon' with: '1.30'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienPollet.241';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-DamienCassou.138';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.256';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.70';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.89';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.79';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.37';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.178';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-DamienCassou.23';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.20';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.139';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.28';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.101';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.17';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.42';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.15';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions (2.x.x)' stamp: 'DamienCassou 2/11/2016 16:36'!version207: spec	<version: '2.0.7' imports: #('0.29-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 2.0.7	- Add missing charset in HTML''s default template'.		spec author: 'DamienCassou'.		spec timestamp: '2/11/2016 16:35'.		spec 			project: 'Grease' with: '1.2.6';			project: 'Mustache' with: '0.72';			project: 'PetitParser' with: '1.14';			project: 'PetitParserTest' with: '1.14';			project: 'Cocoon' with: '1.30'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-DamienPollet.241';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-DamienCassou.138';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-CyrilFerlicot.256';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.70';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.89';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-CyrilFerlicot.25';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.80';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-CyrilFerlicot.8';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.37';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.10';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-CyrilFerlicot.178';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-DamienCassou.23';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.20';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-CyrilFerlicot.139';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.28';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.101';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.17';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.43';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.15';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-CyrilFerlicot.13';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-CyrilFerlicot.9';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1'. ].! !!ConfigurationOfPillar methodsFor: 'versions' stamp: 'ThibaultArloing 4/20/2016 14:55'!version300: spec	<version: '3.0.0' imports: #('0.30-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 3.0.0- Addition of an AsciiDoc exporter- LaTeX exporter:	-- external links now produce footnotes	-- replace \begin{code}{} with \begin{listing}[language=XXXX]	-- replace \ct with \code	-- use \textasciitilde instead of \texttildelow to represent a ~ character in Pillar	-- SBALaTeXWriter for sba book (by Damien Pollet) https://github.com/cdlm/sbabook- HTML exporter:	-- default template charset is UTF-8- Features: For more you can see Pillar documentation.	-- hideable scripts with the option hideable.		ex: [[[hideable=true				with a parameter in pillar.conf "scriptHide"=true this text will be hidden.	 			 ]]]	-- auto anchor for headers		ex: in a level configuration			 "level1":{				"numbering"=true,				"autoAnchor"=true			}			there will be an automatic creation of an anchor for headers of level 1.	-- header capitalization in a level configuration with options:		capitalize, capitalizeEnglish, uppercase and lowercase		ex: "level1":{				"capitalization":"uppercase"			 }			Will render all headers of level 1 to Uppercase.'.		spec author: 'ThibaultArloing'.		spec timestamp: '4/20/2016 11:48'.		spec 			project: 'Grease' with: '1.2.7';			project: 'Mustache' with: '0.72';			project: 'PetitParser' with: '1.14';			project: 'PetitParserTest' with: '1.14';			project: 'Cocoon' with: '1.30'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-ThibaultArloing.254';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-DamienCassou.138';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-ThibaultArloing.275';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.71';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.100';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.26';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.83';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-DamienCassou.9';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.39';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.11';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-YannDubois.186';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-DamienCassou.23';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.20';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.146';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.28';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.109';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.17';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.43';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.16';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.15';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-ThibaultArloing.10';			package: #'Pillar-ExporterAsciiDoc' with: 'Pillar-ExporterAsciiDoc-ThibaultArloing.23';			package: #'Pillar-Tests-ExporterAsciiDoc' with: 'Pillar-Tests-ExporterAsciiDoc-ThibaultArloing.10'. ].! !!ConfigurationOfPillar methodsFor: 'versions' stamp: 'ThibaultArloing 4/20/2016 17:03'!version301: spec	<version: '3.0.1' imports: #('0.30-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 3.0.1Cocoon 1.31'.		spec author: 'ThibaultArloing'.		spec timestamp: '4/20/2016 17:02'.		spec 			project: 'Grease' with: '1.2.7';			project: 'Mustache' with: '0.72';			project: 'PetitParser' with: '1.14';			project: 'PetitParserTest' with: '1.14';			project: 'Cocoon' with: '1.31'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-ThibaultArloing.254';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-DamienCassou.138';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-ThibaultArloing.275';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.71';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.100';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.26';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.83';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-DamienCassou.9';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.39';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.11';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-YannDubois.186';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-DamienCassou.23';			package: 'Pillar-Cli' with: 'Pillar-Cli-CyrilFerlicot.20';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.146';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.28';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.109';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.17';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.43';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.16';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.15';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-ThibaultArloing.10';			package: #'Pillar-ExporterAsciiDoc' with: 'Pillar-ExporterAsciiDoc-ThibaultArloing.23';			package: #'Pillar-Tests-ExporterAsciiDoc' with: 'Pillar-Tests-ExporterAsciiDoc-ThibaultArloing.10'. ].! !!ConfigurationOfPillar methodsFor: 'versions' stamp: 'YannDubois 4/29/2016 09:42'!version302: spec	<version: '3.0.2' imports: #('0.30-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 3.0.2Define a specific listing environment for beamer. This should probably be cleaned later.'.		spec author: 'DamienCassou'.		spec timestamp: '4/25/2016 16:38'.		spec 			project: 'Grease' with: '1.2.7';			project: 'PetitParser' with: '1.14';			project: 'PetitParserTest' with: '1.14';			project: 'Cocoon' with: '1.31'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-ThibaultArloing.254';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-DamienCassou.138';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-YannDubois.295';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.71';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.100';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.27';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.83';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-DamienCassou.9';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.39';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.11';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-YannDubois.186';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-DamienCassou.23';			package: 'Pillar-Cli' with: 'Pillar-Cli-YannDubois.30';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.146';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.28';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.109';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.18';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.43';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.16';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.15';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: #'Pillar-ExporterAsciiDoc' with: 'Pillar-ExporterAsciiDoc-ThibaultArloing.23';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-ThibaultArloing.10';			package: #'Pillar-Tests-ExporterAsciiDoc' with: 'Pillar-Tests-ExporterAsciiDoc-ThibaultArloing.10'. ].! !!ConfigurationOfPillar methodsFor: 'versions' stamp: 'DamienCassou 5/11/2016 15:52'!version303: spec	<version: '3.0.3' imports: #('0.30-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 3.0.3sbabook should export preformatted environments to the same latex environments as scripts'.		spec author: 'DamienCassou'.		spec timestamp: '5/11/2016 15:48'.		spec 			project: 'Grease' with: '1.2.7';			project: 'PetitParser' with: '1.14';			project: 'PetitParserTest' with: '1.14';			project: 'Cocoon' with: '1.31'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-ThibaultArloing.254';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-DamienCassou.138';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-YannDubois.295';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.71';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.101';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.27';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.83';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-DamienCassou.9';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.39';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.11';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-YannDubois.186';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-DamienCassou.23';			package: 'Pillar-Cli' with: 'Pillar-Cli-YannDubois.30';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-DamienCassou.146';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.28';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.110';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.18';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.43';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.16';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.15';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: #'Pillar-ExporterAsciiDoc' with: 'Pillar-ExporterAsciiDoc-ThibaultArloing.23';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-ThibaultArloing.10';			package: #'Pillar-Tests-ExporterAsciiDoc' with: 'Pillar-Tests-ExporterAsciiDoc-ThibaultArloing.10'. ].! !!ConfigurationOfPillar methodsFor: 'versions' stamp: 'YannDubois 6/9/2016 11:00'!version304: spec	<version: '3.0.4' imports: #('0.30-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 3.0.4Fix bug when copying support'.		spec author: 'DamienCassou'.		spec timestamp: '6/9/2016 11:00'.		spec 			project: 'Grease' with: '1.2.7';			project: 'PetitParser' with: '1.14';			project: 'PetitParserTest' with: '1.14';			project: 'Cocoon' with: '1.31'.		spec 			package: 'Pillar-Model' with: 'Pillar-Model-ThibaultArloing.254';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-DamienCassou.138';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-YannDubois.321';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-CyrilFerlicot.71';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.101';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.27';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.83';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-DamienCassou.9';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-DamienCassou.39';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.11';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-YannDubois.186';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-DamienCassou.23';			package: 'Pillar-Cli' with: 'Pillar-Cli-YannDubois.30';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-YannDubois.147';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-CyrilFerlicot.28';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.110';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.18';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.43';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.16';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.15';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.1';			package: #'Pillar-ExporterAsciiDoc' with: 'Pillar-ExporterAsciiDoc-ThibaultArloing.23';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-ThibaultArloing.10';			package: #'Pillar-Tests-ExporterAsciiDoc' with: 'Pillar-Tests-ExporterAsciiDoc-ThibaultArloing.10'. ].! !!ConfigurationOfPillar methodsFor: 'versions' stamp: 'ThibaultArloing 7/22/2016 15:27'!version400: spec	<version: '4.0.0' imports: #('0.31-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 4.0.0'.		spec author: 'ThibaultArloing'.		spec timestamp: '7/22/2016 15:27'.		spec 			project: 'Cocoon' with: '1.31';			project: 'JSON' with: '1.2';			project: 'LightPhaser' with: '0.1-baseline';			project: 'PetitParser' with: '1.14';			project: 'PetitParserTest' with: '1.14'.		spec 			package: 'Pillar-Cli' with: 'Pillar-Cli-YannDubois.36';			package: #'Pillar-ExporterAsciiDoc' with: 'Pillar-ExporterAsciiDoc-DamienCassou.27';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.30';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-ThibaultArloing.372';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-DamienCassou.12';			package: #'Pillar-ExporterEPub' with: 'Pillar-ExporterEPub-DamienCassou.9';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.88';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.107';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.75';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-StephaneDucasse.41';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.11';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.2';			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.289';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-YannDubois.142';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-YannDubois.12';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1';			package: #'Pillar-Tests-ExporterAsciiDoc' with: 'Pillar-Tests-ExporterAsciiDoc-DamienCassou.12';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.19';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-ThibaultArloing.207';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: #'Pillar-Tests-ExporterEPub' with: 'Pillar-Tests-ExporterEPub-DamienCassou.6';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.46';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.113';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.32';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.18';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.16';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-ThibaultArloing.215';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-YannDubois.25'. ].! !!ConfigurationOfPillar methodsFor: 'versions' stamp: 'YannDubois 7/27/2016 16:09'!version401: spec	<version: '4.0.1' imports: #('0.31-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 4.0.1'.		spec author: 'YannDubois'.		spec timestamp: '7/27/2016 16:09'.		spec 			project: 'Cocoon' with: '1.31';			project: 'JSON' with: '1.2';			project: 'LightPhaser' with: '0.1-baseline';			project: 'PetitParser' with: '1.14';			project: 'PetitParserTest' with: '1.14'.		spec 			package: 'Pillar-Cli' with: 'Pillar-Cli-YannDubois.37';			package: #'Pillar-ExporterAsciiDoc' with: 'Pillar-ExporterAsciiDoc-DamienCassou.27';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.30';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-ThibaultArloing.372';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-DamienCassou.12';			package: #'Pillar-ExporterEPub' with: 'Pillar-ExporterEPub-DamienCassou.9';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.88';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.107';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.75';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-StephaneDucasse.41';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.11';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.2';			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.289';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-YannDubois.142';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-YannDubois.12';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1';			package: #'Pillar-Tests-ExporterAsciiDoc' with: 'Pillar-Tests-ExporterAsciiDoc-DamienCassou.12';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.19';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-ThibaultArloing.207';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: #'Pillar-Tests-ExporterEPub' with: 'Pillar-Tests-ExporterEPub-DamienCassou.6';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.46';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.113';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.32';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.18';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.16';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-ThibaultArloing.215';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-YannDubois.25'. ].! !!ConfigurationOfPillar methodsFor: 'versions' stamp: 'ThibaultArloing 8/2/2016 14:51'!version402: spec	<version: '4.0.2' imports: #('0.31-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 4.0.2'.		spec author: 'ThibaultArloing'.		spec timestamp: '8/2/2016 14:51'.		spec 			project: 'Cocoon' with: '1.31';			project: 'JSON' with: '1.2';			project: 'LightPhaser' with: '0.1-baseline';			project: 'PetitParser' with: '1.14';			project: 'PetitParserTest' with: '1.14'.		spec 			package: 'Pillar-Cli' with: 'Pillar-Cli-YannDubois.37';			package: #'Pillar-ExporterAsciiDoc' with: 'Pillar-ExporterAsciiDoc-DamienCassou.27';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.30';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-ThibaultArloing.373';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-DamienCassou.12';			package: #'Pillar-ExporterEPub' with: 'Pillar-ExporterEPub-DamienCassou.9';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.88';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.107';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.75';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-StephaneDucasse.41';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.11';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.2';			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.289';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-YannDubois.142';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-YannDubois.12';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1';			package: #'Pillar-Tests-ExporterAsciiDoc' with: 'Pillar-Tests-ExporterAsciiDoc-DamienCassou.12';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.19';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-ThibaultArloing.207';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: #'Pillar-Tests-ExporterEPub' with: 'Pillar-Tests-ExporterEPub-DamienCassou.6';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.46';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.113';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.32';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.18';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.16';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-ThibaultArloing.215';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-YannDubois.25'. ].! !!ConfigurationOfPillar methodsFor: 'versions' stamp: 'ThibaultArloing 8/3/2016 15:05'!version403: spec	<version: '4.0.3' imports: #('0.31-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 4.0.3'.		spec author: 'ThibaultArloing'.		spec timestamp: '8/3/2016 15:05'.		spec 			project: 'Cocoon' with: '1.31';			project: 'JSON' with: '1.2';			project: 'LightPhaser' with: '0.1-baseline';			project: 'PetitParser' with: '1.14';			project: 'PetitParserTest' with: '1.14'.		spec 			package: 'Pillar-Cli' with: 'Pillar-Cli-YannDubois.37';			package: #'Pillar-ExporterAsciiDoc' with: 'Pillar-ExporterAsciiDoc-DamienCassou.27';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.30';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-ThibaultArloing.374';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-DamienCassou.12';			package: #'Pillar-ExporterEPub' with: 'Pillar-ExporterEPub-DamienCassou.9';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.88';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.107';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.75';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-StephaneDucasse.41';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.11';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.2';			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.289';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-YannDubois.142';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-YannDubois.12';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1';			package: #'Pillar-Tests-ExporterAsciiDoc' with: 'Pillar-Tests-ExporterAsciiDoc-DamienCassou.12';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.19';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-ThibaultArloing.207';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: #'Pillar-Tests-ExporterEPub' with: 'Pillar-Tests-ExporterEPub-DamienCassou.6';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.46';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.113';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.32';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.18';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.16';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-ThibaultArloing.215';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-YannDubois.25'. ].! !!ConfigurationOfPillar methodsFor: 'versions' stamp: 'YannDubois 8/9/2016 14:47'!version404: spec	<version: '4.0.4' imports: #('0.31-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 4.0.3'.		spec author: 'ThibaultArloing'.		spec timestamp: '8/9/2016 14:47'.		spec 			project: 'Cocoon' with: '1.31';			project: 'JSON' with: '1.2';			project: 'LightPhaser' with: '0.1-baseline';			project: 'PetitParser' with: '1.14';			project: 'PetitParserTest' with: '1.14'.		spec 			package: 'Pillar-Cli' with: 'Pillar-Cli-YannDubois.37';			package: #'Pillar-ExporterAsciiDoc' with: 'Pillar-ExporterAsciiDoc-DamienCassou.27';			package: 'Pillar-ExporterBeamer' with: 'Pillar-ExporterBeamer-DamienCassou.30';			package: 'Pillar-ExporterCore' with: 'Pillar-ExporterCore-YannDubois.375';			package: 'Pillar-ExporterDeckJS' with: 'Pillar-ExporterDeckJS-DamienCassou.12';			package: #'Pillar-ExporterEPub' with: 'Pillar-ExporterEPub-DamienCassou.9';			package: 'Pillar-ExporterHTML' with: 'Pillar-ExporterHTML-DamienCassou.88';			package: 'Pillar-ExporterLaTeX' with: 'Pillar-ExporterLaTeX-DamienCassou.107';			package: 'Pillar-ExporterMarkdown' with: 'Pillar-ExporterMarkdown-DamienCassou.75';			package: 'Pillar-ExporterPillar' with: 'Pillar-ExporterPillar-StephaneDucasse.41';			package: 'Pillar-ExporterText' with: 'Pillar-ExporterText-CyrilFerlicot.11';			package: 'Pillar-GitBook' with: 'Pillar-GitBook-DamienCassou.2';			package: 'Pillar-Model' with: 'Pillar-Model-DamienCassou.289';			package: 'Pillar-PetitPillar' with: 'Pillar-PetitPillar-YannDubois.142';			package: 'Pillar-Pharo-Tools' with: 'Pillar-Pharo-Tools-YannDubois.12';			package: #'Pillar-Tests-Cli' with: 'Pillar-Tests-Cli-DamienCassou.1';			package: #'Pillar-Tests-ExporterAsciiDoc' with: 'Pillar-Tests-ExporterAsciiDoc-DamienCassou.12';			package: 'Pillar-Tests-ExporterBeamer' with: 'Pillar-Tests-ExporterBeamer-DamienCassou.19';			package: 'Pillar-Tests-ExporterCore' with: 'Pillar-Tests-ExporterCore-ThibaultArloing.207';			package: 'Pillar-Tests-ExporterDeckJS' with: 'Pillar-Tests-ExporterDeckJS-DamienCassou.5';			package: #'Pillar-Tests-ExporterEPub' with: 'Pillar-Tests-ExporterEPub-DamienCassou.6';			package: 'Pillar-Tests-ExporterHTML' with: 'Pillar-Tests-ExporterHTML-DamienCassou.46';			package: 'Pillar-Tests-ExporterLaTeX' with: 'Pillar-Tests-ExporterLaTeX-DamienCassou.113';			package: 'Pillar-Tests-ExporterMarkdown' with: 'Pillar-Tests-ExporterMarkdown-DamienCassou.32';			package: 'Pillar-Tests-ExporterPillar' with: 'Pillar-Tests-ExporterPillar-DamienCassou.18';			package: 'Pillar-Tests-ExporterText' with: 'Pillar-Tests-ExporterText-DamienCassou.16';			package: 'Pillar-Tests-Model' with: 'Pillar-Tests-Model-ThibaultArloing.215';			package: 'Pillar-Tests-PetitPillar' with: 'Pillar-Tests-PetitPillar-YannDubois.25'. ].! !"ConfigurationOfPillar"!!ConfigurationOfCocoon commentStamp: 'DamienCassou 4/24/2015 16:44' prior: 0![[[language=smalltalkConfigurationOfCocoon loadBleedingEdge]]](This documentation is automatically generated from `ConfigurationOfCocoon`'s class comment. Please update it there.)An application configuration system using JSON.!!!! Using CocoonTo use Cocoon in your application, you first have to describe how your application can be configured. This is done in a dedicated subclass of ==CCConfiguration==: e.g., with a new ==MyAppCocoonConfiguration== class.In your ==MyAppCocoonConfiguration== class you'll need to define the configuration properties accepted by the application. For example if the application lets the user specify input files you can create this method:[[[language=smalltalkMyAppCocoonConfiguration>>inputFiles	<cocoonParameter: 'List the files that I need to use.'>	^ self propertyAt: 'inputFiles' default: [ self defaultInputFiles ]MyAppCocoonConfiguration>>defaultInputFiles	<cocoonDefaultParameter:'None'>		^ Array new]]]One design principle of Cocoon is that the Cocoon configuration class manipulates real objects, not strings. For example, ==inputFiles== is likely to be a collection of file references (instances of ==FileReference==). To interpret what will be specified in the user's configuration file, you have to create an interpreter. This is done by subclassing ==CCSTONConfigurationInterpreter==: e.g., with a new ==MyAppSTONConfigurationInterpreter== class. Override both ==#configuration== and ==#initializeInterpretationBlocks==.!!!!Generating DocumentationCocoon contains a system that allows you to generate a pillar documentation of your parameters in your configuration: CCDocumentationGenerator !!To use it it's simple. On a property's method add this pragma: [[[	<cocoonParameter: 'The documentation of my property'>]]]The default value's property need to be named like this: if your property is 'author' so the default value's method will be named 'defaultAuthor'.Inside the default method add this pragma: [[[	<cocoonDefaultParameter: 'The description of the default value.'>]]]If the default value is a litteral you can also write [[[	<cocoonDefaultParameter: ''>]]]This will print the litteral value.Now you can generate your documentation like this.Create a stream and use this simple command:[[[	stream := String new writeStream.	CCDocumentationGeneration of: myClassWhoExtendsCCConfiguration on: stream.]]]________________________________________________@@note A part of the properties has been copied from PRBasicObject.@@note You can see an example of use in the Pillar Exporter's configuration. ( PRCocoonConfiguration and PRCocoonConfigurationInterpreter )!!ConfigurationOfCocoon class methodsFor: 'development support' stamp: 'StephaneDucasse 3/31/2015 10:07'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfCocoon class methodsFor: 'private' stamp: 'StephaneDucasse 3/31/2015 10:07'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfCocoon class methodsFor: 'metadata' stamp: 'DamienCassou 10/9/2015 14:04'!catalogContactInfo	^ 'The creators of Cocoon are Cyril Ferlicot and Damien Cassou.The website is at *http://smalltalkhub.com/#!!/~PharoExtras/Cocoon/*.'! !!ConfigurationOfCocoon class methodsFor: 'metadata' stamp: 'DamienCassou 10/9/2015 14:05'!catalogDescription	^ 'An application configuration system using JSON. I manage sets of meta-described properties. A cocoon configuration can contain sub-configurations that inhers their properties from their parent.'! !!ConfigurationOfCocoon class methodsFor: 'metadata' stamp: 'DamienCassou 10/9/2015 14:05'!catalogKeywords	^ #(cocoon configuration manager documentation magritte meta-description)! !!ConfigurationOfCocoon class methodsFor: 'private' stamp: 'StephaneDucasse 3/31/2015 10:07'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfCocoon class methodsFor: 'private' stamp: 'StephaneDucasse 3/31/2015 10:07'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfCocoon class methodsFor: 'metacello tool support' stamp: 'StephaneDucasse 3/31/2015 10:07'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfCocoon class methodsFor: 'loading' stamp: 'StephaneDucasse 3/31/2015 10:07'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfCocoon class methodsFor: 'loading' stamp: 'StephaneDucasse 3/31/2015 10:07'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfCocoon class methodsFor: 'loading' stamp: 'StephaneDucasse 3/31/2015 10:07'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfCocoon class methodsFor: 'accessing' stamp: 'StephaneDucasse 3/31/2015 10:07'!project	^self new project! !!ConfigurationOfCocoon class methodsFor: 'development support' stamp: 'StephaneDucasse 3/31/2015 10:07'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfCocoon methodsFor: 'baselines' stamp: 'StephaneDucasse 3/31/2015 10:09'!baseline01: spec	<version: '0.1-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/PharoExtras/Cocoon/main/'.		spec project: 'Ston' with: [				spec					className: #ConfigurationOfSton;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/SvenVanCaekenberghe/STON/main/' ].		spec package: 'Cocoon-Core' with: [				spec requires: #('Ston' ). ]. ].! !!ConfigurationOfCocoon methodsFor: 'baselines' stamp: 'CyrilFerlicot 3/31/2015 16:51'!baseline02: spec	<version: '0.2-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/PharoExtras/Cocoon/main/'.		spec project: 'Ston' with: [				spec					className: #ConfigurationOfSton;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/SvenVanCaekenberghe/STON/main/' ].		spec 			package: 'Cocoon-Core' with: [				spec requires: #('Ston' ). ];			package: #'Cocoon-Test-Core'. ].! !!ConfigurationOfCocoon methodsFor: 'baselines' stamp: 'CyrilFerlicot 3/31/2015 17:59'!baseline03: spec	<version: '0.3-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/PharoExtras/Cocoon/main/'.		spec project: 'Ston' with: [				spec					className: #ConfigurationOfSton;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/SvenVanCaekenberghe/STON/main/' ].		spec 			package: 'Cocoon-Core' with: [				spec requires: #('Ston' ). ];			package: #'Cocoon-Tests-Core'. ].! !!ConfigurationOfCocoon methodsFor: 'baselines' stamp: 'CyrilFerlicot 6/18/2015 10:01'!baseline04: spec	<version: '0.4-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/PharoExtras/Cocoon/main/'.		spec 			project: 'Ston' with: [				spec					className: #ConfigurationOfSton;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/SvenVanCaekenberghe/STON/main/' ];			project: 'Magritte3' with: [				spec					className: #ConfigurationOfMagritte3;					versionString: #'stable';					repository: 'http://smalltalkhub.com/mc/Magritte/Magritte3/main/' ].		spec 			package: 'Cocoon-Core' with: [				spec requires: #('Ston' 'Magritte3' ). ];			package: #'Cocoon-Tests-Core'. ].! !!ConfigurationOfCocoon methodsFor: 'accessing' stamp: 'StephaneDucasse 3/31/2015 10:07'!customProjectAttributes	 "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes"	^ #().! !!ConfigurationOfCocoon methodsFor: 'symbolic versions' stamp: 'CyrilFerlicot 6/29/2015 15:38'!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: '0.4-baseline'.! !!ConfigurationOfCocoon methodsFor: 'symbolic versions' stamp: 'CyrilFerlicot 1/24/2016 19:39'!pier: spec	<symbolicVersion: #'pier'>	spec for: #'common' version: '1.29'.! !!ConfigurationOfCocoon methodsFor: 'accessing' stamp: 'StephaneDucasse 3/31/2015 10:07'!project	^ project ifNil: [ 		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		project := MetacelloMCProject new projectAttributes: self customProjectAttributes. 		(Smalltalk at: #MetacelloVersionConstructor) on: self project: project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfCocoon methodsFor: 'symbolic versions' stamp: 'ThibaultArloing 4/20/2016 16:55'!stable: spec	<symbolicVersion: #'stable'>	spec for: #'common' version: '1.31'.! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'StephaneDucasse 3/31/2015 10:31'!version10: spec	<version: '1.0' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.0'.		spec author: 'StephaneDucasse'.		spec timestamp: '3/31/2015 10:31'.		spec project: 'Ston' with: '0.10'.		spec package: 'Cocoon-Core' with: 'Cocoon-Core-StephaneDucasse.2'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 4/10/2015 14:10'!version110: spec	<version: '1.10' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.10'.		spec author: 'CyrilFerlicot'.		spec timestamp: '4/10/2015 14:10'.		spec project: 'Ston' with: '0.10'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.9';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.11'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 4/16/2015 13:14'!version111: spec	<version: '1.11' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.11'.		spec author: 'CyrilFerlicot'.		spec timestamp: '4/16/2015 13:14'.		spec project: 'Ston' with: '0.12'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.11';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.12'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 4/21/2015 16:51'!version112: spec	<version: '1.12' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.12'.		spec author: 'CyrilFerlicot'.		spec timestamp: '4/21/2015 16:51'.		spec project: 'Ston' with: '0.12'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.12';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.13'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 4/22/2015 10:30'!version113: spec	<version: '1.13' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.13'.		spec author: 'CyrilFerlicot'.		spec timestamp: '4/22/2015 10:30'.		spec project: 'Ston' with: '0.12'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.13';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.14'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 4/22/2015 13:44'!version114: spec	<version: '1.14' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.14'.		spec author: 'CyrilFerlicot'.		spec timestamp: '4/22/2015 13:44'.		spec project: 'Ston' with: '0.12'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.13';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.15'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 4/27/2015 10:46'!version115: spec	<version: '1.15' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.15'.		spec author: 'CyrilFerlicot'.		spec timestamp: '4/27/2015 10:46'.		spec project: 'Ston' with: '0.12'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.17';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.17'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 5/2/2015 01:31'!version116: spec	<version: '1.16' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.16'.		spec author: 'CyrilFerlicot'.		spec timestamp: '5/2/2015 01:31'.		spec project: 'Ston' with: '0.13'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.17';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.17'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 6/7/2015 02:59'!version117: spec	<version: '1.17' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.17 - configuration compatible with GemStone'.		spec author: 'CyrilFerlicot'.		spec timestamp: '06/07/2015 02:57'.		spec project: 'Ston' with: '0.14'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.17';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.17'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'GuillermoPolito 6/8/2015 14:40'!version118: spec	<version: '1.18' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.18 - properties are looked up in parent configurations'.		spec author: 'GuillermoPolito'.		spec timestamp: '2015-06-08T14:38:28.791798+02:00'.		spec project: 'Ston' with: '0.14'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-GuillermoPolito.18';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.17'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'GuillermoPolito 6/8/2015 16:17'!version119: spec	<version: '1.19' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.19 - allProperties gets all properties flattened'.		spec author: 'GuillermoPolito'.		spec timestamp: '2015-06-08T16:14:14.337825+02:00'.		spec project: 'Ston' with: '0.14'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-GuillermoPolito.19';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.17'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'StephaneDucasse 3/31/2015 10:32'!version11: spec	<version: '1.1' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.1'.		spec author: 'StephaneDucasse'.		spec timestamp: '3/31/2015 10:32'.		spec project: 'Ston' with: '0.10'.		spec package: 'Cocoon-Core' with: 'Cocoon-Core-StephaneDucasse.3'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 6/29/2015 16:14'!version120: spec	<version: '1.20' imports: #('0.4-baseline')>	spec		for: #common		do: [ 			spec blessing: #stable.			spec description: 'version 1.20'.			spec author: 'CyrilFerlicot'.			spec timestamp: '6/29/2015 15:38'.			spec				project: 'Ston' with: '0.14';				project: 'Magritte3' with: '3.3.2'.			spec				package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.32';				package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.28' ]! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 7/10/2015 17:53'!version121: spec	<version: '1.21' imports: #('0.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.21'.		spec author: 'CyrilFerlicot'.		spec timestamp: '7/10/2015 17:26'.		spec 			project: 'Ston' with: '0.14';			project: 'Magritte3' with: '3.3.2'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.34';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.28'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 7/29/2015 14:55'!version122: spec	<version: '1.22' imports: #('0.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.22'.		spec author: 'CyrilFerlicot'.		spec timestamp: '7/29/2015 14:55'.		spec 			project: 'Ston' with: '0.14';			project: 'Magritte3' with: '3.3.2'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.35';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.28'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 7/30/2015 13:21'!version123: spec	<version: '1.23' imports: #('0.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.23'.		spec author: 'CyrilFerlicot'.		spec timestamp: '7/30/2015 13:21'.		spec 			project: 'Ston' with: '0.14';			project: 'Magritte3' with: '3.3.2'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.37';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.28'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 7/31/2015 15:38'!version124: spec	<version: '1.24' imports: #('0.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.24'.		spec author: 'CyrilFerlicot'.		spec timestamp: '7/31/2015 15:38'.		spec 			project: 'Ston' with: '0.14';			project: 'Magritte3' with: '3.3.2'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.39';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.28'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 8/17/2015 10:53'!version125: spec	<version: '1.25' imports: #('0.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.25'.		spec author: 'CyrilFerlicot'.		spec timestamp: '8/17/2015 10:19'.		spec 			project: 'Ston' with: '0.14';			project: 'Magritte3' with: '3.4.2'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.44';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.30'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 8/18/2015 16:36'!version126: spec	<version: '1.26' imports: #('0.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.26'.		spec author: 'CyrilFerlicot'.		spec timestamp: '8/18/2015 16:36'.		spec 			project: 'Ston' with: '0.14';			project: 'Magritte3' with: '3.4.2'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.46';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.30'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 8/19/2015 23:41'!version127: spec	<version: '1.27' imports: #('0.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.27'.		spec author: 'CyrilFerlicot'.		spec timestamp: '8/19/2015 23:41'.		spec 			project: 'Ston' with: '0.14';			project: 'Magritte3' with: '3.4.2'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.48';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.30'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'DamienCassou 8/28/2015 13:26'!version128: spec	<version: '1.28' imports: #('0.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.28'.		spec author: 'DamienCassou'.		spec timestamp: '8/28/2015 13:26'.		spec 			project: 'Ston' with: '0.14';			project: 'Magritte3' with: '3.5.0'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-DamienCassou.49';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-DamienCassou.34'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'StephanEggermont 1/18/2016 16:00'!version129: spec	<version: '1.29' imports: #('0.4-baseline' )>	"Dependencies fix"	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.29'.		spec author: 'StephanEggermont'.		spec timestamp: '1/18/2016 16:00'.		spec 			project: 'Ston' with: #stable;			project: 'Magritte3' with: #'release3.1'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-DamienCassou.49';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-DamienCassou.34'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 3/31/2015 16:52'!version12: spec	<version: '1.2' imports: #('0.2-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.2'.		spec author: 'CyrilFerlicot'.		spec timestamp: '3/31/2015 16:52'.		spec project: 'Ston' with: '0.10'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.5';			package: #'Cocoon-Test-Core' with: 'Cocoon-Test-Core-CyrilFerlicot.1'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 1/24/2016 19:29'!version130: spec	<version: '1.30' imports: #('0.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.30 - Configuration should have a name.'.		spec author: 'CyrilFerlicot'.		spec timestamp: '1/24/2016 19:00'.		spec 			project: 'Ston' with: #stable;			project: 'Magritte3' with: #stable.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.54';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.36'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'ThibaultArloing 4/20/2016 16:55'!version131: spec	<version: '1.31' imports: #('0.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.31'.		spec author: 'ThibaultArloing'.		spec timestamp: '4/20/2016 16:55'.		spec 			project: 'Ston' with: '0.18';			project: 'Magritte3' with: '3.5.0'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-DamienCassou.55';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.36'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 3/31/2015 17:59'!version13: spec	<version: '1.3' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.3'.		spec author: 'CyrilFerlicot'.		spec timestamp: '3/31/2015 17:59'.		spec project: 'Ston' with: '0.10'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.5';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.2'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 3/31/2015 18:11'!version14: spec	<version: '1.4' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.4'.		spec author: 'CyrilFerlicot'.		spec timestamp: '3/31/2015 18:11'.		spec project: 'Ston' with: '0.10'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.5';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.3'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 4/1/2015 11:14'!version15: spec	<version: '1.5' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.5'.		spec author: 'CyrilFerlicot'.		spec timestamp: '4/1/2015 11:14'.		spec project: 'Ston' with: '0.10'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.6';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.4'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 4/1/2015 17:38'!version16: spec	<version: '1.6' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.6'.		spec author: 'CyrilFerlicot'.		spec timestamp: '4/1/2015 17:38'.		spec project: 'Ston' with: '0.10'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.8';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.7'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 4/1/2015 17:54'!version17: spec	<version: '1.7' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.7'.		spec author: 'CyrilFerlicot'.		spec timestamp: '4/1/2015 17:54'.		spec project: 'Ston' with: '0.10'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.8';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.8'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 4/2/2015 10:29'!version18: spec	<version: '1.8' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.8'.		spec author: 'CyrilFerlicot'.		spec timestamp: '4/2/2015 10:29'.		spec project: 'Ston' with: '0.10'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.8';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.8'. ].! !!ConfigurationOfCocoon methodsFor: 'versions' stamp: 'CyrilFerlicot 4/2/2015 17:00'!version19: spec	<version: '1.9' imports: #('0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.9'.		spec author: 'CyrilFerlicot'.		spec timestamp: '4/2/2015 17:00'.		spec project: 'Ston' with: '0.10'.		spec 			package: 'Cocoon-Core' with: 'Cocoon-Core-CyrilFerlicot.9';			package: #'Cocoon-Tests-Core' with: 'Cocoon-Tests-Core-CyrilFerlicot.9'. ].! !"ConfigurationOfCocoon"!!ConfigurationOfPetitParser commentStamp: '<historical>' prior: 0!self loadDevelopment!!ConfigurationOfPetitParser class methodsFor: 'catalog' stamp: 'TudorGirba 1/5/2016 16:06'!catalogContactInfo	^ 'info@moosetechnology.org'! !!ConfigurationOfPetitParser class methodsFor: 'catalog' stamp: 'TudorGirba 1/5/2016 16:06'!catalogDescription	^ 'PetitParser is a parsing engine. It models grammars and parsers dynamically as objects based on a mechanism inspired from scannnerless parsing, parser combinators, parsing expression grammars and packrat parsers.'! !!ConfigurationOfPetitParser class methodsFor: 'catalog' stamp: 'TudorGirba 1/5/2016 15:23'!catalogKeywords	^ #(parser)	! !!ConfigurationOfPetitParser class methodsFor: 'private' stamp: 'FabrizioPerin 4/27/2010 15:04'!ensureMetacello	Smalltalk at: #MetacelloProject ifAbsent: [		Gofer new				url: 'http://seaside.gemstone.com/ss/metacello';				package: 'ConfigurationOfMetacello';				load.		(Smalltalk at: #ConfigurationOfMetacello) loadLatestVersion ]! !!ConfigurationOfPetitParser class methodsFor: 'metacello tool support' stamp: 'tg 4/18/2010 23:51'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfPetitParser class methodsFor: 'loading' stamp: 'JanKurs 4/4/2015 11:47'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfPetitParser class methodsFor: 'loading' stamp: 'TudorGirba 4/21/2013 23:27'!loadDevelopment	(self project version: #development) load! !!ConfigurationOfPetitParser class methodsFor: 'loading' stamp: 'JanKurs 4/1/2015 11:57'!loadPetitParser		(self project version: #development) load: 'Parser'! !!ConfigurationOfPetitParser class methodsFor: 'loading' stamp: 'JanKurs 4/1/2015 11:57'!loadPetitParserIDE		(self project version: #development) load: 'ParserIDE'! !!ConfigurationOfPetitParser class methodsFor: 'loading' stamp: 'JanKurs 4/1/2015 11:17'!loadStable	(self project version: #stable) load! !!ConfigurationOfPetitParser class methodsFor: 'accessing' stamp: 'tg 4/18/2010 23:51'!project	^self new project! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'AlexandreBergel 12/3/2010 09:14'!baseline10: spec 	<version: '1.0-baseline'>		spec for: #common do: [		spec blessing: #baseline.		spec author: 'Alexandre Bergel'.		spec description: 'work on Pharo 1.1.1'.		spec repository: 'http://source.lukas-renggli.ch/petit'.		spec 			package: 'PetitParser';			package: 'PetitTests' with: [ spec requires: 'PetitParser'];			package: 'PetitAnalyzer' with: [ spec requires: 'PetitTests'];			package: 'PetitGui' with: [ spec requires: 'Glamour for Petit'].		spec group: 'Core' with: #( 'PetitParser' 'PetitAnalyzer' ).		spec group: 'Tests' with: #( 'PetitTests' 'PetitAnalyzer' ).		spec project: 'Glamour for Petit' with: [				spec					className: 'ConfigurationOfGlamour';					file: 'ConfigurationOfGlamour';					version: '2.0-beta.8';					repository: 'http://www.squeaksource.com/Glamour' ].	]! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'AlexandreBergel 2/18/2011 13:56'!baseline11: spec	<version: '1.1-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'Preparing Moose 4.3.2'.		spec repository: 'http://source.lukas-renggli.ch/petit'.		spec project: 'Glamour for Petit' with: [				spec					className: 'ConfigurationOfGlamour';					versionString: '2.1';					repository: 'http://www.squeaksource.com/Glamour' ].		spec 			package: 'PetitParser';			package: 'PetitTests' with: [				spec requires: #('PetitParser' ). ];			package: 'PetitAnalyzer' with: [				spec requires: #('PetitTests' ). ];			package: 'PetitGui' with: [				spec requires: #('Glamour for Petit' ). ].		spec 			group: 'Core' with: #('PetitParser' 'PetitAnalyzer' );			group: 'Tests' with: #('PetitTests' 'PetitAnalyzer' ). ].! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'DiegoLont 9/2/2013 11:15'!baseline12: spec	<version: '1.2-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'Describing satellite packages'.		spec repository: 'http://source.lukas-renggli.ch/petit'.		spec project: 'Glamour for Petit' with: [			spec				className: 'ConfigurationOfGlamour';				versionString: '2.1';				repository: 'http://www.squeaksource.com/Glamour' ].				spec project: 'AST-Core' with: [			spec				repository: 'http://www.squeaksource.com/MetacelloRepository';				className: 'ConfigurationOfRefactoringBrowser';				loads: #('AST-Core') ].				spec 			package: 'PetitParser';			package: 'PetitTests' with: [				spec requires: #('PetitParser' ) ];			package: 'PetitAnalyzer' with: [				spec requires: #('PetitTests' ) ];			package: 'PetitGui' with: [				spec requires: #('Glamour for Petit' ) ];			package: 'PetitSmalltalk' with: [				spec requires: #( 'AST-Core' 'PetitParser' 'PetitTests') ].			"todo: declare all other packages & dependencies here"		spec 			group: 'Core' with: #('PetitParser' 'PetitAnalyzer' );			group: 'Tests' with: #('PetitTests' 'PetitAnalyzer' ) ]! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'DiegoLont 9/2/2013 11:16'!baseline13: spec	<version: '1.3-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'Describing all satellite packages'.		spec repository: 'http://source.lukas-renggli.ch/petit'.		spec project: 'Glamour for Petit' with: [			spec				className: 'ConfigurationOfGlamour';				versionString: '2.1';				loads: #(Core Morphic);				repository: 'http://www.squeaksource.com/Glamour' ].				spec 			package: 'PetitParser';			package: 'PetitTests' with: [				spec requires: #('PetitParser' ). ];			package: 'PetitAnalyzer' with: [				spec requires: #('PetitTests' ). ];			package: 'PetitGui' with: [				spec requires: #('PetitParser' 'Glamour for Petit' ). ].				spec			package: 'PrettyPetit'.				spec			package: 'PetitSmalltalk' with: [				spec requires: #( 'PetitParser' 'PetitTests') ];			package: 'PetitCSV' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitJson' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitMSE' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitManifestMf' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitRegex' with: [				spec requires: #('PetitParser') ];			package: 'PetitSQL' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitXPath' with: [				spec requires: #('PetitParser' 'PetitXml') ];			package: 'PetitXml' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'Factorial-Language' with: [				spec requires: #('PetitParser') ].		spec 			group: 'Core' with: #('PetitParser' 'PetitAnalyzer' );			group: 'Tests' with: #('PetitTests' 'PetitAnalyzer' ). ].! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'StephanEggermont 3/16/2015 09:04'!baseline151: spec 	<version: '1.5.1-baseline'>		spec for: #common do: [		spec blessing: #baseline.		spec description: 'petitparser project description that loads the version before the changes regarding integration of the island grammar and context by Jan Kurs'.		spec repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main'.		spec 			package: 'PetitParser';			package: 'PetitTests' with: [ spec requires: 'PetitParser'];			package: 'PetitAnalyzer' with: [ spec requires: 'PetitTests'];			package: 'PetitSmalltalk' with: [				spec requires: #( 'PetitParser' 'PetitTests') ];			package: 'PetitCSV' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitJson' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitMSE' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitManifestMf' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitRegex' with: [				spec requires: #('PetitParser') ];			package: 'PetitXPath' with: [				spec requires: #('PetitParser' 'PetitXml') ];			package: 'PetitXml' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'Factorial-Language' with: [				spec requires: #('PetitParser') ].		spec group: 'Core' with: #( 'PetitParser' 'PetitAnalyzer' ).		spec group: 'Tests' with: #( 'PetitTests' 'PetitAnalyzer' ) ].	spec for: #( 'squeakCommon' )  do: [		spec project: 'Glamour' with: [			spec				className: 'ConfigurationOfGlamour';				file: 'ConfigurationOfGlamour';				version: #development;				loads: #('GlamourCore');				repository: 'http://www.smalltalkhub.com/mc/Moose/Glamour/main' ].		spec 			package: 'PetitGui' with: [ spec requires: #('Glamour' 'PetitAnalyzer')].		spec group: 'Gui' with: #( 'PetitGui' ) ]! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'DiegoLont 9/2/2013 11:16'!baseline15: spec	<version: '1.5-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'Describing all satellite packages'.		spec repository: 'http://source.lukas-renggli.ch/petit'.		spec project: 'Glamour for Petit' with: [			spec				className: 'ConfigurationOfGlamour';				versionString: #stable;				loads: #(Core Morphic);				repository: 'http://www.squeaksource.com/Glamour' ].				spec 			package: 'PetitParser';			package: 'PetitTests' with: [				spec requires: #('PetitParser' ). ];			package: 'PetitAnalyzer' with: [				spec requires: #('PetitTests' ). ];			package: 'PetitGui' with: [				spec requires: #('PetitParser' 'Glamour for Petit' ). ].				spec			package: 'PrettyPetit'.				spec			package: 'PetitSmalltalk' with: [				spec requires: #( 'PetitParser' 'PetitTests') ];			package: 'PetitCSV' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitJson' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitMSE' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitManifestMf' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitRegex' with: [				spec requires: #('PetitParser') ];			package: 'PetitXPath' with: [				spec requires: #('PetitParser' 'PetitXml') ];			package: 'PetitXml' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'Factorial-Language' with: [				spec requires: #('PetitParser') ].		spec 			group: 'default' with: #('UI' 'Tests');			group: 'Core' with: #('PetitParser' 'PetitAnalyzer' );			group: 'UI' with: #('Core' 'PetitGui' );			group: 'Tests' with: #('Core' 'PetitTests'). ].! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'JanKurs 11/12/2014 15:54'!baseline16: spec 	<version: '1.6-baseline'>		spec for: #common do: [		spec blessing: #baseline.		spec description: 'Describing all satellite packages. Loads configuration from new repository on SmalltalkHub'.		spec repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main'.		spec 			package: 'PetitParser';			package: 'PetitTests' with: [ spec requires: 'PetitParser'];			package: 'PetitAnalyzer' with: [ spec requires: 'PetitTests'];			package: 'PetitSmalltalk' with: [				spec requires: #( 'PetitParser' 'PetitTests') ];			package: 'PetitCSV' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitJson' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitMSE' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitManifestMf' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitRegex' with: [				spec requires: #('PetitParser') ];			package: 'PetitXPath' with: [				spec requires: #('PetitParser' 'PetitXml') ];			package: 'PetitXml' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitIslands' with: [				spec requires: #('PetitParser') ];			package: 'PetitIndent' with: [				spec requires: #('PetitParser') ];			package: 'Factorial-Language' with: [				spec requires: #('PetitParser') ].		spec group: 'Core' with: #( 'PetitParser').		spec group: 'Tests' with: #( 'PetitTests') ].	spec for: #( 'squeakCommon' )  do: [		spec project: 'Glamour' with: [			spec				className: 'ConfigurationOfGlamour';				file: 'ConfigurationOfGlamour';				version: #development;				repository: 'http://www.smalltalkhub.com/mc/Moose/Glamour/main' ].		spec 			package: 'PetitGui' with: [ spec requires: #('Glamour' 'PetitAnalyzer')].		spec group: 'Gui' with: #( 'PetitGui' ) ]! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'JanKurs 4/1/2015 12:19'!baseline17: spec 	<version: '1.7-baseline'>		spec for: #common do: [		spec blessing: #'development'.		spec description: 'Describing all satellite packages. Loads configuration from new repository on SmalltalkHub'.		spec repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main'.		spec 			package: 'PetitParser';			package: 'PetitTests' with: [ spec requires: 'PetitParser'];			package: 'PetitAnalyzer' with: [ spec requires: 'PetitTests'];			package: 'PetitSmalltalk' with: [				spec requires: #( 'PetitParser' 'PetitTests') ];			package: 'PetitCSV' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitJson' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitMSE' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitManifestMf' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitRegex' with: [				spec requires: #('PetitParser') ];			package: 'PetitXPath' with: [				spec requires: #('PetitParser' 'PetitXml') ];			package: 'PetitXml' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitIndent' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitIslands' with: [				spec requires: #('PetitParser' 'PetitIndent' 'PetitTests') ];			package: 'Factorial-Language' with: [				spec requires: #('PetitParser') ];			package: 'PetitYAML' with: [				spec requires: #('PetitParser' 'PetitIndent') ].		spec group: 'Core' with: #( 'PetitParser').		spec group: 'Tests' with: #( 'PetitTests').		spec group: 'Parser' with: #('PetitParser' 													'PetitTests' 													'PetitAnalyzer' 													'PetitSmalltalk' 													'PetitCSV' 													'PetitJson' 													'PetitMSE'													'PetitManifestMf' 													'PetitRegex'													'PetitXPath'													'PetitXml'													'PetitIndent'													'PetitIslands'													'Factorial-Language'													'PetitYAML').	].	spec for: #( 'squeakCommon' )  do: [		spec project: 'Glamour' with: [			spec				className: 'ConfigurationOfGlamour';				file: 'ConfigurationOfGlamour';				version: #stable;				repository: 'http://www.smalltalkhub.com/mc/Moose/Glamour/main' ].		spec 			package: 'PetitGui' with: [ spec requires: #('Glamour' 'PetitAnalyzer')].				spec group: 'ParserIDE' with: #( 'PetitGui' ) ] ! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'AndreiChis 10/5/2015 11:59'!baseline18: spec 	<version: '1.8-baseline'>		spec for: #common do: [		spec blessing: #'development'.		spec description: 'For Pharo 5. Use #development for Glamour'.		spec repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main'.		spec 			package: 'PetitParser';			package: 'PetitTests' with: [ spec requires: 'PetitParser'];			package: 'PetitAnalyzer' with: [ spec requires: 'PetitTests'];			package: 'PetitSmalltalk' with: [				spec requires: #( 'PetitParser' 'PetitTests') ];			package: 'PetitCSV' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitJson' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitMSE' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitManifestMf' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitRegex' with: [				spec requires: #('PetitParser') ];			package: 'PetitXPath' with: [				spec requires: #('PetitParser' 'PetitXml') ];			package: 'PetitXml' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitIndent' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitIslands' with: [				spec requires: #('PetitParser' 'PetitIndent' 'PetitTests') ];			package: 'Factorial-Language' with: [				spec requires: #('PetitParser') ];			package: 'PetitYAML' with: [				spec requires: #('PetitParser' 'PetitIndent') ].		spec group: 'Core' with: #( 'PetitParser').		spec group: 'Tests' with: #( 'PetitTests').		spec group: 'Parser' with: #('PetitParser' 													'PetitTests' 													'PetitAnalyzer' 													'PetitSmalltalk' 													'PetitCSV' 													'PetitJson' 													'PetitMSE'													'PetitManifestMf' 													'PetitRegex'													'PetitXPath'													'PetitXml'													'PetitIndent'													'PetitIslands'													'Factorial-Language'													'PetitYAML').	].	spec for: #( 'squeakCommon' )  do: [		spec project: 'Glamour' with: [			spec				className: 'ConfigurationOfGlamour';				file: 'ConfigurationOfGlamour';				version: #development;				repository: 'http://www.smalltalkhub.com/mc/Moose/Glamour/main' ].		spec 			package: 'PetitGui' with: [ spec requires: #('Glamour' 'PetitAnalyzer')].				spec group: 'ParserIDE' with: #( 'PetitGui' ) ] ! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'TudorGirba 8/16/2016 08:32'!baseline19: spec 	<version: '1.9-baseline'>		spec for: #common do: [		spec blessing: #'development'.		spec description: 'For Pharo 6. Use #development for Glamour'.		spec repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main'.		spec 			package: 'PetitParser';			package: 'PetitTests' with: [ spec requires: 'PetitParser'];			package: 'PetitAnalyzer' with: [ spec requires: 'PetitTests'];			package: 'PetitSmalltalk' with: [				spec requires: #( 'PetitParser' 'PetitTests') ];			package: 'PetitCSV' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitJson' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitMSE' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitManifestMf' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitRegex' with: [				spec requires: #('PetitParser') ];			package: 'PetitXPath' with: [				spec requires: #('PetitParser' 'PetitXml') ];			package: 'PetitXml' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitIndent' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitIslands' with: [				spec requires: #('PetitParser' 'PetitIndent' 'PetitTests') ];			package: 'Factorial-Language' with: [				spec requires: #('PetitParser') ];			package: 'PetitYAML' with: [				spec requires: #('PetitParser' 'PetitIndent') ].		spec group: 'Core' with: #( 'PetitParser').		spec group: 'Tests' with: #( 'PetitTests').		spec group: 'Parser' with: #('PetitParser' 													'PetitTests' 													'PetitAnalyzer' 													'PetitSmalltalk' 													'PetitCSV' 													'PetitJson' 													'PetitMSE'													'PetitManifestMf' 													'PetitRegex'													'PetitXPath'													'PetitXml'													'PetitIndent'													'PetitIslands'													'Factorial-Language'													'PetitYAML').	].	spec for: #( 'squeakCommon' )  do: [		spec project: 'Glamour' with: [			spec				className: 'ConfigurationOfGlamour';				file: 'ConfigurationOfGlamour';				version: #development;				repository: 'http://www.smalltalkhub.com/mc/Moose/Glamour/main' ].		spec 			package: 'PetitGui' with: [ spec requires: #('Glamour' 'PetitAnalyzer')].				spec group: 'ParserIDE' with: #( 'PetitGui' ) ] ! !!ConfigurationOfPetitParser methodsFor: 'symbolic versions' stamp: 'TudorGirba 8/16/2016 08:50'!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: '1.8-baseline'.	spec for: #'pharo1.4.x' version: '1.6-baseline'.	spec for: #'pharo2.x' version: '1.6-baseline'.	spec for: #'pharo3.x' version: '1.6-baseline'.	spec for: #'pharo4.x' version: '1.7-baseline'.	spec for: #'pharo5.x' version: #'stable'.	spec for: #'pharo6.x' version: '1.9-baseline'.! !!ConfigurationOfPetitParser methodsFor: 'accessing' stamp: 'tg 4/18/2010 23:50'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		self class ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project]! !!ConfigurationOfPetitParser methodsFor: 'symbolic versions' stamp: 'TudorGirba 9/13/2016 21:56'!stable: spec	<symbolicVersion: #'stable'>	spec for: #'common' version: '2.0'.	spec for: #'pharo1.3.x' version: '1.5'.	spec for: #'pharo2.x' version: '1.6-baseline'.	spec for: #'pharo3.x' version: '1.10'.	spec for: #'pharo4.x' version: '1.14'.	spec for: #'pharo5.x' version: '2.0'.! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'AlexandreBergel 12/10/2010 18:51'!version10: spec	<version: '1.0' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'First release'.		spec author: 'AlexandreBergel'.		spec timestamp: '12/6/2010 16:11'.		spec project: 'Glamour for Petit' with: '2.0-beta.8'.		spec 			package: 'PetitParser' with: 'PetitParser-lr.208';			package: 'PetitTests' with: 'PetitTests-TudorGirba.24';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-lr.31';			package: 'PetitGui' with: 'PetitGui-TudorGirba.58'.].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'TudorGirba 12/23/2014 14:30'!version110: spec	<version: '1.10' imports: #('1.6-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.10'.		spec author: 'TudorGirba'.		spec timestamp: '12/23/2014 14:30'.		spec 			package: 'PetitParser' with: 'PetitParser-JanKurs.262';			package: 'PetitTests' with: 'PetitTests-JanKurs.67';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-JanKurs.48';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-JanKurs.78';			package: 'PetitCSV' with: 'PetitCSV-tg.7';			package: 'PetitJson' with: 'PetitJson-JanKurs.9';			package: 'PetitMSE' with: 'PetitMSE-AndreHora.21';			package: 'PetitManifestMf' with: 'PetitManifestMf-JanKurs.10';			package: 'PetitRegex' with: 'PetitRegex-StephanEggermont.30';			package: 'PetitXPath' with: 'PetitXPath-EstebanLorenzano.7';			package: 'PetitXml' with: 'PetitXml-JanKurs.36';			package: 'PetitIslands' with: 'PetitIslands-JanKurs.18';			package: 'PetitIndent' with: 'PetitIndent-JanKurs.1';			package: 'Factorial-Language' with: 'Factorial-Language-lr.6'. ].	spec for: #'squeakCommon' do: [		spec project: 'Glamour' with: #stable.		spec package: 'PetitGui' with: 'PetitGui-JanKurs.148'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'AndreiChis 4/1/2015 14:52'!version111: spec	<version: '1.11' imports: #('1.6-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.11'.		spec author: 'JanKurs'.		spec timestamp: '4/1/2015 11:27'.		spec 			package: 'PetitParser' with: 'PetitParser-JamesFoster.274';			package: 'PetitTests' with: 'PetitTests-JanKurs.73';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-JanKurs.48';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-BernardoContreras.86';			package: 'PetitCSV' with: 'PetitCSV-tg.7';			package: 'PetitJson' with: 'PetitJson-JanKurs.9';			package: 'PetitMSE' with: 'PetitMSE-AndreHora.21';			package: 'PetitManifestMf' with: 'PetitManifestMf-JanKurs.10';			package: 'PetitRegex' with: 'PetitRegex-StephanEggermont.30';			package: 'PetitXPath' with: 'PetitXPath-EstebanLorenzano.7';			package: 'PetitXml' with: 'PetitXml-JanKurs.36';			package: 'PetitIslands' with: 'PetitIslands-JanKurs.22';			package: 'PetitIndent' with: 'PetitIndent-JanKurs.7';			package: 'Factorial-Language' with: 'Factorial-Language-lr.6'. ].	spec for: #'squeakCommon' do: [		spec project: 'Glamour' with: #'development'.		spec package: 'PetitGui' with: 'PetitGui-StefanReichhart.150'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'AndreiChis 5/5/2015 19:07'!version112: spec	<version: '1.12' imports: #('1.6-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.12'.		spec author: 'AndreiChis'.		spec timestamp: '5/5/2015 19:03'.		spec 			package: 'PetitParser' with: 'PetitParser-JanKurs.278';			package: 'PetitTests' with: 'PetitTests-JanKurs.73';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-JanKurs.48';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-BernardoContreras.86';			package: 'PetitCSV' with: 'PetitCSV-tg.7';			package: 'PetitJson' with: 'PetitJson-JanKurs.9';			package: 'PetitMSE' with: 'PetitMSE-AndreHora.21';			package: 'PetitManifestMf' with: 'PetitManifestMf-JanKurs.10';			package: 'PetitRegex' with: 'PetitRegex-JanKurs.31';			package: 'PetitXPath' with: 'PetitXPath-EstebanLorenzano.7';			package: 'PetitXml' with: 'PetitXml-JanKurs.36';			package: 'PetitIslands' with: 'PetitIslands-JanKurs.28';			package: 'PetitIndent' with: 'PetitIndent-JanKurs.11';			package: 'Factorial-Language' with: 'Factorial-Language-lr.6'. ].	spec for: #'squeakCommon' do: [		spec project: 'Glamour' with: #'stable'.		spec package: 'PetitGui' with: 'PetitGui-StefanReichhart.150'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'AndreiChis 5/27/2015 16:42'!version113: spec	<version: '1.13' imports: #('1.7-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.13'.		spec author: 'AndreiChis'.		spec timestamp: '5/27/2015 16:41'.		spec 			package: 'PetitParser' with: 'PetitParser-JanKurs.278';			package: 'PetitTests' with: 'PetitTests-JanKurs.73';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-JanKurs.48';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-BernardoContreras.86';			package: 'PetitCSV' with: 'PetitCSV-tg.7';			package: 'PetitJson' with: 'PetitJson-JanKurs.9';			package: 'PetitMSE' with: 'PetitMSE-AndreHora.21';			package: 'PetitManifestMf' with: 'PetitManifestMf-JanKurs.10';			package: 'PetitRegex' with: 'PetitRegex-JanKurs.31';			package: 'PetitXPath' with: 'PetitXPath-EstebanLorenzano.7';			package: 'PetitXml' with: 'PetitXml-JanKurs.36';			package: 'PetitIslands' with: 'PetitIslands-JanKurs.28';			package: 'PetitIndent' with: 'PetitIndent-JanKurs.11';			package: 'Factorial-Language' with: 'Factorial-Language-lr.6';			package: 'PetitYAML' with: 'PetitYAML-JanKurs.6'.].	spec for: #'squeakCommon' do: [		spec project: 'Glamour' with: #'stable'.		spec package: 'PetitGui' with: 'PetitGui-StefanReichhart.150'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'JanKurs 1/10/2016 17:17'!version114: spec	<version: '1.14' imports: #('1.7-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.13'.		spec author: 'JanKurs'.		spec timestamp: '20/10/2015 10:41'.		spec 			package: 'PetitParser' with: 'PetitParser-JanKurs.278';			package: 'PetitTests' with: 'PetitTests-JanKurs.73';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-JanKurs.48';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-BernardoContreras.86';			package: 'PetitCSV' with: 'PetitCSV-tg.7';			package: 'PetitJson' with: 'PetitJson-JanKurs.9';			package: 'PetitMSE' with: 'PetitMSE-AndreHora.21';			package: 'PetitManifestMf' with: 'PetitManifestMf-JanKurs.10';			package: 'PetitRegex' with: 'PetitRegex-JanKurs.32';			package: 'PetitXPath' with: 'PetitXPath-EstebanLorenzano.7';			package: 'PetitXml' with: 'PetitXml-JanKurs.36';			package: 'PetitIslands' with: 'PetitIslands-JanKurs.32';			package: 'PetitIndent' with: 'PetitIndent-JanKurs.11';			package: 'Factorial-Language' with: 'Factorial-Language-lr.6';			package: 'PetitYAML' with: 'PetitYAML-JanKurs.6'.].	spec for: #'squeakCommon' do: [		spec project: 'Glamour' with: #'stable'.		spec package: 'PetitGui' with: 'PetitGui-StefanReichhart.150'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'AlexandreBergel 5/16/2011 16:23'!version11: spec	<version: '1.1' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: 'New version'.		spec author: 'AlexandreBergel'.		spec timestamp: '2/18/2011 13:30'.		spec project: 'Glamour for Petit' with: '2.1'.		spec 			package: 'PetitParser' with: 'PetitParser-lr.216';			package: 'PetitTests' with: 'PetitTests-lr.32';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-lr.37';			package: 'PetitGui' with: 'PetitGui-TudorGirba.65'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'AlexandreBergel 5/16/2011 16:23'!version12: spec	<version: '1.2' imports: #('1.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: 'New version'.		spec author: 'AlexandreBergel'.		spec timestamp: '2/18/2011 13:56'.		spec project: 'Glamour for Petit' with: '2.1'.		spec 			package: 'PetitParser' with: 'PetitParser-lr.216';			package: 'PetitTests' with: 'PetitTests-lr.32';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-lr.37';			package: 'PetitGui' with: 'PetitGui-TudorGirba.65'.  ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'AlexandreBergel 5/16/2011 16:23'!version13: spec	<version: '1.3' imports: #('1.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: ''.		spec author: 'AlexandreBergel'.		spec timestamp: '5/16/2011 16:23'.		spec project: 'Glamour for Petit' with: '2.1'.		spec 			package: 'PetitParser' with: 'PetitParser-lr.216';			package: 'PetitTests' with: 'PetitTests-lr.32';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-lr.37';			package: 'PetitGui' with: 'PetitGui-TudorGirba.65'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'DamienPollet 8/11/2011 19:21'!version14: spec	<version: '1.4' imports: #('1.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: ''.		spec author: 'DamienPollet'.		spec timestamp: '8/11/2011 14:00'.		spec project: 'Glamour for Petit' with: '2.1'.		spec 			package: 'PetitParser' with: 'PetitParser-lr.218';			package: 'PetitTests' with: 'PetitTests-DamienPollet.35';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-lr.39';			package: 'PetitGui' with: 'PetitGui-TudorGirba.65';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-lr.47'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'StephanEggermont 3/16/2015 09:04'!version151: spec	<version: '1.5.1' imports: #('1.5.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'releasing a version for petit parser before changes regarding integration of the parsing context and island grammar by Jan Kurs for backward compatibility'.		spec author: 'usmanbhatti'.		spec timestamp: '26/9/2014 18:27'.		spec project: 'Glamour' with: '3.0.7'.		spec 			package: 'PetitParser' with: 'PetitParser-DiegoLont.233';			package: 'PetitTests' with: 'PetitTests-AndreHora.47';			package: 'PetitXml' with: 'PetitXml-lr.35';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-DiegoLont.46';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-DamienCassou.70';			package: 'PetitRegex' with: 'PetitRegex-lr.27';			package: 'PetitGui' with: 'PetitGui-AndreiChis.140'].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'TudorGirba 3/4/2012 20:22'!version15: spec	<version: '1.5' imports: #('1.5-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: ''.		spec author: 'DamienPollet'.		spec timestamp: '8/11/2011 14:00'.		spec project: 'Glamour for Petit' with: '2.2'.		spec 			package: 'PetitParser' with: 'PetitParser-lr.228';			package: 'PetitTests' with: 'PetitTests-lr.43';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-lr.39';			package: 'PetitGui' with: 'PetitGui-TudorGirba.90';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-lr.57'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'AndreiChis 10/29/2014 17:57'!version16: spec	<version: '1.6' imports: #('1.6-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'releasing a version of petitparser for moose 4.7 release'.		spec author: 'usmanbhatti'.		spec timestamp: '3/1/2013 18:01'.		spec project: 'Glamour' with: '2.4'.		spec 			package: 'PetitParser' with: 'PetitParser-YuriyTymchuk.232';			package: 'PetitTests' with: 'PetitTests-AndreHora.47';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-DiegoLont.46';			package: 'PetitGui' with: 'PetitGui-DiegoLont.125'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'TudorGirba 12/23/2014 14:29'!version19: spec	<version: '1.9' imports: #('1.6-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'releasing a version of petitparser for moose 5 release'.		spec author: 'StephanEggermont'.		spec timestamp: '12/12/2014 11:28'.		spec project: 'Glamour' with: #stable.		spec 			package: 'PetitParser' with: 'PetitParser-JanKurs.261';			package: 'PetitTests' with: 'PetitTests-JanKurs.65';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-JanKurs.48';			package: 'PetitGui' with: 'PetitGui-TudorGirba.147';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-JanKurs.78';			package: 'PetitCSV' with: 'PetitCSV-tg.7';			package: 'PetitJson' with: 'PetitJson-JanKurs.9';			package: 'PetitMSE' with: 'PetitMSE-AndreHora.21';			package: 'PetitManifestMf' with: 'PetitManifestMf-JanKurs.10';			package: 'PetitRegex' with: 'PetitRegex-JanKurs.30';			package: 'PetitXPath' with: 'PetitXPath-EstebanLorenzano.7';			package: 'PetitXml' with: 'PetitXml-JanKurs.36';			package: 'PetitIslands' with: 'PetitIslands-JanKurs.18';			package: 'PetitIndent' with: 'PetitIndent-JanKurs.1';			package: 'Factorial-Language' with: 'Factorial-Language-lr.6'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'TudorGirba 9/13/2016 21:58'!version20: spec	<version: '2.0' imports: #('1.8-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Moose 6.0 release'.		spec author: 'TudorGirba'.		spec timestamp: '8/14/2016 20:44'.		spec 			package: 'PetitParser' with: 'PetitParser-JanKurs.290';			package: 'PetitTests' with: 'PetitTests-JanKurs.77';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-JanKurs.49';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-TudorGirba.87';			package: 'PetitCSV' with: 'PetitCSV-tg.7';			package: 'PetitJson' with: 'PetitJson-JanKurs.9';			package: 'PetitMSE' with: 'PetitMSE-AndreHora.21';			package: 'PetitManifestMf' with: 'PetitManifestMf-JanKurs.10';			package: 'PetitRegex' with: 'PetitRegex-JanKurs.32';			package: 'PetitXPath' with: 'PetitXPath-EstebanLorenzano.7';			package: 'PetitXml' with: 'PetitXml-JanKurs.36';			package: 'PetitIndent' with: 'PetitIndent-JanKurs.25';			package: 'PetitIslands' with: 'PetitIslands-JanKurs.56';			package: 'Factorial-Language' with: 'Factorial-Language-lr.6';			package: 'PetitYAML' with: 'PetitYAML-JanKurs.8'. ].	spec for: #'squeakCommon' do: [		spec project: 'Glamour' with: #stable.		spec package: 'PetitGui' with: 'PetitGui-JanKurs.162'. ].! !"ConfigurationOfPetitParser"!!ConfigurationOfLightPhaser class methodsFor: 'development support' stamp: 'ThibaultArloing 7/5/2016 09:59'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfLightPhaser class methodsFor: 'private' stamp: 'ThibaultArloing 7/5/2016 09:59'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #'ConfigurationOf'		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #'ConfigurationOf' ifAbsent: aBlock ].! !!ConfigurationOfLightPhaser class methodsFor: 'private' stamp: 'ThibaultArloing 7/5/2016 09:59'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfLightPhaser class methodsFor: 'private' stamp: 'ThibaultArloing 7/5/2016 09:59'!ensureMetacelloBaseConfiguration  Smalltalk    at: #'ConfigurationOf'    ifAbsent: [       | repository version |      repository := MCHttpRepository        location: 'http://smalltalkhub.com/mc/dkh/metacello/main'        user: ''        password: ''.      repository        versionReaderForFileNamed: 'Metacello-Base-dkh.107'        do: [ :reader |           version := reader version.          version load.          version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfLightPhaser class methodsFor: 'metacello tool support' stamp: 'ThibaultArloing 7/5/2016 09:59'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfLightPhaser class methodsFor: 'loading' stamp: 'ThibaultArloing 7/5/2016 09:59'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfLightPhaser class methodsFor: 'loading' stamp: 'ThibaultArloing 7/5/2016 09:59'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfLightPhaser class methodsFor: 'loading' stamp: 'ThibaultArloing 7/5/2016 09:59'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfLightPhaser class methodsFor: 'accessing' stamp: 'ThibaultArloing 7/5/2016 09:59'!project	^self new project! !!ConfigurationOfLightPhaser class methodsFor: 'development support' stamp: 'ThibaultArloing 7/5/2016 09:59'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfLightPhaser methodsFor: 'baselines' stamp: 'ThibaultArloing 7/5/2016 10:18'!baseline01: spec	<version: '0.1-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/Pier/LightPhaser/main/'.		spec 			package: 'LightPhaser-Model';			package: 'LightPhaser-Tests-Model' with: [				spec requires: #('LightPhaser-Model' ). ].		spec 			group: 'all' with: #('model' 'tests' );			group: 'default' with: #('all' );			group: 'model' with: #('LightPhaser-Model' );			group: 'tests' with: #('LightPhaser-Tests-Model' ). ].! !!ConfigurationOfLightPhaser methodsFor: 'accessing' stamp: 'ThibaultArloing 7/5/2016 09:59'!customProjectAttributes    "Edit to return a collection of any custom attributes e.g. for conditional loading: Array with: #'Condition1' with: #'Condition2.	For more information see: http://code.google.com/p/metacello/wiki/CustomProjectAttrributes "    ^ #()! !!ConfigurationOfLightPhaser methodsFor: 'symbolic versions' stamp: 'ThibaultArloing 7/5/2016 09:59'!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: '0.1-baseline'.! !!ConfigurationOfLightPhaser methodsFor: 'accessing' stamp: 'ThibaultArloing 7/5/2016 09:59'!project    ^ project        ifNil: [             "Bootstrap Metacello if it is not already loaded"            self class ensureMetacello.            project := MetacelloMCProject new projectAttributes: self customProjectAttributes.	"Create the Metacello project"            (Smalltalk at: #'MetacelloVersionConstructor') on: self project: project.	"Construct the project"            project loadType: #'linear'.	"change to #atomic if desired"            project ]! !"ConfigurationOfLightPhaser"!!ConfigurationOfJSON class methodsFor: 'development support' stamp: 'StephaneDucasse 8/31/2013 14:51'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfJSON class methodsFor: 'private' stamp: 'StephaneDucasse 8/31/2013 14:51'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfJSON class methodsFor: 'catalog' stamp: 'StephaneDucasse 8/31/2013 15:01'!catalogChangeLog^ '- 2013-08-30 Version 1: moved to SmalltalkHub and first configuration.[ [ [ 	(ConfigurationOfJSON project version: ''1.0'') load] ] ]'! !!ConfigurationOfJSON class methodsFor: 'catalog' stamp: 'StephaneDucasse 8/31/2013 14:57'!catalogDescription	^ 'JSON is an implementation of the JSON syntax. This package was the first implemented. Now NeoJSON proposes another approach covered by tests. JSON was originally hosted on http://www.squeaksource.com/JSON. If you want to maintain this package just ask in the Pharo mailing-list.'! !!ConfigurationOfJSON class methodsFor: 'catalog' stamp: 'StephaneDucasse 8/31/2013 14:58'!catalogKeywords	^ #(JSON object-format text web)! !!ConfigurationOfJSON class methodsFor: 'private' stamp: 'StephaneDucasse 8/31/2013 14:51'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfJSON class methodsFor: 'private' stamp: 'StephaneDucasse 8/31/2013 14:51'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfJSON class methodsFor: 'metacello tool support' stamp: 'StephaneDucasse 8/31/2013 14:51'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfJSON class methodsFor: 'catalog' stamp: 'StephaneDucasse 8/31/2013 15:04'!keyClassesAndExample^ '- ==Json== reads and write JSON objects.- ==JsonObject== represents JSON objects. '! !!ConfigurationOfJSON class methodsFor: 'loading' stamp: 'StephaneDucasse 8/31/2013 14:51'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfJSON class methodsFor: 'loading' stamp: 'StephaneDucasse 8/31/2013 14:51'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfJSON class methodsFor: 'loading' stamp: 'StephaneDucasse 8/31/2013 14:51'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfJSON class methodsFor: 'accessing' stamp: 'StephaneDucasse 8/31/2013 14:51'!project	^self new project! !!ConfigurationOfJSON class methodsFor: 'development support' stamp: 'StephaneDucasse 8/31/2013 14:51'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfJSON methodsFor: 'baselines' stamp: 'PaulDeBruicker 10/24/2013 10:34'!baseline10: spec	<version: '1.0-baseline'>	spec		for: #common		do: [ 			spec repository: 'http://smalltalkhub.com/mc/PharoExtras/JSON/main'.			spec blessing: #baseline.			spec package: 'JSON'.			spec group: 'default' with: #('JSON') ].	spec for: #gemstone do: [ spec repository: 'http://www.smalltalkhub.com/mc/pdebruic/JSONg/main' ]! !!ConfigurationOfJSON methodsFor: 'symbolic versions' stamp: 'StephanEggermont 1/13/2016 16:46'!development: spec	<symbolicVersion: #'development'>		spec for: #common version: '1.2'! !!ConfigurationOfJSON methodsFor: 'accessing' stamp: 'PaulDeBruicker 10/7/2013 16:01'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfJSON methodsFor: 'symbolic versions' stamp: 'PaulDeBruicker 12/30/2015 18:40'!stable: spec	<symbolicVersion: #stable>	spec for: #common version: '1.2'! !!ConfigurationOfJSON methodsFor: 'versions' stamp: 'PaulDeBruicker 10/7/2013 16:02'!version10: spec	<version: '1.0' imports: #('1.0-baseline')>	spec		for: #common		do: [ 			spec blessing: #development.			spec description: 'life is easier with metacello'.			spec author: 'PaulDeBruicker'.			spec timestamp: '9/7/2013 12:45' ].	spec for: #squeakCommon do: [ spec package: 'JSON' with: 'JSON-ul.35' ].	spec for: #gemstone do: [ spec package: 'JSON' with: 'JSON-PaulDeBruicker.40' ]! !!ConfigurationOfJSON methodsFor: 'versions' stamp: 'TommasoDalSasso 3/17/2015 09:53'!version11: spec	<version: '1.1' imports: #('1.0-baseline')>	spec		for: #common		do: [ 			spec blessing: #release.			spec author: 'TommasoDalSasso' ].	spec for: #squeakCommon do: [ spec package: 'JSON' with: 'JSON-TommasoDalSasso.38' ].	spec for: #gemstone do: [ spec package: 'JSON' with: 'JSON-PaulDeBruicker.40' ]! !!ConfigurationOfJSON methodsFor: 'versions' stamp: 'PaulDeBruicker 12/30/2015 18:40'!version12: spec	<version: '1.2' imports: #('1.0-baseline')>	spec		for: #common		do: [ 			spec blessing: #release.			spec author: 'TommasoDalSasso' ].	spec for: #squeakCommon do: [ spec package: 'JSON' with: 'JSON-PaulDeBruicker.39' ].	spec for: #gemstone do: [ spec package: 'JSON' with: 'JSON-PaulDeBruicker.40' ]! !"ConfigurationOfJSON"!!ConfigurationOfMagritte3 commentStamp: 'StephaneDucasse 6/27/2012 09:26' prior: 0!(ConfigurationOfMagritte3 project version: #stable) load!!ConfigurationOfMagritte3 class methodsFor: 'private' stamp: 'NickAger 1/30/2012 11:00'!bootstrapPackage: aString from: aPath 	| repository version |	repository := MCHttpRepository				location: aPath				user: ''				password: ''.	repository		versionReaderForFileNamed: aString , '.mcz'		do: [:reader | 			version := reader version.			version load.			version workingCopy repositoryGroup addRepository: repository]! !!ConfigurationOfMagritte3 class methodsFor: 'private' stamp: 'NickAger 1/30/2012 11:00'!ensureMetacello	"Bootstrap Gofer (if necessary), bootstrap ConfigurationOfMetacello (using old Gofer API), then load the latest 	version of Metacello itself."	Smalltalk at: #MetacelloProject ifAbsent: [		Smalltalk at: #Gofer ifAbsent: [			"Current version of Gofer from which to bootstrap - as of 1.0-beta.15"			self bootstrapPackage: 'Gofer-lr.83' from: 'http://seaside.gemstone.com/ss/metacello' ].		Smalltalk at: #Gofer ifPresent: [:goferClass | | gofer |			gofer := goferClass new				url: 'http://seaside.gemstone.com/ss/metacello';				yourself.			[ gofer addPackage: 'ConfigurationOfMetacello' ] on: Warning do: [:ex | ex resume ].			gofer load ].		"load 'default' group of Metacello"		(Smalltalk at: #ConfigurationOfMetacello) perform: #load ]! !!ConfigurationOfMagritte3 class methodsFor: 'metacello tool support' stamp: 'NickAger 1/30/2012 11:00'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfMagritte3 class methodsFor: 'metacello tool support' stamp: 'NickAger 1/30/2012 11:00'!lastMetacelloVersionLoad	"Answer the last version loaded and the list of packages loaded for that version."	LastVersionLoad == nil ifTrue: [ LastVersionLoad := nil -> 'default' ].	^LastVersionLoad! !!ConfigurationOfMagritte3 class methodsFor: 'loading' stamp: 'NickAger 1/30/2012 13:49'!load	"self load"		self project stableVersion load! !!ConfigurationOfMagritte3 class methodsFor: 'metacello tool support' stamp: 'NickAger 1/30/2012 11:00'!metacelloVersion: versionString loads: anArrayOrString	"Stash the last version loaded and the list of packages loaded for that version. The list	 of packages will be used by the tools when doing 'Load Package Version'"	LastVersionLoad := versionString -> anArrayOrString! !!ConfigurationOfMagritte3 class methodsFor: 'accessing' stamp: 'NickAger 1/30/2012 11:00'!project	^self new project! !!ConfigurationOfMagritte3 class methodsFor: 'release' stamp: 'NickAger 1/30/2012 11:00'!releaseToGemSource	"self releaseToGemSource"	(Smalltalk at: #Gofer) new		gemsource: 'MetacelloRepository';		package: self name asString;		push! !!ConfigurationOfMagritte3 class methodsFor: 'release' stamp: 'NickAger 1/30/2012 11:00'!releaseToSqueakSource	"self releaseToSqueakSource"	(Smalltalk at: #Gofer) new		squeaksource: 'MetacelloRepository';		package: self name asString;		push! !!ConfigurationOfMagritte3 methodsFor: 'baselines' stamp: 'DiegoLont 7/22/2013 14:08'!baseline300: spec	<version: '3.0-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec author: 'DiegoLont'.			spec timestamp: '2013-07-22'.			spec repository: 'http://www.smalltalkhub.com/mc/Magritte/Magritte3/main'.			self baseline300CommonExtDeps: spec.			spec				package: 'Magritte-Model' with: [ spec requires: #('Grease') ];				package: 'Magritte-Tests-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Seaside' with: [ spec requires: #('Magritte-Model' 'Seaside3') ];				package: 'Magritte-Deprecated' with: [ spec requires: #('Magritte-Model') ].			spec				group: 'default' with: #('Core');				group: 'Core' with: #('Magritte-Model');				group: 'Tests' with: #('Magritte-Tests-Model');				group: 'Seaside' with: #('Magritte-Seaside');				group: 'Deprecated' with: #('Magritte-Deprecated') ].	self baseline300ForPharo: spec.	self baseline300ForGemStone: spec! !!ConfigurationOfMagritte3 methodsFor: 'baselines' stamp: 'topa 1/14/2014 21:29'!baseline300CommonExtDeps: spec	"Common external dependencies for baseline 3.0.0"	spec		project: 'Grease'			with: [ 					spec						className: 'ConfigurationOfGrease';						versionString: #'stable';						loads: #('Core' );						repository: 'http://smalltalkhub.com/mc/Seaside/MetacelloConfigurations/main' ];		project: 'Seaside3'			with: [ 					spec						className: 'ConfigurationOfSeaside3';						versionString: '3.0.9';						loads: #('Base' 'Development' 'RSS-Core' 'Javascript-Core' 'Prototype-Core' 'Scriptaculous-Core' 'JQuery-Core' 'JQuery-UI' 'Seaside-Email' 'Seaside-HTML5' 'Seaside-InternetExplorer' 'Seaside-Examples' 'RSS-Examples' 'Seaside-Tools-Web' 'Scriptaculous-Components' 'Seaside-Welcome' 'Seaside-FileSystem' );						repository: 'http://smalltalkhub.com/mc/Seaside/MetacelloConfigurations/main' ]! !!ConfigurationOfMagritte3 methodsFor: 'baselines' stamp: 'DamienCassou 4/2/2013 18:04'!baseline300ForGemStone: spec	spec		for: #gemstone		do: [ 			spec				project: 'GsCore'				with: [ 					spec						className: 'ConfigurationOfGsCore';						versionString: #bleedingEdge;						repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ].			spec				package: 'Magritte-Model'					with: [ 							spec								requires: #('GsCore');								includes: #('Magritte-GemStone-Model') ];				package: 'Magritte-Tests-Model' with: [ spec includes: #('Magritte-Tests-GemStone-Model') ];				package: 'Magritte-Seaside' with: [ spec includes: #('Magritte-GemStone-Seaside') ];				package: 'Magritte-GemStone-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-GemStone-Model' with: [ spec requires: #('Magritte-GemStone-Model') ];				package: 'Magritte-GemStone-Seaside' with: [ spec requires: #('Magritte-Seaside') ] ]! !!ConfigurationOfMagritte3 methodsFor: 'baselines' stamp: 'StephanEggermont 7/12/2015 16:28'!baseline300ForPharo: spec	spec		for: #'pharo1.x'		do: [ 			spec				project: 'FileSystem' with: [ 					spec						className: 'ConfigurationOfFilesystem';						versionString: #'stable';						loads: #( 'default' );						repository: 'http://www.squeaksource.com/MetacelloRepository' ].			spec				package: 'Magritte-Model' with: [ spec requires: #( 'FileSystem' ) ] ].	spec		for: #(#'pharo1.x' #'pharo2.x' #'squeak')		do: [ 			spec				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo-Model') ];				package: 'Magritte-Pharo-Model' with: [ spec requires: #('Magritte-Model') ]].	spec		for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x')		do: [ 			spec				package: 'Magritte-Pharo3-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo3-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo3-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo3-Model'].	spec		for: #squeakCommon		do: [ 			spec				package: 'Magritte-Tests-Model' with: [ spec includes: #('Magritte-Tests-Pharo-Model') ];				package: 'Magritte-Seaside' with: [ spec includes: #('Magritte-Pharo-Seaside') ];								package: 'Magritte-Pharo-Seaside' with: [ spec requires: #('Magritte-Seaside') ];				package: 'Magritte-Morph' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Pharo-Tools' with: [ spec requires: #('Magritte-Deprecated') ].			spec				group: 'Tools' with: #('Magritte-Pharo-Tools');				group: 'Morphic' with: #('Magritte-Morph') ] ! !!ConfigurationOfMagritte3 methodsFor: 'baselines' stamp: 'DiegoLont 7/22/2013 14:08'!baseline310: spec	<version: '3.1-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec author: 'DiegoLont'.			spec timestamp: '2013-07-22'.			spec repository: 'http://www.smalltalkhub.com/mc/Magritte/Magritte3/main'.			self baseline310CommonExtDeps: spec.			spec				package: 'Magritte-Model' with: [ spec requires: #('Grease') ];				package: 'Magritte-Tests-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Seaside' with: [ spec requires: #('Magritte-Model' 'Seaside3') ];				package: 'Magritte-Deprecated' with: [ spec requires: #('Magritte-Model') ].			spec				group: 'default' with: #('Core');				group: 'Core' with: #('Magritte-Model');				group: 'Tests' with: #('Magritte-Tests-Model');				group: 'Seaside' with: #('Magritte-Seaside');				group: 'Deprecated' with: #('Magritte-Deprecated') ].	self baseline300ForPharo: spec.	self baseline300ForGemStone: spec! !!ConfigurationOfMagritte3 methodsFor: 'baselines' stamp: 'DiegoLont 5/21/2014 11:42'!baseline310CommonExtDeps: spec	"Common external dependencies for baseline 3.1.0"	spec		project: 'Grease'			with: [ 					spec						className: 'ConfigurationOfGrease';						versionString: #'stable';						loads: #('Core' );						repository: 'http://smalltalkhub.com/mc/Seaside/MetacelloConfigurations/main' ];		project: 'Seaside3'			with: [				"note: we do not want to depend on Zinc, since this is not present in Squeak. Currently no adapter is loaded" 					spec						className: 'ConfigurationOfSeaside3';						versionString: #'stable';						loads: #('Core' 'Javascript' 'RSS' 'Filesystem' 'Welcome' );						repository: 'http://smalltalkhub.com/mc/Seaside/MetacelloConfigurations/main' ]! !!ConfigurationOfMagritte3 methodsFor: 'baselines' stamp: 'SeanDeNigris 4/5/2015 21:06'!baseline330: spec	<version: '3.3-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec author: 'SeanDeNigris'.			spec timestamp: '2015-04-05'.			spec description: 'For pharo4.x, add Magritte-GT package and add it to the default group'.			spec repository: 'http://www.smalltalkhub.com/mc/Magritte/Magritte3/main'.			self baseline310CommonExtDeps: spec.			spec				package: 'Magritte-Model' with: [ spec requires: #('Grease') ];				package: 'Magritte-Tests-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Seaside' with: [ spec requires: #('Magritte-Model' 'Seaside3') ];				package: 'Magritte-Deprecated' with: [ spec requires: #('Magritte-Model') ].			spec				group: 'default' with: #('Core');				group: 'Core' with: #('Magritte-Model');				group: 'Tests' with: #('Magritte-Tests-Model');				group: 'Seaside' with: #('Magritte-Seaside');				group: 'Deprecated' with: #('Magritte-Deprecated') ].	self baseline330ForPharo: spec.	self baseline300ForGemStone: spec! !!ConfigurationOfMagritte3 methodsFor: 'baselines' stamp: 'TudorGirba 10/23/2016 07:22'!baseline330ForPharo: spec	spec		for: #'pharo1.x'		do: [ 			spec				project: 'FileSystem' with: [ 					spec						className: 'ConfigurationOfFilesystem';						versionString: #'stable';						loads: #( 'default' );						repository: 'http://www.squeaksource.com/MetacelloRepository' ].			spec				package: 'Magritte-Model' with: [ spec requires: #( 'FileSystem' ) ] ].	spec		for: #(#'pharo1.x' #'pharo2.x' #'squeak')		do: [ 			spec				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo-Model') ];				package: 'Magritte-Pharo-Model' with: [ spec requires: #('Magritte-Model') ]].	spec		for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x' #'pharo6.x')		do: [ 			spec				package: 'Magritte-Pharo3-Model' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Tests-Pharo-Model' with: [ spec requires: #('Magritte-Pharo3-Model') ];				package: 'Magritte-Model' with: [ spec includes: #('Magritte-Pharo3-Model') ];				" create a temporary alias "				package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo3-Model'].	spec		for: #(#'pharo4.x')		do: [ 			spec				project: 'MagritteGlamourForPharo40' with: [ 					spec						className: 'ConfigurationOfMagritteGlamourForPharo40';						versionString: #'stable';						repository: 'http://www.smalltalkhub.com/mc/SeanDeNigris/SeansMetaRepo/main' ].			spec package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'MagritteGlamourForPharo40') ].			spec package: 'Magritte-Morph' with: [ spec includes: #('Magritte-GT') ].			spec group: 'default' with: #('Magritte-GT') ].	spec		for: #(#'pharo5.x' #'pharo6.x')		do: [ 			spec package: 'Glamour-Magritte-Presentations' with: [ spec repository: 'http://www.smalltalkhub.com/mc/Moose/Glamour/main' ].			spec package: 'Magritte-GT' with: [ spec requires: #('Morphic' 'Glamour-Magritte-Presentations') ].			spec group: 'default' with: #('Magritte-GT') ].	spec		for: #squeakCommon		do: [ 			spec				package: 'Magritte-Tests-Model' with: [ spec includes: #('Magritte-Tests-Pharo-Model') ];				package: 'Magritte-Seaside' with: [ spec includes: #('Magritte-Pharo-Seaside') ];								package: 'Magritte-Pharo-Seaside' with: [ spec requires: #('Magritte-Seaside') ];				package: 'Magritte-Morph' with: [ spec requires: #('Magritte-Model') ];				package: 'Magritte-Pharo-Tools' with: [ spec requires: #('Magritte-Deprecated') ].			spec				group: 'Tools' with: #('Magritte-Pharo-Tools');				group: 'Morphic' with: #('Magritte-Morph');				group: 'default' with: 'Morphic' ] ! !!ConfigurationOfMagritte3 methodsFor: 'symbolic versions' stamp: 'SeanDeNigris 4/5/2015 21:12'!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: '3.3-baseline'! !!ConfigurationOfMagritte3 methodsFor: 'accessing' stamp: 'NickAger 1/30/2012 11:00'!project	^ project ifNil: [ | projectAttributes |		"Bootstrap Metacello if it is not already loaded"		self class ensureMetacello.		"Construct Metacello project"		project := (Smalltalk at: #MetacelloMCProject) new.		projectAttributes := #().		Smalltalk at: #SystemVersion ifPresent: [:cl | | versionString |			versionString := cl current version.			((versionString beginsWith: 'Pharo-1.0') or: [versionString beginsWith: 'PharoCore1.0'])				ifTrue: [ projectAttributes := projectAttributes, #(#'MagritteForPharo1.0') ] ].		project projectAttributes:  projectAttributes.		(Smalltalk at: #MetacelloVersionConstructor) on: self project: project.		project loadType: #linear ]! !!ConfigurationOfMagritte3 methodsFor: 'symbolic versions' stamp: 'DiegoLont 4/15/2014 14:16'!release30: spec 	<symbolicVersion: #'release3.0'>		spec for: #'common' version: '3.0.4'! !!ConfigurationOfMagritte3 methodsFor: 'symbolic versions' stamp: 'DiegoLont 7/1/2014 10:04'!release31: spec 	<symbolicVersion: #'release3.1'>		spec for: #'common' version: '3.1.4'! !!ConfigurationOfMagritte3 methodsFor: 'symbolic versions' stamp: 'DiegoLont 8/26/2014 14:13'!release32: spec 	<symbolicVersion: #'release3.2'>		spec for: #'common' version: '3.2.0'! !!ConfigurationOfMagritte3 methodsFor: 'symbolic versions' stamp: 'SeanDeNigris 5/31/2015 14:50'!release33: spec 	<symbolicVersion: #'release3.3'>		spec for: #'common' version: '3.3.2'! !!ConfigurationOfMagritte3 methodsFor: 'symbolic versions' stamp: 'SeanDeNigris 8/6/2015 18:18'!release34: spec 	<symbolicVersion: #'release3.4'>		spec for: #'common' version: '3.4.2'! !!ConfigurationOfMagritte3 methodsFor: 'symbolic versions' stamp: 'TudorGirba 8/10/2016 20:51'!release35: spec 	<symbolicVersion: #'release3.5'>		spec for: #'common' version: '3.5.1'! !!ConfigurationOfMagritte3 methodsFor: 'symbolic versions' stamp: 'StephanEggermont 10/10/2015 17:38'!release3: spec 	<symbolicVersion: #'release3'>		spec for: #'common' version: #'release3.5'! !!ConfigurationOfMagritte3 methodsFor: 'symbolic versions' stamp: 'SeanDeNigris 8/22/2015 17:19'!stable: spec 	<symbolicVersion: #stable>		spec for: #'common' version: #'release3.5'! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'DiegoLont 9/11/2013 11:40'!version300: spec	<version: '3.0' imports: #('3.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.				spec description: '3.0:- #description replaced by #magritteDescription (#description deprecated)- MAPragmaBuilder as default - model is now described using pragmas rather than #descriptionXXX naming convention.- models are described on the instance side and built dynamically - no need for #magritteDynamicObject- refactoring support (Magritte-Tools) transforms model descriptions into pragmas and moves descriptions from class to instance-side.Updated configuration to use Seaside3'.		spec author: 'NickAger'.		spec timestamp: '30 January 2012 12:55:56 pm'.		spec 			project: 'Grease' with: '1.0.8';			project: 'Seaside3' with: '3.0.8'.		spec 			package: 'Magritte-Model' with: 'Magritte-Model-NickAger.431';			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DamienCassou.32';			package: 'Magritte-Seaside' with: 'Magritte-Seaside-NickAger.355';			package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].	spec for: #'squeakCommon' do: [		spec 			package: 'Magritte-Tests-Pharo-Model' with: 'Magritte-Tests-Pharo-Model-lr.4';			package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';			package: 'Magritte-Morph' with: 'Magritte-Morph-NickAger.63';			package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].	spec for: #'squeak' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].	spec for: #'pharo' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.27' ].	spec for: #'pharo3.x' do: [ 		spec			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DamienCassou.33'].		spec for: #'gemstone' do: [		spec project: 'GsCore' with: '0.242'.		spec 			package: 'Magritte-GemStone-Model' with: 'Magritte-GemStone-Model-NickAger.3';			package: 'Magritte-Tests-GemStone-Model' with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';			package: 'Magritte-GemStone-Seaside' with: 'Magritte-GemStone-Seaside-DaleHenrichs.2'.].! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'DamienCassou 11/25/2013 14:31'!version301: spec	<version: '3.0.1' imports: #('3.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.				spec description: '3.0:- #description replaced by #magritteDescription (#description deprecated)- MAPragmaBuilder as default - model is now described using pragmas rather than #descriptionXXX naming convention.- models are described on the instance side and built dynamically - no need for #magritteDynamicObject- refactoring support (Magritte-Tools) transforms model descriptions into pragmas and moves descriptions from class to instance-side.Updated configuration to use Seaside3'.		spec author: 'NickAger'.		spec timestamp: '30 January 2012 12:55:56 pm'.		spec 			project: 'Grease' with: '1.0.8';			project: 'Seaside3' with: '3.0.9'.		spec 			package: 'Magritte-Model' with: 'Magritte-Model-DamienCassou.432';			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DamienCassou.32';			package: 'Magritte-Seaside' with: 'Magritte-Seaside-NickAger.355';			package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].	spec for: #'squeakCommon' do: [		spec 			package: 'Magritte-Tests-Pharo-Model' with: 'Magritte-Tests-Pharo-Model-lr.4';			package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';			package: 'Magritte-Morph' with: 'Magritte-Morph-NickAger.63';			package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].	spec for: #'squeak' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].	spec for: #'pharo' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.27' ].	spec for: #'pharo3.x' do: [ 		spec			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DamienCassou.33'].		spec for: #'gemstone' do: [		spec project: 'GsCore' with: '0.242'.		spec 			package: 'Magritte-GemStone-Model' with: 'Magritte-GemStone-Model-NickAger.3';			package: 'Magritte-Tests-GemStone-Model' with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';			package: 'Magritte-GemStone-Seaside' with: 'Magritte-GemStone-Seaside-DaleHenrichs.2'.].! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'EstebanLorenzano 1/8/2014 16:44'!version302: spec	<version: '3.0.2' imports: #('3.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Using #stable version of Grease'.		spec author: 'EstebanLorenzano'.		spec timestamp: '8 January 2014 4:43:33 pm'.		spec 			project: 'Grease' with: #'stable';			project: 'Seaside3' with: '3.0.9'.		spec 			package: 'Magritte-Model' with: 'Magritte-Model-DamienCassou.432';			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DamienCassou.32';			package: 'Magritte-Seaside' with: 'Magritte-Seaside-NickAger.355';			package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].	spec for: #'squeakCommon' do: [		spec 			package: 'Magritte-Tests-Pharo-Model' with: 'Magritte-Tests-Pharo-Model-lr.4';			package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';			package: 'Magritte-Morph' with: 'Magritte-Morph-NickAger.63';			package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].	spec for: #'squeak' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].	spec for: #'pharo' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.27' ].	spec for: #'pharo3.x' do: [ 		spec			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DamienCassou.33'].		spec for: #'gemstone' do: [		spec project: 'GsCore' with: '0.242'.		spec 			package: 'Magritte-GemStone-Model' with: 'Magritte-GemStone-Model-NickAger.3';			package: 'Magritte-Tests-GemStone-Model' with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';			package: 'Magritte-GemStone-Seaside' with: 'Magritte-GemStone-Seaside-DaleHenrichs.2'.].! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'DiegoLont 2/25/2014 11:24'!version303: spec	<version: '3.0.3' imports: #('3.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.				spec description: '3.0.3:- updated version 3.0.1:	More possibilities for labels.'.		spec author: 'DiegoLont'.		spec timestamp: '16 January 2014'.		spec 			project: 'Grease' with: '1.0.8';			project: 'Seaside3' with: '3.0.10'.		spec 			package: 'Magritte-Model' with: 'Magritte-Model-DiegoLont.448';			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DamienCassou.32';			package: 'Magritte-Seaside' with: 'Magritte-Seaside-NickAger.355';			package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].	spec for: #'squeakCommon' do: [		spec 			package: 'Magritte-Tests-Pharo-Model' with: 'Magritte-Tests-Pharo-Model-lr.4';			package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';			package: 'Magritte-Morph' with: 'Magritte-Morph-NickAger.63';			package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].	spec for: #'squeak' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].	spec for: #'pharo' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.39';			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DamienCassou.33' ].		spec for: #'gemstone' do: [		spec project: 'GsCore' with: '0.242'.		spec 			package: 'Magritte-GemStone-Model' with: 'Magritte-GemStone-Model-NickAger.3';			package: 'Magritte-Tests-GemStone-Model' with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';			package: 'Magritte-GemStone-Seaside' with: 'Magritte-GemStone-Seaside-DaleHenrichs.2'.].! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'DiegoLont 4/15/2014 15:31'!version304: spec	<version: '3.0.4' imports: #('3.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.				spec description: '3.0.4:- updated version 3.0.3: use releases instead of fixed versions.'.		spec author: 'DiegoLont'.		spec timestamp: '16 January 2014'.		spec 			project: 'Grease' with: #'release1.0';			project: 'Seaside3' with: #'release3.0'.		spec 			package: 'Magritte-Model' with: 'Magritte-Model-DiegoLont.449';			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DiegoLont.38';			package: 'Magritte-Seaside' with: 'Magritte-Seaside-NickAger.355';			package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].	spec for: #'squeakCommon' do: [		spec 			package: 'Magritte-Tests-Pharo-Model' with: 'Magritte-Tests-Pharo-Model-lr.4';			package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';			package: 'Magritte-Morph' with: 'Magritte-Morph-NickAger.63';			package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].	spec for: #'squeak' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].	spec for: #'pharo' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.39';			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DamienCassou.33' ].		spec for: #'gemstone' do: [		spec project: 'GsCore' with: '0.242'.		spec 			package: 'Magritte-GemStone-Model' with: 'Magritte-GemStone-Model-NickAger.3';			package: 'Magritte-Tests-GemStone-Model' with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';			package: 'Magritte-GemStone-Seaside' with: 'Magritte-GemStone-Seaside-DaleHenrichs.2'.].! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'StephanEggermont 3/4/2014 14:22'!version310: spec	<version: '3.1' imports: #('3.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.				spec description: 'initial enhancement of Morphic implementation to bring on par with the Seaside one.			Updated configuration to use Seaside3.			Updated configuration to use Grease 1.1.5'.		spec author: 'DiegoLont'.		spec timestamp: '22 July 2013 8:13 am'.				spec			project: 'Grease' with: '1.1.5';			project: 'Seaside3' with: '3.1.0'.		spec 			package: 'Magritte-Model' with: 'Magritte-Model-DiegoLont.448';			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DamienCassou.29';			package: 'Magritte-Seaside' with: 'Magritte-Seaside-DiegoLont.356';			package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].	spec for: #'squeakCommon' do: [		spec 			package: 'Magritte-Tests-Pharo-Model' with: 'Magritte-Tests-Pharo-Model-lr.4';			package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';			package: 'Magritte-Morph' with: 'Magritte-Morph-TudorGirba.70';			package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].	spec for: #'squeak' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].	spec for: #'pharo' do: [		spec			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DiegoLont.37' ].	spec for: #(#'pharo1.x' #'pharo2.x') do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.39'].	spec for: #'pharo3.x' do: [		spec			package: 'Magritte-Pharo3-Model' with: 'Magritte-Pharo3-Model-StephanEggermont.1'].		spec for: #'gemstone' do: [		spec project: 'GsCore' with: '0.242'.		spec 			package: 'Magritte-GemStone-Model' with: 'Magritte-GemStone-Model-NickAger.3';			package: 'Magritte-Tests-GemStone-Model' with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';			package: 'Magritte-GemStone-Seaside' with: 'Magritte-GemStone-Seaside-DaleHenrichs.2'.].! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'StephanEggermont 5/14/2014 12:58'!version3111: spec	<version: '3.1.1.1' imports: #('3.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.				spec description: 'MAke Magritte_morph work on Pharo 3'.		spec author: 'Stephan Eggermont'.		spec timestamp: '14 May 2014'.				spec			project: 'Grease' with: #'stable';			project: 'Seaside3' with: '3.1.0'.		spec 			package: 'Magritte-Model' with: 'Magritte-Model-DiegoLont.448';			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DamienCassou.29';			package: 'Magritte-Seaside' with: 'Magritte-Seaside-DiegoLont.356';			package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].	spec for: #'squeakCommon' do: [		spec 			package: 'Magritte-Tests-Pharo-Model' with: 'Magritte-Tests-Pharo-Model-lr.4';			package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';			package: 'Magritte-Morph' with: 'Magritte-Morph-TudorGirba.70';			package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].	spec for: #'squeak' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].	spec for: #'pharo' do: [		spec			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DiegoLont.37' ].	spec for: #(#'pharo1.x' #'pharo2.x') do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.39'].	spec for: #'pharo3.x' do: [		spec			package: 'Magritte-Morph' with: 'Magritte-Morph-TudorGirba.79';			package: 'Magritte-Pharo3-Model' with: 'Magritte-Pharo3-Model-StephanEggermont.1'].		spec for: #'gemstone' do: [		spec project: 'GsCore' with: '0.242'.		spec 			package: 'Magritte-GemStone-Model' with: 'Magritte-GemStone-Model-NickAger.3';			package: 'Magritte-Tests-GemStone-Model' with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';			package: 'Magritte-GemStone-Seaside' with: 'Magritte-GemStone-Seaside-DaleHenrichs.2'.].! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'StephanEggermont 4/7/2014 13:39'!version311: spec	<version: '3.1.1' imports: #('3.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.				spec description: 'switched grease to #stable. Although it is not a good idea we need to find a solution so that only		one version of a package is loaded'.		spec author: 'NorbertHartl'.		spec timestamp: '21 March 2014'.				spec			project: 'Grease' with: #'stable';			project: 'Seaside3' with: '3.1.0'.		spec 			package: 'Magritte-Model' with: 'Magritte-Model-DiegoLont.448';			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DamienCassou.29';			package: 'Magritte-Seaside' with: 'Magritte-Seaside-DiegoLont.356';			package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].	spec for: #'squeakCommon' do: [		spec 			package: 'Magritte-Tests-Pharo-Model' with: 'Magritte-Tests-Pharo-Model-lr.4';			package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';			package: 'Magritte-Morph' with: 'Magritte-Morph-TudorGirba.70';			package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].	spec for: #'squeak' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].	spec for: #'pharo' do: [		spec			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DiegoLont.37' ].	spec for: #(#'pharo1.x' #'pharo2.x') do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.39'].	spec for: #'pharo3.x' do: [		spec			package: 'Magritte-Pharo3-Model' with: 'Magritte-Pharo3-Model-StephanEggermont.1'].		spec for: #'gemstone' do: [		spec project: 'GsCore' with: '0.242'.		spec 			package: 'Magritte-GemStone-Model' with: 'Magritte-GemStone-Model-NickAger.3';			package: 'Magritte-Tests-GemStone-Model' with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';			package: 'Magritte-GemStone-Seaside' with: 'Magritte-GemStone-Seaside-DaleHenrichs.2'.].! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'StephanEggermont 4/7/2014 13:41'!version312: spec	<version: '3.1.2' imports: #('3.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.				spec description: 'switched to release based management'.		spec author: 'StephanEggermont'.		spec timestamp: '7 April 2014'.				spec			project: 'Grease' with: #'release1.1';			project: 'Seaside3' with: #'release3.1'.		spec 			package: 'Magritte-Model' with: 'Magritte-Model-DiegoLont.448';			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DamienCassou.29';			package: 'Magritte-Seaside' with: 'Magritte-Seaside-DiegoLont.356';			package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].	spec for: #'squeakCommon' do: [		spec 			package: 'Magritte-Tests-Pharo-Model' with: 'Magritte-Tests-Pharo-Model-lr.4';			package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';			package: 'Magritte-Morph' with: 'Magritte-Morph-TudorGirba.70';			package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].	spec for: #'squeak' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].	spec for: #'pharo' do: [		spec			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DiegoLont.37' ].	spec for: #(#'pharo1.x' #'pharo2.x') do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.39'].	spec for: #'pharo3.x' do: [		spec			package: 'Magritte-Pharo3-Model' with: 'Magritte-Pharo3-Model-StephanEggermont.1'].		spec for: #'gemstone' do: [		spec project: 'GsCore' with: '0.242'.		spec 			package: 'Magritte-GemStone-Model' with: 'Magritte-GemStone-Model-NickAger.3';			package: 'Magritte-Tests-GemStone-Model' with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';			package: 'Magritte-GemStone-Seaside' with: 'Magritte-GemStone-Seaside-DaleHenrichs.2'.].! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'DiegoLont 6/24/2014 10:08'!version313: spec	<version: '3.1.3' imports: #('3.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.				spec description: 'Updated with latest packages'.		spec author: 'StephanEggermont'.		spec timestamp: '7 April 2014'.				spec			project: 'Grease' with: #'release1.1';			project: 'Seaside3' with: #'release3.1'.		spec 			package: 'Magritte-Model' with: 'Magritte-Model-DiegoLont.450';			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DiegoLont.38';			package: 'Magritte-Seaside' with: 'Magritte-Seaside-DiegoLont.356';			package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].	spec for: #'squeakCommon' do: [		spec 			package: 'Magritte-Tests-Pharo-Model' with: 'Magritte-Tests-Pharo-Model-lr.4';			package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';			package: 'Magritte-Morph' with: 'Magritte-Morph-TudorGirba.70';			package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].	spec for: #'squeak' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].	spec for: #(#'pharo1.x' #'pharo2.x') do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.39'].	spec for: #(#'pharo3.x' #'pharo4.x') do: [		spec			package: 'Magritte-Pharo3-Model' with: 'Magritte-Pharo3-Model-DamienCassou.2'].		spec for: #'gemstone' do: [		spec project: 'GsCore' with: '0.242'.		spec 			package: 'Magritte-GemStone-Model' with: 'Magritte-GemStone-Model-NickAger.3';			package: 'Magritte-Tests-GemStone-Model' with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';			package: 'Magritte-GemStone-Seaside' with: 'Magritte-GemStone-Seaside-DaleHenrichs.2'.].! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'DiegoLont 7/1/2014 10:04'!version314: spec	<version: '3.1.4' imports: #('3.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.				spec description: 'New version opened for development'.		spec author: 'Diego Lont'.		spec timestamp: '21 May 2014'.				spec			project: 'Grease' with: #'release1.1';			project: 'Seaside3' with: #'release3.1'.		spec 			package: 'Magritte-Model' with: 'Magritte-Model-DiegoLont.450';			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DiegoLont.38';			package: 'Magritte-Seaside' with: 'Magritte-Seaside-DiegoLont.357';			package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].	spec for: #'squeakCommon' do: [		spec 			package: 'Magritte-Tests-Pharo-Model' with: 'Magritte-Tests-Pharo-Model-lr.4';			package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';			package: 'Magritte-Morph' with: 'Magritte-Morph-SeanDeNigris.86';			package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].	spec for: #'squeak' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].	spec for: #(#'pharo1.x' #'pharo2.x') do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.39'].	spec for: #(#'pharo3.x' #'pharo4.x') do: [		spec			package: 'Magritte-Pharo3-Model' with: 'Magritte-Pharo3-Model-DamienCassou.2'].		spec for: #'gemstone' do: [		spec project: 'GsCore' with: '0.242'.		spec 			package: 'Magritte-GemStone-Model' with: 'Magritte-GemStone-Model-NickAger.3';			package: 'Magritte-Tests-GemStone-Model' with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';			package: 'Magritte-GemStone-Seaside' with: 'Magritte-GemStone-Seaside-DaleHenrichs.2'.].! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'EstebanMaringolo 11/21/2014 16:53'!version315: spec	<version: '3.1.5' imports: #('3.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.				spec description: 'Updated for recent changes. Not yet published as stable'.		spec author: 'Esteban Maringolo'.		spec timestamp: '2 November 2014'.				spec			project: 'Grease' with: #'release1.1';			project: 'Seaside3' with: #'release3.1'.		spec 			package: 'Magritte-Model' with: 'Magritte-Model-EstebanMaringolo.452';			package: 'Magritte-Tests-Model' with: 'Magritte-Tests-Model-DiegoLont.38';			package: 'Magritte-Seaside' with: 'Magritte-Seaside-EstebanMaringolo.359';			package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].	spec for: #'squeakCommon' do: [		spec 			package: 'Magritte-Tests-Pharo-Model' with: 'Magritte-Tests-Pharo-Model-lr.4';			package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';			package: 'Magritte-Morph' with: 'Magritte-Morph-SeanDeNigris.86';			package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].	spec for: #'squeak' do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].	spec for: #(#'pharo1.x' #'pharo2.x') do: [		spec			package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.39'].	spec for: #(#'pharo3.x' #'pharo4.x') do: [		spec			package: 'Magritte-Pharo3-Model' with: 'Magritte-Pharo3-Model-DiegoLont.3'].		spec for: #'gemstone' do: [		spec project: 'GsCore' with: '0.242'.		spec 			package: 'Magritte-GemStone-Model' with: 'Magritte-GemStone-Model-NickAger.3';			package: 'Magritte-Tests-GemStone-Model' with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';			package: 'Magritte-GemStone-Seaside' with: 'Magritte-GemStone-Seaside-DaleHenrichs.2'.].! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'StephanEggermont 7/12/2015 15:51'!version320: spec  <version: '3.2.0' imports: #('3.1-baseline')>  spec    for: #'common'    do: [       spec blessing: #'development'.      spec description: 'New version opened for development'.      spec author: 'dkh'.      spec timestamp: '2/26/2015 13:51'.      spec        project: 'Grease' with: #'release1.1';        project: 'Seaside3' with: #'release3.1'.      spec        package: 'Magritte-Model' with: 'Magritte-Model-EstebanMaringolo.452';        package: 'Magritte-Tests-Model'          with: 'Magritte-Tests-Model-DiegoLont.38';        package: 'Magritte-Seaside'          with: 'Magritte-Seaside-StephanEggermont.358';        package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].  spec    for: #'squeakCommon'    do: [       spec        package: 'Magritte-Tests-Pharo-Model'          with: 'Magritte-Tests-Pharo-Model-lr.4';        package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';        package: 'Magritte-Morph' with: 'Magritte-Morph-SeanDeNigris.86';        package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].  spec    for: #'squeak'    do: [ spec package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].  spec    for: #(#'pharo1.x' #'pharo2.x')    do: [ spec package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.39' ].  spec    for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x')    do: [ spec package: 'Magritte-Pharo3-Model' with: 'Magritte-Pharo3-Model-DiegoLont.3' ].  spec    for: #'gemstone'    do: [       spec project: 'GsCore' with: '0.242'.      spec        package: 'Magritte-GemStone-Model'          with: 'Magritte-GemStone-Model-dkh.4';        package: 'Magritte-Tests-GemStone-Model'          with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';        package: 'Magritte-GemStone-Seaside'          with: 'Magritte-GemStone-Seaside-DaleHenrichs.2' ]! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'SeanDeNigris 4/5/2015 21:13'!version330: spec  <version: '3.3.0' imports: #('3.3-baseline')>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec description: 'For pharo4.x, add Magritte-GT package and add it to the default group'.      spec author: 'spd'.      spec timestamp: '04/05/2015 13:51'.      spec        project: 'Grease' with: #'release1.1';        project: 'Seaside3' with: #'release3.1'.      spec        package: 'Magritte-Model' with: 'Magritte-Model-EstebanMaringolo.452';        package: 'Magritte-Tests-Model'          with: 'Magritte-Tests-Model-DiegoLont.38';        package: 'Magritte-Seaside'          with: 'Magritte-Seaside-StephanEggermont.358';        package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].  spec    for: #'squeakCommon'    do: [       spec        package: 'Magritte-Tests-Pharo-Model'          with: 'Magritte-Tests-Pharo-Model-lr.4';        package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';        package: 'Magritte-Morph' with: 'Magritte-Morph-SeanDeNigris.86';        package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].  spec    for: #'squeak'    do: [ spec package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].  spec    for: #(#'pharo1.x' #'pharo2.x')    do: [ spec package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.39' ].  spec    for: #(#'pharo3.x' #'pharo4.x')    do: [ spec package: 'Magritte-Pharo3-Model' with: 'Magritte-Pharo3-Model-DiegoLont.3' ].  spec    for: #'pharo4.x'    do: [ spec package: 'Magritte-GT' with: 'Magritte-GT-SeanDeNigris.1' ].  spec    for: #'gemstone'    do: [       spec project: 'GsCore' with: '0.242'.      spec        package: 'Magritte-GemStone-Model'          with: 'Magritte-GemStone-Model-dkh.4';        package: 'Magritte-Tests-GemStone-Model'          with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';        package: 'Magritte-GemStone-Seaside'          with: 'Magritte-GemStone-Seaside-DaleHenrichs.2' ]! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'CyrilFerlicot 5/6/2015 10:53'!version331: spec  <version: '3.3.1' imports: #('3.3-baseline')>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec description: 'configuration in order to avoid deprecated methods'.      spec author: 'CyrilFerlicot'.      spec timestamp: '05/06/2015 10:51'.      spec        project: 'Grease' with: #'release1.1';        project: 'Seaside3' with: #'release3.1'.      spec        package: 'Magritte-Model' with: 'Magritte-Model-StephanEggermont.458';        package: 'Magritte-Tests-Model'          with: 'Magritte-Tests-Model-DiegoLont.38';        package: 'Magritte-Seaside'          with: 'Magritte-Seaside-EstebanMaringolo.359';        package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].  spec    for: #'squeakCommon'    do: [       spec        package: 'Magritte-Tests-Pharo-Model'          with: 'Magritte-Tests-Pharo-Model-lr.4';        package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';        package: 'Magritte-Morph' with: 'Magritte-Morph-SeanDeNigris.86';        package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].  spec    for: #'squeak'    do: [ spec package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].  spec    for: #(#'pharo1.x' #'pharo2.x')    do: [ spec package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.39' ].  spec    for: #(#'pharo3.x' #'pharo4.x')    do: [ spec package: 'Magritte-Pharo3-Model' with: 'Magritte-Pharo3-Model-JohnCBorden.4' ].  spec    for: #'pharo4.x'    do: [ spec package: 'Magritte-GT' with: 'Magritte-GT-SeanDeNigris.1' ].  spec    for: #'gemstone'    do: [       spec project: 'GsCore' with: '0.242'.      spec        package: 'Magritte-GemStone-Model'          with: 'Magritte-GemStone-Model-dkh.4';        package: 'Magritte-Tests-GemStone-Model'          with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';        package: 'Magritte-GemStone-Seaside'          with: 'Magritte-GemStone-Seaside-DaleHenrichs.2' ]! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'StephanEggermont 7/12/2015 10:46'!version332: spec  <version: '3.3.2' imports: #('3.3-baseline')>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec description: 'In-place fix add: pharo 5, StephanEggermont 2015-7-12 configuration in order to avoid deprecated methods'.      spec author: 'CyrilFerlicot'.      spec timestamp: '05/06/2015 10:51'.      spec        project: 'Grease' with: #'release1.1';        project: 'Seaside3' with: #'release3.1'.      spec        package: 'Magritte-Model' with: 'Magritte-Model-StephanEggermont.458';        package: 'Magritte-Tests-Model'          with: 'Magritte-Tests-Model-DiegoLont.38';        package: 'Magritte-Seaside'          with: 'Magritte-Seaside-EstebanMaringolo.359';        package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].  spec    for: #'squeakCommon'    do: [       spec        package: 'Magritte-Tests-Pharo-Model'          with: 'Magritte-Tests-Pharo-Model-lr.4';        package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';        package: 'Magritte-Morph' with: 'Magritte-Morph-SeanDeNigris.86';        package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].  spec    for: #'squeak'    do: [ spec package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].  spec    for: #(#'pharo1.x' #'pharo2.x')    do: [ spec package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.39' ].  spec    for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x')    do: [ spec package: 'Magritte-Pharo3-Model' with: 'Magritte-Pharo3-Model-JohnCBorden.4' ].  spec    for: #(#'pharo4.x' #'pharo5.x')    do: [ spec package: 'Magritte-GT' with: 'Magritte-GT-SeanDeNigris.3' ].  spec    for: #'gemstone'    do: [       spec project: 'GsCore' with: '0.242'.      spec        package: 'Magritte-GemStone-Model'          with: 'Magritte-GemStone-Model-dkh.4';        package: 'Magritte-Tests-GemStone-Model'          with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';        package: 'Magritte-GemStone-Seaside'          with: 'Magritte-GemStone-Seaside-DaleHenrichs.2' ]! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'SeanDeNigris 8/6/2015 18:17'!version342: spec  <version: '3.4.2' imports: #('3.3-baseline')>  spec    for: #'common'    do: [       spec blessing: #'release'.      spec description: '- [ENH]: Add URL description- [BUG]: For Dates, instead of printing "nil", leave blank'.      spec author: 'SeanDeNigris'.      spec timestamp: '08/06/2015 10:51'.      spec        project: 'Grease' with: #'release1.1';        project: 'Seaside3' with: #'release3.1'.      spec        package: 'Magritte-Model' with: 'Magritte-Model-SeanDeNigris.462';        package: 'Magritte-Tests-Model'          with: 'Magritte-Tests-Model-DiegoLont.38';        package: 'Magritte-Seaside'          with: 'Magritte-Seaside-EstebanMaringolo.359';        package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].  spec    for: #'squeakCommon'    do: [       spec        package: 'Magritte-Tests-Pharo-Model'          with: 'Magritte-Tests-Pharo-Model-lr.4';        package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';        package: 'Magritte-Morph' with: 'Magritte-Morph-SeanDeNigris.86';        package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].  spec    for: #'squeak'    do: [ spec package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].  spec    for: #(#'pharo1.x' #'pharo2.x')    do: [ spec package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.39' ].  spec    for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x')    do: [ spec package: 'Magritte-Pharo3-Model' with: 'Magritte-Pharo3-Model-JohnCBorden.4' ].  spec    for: #(#'pharo4.x' #'pharo5.x')    do: [ spec package: 'Magritte-GT' with: 'Magritte-GT-SeanDeNigris.3' ].  spec    for: #'gemstone'    do: [       spec project: 'GsCore' with: '0.242'.      spec        package: 'Magritte-GemStone-Model'          with: 'Magritte-GemStone-Model-dkh.4';        package: 'Magritte-Tests-GemStone-Model'          with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';        package: 'Magritte-GemStone-Seaside'          with: 'Magritte-GemStone-Seaside-DaleHenrichs.2' ]! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'StephanEggermont 10/10/2015 21:08'!version350: spec  <version: '3.5.0' imports: #('3.3-baseline')>  spec    for: #'common'    do: [       spec blessing: #'development'.      spec description: '-[Feature]: Meta-describe GT presentations https://github.com/magritte-metamodel/magritte/issues/26- [ENH]: Provide hook to initialize ToMany Instances https://github.com/magritte-metamodel/magritte/issues/18- [ENH]: Actions; fill out a few dark corners- [BUG]: Hack to make ToOne Morphs work i.e. stop infinite recursion, by duplicating ToMany logic (for now). https://github.com/magritte-metamodel/magritte/issues/25- [Bug]: MAMemoMorph - respect #readonly of description by disabling editing ability- [Bug]: In MAElementMorph>>string:, do not silently swallow read errors- [BUG]: MADateMorph - when building, set value before display block; unfortunately, I don''t remember why that was important, but I ran into a problem the other way.- [Clean]: Import action button construction, which had been mistakenly put in Model package- [BUG]: Hack to make ToOne Morphs work i.e. stop infinite recursion, by duplicating ToMany logic (for now). https://github.com/magritte-metamodel/magritte/issues/25'.      spec author: 'SeanDeNigris'.      spec timestamp: '08/20/2015 10:51'.      spec        project: 'Grease' with: #'release1.2';        project: 'Seaside3' with: #'release3.1'.      spec        package: 'Magritte-Model' with: 'Magritte-Model-SeanDeNigris.465';        package: 'Magritte-Tests-Model'          with: 'Magritte-Tests-Model-DiegoLont.38';        package: 'Magritte-Seaside'          with: 'Magritte-Seaside-EstebanMaringolo.359';        package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].  spec    for: #'squeakCommon'    do: [       spec        package: 'Magritte-Tests-Pharo-Model'          with: 'Magritte-Tests-Pharo-Model-lr.4';        package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';        package: 'Magritte-Morph' with: 'Magritte-Morph-SeanDeNigris.95';        package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].  spec    for: #'squeak'    do: [ spec package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].  spec    for: #(#'pharo1.x' #'pharo2.x')    do: [ spec package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.39' ].  spec    for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x')    do: [ spec package: 'Magritte-Pharo3-Model' with: 'Magritte-Pharo3-Model-JohnCBorden.4' ].  spec    for: #(#'pharo4.x')    do: [ 			spec        project: 'MagritteGlamourForPharo40' with: '1.0'.			spec package: 'Magritte-GT' with: 'Magritte-GT-SeanDeNigris.5' ].  spec    for: #'gemstone'    do: [       spec project: 'GsCore' with: '0.242'.      spec        package: 'Magritte-GemStone-Model'          with: 'Magritte-GemStone-Model-dkh.4';        package: 'Magritte-Tests-GemStone-Model'          with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';        package: 'Magritte-GemStone-Seaside'          with: 'Magritte-GemStone-Seaside-DaleHenrichs.2' ]! !!ConfigurationOfMagritte3 methodsFor: 'versions' stamp: 'TudorGirba 10/23/2016 07:21'!version351: spec  <version: '3.5.1' imports: #('3.3-baseline')>  spec    for: #'common'    do: [       spec blessing: #'development'.      spec description: ''.      spec author: 'TudorGirba'.      spec timestamp: '08/10/2016 20:51'.      spec        project: 'Grease' with: #'release1.2';        project: 'Seaside3' with: #'release3.2'.      spec        package: 'Magritte-Model' with: 'Magritte-Model-TudorGirba.468';        package: 'Magritte-Tests-Model'          with: 'Magritte-Tests-Model-SeanDeNigris.39';        package: 'Magritte-Seaside'          with: 'Magritte-Seaside-EstebanMaringolo.359';        package: 'Magritte-Deprecated' with: 'Magritte-Deprecated-NickAger.7' ].  spec    for: #'squeakCommon'    do: [       spec        package: 'Magritte-Tests-Pharo-Model'          with: 'Magritte-Tests-Pharo-Model-lr.4';        package: 'Magritte-Pharo-Seaside' with: 'Magritte-Pharo-Seaside-lr.5';        package: 'Magritte-Morph' with: 'Magritte-Morph-SeanDeNigris.99';        package: 'Magritte-Pharo-Tools' with: 'Magritte-Pharo-Tools-NickAger.3' ].  spec    for: #'squeak'    do: [ spec package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-NickAger.26' ].  spec    for: #(#'pharo1.x' #'pharo2.x')    do: [ spec package: 'Magritte-Pharo-Model' with: 'Magritte-Pharo-Model-DiegoLont.39' ].  spec    for: #(#'pharo3.x' #'pharo4.x' #'pharo5.x' #'pharo6.x')    do: [ spec package: 'Magritte-Pharo3-Model' with: 'Magritte-Pharo3-Model-JohnCBorden.4' ].  spec    for: #(#'pharo4.x')    do: [ 			spec        project: 'MagritteGlamourForPharo40' with: '1.0'.			spec package: 'Magritte-GT' with: 'Magritte-GT-SeanDeNigris.5' ].  spec    for: #'gemstone'    do: [       spec project: 'GsCore' with: '0.242'.      spec        package: 'Magritte-GemStone-Model'          with: 'Magritte-GemStone-Model-dkh.4';        package: 'Magritte-Tests-GemStone-Model'          with: 'Magritte-Tests-GemStone-Model-DaleHenrichs.1';        package: 'Magritte-GemStone-Seaside'          with: 'Magritte-GemStone-Seaside-DaleHenrichs.2' ]! !"ConfigurationOfMagritte3"!!ConfigurationOfGrease commentStamp: 'StephaneDucasse 10/18/2011 14:07' prior: 0!(ConfigurationOfGrease project version: #stable) load(ConfigurationOfGrease project version: #development) load!!ConfigurationOfGrease class methodsFor: 'development support' stamp: 'JohanBrichau 7/24/2015 09:35'!DevelopmentProcess"DEVELOPMENT Process	- load current version:	  	(self project version: #stable) load: 'ALL'.	- open new version for development:		self createNewDevelopmentVersion	- update the the development version to match mcz file versions		self updateToLatestPackageVersions: '- fixed bug uvw'	- do development and periodically save mcz files and update configuration		self saveModifiedPackages: '- fixed bug xyz'	- do development and periodically save mcz files and configuration until ready for release		self saveModifiedPackagesAndConfiguration: '- fixed bug xyz'	- save configuration		self saveConfiguration: commitMessage '- checkpoint configuration'RELEASE Process	- mark development version as release:		self releaseDevelopmentVersion: 'commit comment'	- copy mcz files to github:		self copyMczFromSmalltalkhubToFileTree: '/path/to/filetree/repository'."! !!ConfigurationOfGrease class methodsFor: 'private' stamp: 'dkh 11/12/2009 09:11'!bootstrapPackage: aString from: aPath 	| repository version |	repository := MCHttpRepository				location: aPath				user: ''				password: ''.	repository		versionReaderForFileNamed: aString , '.mcz'		do: [:reader | 			version := reader version.			version load.			version workingCopy repositoryGroup addRepository: repository]! !!ConfigurationOfGrease class methodsFor: 'development support' stamp: 'DaleHenrichs 1/14/2011 11:50'!compareVersions	"Compare the current #stable version to current #development version"	"self compareVersions"	"Note: you need 1.0-beta.28 or later for the class MetacelloToolBox"	self ensureMetacello.	((Smalltalk at: #MetacelloToolBox) compareVersionsIn: self) inspect! !!ConfigurationOfGrease class methodsFor: 'development support' stamp: 'pmm 8/26/2016 11:59'!copyMczFromSmalltalkhubToFileTree: aDirectoryPathString| latest source destination goSource goDestination |"Copy all latests packages to a filetree repository (that can be committed to github)self copyMczFromSmalltalkhubToFileTree: '/Users/jbrichau/github/Grease/repository/'self copyMczFromSmalltalkhubToFileTree: '/Users/marschall/git/Grease/repository'"source := (Smalltalk at: #MCSmalltalkhubRepository)   perform: #owner:project:user:password:  withArguments: #( 'Seaside' 'Grease11' '' '').destination := (Smalltalk at: #MCFileTreeRepository) 	new directory: (aDirectoryPathString perform: #asFileReference).goSource := Gofer new repository: source.goDestination := Gofer new repository: destination.latest := Dictionary new.(source goferReferences		perform: #groupedBy:        with: [:r | r packageName]) 			keysAndValuesDo:[:packageName :versions |					latest 						at: packageName 						put: (versions sorted:[:v1 :v2 | v1 versionNumber <= v2 versionNumber]) last].latest values do:[:version | 	goSource version: version name. 	goDestination version: version name].goSource fetch.goDestination push! !!ConfigurationOfGrease class methodsFor: 'development support' stamp: 'DaleHenrichs 1/11/2011 15:02'!createNewBaselineVersion	"Create a new baseline version based upon #stable version's baseline.	 A new baseline should be created if new packages have been added or package dependencies have changed."	"self createNewDevelopmentVersion"		"Note: you need 1.0-beta.28 or later for the class MetacelloToolBox"	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) createNewBaselineVersionIn: self description: ''! !!ConfigurationOfGrease class methodsFor: 'development support' stamp: 'DaleHenrichs 1/11/2011 15:01'!createNewDevelopmentVersion	"Create a new development version using the #stable version as model."	"self createNewDevelopmentVersion"		"Note: you need 1.0-beta.28 or later for the class MetacelloToolBox"	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) createNewDevelopmentVersionIn: self description: ''! !!ConfigurationOfGrease class methodsFor: 'private' stamp: 'DaleHenrichs 06/22/2010 09:39'!ensureMetacello	"Bootstrap Gofer (if necessary), load latest mcz file for ConfigurationOfMetacello (using old 	 Gofer API), then load the latest version of Metacello itself."	Smalltalk at: #MetacelloProject ifAbsent: [ | error |		"list of repositories to try, in case primary repository is not accessible"		(Array 			with: 'http://www.squeaksource.com/MetacelloRepository' 			with: 'http://seaside.gemstone.com/ss/metacello') do: [:repositoryUrl |				([					Smalltalk at: #Gofer ifAbsent: [						"Current version of Gofer from which to bootstrap - as of 1.0-beta.21"						self bootstrapPackage: 'Gofer-Core-lr.115' from: repositoryUrl ].					Smalltalk at: #Gofer ifPresent: [:goferClass | | gofer |						gofer := goferClass new							url: repositoryUrl;							yourself.						[ gofer addPackage: 'ConfigurationOfMetacello' ] on: Warning do: [:ex | ex resume ].						gofer load ]]							on: Error							do: [ :ex |								error := ex.								Transcript 									cr; 									show: 'failed ensureMetacello: ';									show: ex description printString;									show: '...retrying'.								"try again"								ex return: nil ]) ~~ nil					ifTrue: [						"load 'default' group of Metacello"						(Smalltalk at: #ConfigurationOfMetacello) perform: #load.						^self ]].		"shouldn't get here unless the load failed ... throw an error"		self error: 'retry with alternate repository failed: ', error description printString ]! !!ConfigurationOfGrease class methodsFor: 'metacello tool support' stamp: 'dkh 11/12/2009 09:11'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfGrease class methodsFor: 'metacello tool support' stamp: 'dkh 11/13/2009 16:33'!lastMetacelloVersionLoad	"Answer the last version loaded and the list of packages loaded for that version."	LastVersionLoad == nil ifTrue: [ LastVersionLoad := nil -> 'default' ].	^LastVersionLoad! !!ConfigurationOfGrease class methodsFor: 'loading' stamp: 'dkh 11/12/2009 09:11'!loadLatestVersion	"self loadLatestVersion"		^self project latestVersion load! !!ConfigurationOfGrease class methodsFor: 'metacello tool support' stamp: 'dkh 11/13/2009 16:33'!metacelloVersion: versionString loads: anArrayOrString	"Stash the last version loaded and the list of packages loaded for that version. The list	 of packages will be used by the tools when doing 'Load Package Version'"	LastVersionLoad := versionString -> anArrayOrString! !!ConfigurationOfGrease class methodsFor: 'accessing' stamp: 'dkh 11/12/2009 09:11'!project	^self new project! !!ConfigurationOfGrease class methodsFor: 'development support' stamp: 'DaleHenrichs 1/11/2011 15:05'!releaseDevelopmentVersion: commitMessage	"Release #development version (set version blessing to #release), update the #development and #stable symbolic versions and save the configuration."	"self releaseDevelopmentVersion: '- release version 1.0.2'"	"Note: you need 1.0-beta.28 or later for the class MetacelloToolBox"	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) releaseDevelopmentVersionIn: self description: commitMessage! !!ConfigurationOfGrease class methodsFor: 'development support' stamp: 'DaleHenrichs 12/06/2010 11:29'!saveConfiguration: commitMessage	"Save the configuration."	"self saveConfiguration: '- fixed bug'"	"Note: you need 1.0-beta.28 or later for the class MetacelloToolBox"	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) saveConfigurationPackageFor: self name asString description: commitMessage! !!ConfigurationOfGrease class methodsFor: 'development support' stamp: 'DaleHenrichs 12/06/2010 11:31'!saveModifiedPackages: commitMessage	"Save modified mcz files and update the configuration."	"self saveModifiedPackages: '- fixed bug'"	"Note: you need 1.0-beta.28 or later for the class MetacelloToolBox"	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) saveModifiedPackagesIn: self description:  commitMessage! !!ConfigurationOfGrease class methodsFor: 'development support' stamp: 'DaleHenrichs 12/06/2010 11:34'!saveModifiedPackagesAndConfiguration: commitMessage	"Save modified mcz files, update and then save the configuration."	"self saveModifiedPackagesAndConfiguration: '- fixed bug'"	"Note: you need 1.0-beta.28 or later for the class MetacelloToolBox"	self ensureMetacello.	(Smalltalk at: #MetacelloToolBox) saveModifiedPackagesAndConfigurationIn: self description: commitMessage! !!ConfigurationOfGrease class methodsFor: 'development support' stamp: 'DaleHenrichs 2/11/2011 13:41'!updateToLatestPackageVersions: descriptionString	"Updates mcz file versions in current version"	"self updateToLatestPackageVersions: '- latest mcz files for 1.0.4'"	"Note: you need 1.0-beta.28 or later for the class MetacelloToolBox"	self ensureMetacello.	((Smalltalk at: #MetacelloToolBox) updateToLatestPackageVersionsIn: self description: descriptionString) isEmpty		ifTrue: [ self inform: 'All specs up to date' ]! !!ConfigurationOfGrease class methodsFor: 'development support' stamp: 'DaleHenrichs 12/06/2010 11:57'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."		"self validate"	"Note: you need 1.0-beta.28 or later for the class MetacelloToolBox"	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'DaleHenrichs 11/17/2010 13:13'!baseline1011: spec	<version: '1.0.1.1-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: ''.		spec repository: 'http://www.squeaksource.com/Seaside30'.		spec 			package: 'Grease-Core';			package: 'Grease-Tests-Core' with: [				spec requires: #('Grease-Core' ). ].		spec 			group: 'Core' with: #('Grease-Core' );			group: 'Core Tests' with: #('Grease-Tests-Core' );			group: 'Slime' with: #('Core' );			group: 'Slime Tests' with: #('Core Tests' );			group: 'Tests' with: #('Core Tests' 'Slime Tests' );			group: 'default' with: #('Slime' ).].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Core' with: [				spec includes: #('Grease-Pharo-Core' ). ];			package: 'Grease-Tests-Core' with: [				spec includes: #('Grease-Tests-Pharo-Core' ). ];			package: 'Grease-Pharo-Core' with: [				spec requires: #('Grease-Core' ). ];			package: 'Grease-Tests-Pharo-Core' with: [				spec requires: #('Grease-Tests-Core' ). ].].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: [				spec					className: 'ConfigurationOfRefactoringBrowser';					versionString: '1.4';					loads: #('Refactoring-Core' );					repository: 'http://www.squeaksource.com/MetacelloRepository' ].		spec 			package: 'Grease-Slime' with: [				spec requires: #('Refactoring-Core' 'Grease-Core' ). ];			package: 'Grease-Tests-Slime' with: [				spec requires: #('Grease-Slime' ). ].		spec 			group: 'Slime' with: #('Grease-Slime' );			group: 'Slime Tests' with: #('Grease-Tests-Slime' ).].	spec for: #'GreaseForPharo1.0' do: [		spec 			package: 'Grease-Pharo-Core' with: [				spec includes: #('Grease-Pharo10-Core' ). ];			package: 'Grease-Pharo10-Core'.].	spec for: #'gemstone' do: [		spec repository: 'http://seaside.gemstone.com/ss/Seaside30'.		spec 			project: 'GsCore' with: [				spec					className: 'ConfigurationOfGsCore';					versionString: '0.241';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'UTF8' with: [				spec					className: 'ConfigurationOfGsMisc';					versionString: '0.237';					loads: #('Utf8Encoding' );					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'System-Digital-Signatures' copyFrom: 'UTF8' with: [				spec loads: #('System-Digital-Signatures' ) ];			project: 'SMTPMail' copyFrom: 'UTF8' with: [				spec loads: #('SMTPMail' ) ].		spec 			package: 'Grease-Core' with: [				spec includes: #('Grease-GemStone-Core' ). ];			package: 'Grease-Tests-Core' with: [				spec includes: #('Grease-Tests-GemStone-Core' ). ];			package: 'Grease-GemStone-Core' with: [				spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail' ). ];			package: 'Grease-Tests-GemStone-Core' with: [				spec requires: #('Grease-Tests-Core' ). ].].	spec for: #'gs2.3.x' do: [		spec 			package: 'Grease-GemStone-Core' with: [				spec includes: #('Grease-GemStone230-Core' ). ];			package: 'Grease-GemStone230-Core' with: [				spec requires: #('Grease-GemStone-Core' ). ].].	spec for: #'gs2.4.x' do: [		spec 			package: 'Grease-GemStone-Core' with: [				spec includes: #('Grease-GemStone240-Core' ). ];			package: 'Grease-GemStone240-Core' with: [				spec requires: #('Grease-GemStone-Core' ). ].].	spec for: #'gs3.x' do: [		spec 			package: 'Grease-GemStone-Core' with: [				spec includes: #('Grease-GemStone300-Core' ). ];			package: 'Grease-GemStone300-Core' with: [				spec requires: #('Grease-GemStone-Core' ). ].].! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'DaleHenrichs 11/10/2010 10:22'!baseline101: spec 	<version: '1.0.1-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://www.squeaksource.com/Seaside30'.		spec			package: 'Grease-Core';			package: 'Grease-Tests-Core' 				with: [ spec requires: #('Grease-Core' ). ];			yourself.		spec			group: 'Core' with: #('Grease-Core');			group: 'Core Tests' with: #('Grease-Tests-Core');			group: 'Slime' with: #('Core');			group: 'Slime Tests' with: #('Core Tests');			group: 'Tests' with: #('Core Tests' 'Slime Tests');			group: 'default' with: #('Slime');			yourself. ].	spec for: #squeakCommon do: [		spec			package: 'Grease-Core' 				with: [ spec includes: #('Grease-Pharo-Core' ) ];			package: 'Grease-Tests-Core' 				with: [ spec includes: #('Grease-Tests-Pharo-Core' ). ];			package: 'Grease-Pharo-Core' 				with: [ spec requires: #('Grease-Core' ) ];			package: 'Grease-Tests-Pharo-Core' 				with: [ spec requires: #('Grease-Tests-Core') ];								yourself. ].	spec for: #pharo do: [		spec			project: 'Refactoring-Core' with: [				spec					className: 'ConfigurationOfRefactoringBrowser';					versionString: '1.4';					loads: #('Refactoring-Core' );					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Grease-Slime' 				with: [ spec requires: #('Refactoring-Core' 'Grease-Core' ) ];			package: 'Grease-Tests-Slime' 				with: [ spec requires: #('Grease-Slime') ];								yourself.		spec			group: 'Slime' with: #('Grease-Slime');			group: 'Slime Tests' with: #('Grease-Tests-Slime');			yourself. ].	spec for: #'GreaseForPharo1.0' do: [		spec			package: 'Grease-Pharo-Core'				with: [ spec includes: #('Grease-Pharo10-Core' ) ];			package: 'Grease-Pharo10-Core';			yourself.].	spec for: #gemstone do: [		spec 			repository: 'http://seaside.gemstone.com/ss/Seaside30'.		spec 			project: 'GsCore' with: [				spec					className: 'ConfigurationOfGsCore';					versionString: '0.239.2-baseline';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'UTF8' with: [				spec					className: 'ConfigurationOfGsMisc';					versionString: '0.237-baseline';					loads: #('Utf8Encoding' );					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'System-Digital-Signatures'				copyFrom: 'UTF8'				with: [ spec loads: #('System-Digital-Signatures' ) ];			project: 'SMTPMail'				copyFrom: 'UTF8'				with: [ spec loads: #('SMTPMail' ) ];						yourself.		spec			package: 'Grease-Core' 				with: [ spec includes: #('Grease-GemStone-Core' ) ];			package: 'Grease-Tests-Core' 				with: [ spec includes: #('Grease-Tests-GemStone-Core' ). ];			package: 'Grease-GemStone-Core' 				with: [ spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail' ) ];			package: 'Grease-Tests-GemStone-Core' 				with: [ spec requires: #('Grease-Tests-Core' ) ];			yourself. ].	spec for: #'gs2.3.x' do: [		spec 			package: 'Grease-GemStone-Core' 				with: [ spec includes: #('Grease-GemStone230-Core' ) ];			package: 'Grease-GemStone230-Core' 				with: [ spec requires: #('Grease-GemStone-Core' ) ];			yourself. ].	spec for: #'gs2.4.x' do: [		spec 			package: 'Grease-GemStone-Core' 				with: [ spec includes: #('Grease-GemStone240-Core' ) ];			package: 'Grease-GemStone240-Core' 				with: [ spec requires: #('Grease-GemStone-Core' ) ];			yourself. ].	spec for: #'gs3.x' do: [		spec 			package: 'Grease-GemStone-Core' 				with: [ spec includes: #('Grease-GemStone300-Core' ) ];			package: 'Grease-GemStone300-Core' 				with: [ spec requires: #('Grease-GemStone-Core' ) ];			yourself. ].! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'pmm 11/21/2010 12:33'!baseline102: spec	<version: '1.0.2-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: ''.		spec repository: 'http://www.squeaksource.com/Seaside30'.		spec 			package: 'Grease-Core';			package: 'Grease-Tests-Core' with: [				spec requires: #('Grease-Core' ). ].		spec 			group: 'Core' with: #('Grease-Core' );			group: 'Core Tests' with: #('Grease-Tests-Core' );			group: 'Slime' with: #('Core' );			group: 'Slime Tests' with: #('Core Tests' );			group: 'Tests' with: #('Core Tests' 'Slime Tests' );			group: 'default' with: #('Slime' ).].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Core' with: [				spec includes: #('Grease-Pharo-Core' ). ];			package: 'Grease-Tests-Core' with: [				spec includes: #('Grease-Tests-Pharo-Core' ). ];			package: 'Grease-Pharo-Core' with: [				spec requires: #('Grease-Core' ). ];			package: 'Grease-Tests-Pharo-Core' with: [				spec requires: #('Grease-Tests-Core' ). ].].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: [				spec					className: 'ConfigurationOfRefactoringBrowser';					versionString: '1.4';					loads: #('Refactoring-Core' );					repository: 'http://www.squeaksource.com/MetacelloRepository' ].		spec 			package: 'Grease-Slime' with: [				spec requires: #('Refactoring-Core' 'Grease-Core' ). ];			package: 'Grease-Tests-Slime' with: [				spec requires: #('Grease-Slime' ). ].		spec 			group: 'Slime' with: #('Grease-Slime' );			group: 'Slime Tests' with: #('Grease-Tests-Slime' ).].	spec for: #'GreaseForPharo1.0' do: [		spec 			package: 'Grease-Pharo-Core' with: [				spec includes: #('Grease-Pharo10-Core' ). ];			package: 'Grease-Pharo10-Core'.].	spec for: #'gemstone' do: [		spec repository: 'http://seaside.gemstone.com/ss/Seaside30'.		spec 			project: 'GsCore' with: [				spec					className: 'ConfigurationOfGsCore';					versionString: '0.241';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'UTF8' with: [				spec					className: 'ConfigurationOfGsMisc';					versionString: '0.237';					loads: #('Utf8Encoding' );					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'System-Digital-Signatures' copyFrom: 'UTF8' with: [				spec loads: #('System-Digital-Signatures' ) ];			project: 'SMTPMail' copyFrom: 'UTF8' with: [				spec loads: #('SMTPMail' ) ].		spec 			package: 'Grease-Core' with: [				spec includes: #('Grease-GemStone-Core' ). ];			package: 'Grease-Tests-Core' with: [				spec includes: #('Grease-Tests-GemStone-Core' ). ];			package: 'Grease-GemStone-Core' with: [				spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail' ). ];			package: 'Grease-Tests-GemStone-Core' with: [				spec requires: #('Grease-Tests-Core' ). ].].	spec for: #'gs2.3.x' do: [		spec 			package: 'Grease-GemStone-Core' with: [				spec includes: #('Grease-GemStone230-Core' ). ];			package: 'Grease-GemStone230-Core' with: [				spec requires: #('Grease-GemStone-Core' ). ].].	spec for: #'gs2.4.x' do: [		spec 			package: 'Grease-GemStone-Core' with: [				spec includes: #('Grease-GemStone240-Core' ). ];			package: 'Grease-GemStone240-Core' with: [				spec requires: #('Grease-GemStone-Core' ). ].].	spec for: #'gs3.x' do: [		spec 			package: 'Grease-GemStone-Core' with: [				spec includes: #('Grease-GemStone300-Core' ). ];			package: 'Grease-GemStone300-Core' with: [				spec requires: #('Grease-GemStone-Core' ). ].].! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'DaleHenrichs 02/01/2011 11:41'!baseline103: spec	<version: '1.0.3-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: ''.		spec repository: 'http://www.squeaksource.com/Seaside30'.		spec 			package: 'Grease-Core';			package: 'Grease-Tests-Core' with: [				spec requires: #('Grease-Core' ). ].		spec 			group: 'Core' with: #('Grease-Core' );			group: 'Core Tests' with: #('Grease-Tests-Core' );			group: 'Slime' with: #('Core' );			group: 'Slime Tests' with: #('Core Tests' );			group: 'Tests' with: #('Core Tests' 'Slime Tests' );			group: 'default' with: #('Slime' ).].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Core' with: [				spec includes: #('Grease-Pharo-Core' ). ];			package: 'Grease-Tests-Core' with: [				spec includes: #('Grease-Tests-Pharo-Core' ). ];			package: 'Grease-Pharo-Core' with: [				spec requires: #('Grease-Core' ). ];			package: 'Grease-Tests-Pharo-Core' with: [				spec requires: #('Grease-Tests-Core' ). ].].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: [				spec					className: 'ConfigurationOfRefactoringBrowser';					versionString: '1.4';					loads: #('Refactoring-Core' );					repository: 'http://www.squeaksource.com/MetacelloRepository' ].		spec 			package: 'Grease-Slime' with: [				spec requires: #('Refactoring-Core' 'Grease-Core' ). ];			package: 'Grease-Tests-Slime' with: [				spec requires: #('Grease-Slime' ). ].		spec 			group: 'Slime' with: #('Grease-Slime' );			group: 'Slime Tests' with: #('Grease-Tests-Slime' ).].	spec for: #'GreaseForPharo1.0' do: [		spec 			package: 'Grease-Pharo-Core' with: [				spec includes: #('Grease-Pharo10-Core' ). ];			package: 'Grease-Pharo10-Core'.].	spec for: #'gemstone' do: [		spec repository: 'http://seaside.gemstone.com/ss/Seaside30'.		spec 			project: 'GsCore' with: [				spec					className: 'ConfigurationOfGsCore';					versionString: '0.241';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'UTF8' with: [				spec					className: 'ConfigurationOfGsMisc';					versionString: '0.237';					loads: #('Utf8Encoding' );					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'System-Digital-Signatures' copyFrom: 'UTF8' with: [				spec loads: #('System-Digital-Signatures' ) ];			project: 'SMTPMail' copyFrom: 'UTF8' with: [				spec loads: #('SMTPMail' ) ].		spec 			package: 'Grease-Core' with: [				spec 					requires: #('GsCore' );					includes: #('Grease-GemStone-Core' ). ];			package: 'Grease-Tests-Core' with: [				spec includes: #('Grease-Tests-GemStone-Core' ). ];			package: 'Grease-GemStone-Core' with: [				spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail' ). ];			package: 'Grease-Tests-GemStone-Core' with: [				spec requires: #('Grease-Tests-Core' ). ].].	spec for: #'gs2.3.x' do: [		spec 			package: 'Grease-GemStone-Core' with: [				spec includes: #('Grease-GemStone230-Core' ). ];			package: 'Grease-GemStone230-Core' with: [				spec requires: #('Grease-GemStone-Core' ). ].].	spec for: #'gs2.4.x' do: [		spec 			package: 'Grease-GemStone-Core' with: [				spec includes: #('Grease-GemStone240-Core' ). ];			package: 'Grease-GemStone240-Core' with: [				spec requires: #('Grease-GemStone-Core' ). ].].	spec for: #'gs3.x' do: [		spec 			package: 'Grease-GemStone-Core' with: [				spec includes: #('Grease-GemStone300-Core' ). ];			package: 'Grease-GemStone300-Core' with: [				spec requires: #('Grease-GemStone-Core' ). ].].! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'DaleHenrichs 2/10/2011 11:22'!baseline104: spec	<version: '1.0.4-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: ''.		spec repository: 'http://www.squeaksource.com/Seaside30'.		spec 			package: 'Grease-Core';			package: 'Grease-Tests-Core' with: [				spec requires: #('Grease-Core' ). ].		spec 			group: 'Core' with: #('Grease-Core' );			group: 'Core Tests' with: #('Grease-Tests-Core' );			group: 'Slime' with: #('Core' );			group: 'Slime Tests' with: #('Core Tests' );			group: 'Tests' with: #('Core Tests' 'Slime Tests' );			group: 'default' with: #('Slime' ).].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Core' with: [				spec includes: #('Grease-Pharo-Core' ). ];			package: 'Grease-Tests-Core' with: [				spec includes: #('Grease-Tests-Pharo-Core' ). ];			package: 'Grease-Pharo-Core' with: [				spec requires: #('Grease-Core' ). ];			package: 'Grease-Tests-Pharo-Core' with: [				spec requires: #('Grease-Tests-Core' ). ].].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: [				spec					className: 'ConfigurationOfRefactoringBrowser';					versionString: #'stable';					loads: #('Core' );					repository: 'http://www.squeaksource.com/MetacelloRepository' ].		spec 			package: 'Grease-Slime' with: [				spec requires: #('Refactoring-Core' 'Grease-Core' ). ];			package: 'Grease-Tests-Slime' with: [				spec requires: #('Grease-Slime' ). ].		spec 			group: 'Slime' with: #('Grease-Slime' );			group: 'Slime Tests' with: #('Grease-Tests-Slime' ).].	spec for: #'GreaseForPharo1.0' do: [		spec 			package: 'Grease-Pharo-Core' with: [				spec includes: #('Grease-Pharo10-Core' ). ];			package: 'Grease-Pharo10-Core'.].	spec for: #'gemstone' do: [		spec repository: 'http://seaside.gemstone.com/ss/Seaside30'.		spec 			project: 'GsCore' with: [				spec					className: 'ConfigurationOfGsCore';					versionString: #'stable';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'UTF8' with: [				spec					className: 'ConfigurationOfGsMisc';					versionString: #'stable';					loads: #('Utf8Encoding' );					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'System-Digital-Signatures' copyFrom: 'UTF8' with: [				spec loads: #('System-Digital-Signatures' ) ];			project: 'SMTPMail' copyFrom: 'UTF8' with: [				spec loads: #('SMTPMail' ) ].		spec 			package: 'Grease-Core' with: [				spec 					requires: #('GsCore' );					includes: #('Grease-GemStone-Core' ). ];			package: 'Grease-Tests-Core' with: [				spec includes: #('Grease-Tests-GemStone-Core' ). ];			package: 'Grease-GemStone-Core' with: [				spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail' ). ];			package: 'Grease-Tests-GemStone-Core' with: [				spec requires: #('Grease-Tests-Core' ). ].].	spec for: #'gs2.3.x' do: [		spec 			package: 'Grease-GemStone-Core' with: [				spec includes: #('Grease-GemStone230-Core' ). ];			package: 'Grease-GemStone230-Core' with: [				spec requires: #('Grease-GemStone-Core' ). ].].	spec for: #'gs2.4.x' do: [		spec 			package: 'Grease-GemStone-Core' with: [				spec includes: #('Grease-GemStone240-Core' ). ];			package: 'Grease-GemStone240-Core' with: [				spec requires: #('Grease-GemStone-Core' ). ].].	spec for: #'gs3.x' do: [		spec 			package: 'Grease-GemStone-Core' with: [				spec includes: #('Grease-GemStone300-Core' ). ];			package: 'Grease-GemStone300-Core' with: [				spec requires: #('Grease-GemStone-Core' ). ].].! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'dkh 10/14/2011 17:01'!baseline1061: spec	<version: '1.0.6.1-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: ''.		spec repository: 'http://www.squeaksource.com/Seaside30'.		spec 			package: 'Grease-Core';			package: 'Grease-Tests-Core' with: [				spec requires: #('Grease-Core' ). ].		spec 			group: 'Core' with: #('Grease-Core' );			group: 'Core Tests' with: #('Grease-Tests-Core' );			group: 'Slime' with: #('Core' );			group: 'Slime Tests' with: #('Core Tests' );			group: 'Tests' with: #('Core Tests' 'Slime Tests' );			group: 'default' with: #('Slime' ).].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Core' with: [				spec includes: #('Grease-Pharo-Core' ). ];			package: 'Grease-Tests-Core' with: [				spec includes: #('Grease-Tests-Pharo-Core' ). ];			package: 'Grease-Pharo-Core' with: [				spec requires: #('Grease-Core' ). ];			package: 'Grease-Tests-Pharo-Core' with: [				spec requires: #('Grease-Tests-Core' ). ].].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: [				spec					className: 'ConfigurationOfRefactoringBrowser';					versionString: #'stable';					loads: #('Core' );					repository: 'http://www.squeaksource.com/MetacelloRepository' ].		spec 			package: 'Grease-Slime' with: [				spec requires: #('Refactoring-Core' 'Grease-Core' ). ];			package: 'Grease-Tests-Slime' with: [				spec requires: #('Grease-Slime' ). ].		spec 			group: 'Slime' with: #('Grease-Slime' );			group: 'Slime Tests' with: #('Grease-Tests-Slime' ).].	spec for: #'GreaseForPharo1.0' do: [		spec 			package: 'Grease-Pharo-Core' with: [				spec includes: #('Grease-Pharo10-Core' ). ];			package: 'Grease-Pharo10-Core'.].	spec for: #'gemstone' do: [		spec repository: 'http://seaside.gemstone.com/ss/Seaside30'.		spec 			project: 'GsCore' with: [				spec					className: 'ConfigurationOfGsCore';					versionString: #'stable';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'UTF8' with: [				spec					className: 'ConfigurationOfGsMisc';					versionString: #'stable';					loads: #('Utf8Encoding' );					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'System-Digital-Signatures' copyFrom: 'UTF8' with: [				spec loads: #('System-Digital-Signatures' ) ];			project: 'SMTPMail' copyFrom: 'UTF8' with: [				spec loads: #('SMTPMail' ) ].		spec 			package: 'Grease-Core' with: [				spec 					requires: #('GsCore' );					includes: #('Grease-GemStone-Core' ). ];			package: 'Grease-Tests-Core' with: [				spec includes: #('Grease-Tests-GemStone-Core' ). ];			package: 'Grease-GemStone-Core' with: [				spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail' ). ];			package: 'Grease-Tests-GemStone-Core' with: [				spec requires: #('Grease-Tests-Core' ). ].].	spec for: #'gs2.x' do: [		spec 			package: 'Grease-GemStone-Core' with: [				spec includes: #('Grease-GemStone200-Core' ). ];			package: 'Grease-GemStone200-Core' with: [				spec requires: #('Grease-GemStone-Core' ). ].].	spec for: #'gs2.3.x' do: [		spec 			package: 'Grease-GemStone-Core' with: [				spec includes: #('Grease-GemStone230-Core' ). ];			package: 'Grease-GemStone230-Core' with: [				spec requires: #('Grease-GemStone-Core' ). ].].	spec for: #'gs2.4.x' do: [		spec 			package: 'Grease-GemStone-Core' with: [				spec includes: #('Grease-GemStone240-Core' ). ];			package: 'Grease-GemStone240-Core' with: [				spec requires: #('Grease-GemStone-Core' ). ].].	spec for: #'gs3.x' do: [		spec 			package: 'Grease-GemStone-Core' with: [				spec includes: #('Grease-GemStone300-Core' ). ];			package: 'Grease-GemStone300-Core' with: [				spec requires: #('Grease-GemStone-Core' ). ].].! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'dkh 06/15/2014 13:56'!baseline1071: spec  <version: '1.0.7.1-baseline'>  spec    for: #'common'    do: [       spec blessing: #'baseline'.      spec description: ''.      spec repository: 'http://www.squeaksource.com/Seaside30'.      spec        package: 'Grease-Core';        package: 'Grease-Tests-Core' with: [ spec requires: #('Grease-Core') ].      spec        group: 'Core' with: #('Grease-Core');        group: 'Core Tests' with: #('Grease-Tests-Core');        group: 'Slime' with: #('Core');        group: 'Slime Tests' with: #('Core Tests');        group: 'Tests' with: #('Core Tests' 'Slime Tests');        group: 'default' with: #('Slime') ].  spec    for: #'squeakCommon'    do: [       spec        package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo-Core') ];        package: 'Grease-Tests-Core'          with: [ spec includes: #('Grease-Tests-Pharo-Core') ];        package: 'Grease-Pharo-Core' with: [ spec requires: #('Grease-Core') ];        package: 'Grease-Tests-Pharo-Core'          with: [ spec requires: #('Grease-Tests-Core') ] ].  spec    for: #'pharo1.x'    do: [       spec        project: 'Refactoring-Core'        with: [           spec            className: 'ConfigurationOfRefactoringBrowser';            versionString: #'stable';            loads: #('Core');            repository: 'http://www.squeaksource.com/MetacelloRepository' ].      spec        package: 'Grease-Slime'          with: [ spec requires: #('Refactoring-Core' 'Grease-Core') ];        package: 'Grease-Tests-Slime'          with: [ spec requires: #('Grease-Slime') ].      spec        group: 'Slime' with: #('Grease-Slime');        group: 'Slime Tests' with: #('Grease-Tests-Slime') ].  spec    for: #'pharo1.x'    do: [       spec        package: 'Grease-Pharo-Core'          with: [ spec includes: #('Grease-Pharo13-Core') ];        package: 'Grease-Pharo13-Core' ].  spec    for: #'squeak'    do: [       spec        package: 'Grease-Pharo-Core'          with: [ spec includes: #('Grease-Pharo13-Core') ];        package: 'Grease-Pharo13-Core' ].  spec    for: #'GreaseForPharo1.0'    do: [       spec        package: 'Grease-Pharo-Core'          with: [ spec includes: #('Grease-Pharo10-Core') ];        package: 'Grease-Pharo10-Core' ].  spec    for: #'gemstone'    do: [       spec repository: 'http://seaside.gemtalksystems.com/ss/Seaside30'.      spec        project: 'GsCore'          with: [               spec                className: 'ConfigurationOfGsCore';                versionString: #'stable';                repository:                    'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];        project: 'UTF8'          with: [               spec                className: 'ConfigurationOfGsMisc';                versionString: #'stable';                loads: #('Utf8Encoding');                repository:                    'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];        project: 'System-Digital-Signatures'          copyFrom: 'UTF8'          with: [ spec loads: #('System-Digital-Signatures') ];        project: 'SMTPMail'          copyFrom: 'UTF8'          with: [ spec loads: #('SMTPMail') ].      spec        package: 'Grease-Core'          with: [               spec                requires: #('GsCore');                includes: #('Grease-GemStone-Core') ];        package: 'Grease-Tests-Core'          with: [ spec includes: #('Grease-Tests-GemStone-Core') ];        package: 'Grease-GemStone-Core'          with: [               spec                requires:                  #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail') ];        package: 'Grease-Tests-GemStone-Core'          with: [ spec requires: #('Grease-Tests-Core') ] ].  spec    for: #'gs2.x'    do: [       spec        package: 'Grease-GemStone-Core'          with: [ spec includes: #('Grease-GemStone200-Core') ];        package: 'Grease-GemStone200-Core'          with: [ spec requires: #('Grease-GemStone-Core') ] ].  spec    for: #'gs2.3.x'    do: [       spec        package: 'Grease-GemStone-Core'          with: [ spec includes: #('Grease-GemStone230-Core') ];        package: 'Grease-GemStone230-Core'          with: [ spec requires: #('Grease-GemStone-Core') ] ].  spec    for: #'gs2.4.x'    do: [       spec        package: 'Grease-GemStone-Core'          with: [ spec includes: #('Grease-GemStone240-Core') ];        package: 'Grease-GemStone240-Core'          with: [ spec requires: #('Grease-GemStone-Core') ] ].  spec    for: #'gs3.x'    do: [       spec        package: 'Grease-GemStone-Core'          with: [ spec includes: #('Grease-GemStone300-Core') ];        package: 'Grease-GemStone300-Core'          with: [ spec requires: #('Grease-GemStone-Core') ] ]! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'JohanBrichau 6/15/2014 20:58'!baseline108: spec	<version: '1.0.8-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec description: ''.			spec repository: 'http://www.smalltalkhub.com/mc/Seaside/Grease10/main'.			spec				package: 'Grease-Core';				package: 'Grease-Tests-Core' with: [ spec requires: #('Grease-Core') ].			spec				group: 'Core' with: #('Grease-Core');				group: 'Core Tests' with: #('Grease-Tests-Core');				group: 'Slime' with: #('Core');				group: 'Slime Tests' with: #('Core Tests');				group: 'Tests' with: #('Core Tests' 'Slime Tests');				group: 'default' with: #('Slime') ].	"use Grease-Pharo-Core for Squeak and Pharo 1.x"	spec		for: #squeak		do: [ 			self greaseCoreAndTestsForSqueakAndPharo1x: spec.			self slimeForSqueakPharo1xPharo2x: spec.			spec				package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo13-Core') ];				package: 'Grease-Pharo13-Core' ].	spec		for: #'pharo1.x'		do: [ 			self greaseCoreAndTestsForSqueakAndPharo1x: spec.			self slimeForSqueakPharo1xPharo2x: spec.			spec				package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo13-Core') ];				package: 'Grease-Pharo13-Core' ].	spec for: #'pharo2.x' do: [ self slimeForSqueakPharo1xPharo2x: spec ].	"use Grease-Pharo20-Core for Pharo 2 and 3"	spec		for: #(#'pharo2.x' #'pharo3.x')		do: [ 			spec				package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo20-Core') ];				package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo-Core') ];				package: 'Grease-Pharo20-Core' with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Pharo-Core' with: [ spec requires: #('Grease-Tests-Core') ] ].	"don't load RB/Slime into Pharo 3"	spec		for: #'GreaseForPharo1.0'		do: [ 			spec				package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo10-Core') ];				package: 'Grease-Pharo10-Core' ].	spec		for: #gemstone		do: [ 			spec repository: 'http://seaside.gemtalksystems.com/ss/Seaside30'.			spec				project: 'GsCore'					with: [ 							spec								className: 'ConfigurationOfGsCore';								versionString: #stable;								repository: 'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];				project: 'UTF8'					with: [ 							spec								className: 'ConfigurationOfGsMisc';								versionString: #stable;								loads: #('Utf8Encoding');								repository: 'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];				project: 'System-Digital-Signatures' copyFrom: 'UTF8' with: [ spec loads: #('System-Digital-Signatures') ];				project: 'SMTPMail' copyFrom: 'UTF8' with: [ spec loads: #('SMTPMail') ].			spec				package: 'Grease-Core'					with: [ 							spec								requires: #('GsCore');								includes: #('Grease-GemStone-Core') ];				package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-GemStone-Core') ];				package: 'Grease-GemStone-Core'					with: [ spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail') ];				package: 'Grease-Tests-GemStone-Core' with: [ spec requires: #('Grease-Tests-Core') ] ].	spec		for: #'gs2.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone200-Core') ];				package: 'Grease-GemStone200-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ].	spec		for: #'gs2.3.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone230-Core') ];				package: 'Grease-GemStone230-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ].	spec		for: #'gs2.4.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone240-Core') ];				package: 'Grease-GemStone240-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ].	spec		for: #'gs3.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone300-Core') ];				package: 'Grease-GemStone300-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ]! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'StephanEggermont 6/25/2014 10:19'!baseline109: spec	<version: '1.0.9-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec description: ''.			spec repository: 'http://www.smalltalkhub.com/mc/Seaside/Grease10/main'.			spec				package: 'Grease-Core';				package: 'Grease-Tests-Core' with: [ spec requires: #('Grease-Core') ].			spec				group: 'Core' with: #('Grease-Core');				group: 'Core Tests' with: #('Grease-Tests-Core');				group: 'Slime' with: #('Core');				group: 'Slime Tests' with: #('Core Tests');				group: 'Tests' with: #('Core Tests' 'Slime Tests');				group: 'default' with: #('Slime') ].	"use Grease-Pharo-Core for Squeak and Pharo 1.x"	spec		for: #squeak		do: [ 			self greaseCoreAndTestsForSqueakAndPharo1x: spec.			self slimeForSqueakPharo1xPharo2x: spec.			spec				package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo13-Core') ];				package: 'Grease-Pharo13-Core' ].	spec		for: #'pharo1.x'		do: [ 			self greaseCoreAndTestsForSqueakAndPharo1x: spec.			self slimeForSqueakPharo1xPharo2x: spec.			spec				package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo13-Core') ];				package: 'Grease-Pharo13-Core' ].	spec		for: #(#'pharo2.x' #'pharo3.x' #'pharo4.x')		do: [ 			spec				package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo20-Core') ];				package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo-Core') ];				package: 'Grease-Pharo20-Core' with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Pharo-Core' with: [ spec requires: #('Grease-Tests-Core') ].							spec				package: 'Grease-Slime' with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Slime' with: [ spec requires: #('Grease-Slime') ].			spec				group: 'Slime' with: #('Grease-Slime');				group: 'Slime Tests' with: #('Grease-Tests-Slime') 	].	spec		for: #'GreaseForPharo1.0'		do: [ 			spec				package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo10-Core') ];				package: 'Grease-Pharo10-Core' ].	spec		for: #gemstone		do: [ 			spec repository: 'http://seaside.gemtalksystems.com/ss/Seaside30'.			spec				project: 'GsCore'					with: [ 							spec								className: 'ConfigurationOfGsCore';								versionString: #stable;								repository: 'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];				project: 'UTF8'					with: [ 							spec								className: 'ConfigurationOfGsMisc';								versionString: #stable;								loads: #('Utf8Encoding');								repository: 'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];				project: 'System-Digital-Signatures' copyFrom: 'UTF8' with: [ spec loads: #('System-Digital-Signatures') ];				project: 'SMTPMail' copyFrom: 'UTF8' with: [ spec loads: #('SMTPMail') ].			spec				package: 'Grease-Core'					with: [ 							spec								requires: #('GsCore');								includes: #('Grease-GemStone-Core') ];				package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-GemStone-Core') ];				package: 'Grease-GemStone-Core'					with: [ spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail') ];				package: 'Grease-Tests-GemStone-Core' with: [ spec requires: #('Grease-Tests-Core') ] ].	spec		for: #'gs2.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone200-Core') ];				package: 'Grease-GemStone200-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ].	spec		for: #'gs2.3.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone230-Core') ];				package: 'Grease-GemStone230-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ].	spec		for: #'gs2.4.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone240-Core') ];				package: 'Grease-GemStone240-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ].	spec		for: #'gs3.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone300-Core') ];				package: 'Grease-GemStone300-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ]! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'DaleHenrichs 10/9/2010 11:40'!baseline10: spec 	<version: '1.0-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://www.squeaksource.com/Seaside30'.		spec			package: 'Grease-Core';			package: 'Grease-Tests-Core' 				with: [ spec requires: #('Grease-Core' ). ];			yourself.		spec			group: 'Core' with: #('Grease-Core');			group: 'Core Tests' with: #('Grease-Tests-Core');			group: 'Slime' with: #('Core');			group: 'Slime Tests' with: #('Core Tests');			group: 'Tests' with: #('Core Tests' 'Slime Tests');			group: 'default' with: #('Slime');			yourself. ].	spec for: #squeakCommon do: [		spec			package: 'Grease-Core' 				with: [ spec includes: #('Grease-Pharo-Core' ) ];			package: 'Grease-Tests-Core' 				with: [ spec includes: #('Grease-Tests-Pharo-Core' ). ];			package: 'Grease-Pharo-Core' 				with: [ spec requires: #('Grease-Core' ) ];			package: 'Grease-Tests-Pharo-Core' 				with: [ spec requires: #('Grease-Tests-Core') ];								yourself. ].	spec for: #pharo do: [		spec			project: 'Refactoring-Core' with: [				spec					className: 'ConfigurationOfRefactoringBrowser';					versionString: '1.2-baseline';					loads: #('Refactoring-Core' );					file: 'ConfigurationOfRefactoringBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Grease-Slime' 				with: [ spec requires: #('Refactoring-Core' 'Grease-Core' ) ];			package: 'Grease-Tests-Slime' 				with: [ spec requires: #('Grease-Slime') ];								yourself.		spec			group: 'Slime' with: #('Grease-Slime');			group: 'Slime Tests' with: #('Grease-Tests-Slime');			yourself. ].	spec for: #'GreaseForPharo1.0' do: [		spec			package: 'Grease-Pharo-Core'				with: [ spec includes: #('Grease-Pharo10-Core' ) ];			package: 'Grease-Pharo10-Core';			yourself.].	spec for: #gemstone do: [		spec 			repository: 'http://seaside.gemstone.com/ss/Seaside30'.		spec 			project: 'GsCore' with: [				spec					className: 'ConfigurationOfGsCore';					versionString: '0.239-baseline';					file: 'ConfigurationOfGsCore';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'UTF8' with: [				spec					className: 'ConfigurationOfGsMisc';					versionString: '0.236-baseline';					loads: #('Utf8Encoding' );					file: 'ConfigurationOfGsMisc';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'System-Digital-Signatures'				copyFrom: 'UTF8'				with: [ spec loads: #('System-Digital-Signatures' ) ];			project: 'SMTPMail'				copyFrom: 'UTF8'				with: [ spec loads: #('SMTPMail' ) ];						yourself.		spec			package: 'Grease-Core' 				with: [ spec includes: #('Grease-GemStone-Core' ) ];			package: 'Grease-Tests-Core' 				with: [ spec includes: #('Grease-Tests-GemStone-Core' ). ];			package: 'Grease-GemStone-Core' 				with: [ spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail' ) ];			package: 'Grease-Tests-GemStone-Core' 				with: [ spec requires: #('Grease-Tests-Core' ) ];			yourself. ].	spec for: #'gs2.3.x' do: [		spec 			package: 'Grease-GemStone-Core' 				with: [ spec includes: #('Grease-GemStone230-Core' ) ];			package: 'Grease-GemStone230-Core' 				with: [ spec requires: #('Grease-GemStone-Core' ) ];			yourself. ].	spec for: #'gs2.4.x' do: [		spec 			package: 'Grease-GemStone-Core' 				with: [ spec includes: #('Grease-GemStone240-Core' ) ];			package: 'Grease-GemStone240-Core' 				with: [ spec requires: #('Grease-GemStone-Core' ) ];			yourself. ].	spec for: #'gs3.x' do: [		spec 			package: 'Grease-GemStone-Core' 				with: [ spec includes: #('Grease-GemStone300-Core' ) ];			package: 'Grease-GemStone300-Core' 				with: [ spec requires: #('Grease-GemStone-Core' ) ];			yourself. ].! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'dkh 01/06/2010 11:33'!baseline10alpha1: spec 	<version: '1.0-alpha1-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://www.squeaksource.com/Seaside30'.		spec			package: 'Grease-Core';			package: 'Grease-Tests-Core' 				with: [ spec requires: #('Grease-Core' ). ];			yourself. ].	spec for: #squeakCommon do: [		spec			package: 'Grease-Core' 				with: [ spec includes: #('Grease-Pharo-Core' ) ];			package: 'Grease-Tests-Core' 				with: [ spec includes: #('Grease-Tests-Pharo-Core' ). ];			package: 'Grease-Pharo-Core' 				with: [ spec requires: #('Grease-Core' ) ];			package: 'Grease-Tests-Pharo-Core' 				with: [ spec requires: #('Grease-Tests-Core') ];								yourself. ].	spec for: #gemstone do: [		spec 			repository: 'http://seaside.gemstone.com/ss/Seaside30'.		spec 			project: 'UTF8' with: [				spec					className: 'ConfigurationOfGsMisc';					versionString: '0.233';					loads: #('Utf8Encoding' );					file: 'ConfigurationOfGsMisc';					repository: 'http://seaside.gemstone.com/ss/GLASSproject' ];			project: 'System-Digital-Signatures'				copyFrom: 'UTF8'				with: [ spec loads: #('System-Digital-Signatures' ) ];			yourself.		spec			package: 'Grease-Core' 				with: [ spec includes: #('Grease-GemStone-Core' ) ];			package: 'Grease-Tests-Core' 				with: [ spec includes: #('Grease-Tests-GemStone-Core' ). ];			package: 'Grease-GemStone-Core' 				with: [ spec requires: #('Grease-Core' 'System-Digital-Signatures' 'UTF8' ) ];			package: 'Grease-Tests-GemStone-Core' 				with: [ spec requires: #('Grease-Tests-Core' ) ];			yourself. ].! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'dkh 11/23/2009 15:11'!baseline10alpha2: spec 	<version: '1.0-alpha2-baseline' imports: #('1.0-alpha1-baseline' )>	spec for: #gemstone do: [		spec			project: 'SMTPMail'				copyFrom: 'UTF8'				with: [ spec loads: #('SMTPMail' ) ];						yourself.		spec 			package: 'Grease-GemStone-Core' 				with: [ spec requires: #('SMTPMail' ) ];			yourself. ].	spec for: #'gs2.3.x' do: [		spec 			package: 'Grease-GemStone-Core' 				with: [ spec includes: #('Grease-GemStone230-Core' ) ];			package: 'Grease-GemStone230-Core' 				with: [ spec requires: #('Grease-GemStone-Core' ) ];			yourself. ].! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'dkh 1/27/2010 15:45'!baseline10alpha5: spec 	<version: '1.0-alpha5-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://www.squeaksource.com/Seaside30'.		spec			package: 'Grease-Core';			package: 'Grease-Tests-Core' 				with: [ spec requires: #('Grease-Core' ). ];			yourself.		spec			group: 'default' with: #('Core');			group: 'Core' with: #('Grease-Core');			group: 'Tests' with: #('Grease-Tests-Core');			yourself. ].	spec for: #squeakCommon do: [		spec			package: 'Grease-Core' 				with: [ spec includes: #('Grease-Pharo-Core' ) ];			package: 'Grease-Tests-Core' 				with: [ spec includes: #('Grease-Tests-Pharo-Core' ). ];			package: 'Grease-Pharo-Core' 				with: [ spec requires: #('Grease-Core' ) ];			package: 'Grease-Tests-Pharo-Core' 				with: [ spec requires: #('Grease-Tests-Core') ];								yourself.		spec			group: 'Core' with: #('Grease-Pharo-Core');			group: 'Tests' with: #('Grease-Tests-Pharo-Core');			yourself. ].	spec for: #pharo do: [		spec			project: 'Refactoring-Core' with: [				spec					className: 'ConfigurationOfRefactoringBrowser';					versionString: '1.1-baseline';					loads: #('Refactoring-Core' );					file: 'ConfigurationOfRefactoringBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Grease-Slime' 				with: [ spec requires: #('Refactoring-Core' 'Grease-Core' ) ];			package: 'Grease-Tests-Slime' 				with: [ spec requires: #('Grease-Slime') ];								yourself.		spec			group: 'Core' with: #('Grease-Slime');			group: 'Tests' with: #('Grease-Tests-Slime');			yourself. ].		spec for: #gemstone do: [		spec 			repository: 'http://seaside.gemstone.com/ss/Seaside30'.		spec 			project: 'UTF8' with: [				spec					className: 'ConfigurationOfGsMisc';					versionString: '0.233';					loads: #('Utf8Encoding' );					file: 'ConfigurationOfGsMisc';					repository: 'http://seaside.gemstone.com/ss/GLASSproject' ];			project: 'System-Digital-Signatures'				copyFrom: 'UTF8'				with: [ spec loads: #('System-Digital-Signatures' ) ];			project: 'SMTPMail'				copyFrom: 'UTF8'				with: [ spec loads: #('SMTPMail' ) ];						yourself.		spec			package: 'Grease-Core' 				with: [ spec includes: #('Grease-GemStone-Core' ) ];			package: 'Grease-Tests-Core' 				with: [ spec includes: #('Grease-Tests-GemStone-Core' ). ];			package: 'Grease-GemStone-Core' 				with: [ spec requires: #('Grease-Core' 'System-Digital-Signatures' 'UTF8' 'SMTPMail' ) ];			package: 'Grease-Tests-GemStone-Core' 				with: [ spec requires: #('Grease-Tests-Core' ) ];			yourself.		spec			group: 'Core' with: #('Grease-GemStone-Core');			group: 'Tests' with: #('Grease-Tests-GemStone-Core');			yourself. ].	spec for: #'gs2.3.x' do: [		spec 			package: 'Grease-GemStone-Core' 				with: [ spec includes: #('Grease-GemStone230-Core' ) ];			package: 'Grease-GemStone230-Core' 				with: [ spec requires: #('Grease-GemStone-Core' ) ];			yourself.		spec			group: 'Core' with: #('Grease-GemStone230-Core');			yourself. ].! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'DaleHenrichs 3/29/2010 11:12'!baseline10alpha7: spec 	<version: '1.0-alpha7-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://www.squeaksource.com/Seaside30'.		spec			package: 'Grease-Core';			package: 'Grease-Tests-Core' 				with: [ spec requires: #('Grease-Core' ). ];			yourself.		spec			group: 'default' with: #('Core');			group: 'Core' with: #('Grease-Core');			group: 'Tests' with: #('Grease-Tests-Core');			yourself. ].	spec for: #squeakCommon do: [		spec			package: 'Grease-Core' 				with: [ spec includes: #('Grease-Pharo-Core' ) ];			package: 'Grease-Tests-Core' 				with: [ spec includes: #('Grease-Tests-Pharo-Core' ). ];			package: 'Grease-Pharo-Core' 				with: [ spec requires: #('Grease-Core' ) ];			package: 'Grease-Tests-Pharo-Core' 				with: [ spec requires: #('Grease-Tests-Core') ];								yourself.		spec			group: 'Core' with: #('Grease-Pharo-Core');			group: 'Tests' with: #('Grease-Tests-Pharo-Core');			yourself. ].	spec for: #pharo do: [		spec			project: 'Refactoring-Core' with: [				spec					className: 'ConfigurationOfRefactoringBrowser';					versionString: '1.2-baseline';					loads: #('Refactoring-Core' );					file: 'ConfigurationOfRefactoringBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Grease-Slime' 				with: [ spec requires: #('Refactoring-Core' 'Grease-Core' ) ];			package: 'Grease-Tests-Slime' 				with: [ spec requires: #('Grease-Slime') ];								yourself.		spec			group: 'Core' with: #('Grease-Slime');			group: 'Tests' with: #('Grease-Tests-Slime');			yourself. ].		spec for: #gemstone do: [		spec 			repository: 'http://seaside.gemstone.com/ss/Seaside30'.		spec 			project: 'UTF8' with: [				spec					className: 'ConfigurationOfGsMisc';					versionString: '0.233';					loads: #('Utf8Encoding' );					file: 'ConfigurationOfGsMisc';					repository: 'http://seaside.gemstone.com/ss/GLASSproject' ];			project: 'System-Digital-Signatures'				copyFrom: 'UTF8'				with: [ spec loads: #('System-Digital-Signatures' ) ];			project: 'SMTPMail'				copyFrom: 'UTF8'				with: [ spec loads: #('SMTPMail' ) ];						yourself.		spec			package: 'Grease-Core' 				with: [ spec includes: #('Grease-GemStone-Core' ) ];			package: 'Grease-Tests-Core' 				with: [ spec includes: #('Grease-Tests-GemStone-Core' ). ];			package: 'Grease-GemStone-Core' 				with: [ spec requires: #('Grease-Core' 'System-Digital-Signatures' 'UTF8' 'SMTPMail' ) ];			package: 'Grease-Tests-GemStone-Core' 				with: [ spec requires: #('Grease-Tests-Core' ) ];			yourself.		spec			group: 'Core' with: #('Grease-GemStone-Core');			group: 'Tests' with: #('Grease-Tests-GemStone-Core');			yourself. ].	spec for: #'gs2.3.x' do: [		spec 			package: 'Grease-GemStone-Core' 				with: [ spec includes: #('Grease-GemStone230-Core' ) ];			package: 'Grease-GemStone230-Core' 				with: [ spec requires: #('Grease-GemStone-Core' ) ];			yourself.		spec			group: 'Core' with: #('Grease-GemStone230-Core');			yourself. ].! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'DaleHenrichs 08/12/2010 10:09'!baseline10alpha93: spec 	<version: '1.0-alpha9.3-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://www.squeaksource.com/Seaside30'.		spec			package: 'Grease-Core';			package: 'Grease-Tests-Core' 				with: [ spec requires: #('Grease-Core' ). ];			yourself.		spec			group: 'Core' with: #('Grease-Core');			group: 'Core Tests' with: #('Grease-Tests-Core');			group: 'Slime' with: #('Core');			group: 'Slime Tests' with: #('Core Tests');			group: 'Tests' with: #('Core Tests' 'Slime Tests');			group: 'default' with: #('Slime');			yourself. ].	spec for: #squeakCommon do: [		spec			package: 'Grease-Core' 				with: [ spec includes: #('Grease-Pharo-Core' ) ];			package: 'Grease-Tests-Core' 				with: [ spec includes: #('Grease-Tests-Pharo-Core' ). ];			package: 'Grease-Pharo-Core' 				with: [ spec requires: #('Grease-Core' ) ];			package: 'Grease-Tests-Pharo-Core' 				with: [ spec requires: #('Grease-Tests-Core') ];								yourself. ].	spec for: #pharo do: [		spec			project: 'Refactoring-Core' with: [				spec					className: 'ConfigurationOfRefactoringBrowser';					versionString: '1.2-baseline';					loads: #('Refactoring-Core' );					file: 'ConfigurationOfRefactoringBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Grease-Slime' 				with: [ spec requires: #('Refactoring-Core' 'Grease-Core' ) ];			package: 'Grease-Tests-Slime' 				with: [ spec requires: #('Grease-Slime') ];								yourself.		spec			group: 'Slime' with: #('Grease-Slime');			group: 'Slime Tests' with: #('Grease-Tests-Slime');			yourself. ].		spec for: #gemstone do: [		spec 			repository: 'http://seaside.gemstone.com/ss/Seaside30'.		spec 			project: 'GsCore' with: [				spec					className: 'ConfigurationOfGsCore';					versionString: '0.239-baseline';					file: 'ConfigurationOfGsCore';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'UTF8' with: [				spec					className: 'ConfigurationOfGsMisc';					versionString: '0.236-baseline';					loads: #('Utf8Encoding' );					file: 'ConfigurationOfGsMisc';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'System-Digital-Signatures'				copyFrom: 'UTF8'				with: [ spec loads: #('System-Digital-Signatures' ) ];			project: 'SMTPMail'				copyFrom: 'UTF8'				with: [ spec loads: #('SMTPMail' ) ];						yourself.		spec			package: 'Grease-Core' 				with: [ spec includes: #('Grease-GemStone-Core' ) ];			package: 'Grease-Tests-Core' 				with: [ spec includes: #('Grease-Tests-GemStone-Core' ). ];			package: 'Grease-GemStone-Core' 				with: [ spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail' ) ];			package: 'Grease-Tests-GemStone-Core' 				with: [ spec requires: #('Grease-Tests-Core' ) ];			yourself. ].	spec for: #'gs2.3.x' do: [		spec 			package: 'Grease-GemStone-Core' 				with: [ spec includes: #('Grease-GemStone230-Core' ) ];			package: 'Grease-GemStone230-Core' 				with: [ spec requires: #('Grease-GemStone-Core' ) ];			yourself. ].! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'DaleHenrichs 08/12/2010 10:09'!baseline10rc: spec 	<version: '1.0-rc-baseline'>	spec for: #common do: [		spec blessing: #baseline.		spec repository: 'http://www.squeaksource.com/Seaside30'.		spec			package: 'Grease-Core';			package: 'Grease-Tests-Core' 				with: [ spec requires: #('Grease-Core' ). ];			yourself.		spec			group: 'Core' with: #('Grease-Core');			group: 'Core Tests' with: #('Grease-Tests-Core');			group: 'Slime' with: #('Core');			group: 'Slime Tests' with: #('Core Tests');			group: 'Tests' with: #('Core Tests' 'Slime Tests');			group: 'default' with: #('Slime');			yourself. ].	spec for: #squeakCommon do: [		spec			package: 'Grease-Core' 				with: [ spec includes: #('Grease-Pharo-Core' ) ];			package: 'Grease-Tests-Core' 				with: [ spec includes: #('Grease-Tests-Pharo-Core' ). ];			package: 'Grease-Pharo-Core' 				with: [ spec requires: #('Grease-Core' ) ];			package: 'Grease-Tests-Pharo-Core' 				with: [ spec requires: #('Grease-Tests-Core') ];								yourself. ].	spec for: #pharo do: [		spec			project: 'Refactoring-Core' with: [				spec					className: 'ConfigurationOfRefactoringBrowser';					versionString: '1.2-baseline';					loads: #('Refactoring-Core' );					file: 'ConfigurationOfRefactoringBrowser';					repository: 'http://www.squeaksource.com/MetacelloRepository' ];			yourself.		spec			package: 'Grease-Slime' 				with: [ spec requires: #('Refactoring-Core' 'Grease-Core' ) ];			package: 'Grease-Tests-Slime' 				with: [ spec requires: #('Grease-Slime') ];								yourself.		spec			group: 'Slime' with: #('Grease-Slime');			group: 'Slime Tests' with: #('Grease-Tests-Slime');			yourself. ].		spec for: #gemstone do: [		spec 			repository: 'http://seaside.gemstone.com/ss/Seaside30'.		spec 			project: 'GsCore' with: [				spec					className: 'ConfigurationOfGsCore';					versionString: '0.239-baseline';					file: 'ConfigurationOfGsCore';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'UTF8' with: [				spec					className: 'ConfigurationOfGsMisc';					versionString: '0.236-baseline';					loads: #('Utf8Encoding' );					file: 'ConfigurationOfGsMisc';					repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];			project: 'System-Digital-Signatures'				copyFrom: 'UTF8'				with: [ spec loads: #('System-Digital-Signatures' ) ];			project: 'SMTPMail'				copyFrom: 'UTF8'				with: [ spec loads: #('SMTPMail' ) ];						yourself.		spec			package: 'Grease-Core' 				with: [ spec includes: #('Grease-GemStone-Core' ) ];			package: 'Grease-Tests-Core' 				with: [ spec includes: #('Grease-Tests-GemStone-Core' ). ];			package: 'Grease-GemStone-Core' 				with: [ spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail' ) ];			package: 'Grease-Tests-GemStone-Core' 				with: [ spec requires: #('Grease-Tests-Core' ) ];			yourself. ].	spec for: #'gs2.3.x' do: [		spec 			package: 'Grease-GemStone-Core' 				with: [ spec includes: #('Grease-GemStone230-Core' ) ];			package: 'Grease-GemStone230-Core' 				with: [ spec requires: #('Grease-GemStone-Core' ) ];			yourself. ].	spec for: #'gs2.4.x' do: [		spec 			package: 'Grease-GemStone-Core' 				with: [ spec includes: #('Grease-GemStone240-Core' ) ];			package: 'Grease-GemStone240-Core' 				with: [ spec requires: #('Grease-GemStone-Core' ) ];			yourself. ].	spec for: #'gs3.x' do: [		spec 			package: 'Grease-GemStone-Core' 				with: [ spec includes: #('Grease-GemStone300-Core' ) ];			package: 'Grease-GemStone300-Core' 				with: [ spec requires: #('Grease-GemStone-Core' ) ];			yourself. ].! !!ConfigurationOfGrease methodsFor: 'baselines (1.1)' stamp: 'PaulDeBruicker 11/1/2013 06:52'!baseline110: spec	<version: '1.1.0-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec description: ''.			spec repository: 'http://www.smalltalkhub.com/mc/Seaside/Seaside31/main'.			spec				package: 'Grease-Core';				package: 'Grease-Tests-Core' with: [ spec requires: #('Grease-Core') ].			spec				group: 'Core' with: #('Grease-Core');				group: 'Core Tests' with: #('Grease-Tests-Core');				group: 'Slime' with: #('Core');				group: 'Slime Tests' with: #('Core Tests');				group: 'Tests' with: #('Core Tests' 'Slime Tests');				group: 'default' with: #('Slime') ].	spec		for: #squeak		do: [ 			self greaseCoreAndTestsForSqueakAndPharo1x: spec.			self slimeForSqueakPharo1xPharo2x: spec ].	spec		for: #'pharo3.x'		do: [ 			spec				package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo20-Core') ];				package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo20-Core') ];				package: 'Grease-Pharo20-Core' with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Pharo20-Core' with: [ spec requires: #('Grease-Tests-Core') ] ].	spec		for: #'pharo2.x'		do: [ 			spec				package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo20-Core') ];				package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo20-Core') ];				package: 'Grease-Pharo20-Core' with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Pharo20-Core' with: [ spec requires: #('Grease-Tests-Core') ].			self slimeForSqueakPharo1xPharo2x: spec ].	spec		for: #'pharo1.x'		do: [ 			self greaseCoreAndTestsForSqueakAndPharo1x: spec.			self slimeForSqueakPharo1xPharo2x: spec ].	spec for: #'pharo1.1' do: [ spec package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo11-Core') ] ].	spec		for: #'pharo1.0'		do: [ spec package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo10-Core' 'Grease-Pharo11-Core') ] ].	spec		for: #gemstone		do: [ 			spec repository: 'http://seaside.gemstone.com/ss/Seaside30'.			spec				project: 'GsCore'					with: [ 							spec								className: 'ConfigurationOfGsCore';								versionString: #stable;								repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];				project: 'UTF8'					with: [ 							spec								className: 'ConfigurationOfGsMisc';								versionString: #stable;								loads: #('Utf8Encoding');								repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];				project: 'System-Digital-Signatures' copyFrom: 'UTF8' with: [ spec loads: #('System-Digital-Signatures') ];				project: 'SMTPMail' copyFrom: 'UTF8' with: [ spec loads: #('SMTPMail') ].			spec				package: 'Grease-Core'					with: [ 							spec								requires: #('GsCore');								includes: #('Grease-GemStone-Core') ];				package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-GemStone-Core') ];				package: 'Grease-GemStone-Core'					with: [ spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail') ];				package: 'Grease-Tests-GemStone-Core' with: [ spec requires: #('Grease-Tests-Core') ] ].	spec		for: #'gs2.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone200-Core') ];				package: 'Grease-GemStone200-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ].	spec		for: #'gs2.3.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone230-Core') ];				package: 'Grease-GemStone230-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ].	spec		for: #'gs2.4.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone240-Core') ];				package: 'Grease-GemStone240-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ].	spec		for: #'gs3.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone300-Core') ];				package: 'Grease-GemStone300-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ]! !!ConfigurationOfGrease methodsFor: 'baselines (1.1)' stamp: 'PaulDeBruicker 10/31/2013 18:11'!baseline113: spec	<version: '1.1.3-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec description: ''.			spec repository: 'http://www.smalltalkhub.com/mc/Seaside/Grease11/main'.			spec				package: 'Grease-Core';				package: 'Grease-Tests-Core' with: [ spec requires: #('Grease-Core') ].			spec				group: 'Core' with: #('Grease-Core');				group: 'Core Tests' with: #('Grease-Tests-Core');				group: 'Slime' with: #('Core');				group: 'Slime Tests' with: #('Core Tests');				group: 'Tests' with: #('Core Tests' 'Slime Tests');				group: 'default' with: #('Slime') ].	spec		for: #'pharo3.x'		do: [ 			spec				package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo30-Core') ];				package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo20-Core') ];				package: 'Grease-Pharo30-Core' with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Pharo20-Core' with: [ spec requires: #('Grease-Tests-Core') ] ].	spec		for: #'pharo2.x'		do: [ 			spec				package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo20-Core') ];				package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo20-Core') ];				package: 'Grease-Pharo20-Core' with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Pharo20-Core' with: [ spec requires: #('Grease-Tests-Core') ].			self slimeForSqueakPharo1xPharo2x: spec ].	spec		for: #'pharo1.x'		do: [ 			self greaseCoreAndTestsForSqueakAndPharo1x: spec.			self slimeForSqueakPharo1xPharo2x: spec ].	spec for: #'pharo1.1' do: [ spec package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo11-Core') ] ].	spec		for: #'pharo1.0'		do: [ spec package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo10-Core' 'Grease-Pharo11-Core') ] ].	spec		for: #squeak		do: [ 			self greaseCoreAndTestsForSqueakAndPharo1x: spec.			self slimeForSqueakPharo1xPharo2x: spec ].	spec		for: #gemstone		do: [ 			spec repository: 'http://seaside.gemstone.com/ss/Seaside30'.			spec				project: 'GsCore'					with: [ 							spec								className: 'ConfigurationOfGsCore';								versionString: #stable;								repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];				project: 'UTF8'					with: [ 							spec								className: 'ConfigurationOfGsMisc';								versionString: #stable;								loads: #('Utf8Encoding');								repository: 'http://seaside.gemstone.com/ss/MetacelloRepository' ];				project: 'System-Digital-Signatures' copyFrom: 'UTF8' with: [ spec loads: #('System-Digital-Signatures') ];				project: 'SMTPMail' copyFrom: 'UTF8' with: [ spec loads: #('SMTPMail') ].			spec				package: 'Grease-Core'					with: [ 							spec								requires: #('GsCore');								includes: #('Grease-GemStone-Core') ];				package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-GemStone-Core') ];				package: 'Grease-GemStone-Core'					with: [ spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail') ];				package: 'Grease-Tests-GemStone-Core' with: [ spec requires: #('Grease-Tests-Core') ] ].	spec		for: #'gs2.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone200-Core') ];				package: 'Grease-GemStone200-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ].	spec		for: #'gs2.3.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone230-Core') ];				package: 'Grease-GemStone230-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ].	spec		for: #'gs2.4.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone240-Core') ];				package: 'Grease-GemStone240-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ].	spec		for: #'gs3.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone300-Core') ];				package: 'Grease-GemStone300-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ]! !!ConfigurationOfGrease methodsFor: 'baselines (1.1)' stamp: 'JohanBrichau 6/15/2014 20:58'!baseline114: spec	<version: '1.1.4-baseline'>	spec		for: #common		do: [ 			spec blessing: #baseline.			spec repository: 'http://www.smalltalkhub.com/mc/Seaside/Grease11/main'.			spec				package: 'Grease-Core';				package: 'Grease-Tests-Core' with: [ spec requires: #('Grease-Core') ].			spec				group: 'Core' with: #('Grease-Core');				group: 'Core Tests' with: #('Grease-Tests-Core');				group: 'Slime' with: #('Core');				group: 'Slime Tests' with: #('Core Tests');				group: 'Tests' with: #('Core Tests' 'Slime Tests');				group: 'default' with: #('Slime') 	].				spec		for: #'pharo3.x'		do: [ 			spec				package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo30-Core') ];				package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo20-Core') ];				package: 'Grease-Pharo30-Core' with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Pharo20-Core' with: [ spec requires: #('Grease-Tests-Core')];				package: 'Grease-Slime' with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Slime' with: [ spec requires: #('Grease-Slime') ].			spec				group: 'Slime' with: #('Grease-Slime');				group: 'Slime Tests' with: #('Grease-Tests-Slime').	].	spec		for: #'pharo4.x'		do: [ 			spec				package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo30-Core') ];				package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo20-Core') ];				package: 'Grease-Pharo30-Core' with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Pharo20-Core' with: [ spec requires: #('Grease-Tests-Core')];				package: 'Grease-Slime' with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Slime' with: [ spec requires: #('Grease-Slime') ].			spec				group: 'Slime' with: #('Grease-Slime');				group: 'Slime Tests' with: #('Grease-Tests-Slime').	].	spec		for: #'pharo2.x'		do: [ 			spec				package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo20-Core') ];				package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo20-Core') ];				package: 'Grease-Pharo20-Core' with: [ spec requires: #('Grease-Core') ];				package: 'Grease-Tests-Pharo20-Core' with: [ spec requires: #('Grease-Tests-Core') ].			self slimeForSqueakPharo1xPharo2x: spec ].	spec		for: #'pharo1.x'		do: [ 			self greaseCoreAndTestsForSqueakAndPharo1x: spec.			self slimeForSqueakPharo1xPharo2x: spec ].	spec for: #'pharo1.1' do: [ spec package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo11-Core') ] ].	spec		for: #'pharo1.0'		do: [ spec package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo10-Core' 'Grease-Pharo11-Core') ] ].	spec		for: #squeak		do: [ 			self greaseCoreAndTestsForSqueakAndPharo1x: spec.			self slimeForSqueakPharo1xPharo2x: spec ].	spec		for: #gemstone		do: [ 			spec repository: 'http://seaside.gemtalksystems.com/ss/Seaside30'.			spec				project: 'GsCore'					with: [ 							spec								className: 'ConfigurationOfGsCore';								versionString: #stable;								repository: 'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];				project: 'UTF8'					with: [ 							spec								className: 'ConfigurationOfGsMisc';								versionString: #stable;								loads: #('Utf8Encoding');								repository: 'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];				project: 'System-Digital-Signatures' copyFrom: 'UTF8' with: [ spec loads: #('System-Digital-Signatures') ];				project: 'SMTPMail' copyFrom: 'UTF8' with: [ spec loads: #('SMTPMail') ].			spec				package: 'Grease-Core'					with: [ 							spec								requires: #('GsCore');								includes: #('Grease-GemStone-Core') ];				package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-GemStone-Core') ];				package: 'Grease-GemStone-Core'					with: [ spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail') ];				package: 'Grease-Tests-GemStone-Core' with: [ spec requires: #('Grease-Tests-Core') ] ].	spec		for: #'gs2.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone200-Core') ];				package: 'Grease-GemStone200-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ].	spec		for: #'gs2.3.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone230-Core') ];				package: 'Grease-GemStone230-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ].	spec		for: #'gs2.4.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone240-Core') ];				package: 'Grease-GemStone240-Core' with: [ spec requires: #('Grease-GemStone-Core') ] ].	spec		for: #'gs3.x'		do: [ 			spec				package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone300-Core') ];				package: 'Grease-GemStone300-Core' with: [ spec requires: #('Grease-GemStone-Core') ] 	] ! !!ConfigurationOfGrease methodsFor: 'baselines (1.1)' stamp: 'StephanEggermont 7/12/2015 15:11'!baseline115: spec	<version: '1.1.5-baseline'>	spec for: #common do: [ 		spec blessing: #baseline.		spec repository: 'http://www.smalltalkhub.com/mc/Seaside/Grease11/main'.		spec			package: 'Grease-Core';			package: 'Grease-Tests-Core' with: [ spec requires: #('Grease-Core') ].		spec			group: 'Core' with: #('Grease-Core');			group: 'Core Tests' with: #('Grease-Tests-Core');			group: 'Slime' with: #('Core');			group: 'Slime Tests' with: #('Core Tests');			group: 'Tests' with: #('Core Tests' 'Slime Tests');			group: 'default' with: #('Slime') 	].	spec for: #squeak do: [ 		self greaseCoreAndTestsForSqueakAndPharo1x: spec.		self slimeForSqueakPharo1xPharo2x: spec 	].	spec for: #'pharo1.x' do: [ 		self greaseCoreAndTestsForSqueakAndPharo1x: spec.		self slimeForSqueakPharo1xPharo2x: spec	].			spec for: #'pharo1.1' do: [ 		spec package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo11-Core') ] 	].		spec for: #'pharo1.0' do: [ 		spec package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo10-Core' 'Grease-Pharo11-Core') ] 	].	spec for: #'pharo2.x' do: [ 		spec			package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo20-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo20-Core') ];			package: 'Grease-Pharo20-Core' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Pharo20-Core' with: [ spec requires: #('Grease-Tests-Core') ].		self slimeForSqueakPharo1xPharo2x: spec 	].				spec for: #'pharo3.x' do: [ 		spec			package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo30-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo20-Core') ];			package: 'Grease-Pharo30-Core' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Pharo20-Core' with: [ spec requires: #('Grease-Tests-Core')];			package: 'Grease-Slime' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Slime' with: [ spec requires: #('Grease-Slime') ].		spec			group: 'Slime' with: #('Grease-Slime');			group: 'Slime Tests' with: #('Grease-Tests-Slime').	].	spec for: #(#'pharo4.x' #'pharo5.x') do: [ 		spec			package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo30-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo20-Core') ];			package: 'Grease-Pharo30-Core' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Pharo20-Core' with: [ spec requires: #('Grease-Tests-Core')];			package: 'Grease-Pharo40-Slime' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Slime' with: [ spec requires: #('Grease-Pharo40-Slime') ].		spec			group: 'Slime' with: #('Grease-Pharo40-Slime');			group: 'Slime Tests' with: #('Grease-Tests-Slime').	].		spec for: #'gs2.x' do: [ 		spec repository: 'http://seaside.gemtalksystems.com/ss/Seaside30'.		spec			project: 'GsCore'			with: [ 				spec					className: 'ConfigurationOfGsCore';					versionString: #stable;					repository: 'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];			project: 'UTF8'			with: [ 				spec					className: 'ConfigurationOfGsMisc';					versionString: #stable;					loads: #('Utf8Encoding');					repository: 'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];			project: 'System-Digital-Signatures' copyFrom: 'UTF8' with: [ spec loads: #('System-Digital-Signatures') ];			project: 'SMTPMail' copyFrom: 'UTF8' with: [ spec loads: #('SMTPMail') ].		spec			package: 'Grease-Core' with: [ 					spec						requires: #('GsCore');						includes: #('Grease-GemStone-Core') ];			package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone200-Core') ];			package: 'Grease-GemStone200-Core' with: [ spec requires: #('Grease-GemStone-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-GemStone-Core') ];			package: 'Grease-GemStone-Core' with: [ spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail') ];			package: 'Grease-Tests-GemStone-Core' with: [ spec requires: #('Grease-Tests-Core') ] 	].		spec for: #'gs2.3.x' do: [ 		spec			package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone230-Core') ];			package: 'Grease-GemStone230-Core' with: [ spec requires: #('Grease-GemStone-Core') ] 	].	spec for: #'gs2.4.x' do: [ 		spec			package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone240-Core') ];			package: 'Grease-GemStone240-Core' with: [ spec requires: #('Grease-GemStone-Core') ]	].		spec for: #'gs3.x' do: [		spec 			baseline: 'Grease' with: [ spec repository: 'github://GsDevKit/Grease:master/repository' ];			import: 'Grease'	].! !!ConfigurationOfGrease methodsFor: 'baselines (1.1)' stamp: 'StephanEggermont 7/12/2015 15:12'!baseline116: spec	<version: '1.1.6-baseline'>	spec for: #common do: [ 		spec blessing: #baseline.		spec repository: 'http://www.smalltalkhub.com/mc/Seaside/Grease11/main'.		spec			package: 'Grease-Core';			package: 'Grease-Tests-Core' with: [ spec requires: #('Grease-Core') ].		spec			group: 'Core' with: #('Grease-Core');			group: 'Core Tests' with: #('Grease-Tests-Core');			group: 'Slime' with: #('Core');			group: 'Slime Tests' with: #('Core Tests');			group: 'Tests' with: #('Core Tests' 'Slime Tests');			group: 'default' with: #('Slime') 	].	spec for: #squeak do: [ 		spec			package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo-Core' 'Grease-Squeak-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo-Core' 'Grease-Tests-Squeak-Core') ];			package: 'Grease-Pharo-Core' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Pharo-Core' with: [ spec requires: #('Grease-Tests-Core') ];			package: 'Grease-Squeak-Core' with: [ spec requires: #('Grease-Pharo-Core') ];			package: 'Grease-Tests-Squeak-Core' with: [ spec requires: #('Grease-Tests-Pharo-Core') ].		self slimeForSqueakPharo1xPharo2x: spec 	].	spec for: #'pharo1.x' do: [ 		spec			package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo-Core') ];			package: 'Grease-Pharo-Core' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Pharo-Core' with: [ spec requires: #('Grease-Tests-Core') ].		self slimeForSqueakPharo1xPharo2x: spec	].			spec for: #'pharo1.1' do: [ 		spec package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo11-Core') ] 	].		spec for: #'pharo1.0' do: [ 		spec package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo10-Core' 'Grease-Pharo11-Core') ] 	].	spec for: #'pharo2.x' do: [ 		spec			package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo20-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo20-Core') ];			package: 'Grease-Pharo20-Core' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Pharo20-Core' with: [ spec requires: #('Grease-Tests-Core') ].		self slimeForSqueakPharo1xPharo2x: spec 	].				spec for: #'pharo3.x' do: [ 		spec			package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo30-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo20-Core') ];			package: 'Grease-Pharo30-Core' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Pharo20-Core' with: [ spec requires: #('Grease-Tests-Core')];			package: 'Grease-Slime' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Slime' with: [ spec requires: #('Grease-Slime') ].		spec			group: 'Slime' with: #('Grease-Slime');			group: 'Slime Tests' with: #('Grease-Tests-Slime').	].	spec for: #(#'pharo4.x' #'pharo5.x')  do: [ 		spec			package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo30-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo20-Core') ];			package: 'Grease-Pharo30-Core' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Pharo20-Core' with: [ spec requires: #('Grease-Tests-Core')];			package: 'Grease-Pharo40-Slime' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Slime' with: [ spec requires: #('Grease-Pharo40-Slime') ].		spec			group: 'Slime' with: #('Grease-Pharo40-Slime');			group: 'Slime Tests' with: #('Grease-Tests-Slime').	].		spec for: #'gs2.x' do: [ 		spec repository: 'http://seaside.gemtalksystems.com/ss/Seaside30'.		spec			project: 'GsCore'			with: [ 				spec					className: 'ConfigurationOfGsCore';					versionString: #stable;					repository: 'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];			project: 'UTF8'			with: [ 				spec					className: 'ConfigurationOfGsMisc';					versionString: #stable;					loads: #('Utf8Encoding');					repository: 'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];			project: 'System-Digital-Signatures' copyFrom: 'UTF8' with: [ spec loads: #('System-Digital-Signatures') ];			project: 'SMTPMail' copyFrom: 'UTF8' with: [ spec loads: #('SMTPMail') ].		spec			package: 'Grease-Core' with: [ 					spec						requires: #('GsCore');						includes: #('Grease-GemStone-Core') ];			package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone200-Core') ];			package: 'Grease-GemStone200-Core' with: [ spec requires: #('Grease-GemStone-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-GemStone-Core') ];			package: 'Grease-GemStone-Core' with: [ spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail') ];			package: 'Grease-Tests-GemStone-Core' with: [ spec requires: #('Grease-Tests-Core') ] 	].		spec for: #'gs2.3.x' do: [ 		spec			package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone230-Core') ];			package: 'Grease-GemStone230-Core' with: [ spec requires: #('Grease-GemStone-Core') ] 	].	spec for: #'gs2.4.x' do: [ 		spec			package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone240-Core') ];			package: 'Grease-GemStone240-Core' with: [ spec requires: #('Grease-GemStone-Core') ]	].		spec for: #'gs3.x' do: [		spec 			baseline: 'Grease' with: [ spec repository: 'github://GsDevKit/Grease:master/repository' ];			import: 'Grease'	].! !!ConfigurationOfGrease methodsFor: 'baselines (1.1)' stamp: 'ChristopheDemarey 10/17/2016 15:51'!baseline117: spec	<version: '1.1.7-baseline'>	spec for: #common do: [ 		spec blessing: #baseline.		spec repository: 'http://www.smalltalkhub.com/mc/Seaside/Grease11/main'.		spec			package: 'Grease-Core';			package: 'Grease-Tests-Core' with: [ spec requires: #('Grease-Core') ].		spec			group: 'Core' with: #('Grease-Core');			group: 'Core Tests' with: #('Grease-Tests-Core');			group: 'Slime' with: #('Core');			group: 'Slime Tests' with: #('Core Tests');			group: 'Tests' with: #('Core Tests' 'Slime Tests');			group: 'default' with: #('Slime') 	].	spec for: #'squeak4.x' do: [ 		spec			package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo-Core' 'Grease-Squeak-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo-Core' 'Grease-Tests-Squeak-Core') ];			package: 'Grease-Pharo-Core' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Pharo-Core' with: [ spec requires: #('Grease-Tests-Core') ];			package: 'Grease-Squeak-Core' with: [ spec requires: #('Grease-Pharo-Core') ];			package: 'Grease-Tests-Squeak-Core' with: [ spec requires: #('Grease-Tests-Pharo-Core') ].		self slimeForSqueakPharo1xPharo2x: spec	].	spec for: #'squeak5.x' do: [ 		spec			package: 'Grease-Core' with: [ spec includes: #('Grease-Squeak5-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Squeak-Core' 'Grease-Tests-Squeak5-Core') ];			package: 'Grease-Squeak5-Core' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Squeak-Core' with: [ spec requires: #('Grease-Tests-Core') ];			package: 'Grease-Tests-Squeak5-Core' with: [ spec requires: #('Grease-Tests-Squeak-Core') ].		self slimeForSqueakPharo1xPharo2x: spec 	].	spec for: #'pharo1.x' do: [ 		spec			package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo-Core') ];			package: 'Grease-Pharo-Core' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Pharo-Core' with: [ spec requires: #('Grease-Tests-Core') ].		self slimeForSqueakPharo1xPharo2x: spec	].			spec for: #'pharo1.1' do: [ 		spec package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo11-Core') ] 	].		spec for: #'pharo1.0' do: [ 		spec package: 'Grease-Pharo-Core' with: [ spec includes: #('Grease-Pharo10-Core' 'Grease-Pharo11-Core') ] 	].	spec for: #'pharo2.x' do: [ 		spec			package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo20-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo20-Core') ];			package: 'Grease-Pharo20-Core' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Pharo20-Core' with: [ spec requires: #('Grease-Tests-Core') ].		self slimeForSqueakPharo1xPharo2x: spec 	].				spec for: #'pharo3.x' do: [ 		spec			package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo30-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo20-Core') ];			package: 'Grease-Pharo30-Core' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Pharo20-Core' with: [ spec requires: #('Grease-Tests-Core')];			package: 'Grease-Slime' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Slime' with: [ spec requires: #('Grease-Slime') ].		spec			group: 'Slime' with: #('Grease-Slime');			group: 'Slime Tests' with: #('Grease-Tests-Slime').	].	spec for: #(#'pharo4.x' #'pharo5.x' #'pharo6.x')  do: [ 		spec			package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo30-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo20-Core') ];			package: 'Grease-Pharo30-Core' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Pharo20-Core' with: [ spec requires: #('Grease-Tests-Core')];			package: 'Grease-Pharo40-Slime' with: [ spec requires: #('Grease-Core') ];			package: 'Grease-Tests-Slime' with: [ spec requires: #('Grease-Pharo40-Slime') ].		spec			group: 'Slime' with: #('Grease-Pharo40-Slime');			group: 'Slime Tests' with: #('Grease-Tests-Slime').	].		spec for: #'gs2.x' do: [ 		spec repository: 'http://seaside.gemtalksystems.com/ss/Seaside30'.		spec			project: 'GsCore'			with: [ 				spec					className: 'ConfigurationOfGsCore';					versionString: #stable;					repository: 'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];			project: 'UTF8'			with: [ 				spec					className: 'ConfigurationOfGsMisc';					versionString: #stable;					loads: #('Utf8Encoding');					repository: 'http://seaside.gemtalksystems.com/ss/MetacelloRepository' ];			project: 'System-Digital-Signatures' copyFrom: 'UTF8' with: [ spec loads: #('System-Digital-Signatures') ];			project: 'SMTPMail' copyFrom: 'UTF8' with: [ spec loads: #('SMTPMail') ].		spec			package: 'Grease-Core' with: [ 					spec						requires: #('GsCore');						includes: #('Grease-GemStone-Core') ];			package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone200-Core') ];			package: 'Grease-GemStone200-Core' with: [ spec requires: #('Grease-GemStone-Core') ];			package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-GemStone-Core') ];			package: 'Grease-GemStone-Core' with: [ spec requires: #('Grease-Core' 'GsCore' 'System-Digital-Signatures' 'UTF8' 'SMTPMail') ];			package: 'Grease-Tests-GemStone-Core' with: [ spec requires: #('Grease-Tests-Core') ] 	].		spec for: #'gs2.3.x' do: [ 		spec			package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone230-Core') ];			package: 'Grease-GemStone230-Core' with: [ spec requires: #('Grease-GemStone-Core') ] 	].	spec for: #'gs2.4.x' do: [ 		spec			package: 'Grease-GemStone-Core' with: [ spec includes: #('Grease-GemStone240-Core') ];			package: 'Grease-GemStone240-Core' with: [ spec requires: #('Grease-GemStone-Core') ]	].		spec for: #'gs3.x' do: [		spec 			baseline: 'Grease' with: [ spec repository: 'github://GsDevKit/Grease:master/repository' ];			import: 'Grease'	].! !!ConfigurationOfGrease methodsFor: 'symbolic versions' stamp: 'JohanBrichau 11/11/2015 13:25'!bleedingEdge: spec	<symbolicVersion: #'bleedingEdge'>	spec for: #'common' version: '1.1.7-baseline'.! !!ConfigurationOfGrease methodsFor: 'symbolic versions' stamp: 'JohanBrichau 9/4/2016 17:06'!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: '1.3.0'! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'PaulDeBruicker 10/31/2013 18:08'!greaseCoreAndTestsForSqueakAndPharo1x: spec	spec		package: 'Grease-Core' with: [ spec includes: #('Grease-Pharo-Core') ];		package: 'Grease-Tests-Core' with: [ spec includes: #('Grease-Tests-Pharo-Core') ];		package: 'Grease-Pharo-Core' with: [ spec requires: #('Grease-Core') ];		package: 'Grease-Tests-Pharo-Core' with: [ spec requires: #('Grease-Tests-Core') ]! !!ConfigurationOfGrease methodsFor: 'doits' stamp: 'dkh 12/16/2009 15:40'!initializeNewRandomCaches10alpha3	Smalltalk at: #WAKeyGenerator ifPresent: [:cl |		cl initialize ].! !!ConfigurationOfGrease methodsFor: 'doits' stamp: 'NickAger 3/25/2012 05:00'!initializeTransactionMutex1051	(Smalltalk at: #GRGemStonePlatform) initialize.! !!ConfigurationOfGrease methodsFor: 'accessing' stamp: 'DaleHenrichs 10/9/2010 11:35'!project	^ project ifNil: [ | projectAttributes |		"Bootstrap Metacello if it is not already loaded"		self class ensureMetacello.		"Construct Metacello project"		project := (Smalltalk at: #MetacelloMCProject) new.		projectAttributes := #().		Smalltalk at: #SystemVersion ifPresent: [:cl | | versionString |			versionString := cl current version.			((versionString beginsWith: 'Pharo-1.0') or: [versionString beginsWith: 'PharoCore1.0'])				ifTrue: [ projectAttributes := projectAttributes, #(#'GreaseForPharo1.0') ] ].		project projectAttributes:  projectAttributes.		(Smalltalk at: #MetacelloVersionConstructor) on: self project: project.		project loadType: #linear ]! !!ConfigurationOfGrease methodsFor: 'symbolic versions' stamp: 'StephanEggermont 6/25/2014 10:12'!release10: aSpec	<symbolicVersion:#'release1.0'>	aSpec for: #'common' version: '1.0.12'! !!ConfigurationOfGrease methodsFor: 'symbolic versions' stamp: 'StephanEggermont 7/13/2015 10:52'!release11: aSpec	<symbolicVersion:#'release1.1'>	aSpec for: #'common' version: '1.1.13.1'! !!ConfigurationOfGrease methodsFor: 'symbolic versions' stamp: 'JohanBrichau 3/26/2016 15:57'!release12: aSpec	<symbolicVersion:#'release1.2'>	aSpec for: #'squeak' version: '1.2.7'.	aSpec for: #'pharo' version: '1.2.7'.	aSpec for: #gemstone version: '1.2.7'.	! !!ConfigurationOfGrease methodsFor: 'symbolic versions' stamp: 'JohanBrichau 7/15/2015 13:53'!release1: aSpec	<symbolicVersion:#'release1'>	aSpec for: #'common' version: #'release1.2'! !!ConfigurationOfGrease methodsFor: 'baselines (1.0)' stamp: 'PaulDeBruicker 10/31/2013 18:08'!slimeForSqueakPharo1xPharo2x: spec	spec		project: 'Refactoring-Core'		with: [ 			spec				className: 'ConfigurationOfRefactoringBrowser';				versionString: #stable;				loads: #('Core');				repository: 'http://www.squeaksource.com/MetacelloRepository' ].	spec		package: 'Grease-Slime' with: [ spec requires: #('Refactoring-Core' 'Grease-Core') ];		package: 'Grease-Tests-Slime' with: [ spec requires: #('Grease-Slime') ].	^ spec		group: 'Slime' with: #('Grease-Slime');		group: 'Slime Tests' with: #('Grease-Tests-Slime')! !!ConfigurationOfGrease methodsFor: 'symbolic versions' stamp: 'DiegoLont 5/21/2014 11:49'!stable: spec	<symbolicVersion: #'stable'>	spec for: #'common' version: #'release1'! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DiegoLont 3/31/2014 14:36'!version10011: aSpec	<version: '1.0.11' imports: #( '1.0.9-baseline')>	aSpec for: #'common' do: [		aSpec			blessing: #'release';			description: 'Fixes for Pharo3.0';			author: 'JohanBrichau';			timestamp: '02/04/2014 21:13'.		aSpec			package: 'Grease-Core' with: 'Grease-Core-JohanBrichau.74';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-JohanBrichau.83' ].	aSpec for: #'squeak' do: [		aSpec			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.58';			package: 'Grease-Pharo13-Core' with: 'Grease-Pharo13-Core-dkh.1';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13';			package: 'Grease-Slime' with: 'Grease-Slime-topa.15';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-JohanBrichau.11' ].	aSpec for: #'pharo3.x' do: [		aSpec			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-pmm.1';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13';			package: 'Grease-Slime' with: 'Grease-Slime-JohanBrichau.16';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-JohanBrichau.11' ].	aSpec for: #'pharo2.x' do: [		aSpec			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-pmm.1';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13';			package: 'Grease-Slime' with: 'Grease-Slime-JohanBrichau.16';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-JohanBrichau.11' ].	aSpec for: #'pharo1.x' do: [		aSpec			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.58';			package: 'Grease-Pharo13-Core' with: 'Grease-Pharo13-Core-dkh.1';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13';			package: 'Grease-Slime' with: 'Grease-Slime-topa.15';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-JohanBrichau.11' ].	aSpec for: #'gemstone' do: [		aSpec			project: 'SMTPMail' with: '0.241.1';			project: 'GsCore' with: '0.246.1';			project: 'UTF8' with: '0.241.1';			project: 'System-Digital-Signatures' with: '0.241.1'.		aSpec			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				aSpec					file: 'Grease-GemStone-Core-dkh.49';					postLoadDoIt: #'initializeTransactionMutex1051' ] ].	aSpec for: #'gs3.x' do: [		aSpec			package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4' ].	aSpec for: #'gs2.x' do: [		aSpec			package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2' ].	aSpec for: #'gs2.4.x' do: [		aSpec			package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3' ].	aSpec for: #'gs2.3.x' do: [		aSpec			package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4' ]! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'StephanEggermont 6/25/2014 10:12'!version10012: aSpec	<version: '1.0.12' imports: #( '1.0.9-baseline')>	aSpec for: #'common' do: [		aSpec			blessing: #'release';			description: 'Fixes for Pharo4.0';			author: 'StephanEggermont';			timestamp: '25/06/2014 21:13'.		aSpec			package: 'Grease-Core' with: 'Grease-Core-JohanBrichau.74';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-JohanBrichau.83' ].	aSpec for: #'squeak' do: [		aSpec			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.58';			package: 'Grease-Pharo13-Core' with: 'Grease-Pharo13-Core-dkh.1';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13';			package: 'Grease-Slime' with: 'Grease-Slime-topa.15';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-JohanBrichau.11' ].	aSpec for: #(#'pharo3.x' #'pharo4.x') do: [		aSpec			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-pmm.1';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13';			package: 'Grease-Slime' with: 'Grease-Slime-JohanBrichau.16';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-JohanBrichau.11' ].	aSpec for: #'pharo2.x' do: [		aSpec			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-pmm.1';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13';			package: 'Grease-Slime' with: 'Grease-Slime-JohanBrichau.16';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-JohanBrichau.11' ].	aSpec for: #'pharo1.x' do: [		aSpec			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.58';			package: 'Grease-Pharo13-Core' with: 'Grease-Pharo13-Core-dkh.1';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13';			package: 'Grease-Slime' with: 'Grease-Slime-topa.15';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-JohanBrichau.11' ].	aSpec for: #'gemstone' do: [		aSpec			project: 'SMTPMail' with: '0.241.1';			project: 'GsCore' with: '0.246.1';			project: 'UTF8' with: '0.241.1';			project: 'System-Digital-Signatures' with: '0.241.1'.		aSpec			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				aSpec					file: 'Grease-GemStone-Core-dkh.49';					postLoadDoIt: #'initializeTransactionMutex1051' ] ].	aSpec for: #'gs3.x' do: [		aSpec			package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4' ].	aSpec for: #'gs2.x' do: [		aSpec			package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2' ].	aSpec for: #'gs2.4.x' do: [		aSpec			package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3' ].	aSpec for: #'gs2.3.x' do: [		aSpec			package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4' ]! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'StephanEggermont 6/10/2014 11:02'!version1010: spec	<version: '1.0.10' imports: #('1.0.9-baseline' )>	spec for: #'common' do: [		spec description: '-Slime in Pharo 3.x (and 4.x, added 2014-6-10'.		spec author: 'JohanBrichau'.		spec timestamp: '20/01/2014 17:23'. 		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.72';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.82'. ].			"RB/Slime"	spec for: #(#'squeak' #'pharo1.x') do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-topa.15';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-JohanBrichau.11' ].			spec for: #(#'squeak' #'pharo1.x') do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.58';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13' ].	spec for: #(#'pharo2.x' #'pharo3.x' #'pharo4.x') do: [		spec 			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-pmm.1';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13';			package: 'Grease-Slime' with: 'Grease-Slime-JohanBrichau.16';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-JohanBrichau.11' ].	spec for: #( #'pharo1.x' #'squeak') do: [		spec 			package: 'Grease-Pharo13-Core' with: 'Grease-Pharo13-Core-dkh.1' ].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.246.1';			project: 'SMTPMail' with: '0.241.1';			project: 'UTF8' with: '0.241.1';			project: 'System-Digital-Signatures' with: '0.241.1'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.49';					postLoadDoIt: #'initializeTransactionMutex1051'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.x' do: [		spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DaleHenrichs 11/19/2010 12:32'!version1011: spec	<version: '1.0.1.1' imports: #('1.0.1.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- pick up latest mcz files'.		spec author: 'dkh'.		spec timestamp: '11/19/2010 10:44'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.51';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.63'.].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.32';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.8'.].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: '1.4'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.7';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.6'.].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.3'.].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.241';			project: 'SMTPMail' with: '0.237';			project: 'UTF8' with: '0.237';			project: 'System-Digital-Signatures' with: '0.237'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-NickAger.28';					postLoadDoIt: #'initializeNewRandomCaches10alpha3'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-DaleHenrichs.8'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-DaleHenrichs.2'.].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-DaleHenrichs.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DaleHenrichs 11/11/2010 13:11'!version101: spec	<version: '1.0.1' imports: #('1.0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- pick up latest mcz files'.		spec author: 'DaleHenrichs'.		spec timestamp: '11/08/2010 15:13:08'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.51';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.62'.].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.31';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.8'.].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: '1.4'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.7';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.6'.].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.3'.].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.241';			project: 'SMTPMail' with: '0.237';			project: 'UTF8' with: '0.237';			project: 'System-Digital-Signatures' with: '0.237'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-DaleHenrichs.27';					postLoadDoIt: #'initializeNewRandomCaches10alpha3'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-DaleHenrichs.8'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-DaleHenrichs.2'.].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-DaleHenrichs.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DaleHenrichs 12/08/2010 12:11'!version1021: spec	<version: '1.0.2.1' imports: #('1.0.2-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: '- ABANDONED in favor of 1.0.3'.		spec author: 'DaleHenrichs'.		spec timestamp: '12/03/2010 16:50:14'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.52';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.63'.].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.32';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.8'.].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: '1.4'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.7';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.6'.].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.3'.].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.242';			project: 'SMTPMail' with: '0.237';			project: 'UTF8' with: '0.237';			project: 'System-Digital-Signatures' with: '0.237'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-DaleHenrichs.31';					postLoadDoIt: #'initializeNewRandomCaches10alpha3'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-DaleHenrichs.11'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-DaleHenrichs.2'.].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-DaleHenrichs.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'pmm 11/21/2010 12:36'!version102: spec	<version: '1.0.2' imports: #('1.0.2-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- pick up latest mcz files'.		spec author: 'pmm'.		spec timestamp: '11/21/2010 12:35'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.52';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.63'.].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.32';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.8'.].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: '1.4'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.7';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.6'.].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.3'.].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.241';			project: 'SMTPMail' with: '0.237';			project: 'UTF8' with: '0.237';			project: 'System-Digital-Signatures' with: '0.237'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-NickAger.28';					postLoadDoIt: #'initializeNewRandomCaches10alpha3'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-DaleHenrichs.8'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-DaleHenrichs.2'.].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-DaleHenrichs.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DaleHenrichs 02/08/2011 16:36'!version1031: spec	<version: '1.0.3.1' imports: #('1.0.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: '- open 1.0.3.1 for development- get Seaside3.0 running on GemStone3.0beta3- fix Issue 212: http://code.google.com/p/glassdb/issues/detail?id=212 "FileDirectory class>>onClient switched sense" [GemStone]- ANSI block behavior means that GemStone3.0 passes GRNumberTest>>testToDoClosures- wait for GemStone bugs 41222 and 41223 to be fixed to pass remaining tests- fix Issue 226:	http://code.google.com/p/glassdb/issues/detail?id=226 "Grease-Core should depend upon GsCore for #gemstone [isInfinite]"'.		spec author: 'DaleHenrichs'.		spec timestamp: '01/20/2011 11:01:37'.		spec 			package: 'Grease-Core' with: 'Grease-Core-DaleHenrichs.53';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.63'. ].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.32';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.8'. ].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: '1.4'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.7';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.6'. ].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.3'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.244';			project: 'SMTPMail' with: '0.238';			project: 'UTF8' with: '0.238';			project: 'System-Digital-Signatures' with: '0.238'.		spec 			package: 'Grease-GemStone-Core' with: 'Grease-GemStone-Core-DaleHenrichs.33';			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-DaleHenrichs.12'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-DaleHenrichs.2'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-DaleHenrichs.2'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 12/13/2010 18:17'!version103: spec	<version: '1.0.3' imports: #('1.0.2-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- add test coverage for GRPlatform file library support methods [GemStone]- User ServerDirectory in Grease (for performance) [GemStone].- fix open file descriptor leak [GemStone]- fix Issue 166: http://code.google.com/p/glassdb/issues/detail?id=166 "discrepancy between Pharo regex and Gemstone on multiline strings [moved Ansi* streams to core GemStone]'.		spec author: 'DaleHenrichs'.		spec timestamp: '12/13/2010 14:45:46'.		spec 			package: 'Grease-Core' with: 'Grease-Core-DaleHenrichs.53';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.63'.].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.32';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.8'.].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: '1.4'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.7';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.6'.].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.3'.].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.243';			project: 'SMTPMail' with: '0.237';			project: 'UTF8' with: '0.237';			project: 'System-Digital-Signatures' with: '0.237'.		spec 			package: 'Grease-GemStone-Core' with: 'Grease-GemStone-Core-DaleHenrichs.32';			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-DaleHenrichs.11'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-DaleHenrichs.2'.].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-DaleHenrichs.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 3/3/2011 15:28'!version104: spec	<version: '1.0.4' imports: #('1.0.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- latest mcz files for 1.0.4- fix Issue 239: using WAFastCGIAdaptor leads the false conversion of + in urls. [GemStone]  http://code.google.com/p/glassdb/issues/detail?id=239 - fix Issue 227: Squeak/Pharo String extensions methods don''t work on multibyte strings [GemStone]  http://code.google.com/p/glassdb/issues/detail?id=227'.		spec author: 'dkh'.		spec timestamp: '2/28/2011 13:48'.		spec 			package: 'Grease-Core' with: 'Grease-Core-DaleHenrichs.58';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.65'. ].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.36';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.10'. ].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.8';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.7'. ].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.3'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.244';			project: 'SMTPMail' with: '0.238';			project: 'UTF8' with: '0.238';			project: 'System-Digital-Signatures' with: '0.238'.		spec 			package: 'Grease-GemStone-Core' with: 'Grease-GemStone-Core-DaleHenrichs.36';			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-DaleHenrichs.13'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-DaleHenrichs.2'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-DaleHenrichs.2'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 08/31/2011 12:43'!version1051: spec	<version: '1.0.5.1' imports: #('1.0.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: '1.0.5.1 (dkh.150):- open 1.0.5.1 for development ... GemStone-specific branch aimed at bypassing use of class instance variables (etc.) to allow the GemStone 3.0 version of Seaside to run against a read only SymbolDictionary. Some class instance variables are mapped to session temps and some are mapped to user-specific storage in UserGlobals.- refactor GRGemStonePlatform>>logError:title: and friends a bit to make it somewhat more useful- GRGemStoneRandomProvider class instance variables mutex and generator mapped to session temps1.0.5.1 (dkh.152):- fix issue 290  "transactionMutex is always nil"  http://code.google.com:9393/p/glassdb/issues/detail?id=290'.		spec author: 'dkh'.		spec timestamp: '08/31/2011 12:43:20'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.59';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.65'. ].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.37';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.10'. ].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.8';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.7'. ].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.245';			project: 'SMTPMail' with: '0.239';			project: 'UTF8' with: '0.239';			project: 'System-Digital-Signatures' with: '0.239'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.40';					postLoadDoIt: #'initializeTransactionMutex1051'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-DaleHenrichs.2'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 09/13/2011 16:42'!version105: spec	<version: '1.0.5' imports: #('1.0.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '1.0.5 (DaleHenrichs.141):- experimental Pharo 1.2 support- support for Iliad [GemStone]1.0.5 (dkh.143):- Move GRGemStonePlatformTest>>testFileLibrary to WAGemStoneFileLibraryTest ... reference to WAFileLibrary belongs in a Seaside package1.0.5 (dkh.145):- changes for the new Random classes available in 3.0'.		spec author: 'dkh'.		spec timestamp: '5/17/2011 11:10'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.59';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.65'. ].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.37';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.10'. ].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.8';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.7'. ].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.244';			project: 'SMTPMail' with: '0.238';			project: 'UTF8' with: '0.238';			project: 'System-Digital-Signatures' with: '0.238'.		spec 			package: 'Grease-GemStone-Core' with: 'Grease-GemStone-Core-DaleHenrichs.38';			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-DaleHenrichs.2'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 10/14/2011 17:52'!version1061: spec	<version: '1.0.6.1' imports: #('1.0.6.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: '1.0.6.1 (dkh.157):- address GemStone2.3.x upgrade issues for GLASS 1.0-beta.8.71.0.6.1 (dkh.158):- fix Issue 279: GRGemStoneRandomProvider class>>#''sessionStart'' calls TransientRandom>>#''open'' which does not exist  http://code.google.com/p/glassdb/issues/detail?id=279  GemStone 2.3 fix (GemStone 2.4 fixed in earlier version)1.0.6.1 (dkh.159):- port to GemStone 3.0.1 (#generatehardBreak changed for 3.0)- GemStone 3.0.1 fix for Issue 130: remote breakpoints don''t work  http://code.google.com/p/glassdb/issues/detail?id=130'.		spec author: 'dkh'.		spec timestamp: '10/14/2011 16:56'.		spec 			package: 'Grease-Core' with: 'Grease-Core-dkh.65';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.78'. ].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.43';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13'. ].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.13';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.9'. ].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.245';			project: 'SMTPMail' with: '0.239.1';			project: 'UTF8' with: '0.239.1';			project: 'System-Digital-Signatures' with: '0.239.1'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.45';					postLoadDoIt: #'initializeTransactionMutex1051'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.x' do: [		spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 10/19/2011 11:31'!version1062: spec	<version: '1.0.6.2' imports: #('1.0.6.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '1.0.6.1 (dkh.157):- address GemStone2.3.x upgrade issues for GLASS 1.0-beta.8.71.0.6.1 (dkh.158):- fix Issue 279: GRGemStoneRandomProvider class>>#''sessionStart'' calls TransientRandom>>#''open'' which does not exist  http://code.google.com/p/glassdb/issues/detail?id=279  GemStone 2.3 fix (GemStone 2.4 fixed in earlier version)1.0.6.1 (dkh.159):- port to GemStone 3.0.1 (#generatehardBreak changed for 3.0)- GemStone 3.0.1 fix for Issue 130: remote breakpoints don''t work  http://code.google.com/p/glassdb/issues/detail?id=1301.0.6.2 (StephaneDucasse.157): updating to renaming happening in RB :( 								- grease-slime.14.lr and a couple of others'.		spec author: 'StephaneDucasse'.		spec timestamp: ' 18 October 2011'. "Date today"		spec 			package: 'Grease-Core' with: 'Grease-Core-lr.66';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-lr.79'. ].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-lr.44';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13'. ].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.14';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.10'. ].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4'. ].	spec for: #'pharo1.1.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.13';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.9'. ].		spec for: #'pharo1.0.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.13';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.9'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.245';			project: 'SMTPMail' with: '0.239.1';			project: 'UTF8' with: '0.239.1';			project: 'System-Digital-Signatures' with: '0.239.1'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.45';					postLoadDoIt: #'initializeTransactionMutex1051'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.x' do: [		spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 10/20/2011 14:52'!version1063: spec	<version: '1.0.6.3' imports: #('1.0.6.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '1.0.6.1 (dkh.157):- address GemStone2.3.x upgrade issues for GLASS 1.0-beta.8.71.0.6.1 (dkh.158):- fix Issue 279: GRGemStoneRandomProvider class>>#''sessionStart'' calls TransientRandom>>#''open'' which does not exist  http://code.google.com/p/glassdb/issues/detail?id=279  GemStone 2.3 fix (GemStone 2.4 fixed in earlier version)1.0.6.1 (dkh.159):- port to GemStone 3.0.1 (#generatehardBreak changed for 3.0)- GemStone 3.0.1 fix for Issue 130: remote breakpoints don''t work  http://code.google.com/p/glassdb/issues/detail?id=1301.0.6.2 (StephaneDucasse.157): updating to renaming happening in RB :( 								- grease-slime.14.lr and a couple of others1.0.6.3 (dkh.172):- opened for development ... continued GemStone 3.0.1 work continued from 1.0.6.1- clean up tests when run against Minimal GLASS group'.		spec author: 'dkh'.		spec timestamp: '10/20/2011 14:51'. "Date today"		spec 			package: 'Grease-Core' with: 'Grease-Core-lr.66';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-lr.79'. ].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-lr.44';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13'. ].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.14';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.10'. ].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4'. ].	spec for: #'pharo1.1.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.13';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.9'. ].		spec for: #'pharo1.0.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.13';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.9'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.245';			project: 'SMTPMail' with: '0.239.1';			project: 'UTF8' with: '0.239.1';			project: 'System-Digital-Signatures' with: '0.239.1'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.46';					postLoadDoIt: #'initializeTransactionMutex1051'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.x' do: [		spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 11/17/2011 14:11'!version1064: spec	<version: '1.0.6.4' imports: #('1.0.6.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '1.0.6.4 (dkh.174):- open 1.0.6.4 for development- support for GemStone/S 2.4.5 release'.		spec author: 'dkh'.		spec timestamp: '11/17/2011 14:11'.		spec 			package: 'Grease-Core' with: 'Grease-Core-lr.66';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-lr.79'. ].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-lr.44';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13'. ].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.14';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.10'. ].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4'. ].	spec for: #'pharo1.1.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.13';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.9'. ].		spec for: #'pharo1.0.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.13';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.9'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.245';			project: 'SMTPMail' with: '0.239.1';			project: 'UTF8' with: '0.239.1';			project: 'System-Digital-Signatures' with: '0.239.1'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.47';					postLoadDoIt: #'initializeTransactionMutex1051'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.x' do: [		spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 12/02/2011 14:45'!version1065: spec	<version: '1.0.6.5' imports: #('1.0.6.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'open 1.0.6.5 for development1.0.6.5 (dkh.177) [GemStone only];- reimplement SendMail>>connectTo:on: to be portable between GemStone/S 2.x and 3.x'.		spec author: 'dkh'.		spec timestamp: '12/2/2011 14:16'.		spec 			package: 'Grease-Core' with: 'Grease-Core-lr.66';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-lr.79'. ].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-lr.44';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13'. ].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.14';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.10'. ].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4'. ].	spec for: #'pharo1.1.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.13';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.9'. ].		spec for: #'pharo1.0.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.13';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.9'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.245.2';			project: 'SMTPMail' with: '0.240.1';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.47';					postLoadDoIt: #'initializeTransactionMutex1051'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.x' do: [		spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 9/11/2011 11:34'!version106: spec	<version: '1.0.6' imports: #('1.0.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '1.0.6 (dkh.153):- open 1.0.6 for development- update to latest packages (http://code.google.com/p/seaside/wiki/Seaside306Changelog)- update GRPlatform version to 1.0.61.0.6 (dkh.154) [GEMSTONE]:- merge Grease-GemStone-Core-NickAger.431.0.6 (dkh.155) [GEMSTONE]:- fix Issue 290: transactionMutex is always nil  http://code.google.com/p/glassdb/issues/detail?id=290- fix Issue 287: Pick up GsMisc v.0239.1  http://code.google.com/p/glassdb/issues/detail?id=287'.		spec author: 'dkh'.		spec timestamp: '09/02/2011 17:03:50'.		spec 			package: 'Grease-Core' with: 'Grease-Core-dkh.65';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.78'. ].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.43';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13'. ].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.13';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.9'. ].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.245';			project: 'SMTPMail' with: '0.239.1';			project: 'UTF8' with: '0.239.1';			project: 'System-Digital-Signatures' with: '0.239.1'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.44';					postLoadDoIt: #'initializeTransactionMutex1051'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-DaleHenrichs.2'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 06/19/2012 17:01'!version1071: spec	<version: '1.0.7.1' imports: #('1.0.7.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- Port Grease to Pharo2.0.- BlockContext class no longer exists in Pharo2.0, so the BlockContext extension methods only needed for Pharo1.3 and earlier- Slime not ported to Pharo2.0, yet, so exclude- GemStone 3.1 support for libICU (Unicode)1.0.7.1 (dkh.186):- Adjust Utf8 code .. libICU produces a ByteArray when it encodes to UTF8, but Seaside wants Strings'.		spec author: 'dkh'.		spec timestamp: '6/19/2012 17:01'.		spec 			package: 'Grease-Core' with: 'Grease-Core-NickAger.70';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.80'. ].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-dkh.50';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13'. ].	spec for: #'pharo1.x' do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.14';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.10';			package: 'Grease-Pharo13-Core' with: 'Grease-Pharo13-Core-dkh.1'. ].	spec for: #'squeak' do: [		spec 			package: 'Grease-Pharo13-Core' with: 'Grease-Pharo13-Core-dkh.1'. ].		spec for: #'pharo1.1.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.13';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.9'. ].	spec for: #'pharo1.0.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.13';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.9'. ].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.246';			project: 'SMTPMail' with: '0.241';			project: 'UTF8' with: '0.241';			project: 'System-Digital-Signatures' with: '0.241'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.48';					postLoadDoIt: #'initializeTransactionMutex1051'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.x' do: [		spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 09/21/2012 14:23'!version1072: spec	<version: '1.0.7.2' imports: #('1.0.7.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: 'GemStone/S 3.1.0.1 support (GLASS 1.0-beta.8.7.3)'.		spec author: 'dkh'.		spec timestamp: '9/21/2012 14:23'.		spec 			package: 'Grease-Core' with: 'Grease-Core-NickAger.70';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.80'. ].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-dkh.50';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13'. ].	spec for: #'pharo1.x' do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.14';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.10';			package: 'Grease-Pharo13-Core' with: 'Grease-Pharo13-Core-dkh.1'. ].	spec for: #'squeak' do: [		spec 			package: 'Grease-Pharo13-Core' with: 'Grease-Pharo13-Core-dkh.1'. ].		spec for: #'pharo1.1.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.13';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.9'. ].	spec for: #'pharo1.0.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.13';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.9'. ].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.246.1';			project: 'SMTPMail' with: '0.241.1';			project: 'UTF8' with: '0.241.1';			project: 'System-Digital-Signatures' with: '0.241.1'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.48';					postLoadDoIt: #'initializeTransactionMutex1051'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.x' do: [		spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 4/25/2012 10:31'!version107: spec	<version: '1.0.7' imports: #('1.0.6.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: ''.		spec author: 'dkh'.		spec timestamp: '3/28/2012 16:39'.		spec 			package: 'Grease-Core' with: 'Grease-Core-NickAger.70';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.80'. ].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-NickAger.49';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13'. ].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.14';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.10'. ].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4'. ].	spec for: #'pharo1.1.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.13';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.9'. ].		spec for: #'pharo1.0.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.13';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.9'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.245.2';			project: 'SMTPMail' with: '0.240.1';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.47';					postLoadDoIt: #'initializeTransactionMutex1051'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.x' do: [		spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DamienCassou 10/17/2013 14:56'!version108: spec	<version: '1.0.8' imports: #('1.0.8-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: '- Seaside 3 for Pharo 2.0 and Squeak 4.4- support for Seaside3.1 on GemStone'.		spec author: 'dkh'.		spec timestamp: '9/15/2013 07:07'. 		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.72';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-DamienCassou.81'. ].			"RB/Slime"	spec for: #(#'squeak' #'pharo1.x' #'pharo2.x') do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-topa.15';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-JohanBrichau.11' ].			spec for: #(#'squeak' #'pharo1.x') do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.58';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13' ].	spec for: #(#'pharo2.x' #'pharo3.x') do: [		spec 			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-pmm.1';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13' ].	spec for: #( #'pharo1.x' #'squeak') do: [		spec 			package: 'Grease-Pharo13-Core' with: 'Grease-Pharo13-Core-dkh.1' ].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.246.1';			project: 'SMTPMail' with: '0.241.1';			project: 'UTF8' with: '0.241.1';			project: 'System-Digital-Signatures' with: '0.241.1'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.49';					postLoadDoIt: #'initializeTransactionMutex1051'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.x' do: [		spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'JohanBrichau 1/25/2014 14:04'!version109: spec	<version: '1.0.9' imports: #('1.0.8-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: '- Seaside 3 for Pharo 2.0 and Squeak 4.4- support for Seaside3.1 on GemStone'.		spec author: 'dkh'.		spec timestamp: '9/15/2013 07:07'. 		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.72';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.82'. ].			"RB/Slime"	spec for: #(#'squeak' #'pharo1.x' #'pharo2.x') do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-topa.15';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-JohanBrichau.11' ].			spec for: #(#'squeak' #'pharo1.x') do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.58';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13' ].	spec for: #(#'pharo2.x' #'pharo3.x') do: [		spec 			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-pmm.1';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.13' ].	spec for: #( #'pharo1.x' #'squeak') do: [		spec 			package: 'Grease-Pharo13-Core' with: 'Grease-Pharo13-Core-dkh.1' ].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.246.1';			project: 'SMTPMail' with: '0.241.1';			project: 'UTF8' with: '0.241.1';			project: 'System-Digital-Signatures' with: '0.241.1'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.49';					postLoadDoIt: #'initializeTransactionMutex1051'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.x' do: [		spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DaleHenrichs 10/11/2010 14:46'!version10: spec	<version: '1.0' imports: #('1.0-baseline' )>	spec for: #common do: [		spec blessing: #release.		spec description: '- 1.0 final'.		spec author: 'DaleHenrichs'.		spec timestamp: '10/11/2010 14:46'.		spec 			package: 'Grease-Core' with: 'Grease-Core-lr.48';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.60'.].	spec for: #squeakCommon do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-lr.29';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.8'.].	spec for: #pharo do: [		spec project: 'Refactoring-Core' with: '1.4'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-jok.5';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-jok.5'.].	spec for: #'GreaseForPharo1.0' do: [		spec package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-pmm.2'].	spec for: #gemstone do: [		spec 			project: 'GsCore' with: '0.241';			project: 'SMTPMail' with: '0.237';			project: 'UTF8' with: '0.237';			project: 'System-Digital-Signatures' with: '0.237'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-DaleHenrichs.26';					postLoadDoIt: #initializeNewRandomCaches10alpha3. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-DaleHenrichs.8'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-DaleHenrichs.2'.].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-DaleHenrichs.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 11/13/2009 10:41'!version10alpha1: spec	<version: '1.0-alpha1' imports: #('1.0-alpha1-baseline' )>	spec for: #'common' do: [		spec blessing: #'alpha'.		spec author: 'dkh'.		spec timestamp: '11/12/2009 09:41'.		spec 			package: 'Grease-Core' with: 'Grease-Core-obi.3';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-jf.1'.].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-jf.1';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-jf.1'.].	spec for: #'gemstone' do: [		spec			project: 'UTF8' with: '0.233';			project: 'System-Digital-Signatures' with: '0.233'.		spec 			package: 'Grease-GemStone-Core' with: 'Grease-GemStone-Core-dkh.5';			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.3'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 12/8/2009 16:07'!version10alpha2: spec	<version: '1.0-alpha2' imports: #('1.0-alpha2-baseline' )>	spec for: #common do: [		spec blessing: #alpha.		spec description: '- in GemStone the block arg for #on:do: must always have an argument- fix Issue 480: http://code.google.com/p/seaside/issues/detail?id=480 (GemStone/Pharo)- fix Issue 488: http://code.google.com/p/seaside/issues/detail?id=488- fix Issue 499: http://code.google.com/p/seaside/issues/detail?id=499 (GemStone/Pharo)- support for loading Grease into a 2.3 GemStone/S repository- support ''UTF-8'' has a codec name as well- pick up latest repository changes as of 11/17/2009 15:09"'.		spec author: 'dkh'.		spec timestamp: '11/23/2009 16:09'.		spec 			package: 'Grease-Core' with: 'Grease-Core-dkh.8';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.5'.].	spec for: #squeakCommon do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-dkh.3';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-dkh.2'.].	spec for: #gemstone do: [		spec 			project: 'SMTPMail' with: '0.233';			project: 'UTF8' with: '0.233';			project: 'System-Digital-Signatures' with: '0.233'.		spec 			package: 'Grease-GemStone-Core' with: 'Grease-GemStone-Core-dkh.9';			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.5'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DaleHenrichs 1/22/2010 10:55'!version10alpha3: spec	<version: '1.0-alpha3' imports: #('1.0-alpha2-baseline' )>	spec for: #'common' do: [		spec blessing: #'alpha'.		spec description: '- pick up latest developer package versions (12/8/2009 16:14)"'.		spec author: 'dkh'.		spec timestamp: '12/23/09 16:52:29'.		spec 			package: 'Grease-Core' with: 'Grease-Core-dkh.8';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-jf.7'.].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-dkh.4';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-dkh.2'.].	spec for: #'gemstone' do: [		spec 			project: 'SMTPMail' with: '0.233';			project: 'UTF8' with: '0.233';			project: 'System-Digital-Signatures' with: '0.233'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.12';					postLoadDoIt: #'initializeNewRandomCaches10alpha3'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.5'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DaleHenrichs 1/22/2010 16:02'!version10alpha4: spec	<version: '1.0-alpha4' imports: #('1.0-alpha2-baseline' )>	spec for: #common do: [		spec blessing: #alpha.		spec description: '- pick up latest developer package versions (1/22/2010 12:06)"'.		spec author: 'DaleHenrichs'.		spec timestamp: '1/22/2010 12:08'.		spec 			package: 'Grease-Core' with: 'Grease-Core-jf.14';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-jok.17'.].	spec for: #squeakCommon do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-jf.7';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-jf.5'.].	spec for: #gemstone do: [		spec blessing: #broken.		spec description: 'NOT PORTED TO GEMSTONE'.		spec 			project: 'SMTPMail' with: '0.233';			project: 'UTF8' with: '0.233';			project: 'System-Digital-Signatures' with: '0.233'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.12';					postLoadDoIt: #initializeNewRandomCaches10alpha3. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.5'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 1/27/2010 15:38'!version10alpha501: spec	<version: '1.0-alpha5.1' imports: #('1.0-alpha5-baseline' )>	spec for: #common do: [		spec blessing: #alpha.		spec description: '- pick up latest developer package versions (1/22/2010 12:06)"'.		spec author: 'dkh'.		spec timestamp: '1/27/2010 15:01'.		spec 			package: 'Grease-Core' with: 'Grease-Core-jok.15';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-jok.22'.].	spec for: #squeakCommon do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-jf.8';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-jf.5'.].	spec for: #pharo do: [		spec project: 'Refactoring-Core' with: '1.1'.		spec			package: 'Grease-Slime' with: 'Grease-Slime-jok.2';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-jok.1'. ].	spec for: #gemstone do: [		spec blessing: #broken.		spec description: 'NOT PORTED TO GEMSTONE'.		spec 			project: 'SMTPMail' with: '0.233';			project: 'UTF8' with: '0.233';			project: 'System-Digital-Signatures' with: '0.233'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.12';					postLoadDoIt: #initializeNewRandomCaches10alpha3. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.5'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DaleHenrichs 3/1/2010 14:57'!version10alpha6: spec	<version: '1.0-alpha6' imports: #('1.0-alpha5-baseline' )>	spec for: #common do: [		spec blessing: #alpha.		spec description: '- pick up latest developer package versions (3/1/2010 12:39)'.		spec author: 'DaleHenrichs'.		spec timestamp: '3/1/2010 13:16'.		spec 			package: 'Grease-Core' with: 'Grease-Core-obi.30';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.39'.].	spec for: #squeakCommon do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.13';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.6'.].	spec for: #pharo do: [		spec project: 'Refactoring-Core' with: '1.1'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.3';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.2'.].	spec for: #gemstone do: [		spec blessing: #broken.		spec description: 'NOT PORTED TO GEMSTONE'.		spec 			project: 'SMTPMail' with: '0.233';			project: 'UTF8' with: '0.233';			project: 'System-Digital-Signatures' with: '0.233'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.12';					postLoadDoIt: #initializeNewRandomCaches10alpha3. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.5'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DaleHenrichs 3/29/2010 12:41'!version10alpha7: spec	<version: '1.0-alpha7' imports: #('1.0-alpha7-baseline' )>	spec for: #common do: [		spec blessing: #alpha.		spec description: '- pick up latest developer package versions (3/29/2010 11:09)'.		spec author: 'DaleHenrichs'.		spec timestamp: '3/29/2010 11:34'.		spec 			package: 'Grease-Core' with: 'Grease-Core-jok.31';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-jok.43'.].	spec for: #squeakCommon do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-jok.14';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.6'.].	spec for: #pharo do: [		spec project: 'Refactoring-Core' with: '1.2'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-jok.4';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-jok.3'.].	spec for: #gemstone do: [		spec blessing: #broken.		spec description: 'NOT PORTED TO GEMSTONE'.		spec 			project: 'SMTPMail' with: '0.233';			project: 'UTF8' with: '0.233';			project: 'System-Digital-Signatures' with: '0.233'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.12';					postLoadDoIt: #initializeNewRandomCaches10alpha3. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.5'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DaleHenrichs 4/9/2010 15:52'!version10alpha8: spec	<version: '1.0-alpha8' imports: #('1.0-alpha7-baseline' )>	spec for: #common do: [		spec blessing: #development.		spec description: '- pick up latest developer package versions (4/9/2010 15:51)'.		spec author: 'DaleHenrichs'.		spec timestamp: '4/9/2010 15:52'.		spec 			package: 'Grease-Core' with: 'Grease-Core-jok.31';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-jok.45'.].	spec for: #squeakCommon do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-lr.15';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-lr.6'.].	spec for: #pharo do: [		spec project: 'Refactoring-Core' with: '1.2'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-jok.4';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-lr.4'.].	spec for: #gemstone do: [		spec blessing: #broken.		spec description: 'NOT PORTED TO GEMSTONE'.		spec 			project: 'SMTPMail' with: '0.233';			project: 'UTF8' with: '0.233';			project: 'System-Digital-Signatures' with: '0.233'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.12';					postLoadDoIt: #initializeNewRandomCaches10alpha3. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.5'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'dkh 5/14/2010 17:09'!version10alpha91: spec	<version: '1.0-alpha9.1' imports: #('1.0-alpha7-baseline' )>	spec for: #common do: [		spec blessing: #alpha.		spec description: '- pick up latest developer package versions Pharo1.1 compat (5/14/2010 13:29)- pick up latest Refactoring-Core'.		spec author: 'DaleHenrichs'.		spec timestamp: '5/14/2010 13:47'.		spec 			package: 'Grease-Core' with: 'Grease-Core-lr.37';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-lr.50'.].	spec for: #squeakCommon do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-jok.18';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-jok.7'.].	spec for: #pharo do: [		spec project: 'Refactoring-Core' with: '1.3'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-jok.5';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-jok.5'.].	spec for: #gemstone do: [		spec blessing: #broken.		spec description: 'NOT PORTED TO GEMSTONE'.		spec 			project: 'SMTPMail' with: '0.233';			project: 'UTF8' with: '0.233';			project: 'System-Digital-Signatures' with: '0.233'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.12';					postLoadDoIt: #initializeNewRandomCaches10alpha3. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.5'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DaleHenrichs 6/1/2010 14:33'!version10alpha92: spec	<version: '1.0-alpha9.2' imports: #('1.0-alpha7-baseline' )>	spec for: #common do: [		spec blessing: #alpha.		spec description: '- pick up latest mcz files(6/1/2010 10:21)'.		spec author: 'DaleHenrichs'.		spec timestamp: '6/1/2010 10:21'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.42';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.56'.].	spec for: #squeakCommon do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.23';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-jok.7'.].	spec for: #pharo do: [		spec project: 'Refactoring-Core' with: '1.3'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-jok.5';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-jok.5'.].	spec for: #gemstone do: [		spec blessing: #broken.		spec description: 'NOT PORTED TO GEMSTONE'.		spec 			project: 'SMTPMail' with: '0.233';			project: 'UTF8' with: '0.233';			project: 'System-Digital-Signatures' with: '0.233'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.12';					postLoadDoIt: #initializeNewRandomCaches10alpha3. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.5'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DaleHenrichs 7/13/2010 10:24'!version10alpha93: spec	<version: '1.0-alpha9.3' imports: #('1.0-alpha9.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- refactor groups:On platforms without Slime   ''Core''        = #(''Grease-Core'')   ''Core Tests''  = #(''Grease-Tests-Core'')   ''Slime''       = #(''Core'')   ''Slime Tests'' = #(''Core Tests'')   ''Tests''       = #(''Core Tests'' ''Slime Tests'')   ''default''     = #(''Slime'')On platforms with Slime   ''Core''        = #(''Grease-Core'')   ''Core Tests''  = #(''Grease-Tests-Core'')   ''Slime''       = #(''Core'' ''Grease-Slime'')   ''Slime Tests'' = #(''Core Tests'' ''Grease-Tests-Slime'')   ''Tests''       = #(''Core Tests'' ''Slime Tests'')   ''default''     = #(''Slime'')- port to GemStone GLASS 1.0-beta.8- adjust grease tests for GemStone Interval implementation; replace #= with #keysAndValuesDo:'.		spec author: 'DaleHenrichs'.		spec timestamp: '6/4/2010 17:41'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.42';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-DaleHenrichs.58'.].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.23';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-jok.7'.].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: '1.3'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-jok.5';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-jok.5'.].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.241';			project: 'SMTPMail' with: '0.236';			project: 'UTF8' with: '0.236';			project: 'System-Digital-Signatures' with: '0.236'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-DaleHenrichs.16';					postLoadDoIt: #'initializeNewRandomCaches10alpha3'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-DaleHenrichs.7'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DaleHenrichs 5/12/2010 17:56'!version10alpha9: spec	<version: '1.0-alpha9' imports: #('1.0-alpha7-baseline' )>	spec for: #common do: [		spec blessing: #alpha.		spec description: '- pick up latest developer package versions (5/12/2010 16:34)- 1.0-alpha8 skipped as it is still in development'.		spec author: 'DaleHenrichs'.		spec timestamp: '5/12/2010 17:15'.		spec 			package: 'Grease-Core' with: 'Grease-Core-DaleHenrichs.36';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-lr.49'.].	spec for: #squeakCommon do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-jok.18';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-jok.7'.].	spec for: #pharo do: [		spec project: 'Refactoring-Core' with: '1.2'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-jok.5';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-jok.5'.].	spec for: #gemstone do: [		spec blessing: #broken.		spec description: 'NOT PORTED TO GEMSTONE'.		spec 			project: 'SMTPMail' with: '0.233';			project: 'UTF8' with: '0.233';			project: 'System-Digital-Signatures' with: '0.233'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.12';					postLoadDoIt: #initializeNewRandomCaches10alpha3. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.5'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DaleHenrichs 08/27/2010 13:15'!version10rc1: spec	<version: '1.0-rc.1' imports: #('1.0-rc-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: 'code updates as of 8/27/2010 10:49'.		spec author: 'DaleHenrichs'.		spec timestamp: '08/27/2010 12:05:55'.		spec 			package: 'Grease-Core' with: 'Grease-Core-jf.45';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-lr.59'.].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-lr.27';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.8'.].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: '1.3'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-jok.5';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-jok.5'.].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.241';			project: 'SMTPMail' with: '0.237';			project: 'UTF8' with: '0.237';			project: 'System-Digital-Signatures' with: '0.237'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-DaleHenrichs.25';					postLoadDoIt: #'initializeNewRandomCaches10alpha3'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-DaleHenrichs.8'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-DaleHenrichs.2'.].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-DaleHenrichs.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DaleHenrichs 09/03/2010 09:49'!version10rc2: spec	<version: '1.0-rc.2' imports: #('1.0-rc-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: 'GemStone bugfixes:- fix Issue 165: http://code.google.com/p/glassdb/issues/detail?id=165 "Include GemStone version of Seaside-FileSystem in Seaside3.0"'.		spec author: 'DaleHenrichs'.		spec timestamp: '09/02/2010 16:22:59'.		spec 			package: 'Grease-Core' with: 'Grease-Core-jf.45';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-lr.59'.].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-lr.27';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.8'.].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: '1.3'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-jok.5';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-jok.5'.].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.241';			project: 'SMTPMail' with: '0.237';			project: 'UTF8' with: '0.237';			project: 'System-Digital-Signatures' with: '0.237'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-DaleHenrichs.26';					postLoadDoIt: #'initializeNewRandomCaches10alpha3'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-DaleHenrichs.8'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-DaleHenrichs.2'.].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-DaleHenrichs.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.0.x)' stamp: 'DaleHenrichs 07/27/2010 12:49'!version10rc: spec	<version: '1.0-rc' imports: #('1.0-rc-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '- Grease 1.0 release candidate- port Grease to GemStone 3.0'.		spec author: 'DaleHenrichs'.		spec timestamp: '07/27/10 12:49:44'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.42';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-DaleHenrichs.58'.].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-DaleHenrichs.24';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-jok.7'.].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: '1.3'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-jok.5';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-jok.5'.].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.241';			project: 'SMTPMail' with: '0.237';			project: 'UTF8' with: '0.237';			project: 'System-Digital-Signatures' with: '0.237'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-DaleHenrichs.21';					postLoadDoIt: #'initializeNewRandomCaches10alpha3'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-DaleHenrichs.8'.].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.2'.].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-DaleHenrichs.2'.].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-DaleHenrichs.2'.].! !!ConfigurationOfGrease methodsFor: 'versions (1.1.x)' stamp: 'pmm 8/27/2012 14:54'!version110: spec	<version: '1.1.0' imports: #('1.1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: ''.		spec author: 'pmm'.		spec timestamp: '08/05/2012 19:27'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.74';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.84'. ].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.52';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.17'. ].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.17';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.11'.		spec 			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-pmm.10';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.3'. ].	spec for: #'pharo1.x' do: [		spec			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.245.2';			project: 'SMTPMail' with: '0.240.1';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.47';					postLoadDoIt: #'initializeTransactionMutex1051'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.x' do: [		spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.1.x)' stamp: 'JohanBrichau 7/20/2014 18:05'!version1110: spec	<version: '1.1.10' imports: #('1.1.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'released'.		spec author: 'JohanBrichau'.		spec timestamp: '7/4/2014 11:33'.		spec 			package: 'Grease-Core' with: 'Grease-Core-JohanBrichau.89';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-JohanBrichau.95'. ].	spec for: #'squeak' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21'. ].	spec for: #'pharo' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-JohanBrichau.27';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.18'. ].	spec for: #'pharo4.x' do: [		spec 			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-pmm.15';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.11'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-pmm.15';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.11'. ].	spec for: #'pharo2.x' do: [		spec 			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-pmm.19';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.11'. ].	spec for: #'pharo1.x' do: [		spec 			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21'. ].	spec for: #'gemstone' do: [		spec 			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-JohanBrichau.52';					postLoadDoIt: #'initializeTransactionMutex1051'. ]. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4'. ].	spec for: #'gs2.x' do: [		spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.1.x)' stamp: 'JohanBrichau 9/6/2014 19:01'!version1111: spec	<version: '1.1.11' imports: #('1.1.4-baseline' )>	spec for: #'common' do: [		spec blessing: #'released'.		spec author: 'JohanBrichau'.		spec timestamp: '9/6/2014 12:30'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.93';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.99'. ].	spec for: #'squeak' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21'. ].	spec for: #'pharo' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.19'. ].	spec for: #'pharo4.x' do: [		spec 			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-pmm.15';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.11'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-pmm.15';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.11'. ].	spec for: #'pharo2.x' do: [		spec 			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-pmm.19';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.11'. ].	spec for: #'pharo1.x' do: [		spec 			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21'. ].			spec for: #'gs2.x' do: [		spec 			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-JohanBrichau.52';					postLoadDoIt: #'initializeTransactionMutex1051'. ]. ].	spec 		for: #'gs3.x'		do: [			spec import: 'Grease'.			spec baseline: 'Grease' with: [ spec repository: 'github://GsDevKit/Grease:v1.1.11/repository' ] ].! !!ConfigurationOfGrease methodsFor: 'versions (1.1.x)' stamp: 'JohanBrichau 11/8/2014 12:37'!version1112: spec	<version: '1.1.12' imports: #('1.1.5-baseline' )>	spec for: #'common' do: [		spec blessing: #'released'.		spec author: 'JohanBrichau'.		spec timestamp: '11/7/2014 12:36'.		spec 			package: 'Grease-Core' with: 'Grease-Core-JohanBrichau.94';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.99'. ].	spec for: #'squeak' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21'. ].	spec for: #'pharo' do: [		spec 			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.19'. ].			spec for: #'pharo1.x' do: [		spec 			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21' ].	spec for: #'pharo2.x' do: [		spec			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-JohanBrichau.20';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].			spec for: #'pharo3.x' do: [		spec			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.16';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'pharo4.x' do: [		spec			package: 'Grease-Pharo40-Slime' with: 'Grease-Pharo40-Slime-JohanBrichau.3';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-pmm.15';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'gs2.x' do: [		spec 			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-JohanBrichau.52';					postLoadDoIt: #'initializeTransactionMutex1051'. ]. ].	spec for: #'gs3.x' do: [		spec import: 'Grease'.		spec baseline: 'Grease' with: [				spec repository: 'github://GsDevKit/Grease:v1.1.12/repository' ]. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.1.x)' stamp: 'StephanEggermont 7/13/2015 10:52'!version11131: spec	<version: '1.1.13.1' imports: #('1.1.5-baseline' )>	spec for: #'common' do: [		spec blessing: #'released'.		spec author: 'StephanEggermont'.		spec timestamp: '2015-07-12 15:08'.		spec 			package: 'Grease-Core' with: 'Grease-Core-JohanBrichau.94';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.99'. ].	spec for: #'squeak' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21'. ].	spec for: #'pharo' do: [		spec 			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.19'. ].			spec for: #'pharo1.x' do: [		spec 			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21' ].	spec for: #'pharo2.x' do: [		spec			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-JohanBrichau.20';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].			spec for: #'pharo3.x' do: [		spec			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.16';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #(#'pharo4.x' #'pharo5.x') do: [		spec			package: 'Grease-Pharo40-Slime' with: 'Grease-Pharo40-Slime-JohanBrichau.3';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.16';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'gs2.x' do: [		spec 			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-JohanBrichau.52';					postLoadDoIt: #'initializeTransactionMutex1051'. ]. ].	spec for: #'gs3.x' do: [		spec import: 'Grease'.		spec baseline: 'Grease' with: [				spec repository: 'github://GsDevKit/Grease:v1.1.12/repository' ]. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.1.x)' stamp: 'StephanEggermont 11/10/2014 15:35'!version1113: spec	<version: '1.1.13' imports: #('1.1.5-baseline' )>	spec for: #'common' do: [		spec blessing: #'released'.		spec author: 'JohanBrichau'.		spec timestamp: '11/7/2014 12:36'.		spec 			package: 'Grease-Core' with: 'Grease-Core-JohanBrichau.94';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.99'. ].	spec for: #'squeak' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21'. ].	spec for: #'pharo' do: [		spec 			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.19'. ].			spec for: #'pharo1.x' do: [		spec 			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21' ].	spec for: #'pharo2.x' do: [		spec			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-JohanBrichau.20';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].			spec for: #'pharo3.x' do: [		spec			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.16';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'pharo4.x' do: [		spec			package: 'Grease-Pharo40-Slime' with: 'Grease-Pharo40-Slime-JohanBrichau.3';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.16';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'gs2.x' do: [		spec 			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-JohanBrichau.52';					postLoadDoIt: #'initializeTransactionMutex1051'. ]. ].	spec for: #'gs3.x' do: [		spec import: 'Grease'.		spec baseline: 'Grease' with: [				spec repository: 'github://GsDevKit/Grease:v1.1.12/repository' ]. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.1.x)' stamp: 'JohanBrichau 7/21/2013 22:23'!version111: spec	<version: '1.1.1' imports: #('1.1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: 'Issue 733: multibyte characters broken when flushing a WAComboResponse + Slime fixes'.		spec author: 'JohanBrichau'.		spec timestamp: '07/21/2013 19:27'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.76';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.84'. ].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.52';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.17'. ].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.17';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.11'.		spec 			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-pmm.10';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.3'. ].	spec for: #'pharo1.x' do: [		spec			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.245.2';			project: 'SMTPMail' with: '0.240.1';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.47';					postLoadDoIt: #'initializeTransactionMutex1051'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.x' do: [		spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.1.x)' stamp: 'JohanBrichau 8/22/2013 20:03'!version112: spec	<version: '1.1.2' imports: #('1.1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec author: 'JohanBrichau'.		spec timestamp: '08/22/2013 20:00'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.76';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.86'. ].	spec for: #'squeakCommon' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.52';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.17'. ].	spec for: #'pharo' do: [		spec project: 'Refactoring-Core' with: #'stable'.		spec 			package: 'Grease-Slime' with: 'Grease-Slime-lr.17';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.11'.		spec 			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-pmm.10';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.4'. ].	spec for: #'pharo1.x' do: [		spec			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1'. ].	spec for: #'gemstone' do: [		spec 			project: 'GsCore' with: '0.245.2';			project: 'SMTPMail' with: '0.240.1';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-dkh.47';					postLoadDoIt: #'initializeTransactionMutex1051'. ];			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14'. ].	spec for: #'gs2.x' do: [		spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2'. ].	spec for: #'gs2.3.x' do: [		spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4'. ].	spec for: #'gs2.4.x' do: [		spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3'. ].	spec for: #'gs3.x' do: [		spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4'. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.1.x)' stamp: 'pmm 12/21/2013 12:31'!version113: spec	<version: '1.1.3' imports: #('1.1.3-baseline')>	spec		for: #common		do: [ 			spec blessing: #development.			spec author: 'JohanBrichau'.			spec timestamp: '9/14/2013 12:42'.			spec				package: 'Grease-Core' with: 'Grease-Core-pmm.82';				package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-DamienCassou.92' ].	spec		for: #squeak		do: [ 			spec project: 'Refactoring-Core' with: #stable.			spec				package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';				package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21';				package: 'Grease-Slime' with: 'Grease-Slime-pmm.24';				package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.18' ].	spec		for: #'pharo1.x'		do: [ 			spec project: 'Refactoring-Core' with: #stable.			spec				package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';				package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21';				package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';				package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';				package: 'Grease-Slime' with: 'Grease-Slime-pmm.24';				package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.18' ].	spec		for: #'pharo2.x'		do: [ 			spec project: 'Refactoring-Core' with: #stable.			spec				package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-pmm.17';				package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.8';				package: 'Grease-Slime' with: 'Grease-Slime-pmm.24';				package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.18' ].	spec		for: #'pharo3.x'		do: [ 			spec				package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-pmm.11';				package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.8' ].	spec		for: #gemstone		do: [ 			spec				project: 'GsCore' with: '0.245.2';				project: 'SMTPMail' with: '0.240.1';				project: 'UTF8' with: '0.240.1';				project: 'System-Digital-Signatures' with: '0.240.1'.			spec				package: 'Grease-GemStone-Core'					with: [ 							spec								file: 'Grease-GemStone-Core-dkh.47';								postLoadDoIt: #initializeTransactionMutex1051 ];				package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14' ].	spec for: #'gs2.x' do: [ spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2' ].	spec for: #'gs2.3.x' do: [ spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4' ].	spec for: #'gs2.4.x' do: [ spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3' ].	spec for: #'gs3.x' do: [ spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4' ]! !!ConfigurationOfGrease methodsFor: 'versions (1.1.x)' stamp: 'pmm 12/21/2013 12:31'!version114: spec	<version: '1.1.4' imports: #('1.1.3-baseline')>	spec		for: #common		do: [ 			spec blessing: #development.			spec author: 'JohanBrichau'.			spec timestamp: '12/15/2013 19:00'.			spec				package: 'Grease-Core' with: 'Grease-Core-JohanBrichau.83';				package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-JohanBrichau.93'];		for: #squeak		do: [ 			spec project: 'Refactoring-Core' with: #stable.			spec				package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';				package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21';				package: 'Grease-Slime' with: 'Grease-Slime-pmm.24';				package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.18' ].	spec		for: #'pharo1.x'		do: [ 			spec project: 'Refactoring-Core' with: #stable.			spec				package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';				package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21';				package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';				package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';				package: 'Grease-Slime' with: 'Grease-Slime-pmm.24';				package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.18' ].	spec		for: #'pharo2.x'		do: [ 			spec project: 'Refactoring-Core' with: #stable.			spec				package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-pmm.17';				package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.8';				package: 'Grease-Slime' with: 'Grease-Slime-pmm.24';				package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.18' ].	spec		for: #'pharo3.x'		do: [ 			spec				package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-pmm.11';				package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.8' ].	spec		for: #gemstone		do: [ 			spec				project: 'GsCore' with: '0.245.2';				project: 'SMTPMail' with: '0.240.1';				project: 'UTF8' with: '0.240.1';				project: 'System-Digital-Signatures' with: '0.240.1'.			spec				package: 'Grease-GemStone-Core'					with: [ 							spec								file: 'Grease-GemStone-Core-dkh.47';								postLoadDoIt: #initializeTransactionMutex1051 ];				package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14' ].	spec for: #'gs2.x' do: [ spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2' ].	spec for: #'gs2.3.x' do: [ spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4' ].	spec for: #'gs2.4.x' do: [ spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3' ].	spec for: #'gs3.x' do: [ spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4' ]! !!ConfigurationOfGrease methodsFor: 'versions (1.1.x)' stamp: 'JohanBrichau 1/18/2014 07:09'!version115: spec	<version: '1.1.5' imports: #('1.1.3-baseline')>	spec		for: #common		do: [ 			spec author: 'JohanBrichau'.			spec timestamp: '12/15/2013 19:00'.			spec				package: 'Grease-Core' with: 'Grease-Core-JohanBrichau.83';				package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.94' ];		for: #squeak		do: [ 			spec project: 'Refactoring-Core' with: #stable.			spec				package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';				package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21';				package: 'Grease-Slime' with: 'Grease-Slime-pmm.24';				package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.18' ].	spec		for: #'pharo1.x'		do: [ 			spec project: 'Refactoring-Core' with: #stable.			spec				package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';				package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21';				package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';				package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';				package: 'Grease-Slime' with: 'Grease-Slime-pmm.24';				package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.18' ].	spec		for: #'pharo2.x'		do: [ 			spec project: 'Refactoring-Core' with: #stable.			spec				package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-pmm.17';				package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.8';				package: 'Grease-Slime' with: 'Grease-Slime-pmm.24';				package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.18' ].	spec		for: #'pharo3.x'		do: [ 			spec				package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-pmm.11';				package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.8' ].	spec		for: #gemstone		do: [ 			spec				project: 'GsCore' with: '0.245.2';				project: 'SMTPMail' with: '0.240.1';				project: 'UTF8' with: '0.240.1';				project: 'System-Digital-Signatures' with: '0.240.1'.			spec				package: 'Grease-GemStone-Core'					with: [ 							spec								file: 'Grease-GemStone-Core-dkh.49';								postLoadDoIt: #initializeTransactionMutex1051 ];				package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14' ].	spec for: #'gs2.x' do: [ spec package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2' ].	spec for: #'gs2.3.x' do: [ spec package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4' ].	spec for: #'gs2.4.x' do: [ spec package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3' ].	spec for: #'gs3.x' do: [ spec package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4' ]! !!ConfigurationOfGrease methodsFor: 'versions (1.1.x)' stamp: 'JohanBrichau 4/5/2014 14:19'!version116: aSpec	<version: '1.1.6' imports: #( '1.1.4-baseline')>	aSpec for: #'common' do: [		aSpec			blessing: #'release';			author: 'JohanBrichau';			timestamp: '02/16/2014 21:30'.		aSpec			package: 'Grease-Core' with: 'Grease-Core-JohanBrichau.86';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-JohanBrichau.95' ].	aSpec for: #'squeak' do: [		aSpec			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21' ].	aSpec for: #'pharo' do: [		aSpec			package: 'Grease-Slime' with: 'Grease-Slime-JohanBrichau.25';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.18' ].	aSpec for: #'pharo3.x' do: [		aSpec			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.13';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.9' ].	aSpec for: #'pharo2.x' do: [		aSpec			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.9' ].	aSpec for: #'pharo1.x' do: [		aSpec			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21' ].	aSpec for: #'gemstone' do: [		aSpec			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		aSpec			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				aSpec					file: 'Grease-GemStone-Core-dkh.49';					postLoadDoIt: #'initializeTransactionMutex1051' ] ].	aSpec for: #'gs3.x' do: [		aSpec			package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4' ].	aSpec for: #'gs2.x' do: [		aSpec			package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2' ].	aSpec for: #'gs2.4.x' do: [		aSpec			package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3' ].	aSpec for: #'gs2.3.x' do: [		aSpec			package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4' ]! !!ConfigurationOfGrease methodsFor: 'versions (1.1.x)' stamp: 'JohanBrichau 4/5/2014 15:12'!version117: aSpec	<version: '1.1.7' imports: #( '1.1.4-baseline')>	aSpec for: #'common' do: [		aSpec			blessing: #'release';			author: 'JohanBrichau';			timestamp: '04/05/2014 14:20'.		aSpec			package: 'Grease-Core' with: 'Grease-Core-JohanBrichau.86';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-JohanBrichau.95' ].	aSpec for: #'squeak' do: [		aSpec			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21' ].	aSpec for: #'pharo' do: [		aSpec			package: 'Grease-Slime' with: 'Grease-Slime-topa.26';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.18' ].	aSpec for: #'pharo3.x' do: [		aSpec			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.13';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.9' ].	aSpec for: #'pharo2.x' do: [		aSpec			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.9' ].	aSpec for: #'pharo1.x' do: [		aSpec			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21' ].	aSpec for: #'gemstone' do: [		aSpec			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		aSpec			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				aSpec					file: 'Grease-GemStone-Core-dkh.49';					postLoadDoIt: #'initializeTransactionMutex1051' ] ].	aSpec for: #'gs3.x' do: [		aSpec			package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4' ].	aSpec for: #'gs2.x' do: [		aSpec			package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2' ].	aSpec for: #'gs2.4.x' do: [		aSpec			package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3' ].	aSpec for: #'gs2.3.x' do: [		aSpec			package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4' ]! !!ConfigurationOfGrease methodsFor: 'versions (1.1.x)' stamp: 'JohanBrichau 4/19/2014 19:57'!version118: aSpec	<version: '1.1.8' imports: #( '1.1.4-baseline')>	aSpec for: #'common' do: [		aSpec			blessing: #'release';			author: 'JohanBrichau';			timestamp: '04/19/2014 19:20'.		aSpec			package: 'Grease-Core' with: 'Grease-Core-JohanBrichau.86';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-JohanBrichau.95' ].	aSpec for: #'squeak' do: [		aSpec			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21' ].	aSpec for: #'pharo' do: [		aSpec			package: 'Grease-Slime' with: 'Grease-Slime-topa.26';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.18' ].	aSpec for: #'pharo3.x' do: [		aSpec			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.13';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.9' ].	aSpec for: #'pharo2.x' do: [		aSpec			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.9' ].	aSpec for: #'pharo1.x' do: [		aSpec			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21' ].	aSpec for: #'gemstone' do: [		aSpec			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		aSpec			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				aSpec					file: 'Grease-GemStone-Core-JohanBrichau.52';					postLoadDoIt: #'initializeTransactionMutex1051' ] ].	aSpec for: #'gs3.x' do: [		aSpec			package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4' ].	aSpec for: #'gs2.x' do: [		aSpec			package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2' ].	aSpec for: #'gs2.4.x' do: [		aSpec			package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3' ].	aSpec for: #'gs2.3.x' do: [		aSpec			package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4' ]! !!ConfigurationOfGrease methodsFor: 'versions (1.1.x)' stamp: 'DamienCassou 6/10/2014 08:12'!version119: aSpec	<version: '1.1.9' imports: #( '1.1.4-baseline')>	aSpec for: #'common' do: [		aSpec			blessing: #'release';			author: 'JohanBrichau';			timestamp: '05/24/2014 17:08'.		aSpec			package: 'Grease-Core' with: 'Grease-Core-JohanBrichau.86';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-JohanBrichau.95' ].	aSpec for: #'squeak' do: [		aSpec			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21' ].	aSpec for: #'pharo' do: [		aSpec			package: 'Grease-Slime' with: 'Grease-Slime-topa.26';			package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.18' ].	aSpec for: #'pharo4.x' do: [		aSpec			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-pmm.15';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.11' ].	aSpec for: #'pharo3.x' do: [		aSpec			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-pmm.15';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.11' ].	aSpec for: #'pharo2.x' do: [		aSpec			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-pmm.19';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.11' ].	aSpec for: #'pharo1.x' do: [		aSpec			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.67';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.21' ].	aSpec for: #'gemstone' do: [		aSpec			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		aSpec			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				aSpec					file: 'Grease-GemStone-Core-JohanBrichau.52';					postLoadDoIt: #'initializeTransactionMutex1051' ] ].	aSpec for: #'gs3.x' do: [		aSpec			package: 'Grease-GemStone300-Core' with: 'Grease-GemStone300-Core-dkh.4' ].	aSpec for: #'gs2.x' do: [		aSpec			package: 'Grease-GemStone200-Core' with: 'Grease-GemStone200-Core-dkh.2' ].	aSpec for: #'gs2.4.x' do: [		aSpec			package: 'Grease-GemStone240-Core' with: 'Grease-GemStone240-Core-dkh.3' ].	aSpec for: #'gs2.3.x' do: [		aSpec			package: 'Grease-GemStone230-Core' with: 'Grease-GemStone230-Core-dkh.4' ]! !!ConfigurationOfGrease methodsFor: 'versions (1.2.x)' stamp: 'JohanBrichau 7/15/2015 14:02'!version120: spec	<version: '1.2.0' imports: #('1.1.6-baseline' )>	spec for: #'common' do: [		spec blessing: #'released'.		spec author: 'JohanBrichau'.		spec timestamp: '7/15/2015 13:18'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.96';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-JohanBrichau.101'. ].	spec for: #'squeak' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-JohanBrichau.74';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22';			package: 'Grease-Squeak-Core' with: 'Grease-Squeak-Core-JohnMcKeon.2';			package: 'Grease-Tests-Squeak-Core' with: 'Grease-Tests-Squeak-Core-JohnMcKeon.1'. ].	spec for: #'pharo' do: [		spec package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.19'. ].	spec for: #'pharo1.x' do: [		spec 			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-JohanBrichau.74';			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22'. ].	spec for: #'pharo2.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-JohanBrichau.22';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #(#'pharo4.x' #'pharo5.x' ) do: [		spec 			package: 'Grease-Pharo40-Slime' with: 'Grease-Pharo40-Slime-JohanBrichau.3';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'gs2.x' do: [		spec 			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-JohanBrichau.52';					postLoadDoIt: #'initializeTransactionMutex1051'. ]. ].	spec for: #'gs3.x' do: [		spec import: 'Grease'.		spec baseline: 'Grease' with: [				spec repository: 'github://GsDevKit/Grease:v1.2.0/repository' ]. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.2.x)' stamp: 'JohanBrichau 7/24/2015 09:37'!version121: spec	<version: '1.2.1' imports: #('1.1.6-baseline' )>	spec for: #'common' do: [		spec blessing: #'released'.		spec author: 'JohanBrichau'.		spec timestamp: '7/24/2015 09:35'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.96';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.104'. ].	spec for: #'squeak' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-JohanBrichau.74';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22';			package: 'Grease-Squeak-Core' with: 'Grease-Squeak-Core-JohnMcKeon.2';			package: 'Grease-Tests-Squeak-Core' with: 'Grease-Tests-Squeak-Core-JohnMcKeon.1'. ].	spec for: #'pharo' do: [		spec package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.19'. ].	spec for: #'pharo1.x' do: [		spec 			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-JohanBrichau.74';			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22'. ].	spec for: #'pharo2.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-JohanBrichau.22';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #(#'pharo4.x' #'pharo5.x' ) do: [		spec 			package: 'Grease-Pharo40-Slime' with: 'Grease-Pharo40-Slime-JohanBrichau.3';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'gs2.x' do: [		spec 			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-JohanBrichau.52';					postLoadDoIt: #'initializeTransactionMutex1051'. ]. ].	spec for: #'gs3.x' do: [		spec import: 'Grease'.		spec baseline: 'Grease' with: [				spec					repository: 'github://GsDevKit/Grease:v1.2.0/repository' ]. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.2.x)' stamp: 'topa 10/6/2015 02:28'!version122: spec	<version: '1.2.2' imports: #('1.1.6-baseline' )>	spec for: #'common' do: [		spec blessing: #'released'.		spec author: 'topa'.		spec timestamp: '10/06/2015 02:28'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.96';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.104'. ].	spec for: #'squeak' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.75';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22';			package: 'Grease-Squeak-Core' with: 'Grease-Squeak-Core-pmm.5';			package: 'Grease-Tests-Squeak-Core' with: 'Grease-Tests-Squeak-Core-JohnMcKeon.1'. ].	spec for: #'pharo' do: [		spec package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.19'. ].	spec for: #'pharo1.x' do: [		spec 			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-JohanBrichau.74';			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22'. ].	spec for: #'pharo2.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-JohanBrichau.22';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #(#'pharo4.x' #'pharo5.x' ) do: [		spec 			package: 'Grease-Pharo40-Slime' with: 'Grease-Pharo40-Slime-JohanBrichau.3';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'gs2.x' do: [		spec 			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-JohanBrichau.52';					postLoadDoIt: #'initializeTransactionMutex1051'. ]. ].	spec for: #'gs3.x' do: [		spec import: 'Grease'.		spec baseline: 'Grease' with: [				spec					repository: 'github://GsDevKit/Grease:v1.2.0/repository' ]. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.2.x)' stamp: 'JohanBrichau 10/24/2015 18:04'!version123: spec	<version: '1.2.3' imports: #('1.1.6-baseline' )>	spec for: #'common' do: [		spec blessing: #'released'.		spec author: 'JohanBrichau'.		spec timestamp: '10/24/2015 18:04'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.96';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.104'. ].	spec for: #'squeak' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.75';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22';			package: 'Grease-Squeak-Core' with: 'Grease-Squeak-Core-JohanBrichau.6';			package: 'Grease-Tests-Squeak-Core' with: 'Grease-Tests-Squeak-Core-JohnMcKeon.1'. ].	spec for: #'pharo' do: [		spec package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.19'. ].	spec for: #'pharo1.x' do: [		spec 			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-JohanBrichau.74';			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22'. ].	spec for: #'pharo2.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-JohanBrichau.22';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #(#'pharo4.x' #'pharo5.x' ) do: [		spec 			package: 'Grease-Pharo40-Slime' with: 'Grease-Pharo40-Slime-JohanBrichau.3';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'gs2.x' do: [		spec 			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-JohanBrichau.52';					postLoadDoIt: #'initializeTransactionMutex1051'. ]. ].	spec for: #'gs3.x' do: [		spec import: 'Grease'.		spec baseline: 'Grease' with: [				spec					repository: 'github://GsDevKit/Grease:v1.2.0/repository' ]. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.2.x)' stamp: 'JohanBrichau 12/13/2015 20:30'!version124: spec	<version: '1.2.4' imports: #('1.1.7-baseline' )>	spec for: #'common' do: [		spec blessing: #'released'.		spec author: 'JohanBrichau'.		spec timestamp: '11/11/2015 13:24'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.96';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.104'. ].	spec for: #'squeak4.x' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.75';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22';			package: 'Grease-Squeak-Core' with: 'Grease-Squeak-Core-JohanBrichau.6';			package: 'Grease-Tests-Squeak-Core' with: 'Grease-Tests-Squeak-Core-JohnMcKeon.1'. ].			spec for: #'squeak5.x' do: [		spec 			package: 'Grease-Squeak5-Core' with: 'Grease-Squeak5-Core-JB.8';			package: 'Grease-Tests-Squeak-Core' with: 'Grease-Tests-Squeak-Core-JohnMcKeon.1'. ].	spec for: #'pharo' do: [		spec package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.19'. ].	spec for: #'pharo1.x' do: [		spec 			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-JohanBrichau.74';			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22'. ].	spec for: #'pharo2.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-JohanBrichau.22';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #(#'pharo4.x' #'pharo5.x' ) do: [		spec 			package: 'Grease-Pharo40-Slime' with: 'Grease-Pharo40-Slime-JohanBrichau.3';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'gs2.x' do: [		spec 			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-JohanBrichau.52';					postLoadDoIt: #'initializeTransactionMutex1051'. ]. ].	spec for: #'gs3.x' do: [		spec import: 'Grease'.		spec baseline: 'Grease' with: [				spec					repository: 'github://GsDevKit/Grease:v1.2.0/repository' ]. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.2.x)' stamp: 'JohanBrichau 1/10/2016 15:34'!version125: spec	<version: '1.2.5' imports: #('1.1.7-baseline' )>	spec for: #'common' do: [		spec blessing: #'released'.		spec author: 'JohanBrichau'.		spec timestamp: '01/10/2015 15:16'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.96';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.104'. ].	spec for: #'squeak4.x' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.75';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22';			package: 'Grease-Squeak-Core' with: 'Grease-Squeak-Core-JohanBrichau.6';			package: 'Grease-Tests-Squeak-Core' with: 'Grease-Tests-Squeak-Core-JohnMcKeon.1'. ].			spec for: #'squeak5.x' do: [		spec 			package: 'Grease-Squeak5-Core' with: 'Grease-Squeak5-Core-JB.8';			package: 'Grease-Tests-Squeak-Core' with: 'Grease-Tests-Squeak-Core-JohnMcKeon.1'. ].	spec for: #'pharo' do: [		spec package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.19'. ].	spec for: #'pharo1.x' do: [		spec 			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-JohanBrichau.74';			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22'. ].	spec for: #'pharo2.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-JohanBrichau.22';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #(#'pharo4.x' #'pharo5.x' ) do: [		spec 			package: 'Grease-Pharo40-Slime' with: 'Grease-Pharo40-Slime-JohanBrichau.3';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'gs2.x' do: [		spec 			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-JohanBrichau.52';					postLoadDoIt: #'initializeTransactionMutex1051'. ]. ].	spec for: #'gs3.x' do: [		spec import: 'Grease'.		spec baseline: 'Grease' with: [				spec					repository: 'github://GsDevKit/Grease:v1.2.0/repository' ]. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.2.x)' stamp: 'JohanBrichau 1/18/2016 08:22'!version126: spec	<version: '1.2.6' imports: #('1.1.7-baseline' )>	spec for: #'common' do: [		spec blessing: #'released'.		spec author: 'JohanBrichau'.		spec timestamp: '1/18/2016 08:17'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.96';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.104'. ].	spec for: #'squeak4.x' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.75';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22';			package: 'Grease-Squeak-Core' with: 'Grease-Squeak-Core-JohanBrichau.6';			package: 'Grease-Tests-Squeak-Core' with: 'Grease-Tests-Squeak-Core-JohnMcKeon.1'. ].	spec for: #'squeak5.x' do: [		spec 			package: 'Grease-Squeak5-Core' with: 'Grease-Squeak5-Core-JB.8';			package: 'Grease-Tests-Squeak-Core' with: 'Grease-Tests-Squeak-Core-JohnMcKeon.1'. ].	spec for: #'pharo' do: [		spec package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.19'. ].	spec for: #'pharo1.x' do: [		spec 			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-JohanBrichau.74';			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22'. ].	spec for: #'pharo2.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-JohanBrichau.22';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #(#'pharo4.x' #'pharo5.x' ) do: [		spec 			package: 'Grease-Pharo40-Slime' with: 'Grease-Pharo40-Slime-JohanBrichau.3';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.19';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'gs2.x' do: [		spec 			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-JohanBrichau.52';					postLoadDoIt: #'initializeTransactionMutex1051'. ]. ].	spec for: #'gs3.x' do: [		spec import: 'Grease'.		spec baseline: 'Grease' with: [				spec					repository: 'github://GsDevKit/Grease:v1.2.6/repository' ]. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.2.x)' stamp: 'JohanBrichau 3/26/2016 15:58'!version127: spec	<version: '1.2.7' imports: #('1.1.7-baseline' )>	spec for: #'common' do: [		spec blessing: #'released'.		spec author: 'JohanBrichau'.		spec timestamp: '03/26/2016 15:58'.		spec 			package: 'Grease-Core' with: 'Grease-Core-JohanBrichau.97';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.104'. ].	spec for: #'squeak4.x' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.75';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22';			package: 'Grease-Squeak-Core' with: 'Grease-Squeak-Core-JohanBrichau.6';			package: 'Grease-Tests-Squeak-Core' with: 'Grease-Tests-Squeak-Core-JohnMcKeon.1'. ].	spec for: #'squeak5.x' do: [		spec 			package: 'Grease-Squeak5-Core' with: 'Grease-Squeak5-Core-JB.8';			package: 'Grease-Tests-Squeak-Core' with: 'Grease-Tests-Squeak-Core-JohnMcKeon.1';			package: 'Grease-Tests-Squeak5-Core' with: 'Grease-Tests-Squeak5-Core-JohanBrichau.1' ].	spec for: #'pharo' do: [		spec package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.19'. ].	spec for: #'pharo1.x' do: [		spec 			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-JohanBrichau.74';			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22'. ].	spec for: #'pharo2.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-JohanBrichau.22';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #(#'pharo4.x' #'pharo5.x' ) do: [		spec 			package: 'Grease-Pharo40-Slime' with: 'Grease-Pharo40-Slime-JohanBrichau.3';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.19';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'gs2.x' do: [		spec 			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-JohanBrichau.52';					postLoadDoIt: #'initializeTransactionMutex1051'. ]. ].	spec for: #'gs3.x' do: [		spec import: 'Grease'.		spec baseline: 'Grease' with: [				spec					repository: 'github://GsDevKit/Grease:v1.2.6/repository' ]. ].! !!ConfigurationOfGrease methodsFor: 'versions (1.3.x)' stamp: 'ChristopheDemarey 10/17/2016 15:52'!version130: spec	<version: '1.3.0' imports: #('1.1.7-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec author: 'JohanBrichau'.		spec timestamp: '9/4/2016 17:08'.		spec 			package: 'Grease-Core' with: 'Grease-Core-pmm.107';			package: 'Grease-Tests-Core' with: 'Grease-Tests-Core-pmm.107'. ].	spec for: #'squeak4.x' do: [		spec 			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-pmm.75';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22';			package: 'Grease-Squeak-Core' with: 'Grease-Squeak-Core-JohanBrichau.6';			package: 'Grease-Tests-Squeak-Core' with: 'Grease-Tests-Squeak-Core-JohnMcKeon.1'. ].	spec for: #'squeak5.x' do: [		spec 			package: 'Grease-Squeak5-Core' with: 'Grease-Squeak5-Core-JB.8';			package: 'Grease-Tests-Squeak-Core' with: 'Grease-Tests-Squeak-Core-JohnMcKeon.1';			package: 'Grease-Tests-Squeak5-Core' with: 'Grease-Tests-Squeak5-Core-JohanBrichau.1'. ].	spec for: #'pharo' do: [		spec package: 'Grease-Tests-Slime' with: 'Grease-Tests-Slime-pmm.19'. ].	spec for: #'pharo1.x' do: [		spec 			package: 'Grease-Pharo10-Core' with: 'Grease-Pharo10-Core-dkh.4';			package: 'Grease-Pharo11-Core' with: 'Grease-Pharo11-Core-pmm.1';			package: 'Grease-Pharo-Core' with: 'Grease-Pharo-Core-JohanBrichau.74';			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Tests-Pharo-Core' with: 'Grease-Tests-Pharo-Core-pmm.22'. ].	spec for: #'pharo2.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo20-Core' with: 'Grease-Pharo20-Core-JohanBrichau.22';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #'pharo3.x' do: [		spec 			package: 'Grease-Slime' with: 'Grease-Slime-pmm.29';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-JohanBrichau.18';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-JohanBrichau.12'. ].	spec for: #(#'pharo4.x' #'pharo5.x' #'pharo6.x') do: [		spec 			package: 'Grease-Pharo40-Slime' with: 'Grease-Pharo40-Slime-pmm.4';			package: 'Grease-Pharo30-Core' with: 'Grease-Pharo30-Core-pmm.21';			package: 'Grease-Tests-Pharo20-Core' with: 'Grease-Tests-Pharo20-Core-pmm.13'. ].	spec for: #'gs2.x' do: [		spec 			project: 'SMTPMail' with: '0.240.1';			project: 'GsCore' with: '0.245.2';			project: 'UTF8' with: '0.240.1';			project: 'System-Digital-Signatures' with: '0.240.1'.		spec 			package: 'Grease-Tests-GemStone-Core' with: 'Grease-Tests-GemStone-Core-dkh.14';			package: 'Grease-GemStone-Core' with: [				spec 					file: 'Grease-GemStone-Core-JohanBrichau.52';					postLoadDoIt: #'initializeTransactionMutex1051'. ]. ].	spec for: #'gs3.x' do: [		spec import: 'Grease'.		spec baseline: 'Grease' with: [				spec repository: 'github://GsDevKit/Grease:v1.3.0/repository' ]. ].! !"ConfigurationOfGrease"!!GRNotification commentStamp: 'pmm 9/14/2013 15:50' prior: 0!This class provides consistent initialization and exception signaling behaviour across platforms. All platforms must provide the ANSI-standard signaling protocol on this class. #signal: can therefore be safely called on any subclass.Packages that are using Seaside-Platform should usually subclass GRNotification instead of Notification.!!GRDeprecatedApiNotification commentStamp: 'pmm 9/14/2013 15:50' prior: 0!This notification is signaled whenever a deprecated message is sent.see WAObject>>#greaseDeprecatedApi:details: !!GRError commentStamp: 'pmm 9/14/2013 15:50' prior: 0!This class provides consistent initialization and exception signaling behaviour across platforms. All platforms must provide the ANSI-standard signaling protocol on this class. #signal: can therefore be safely called on any subclass.Packages that are using Seaside-Platform should usually subclass GRError instead of Error.!!GRInvalidArgumentCount commentStamp: 'jf 3/14/2009 11:05' prior: 0!Signaled whenever a message is sent with the incorrect number of arguments.!!GRInvalidUtf8Error commentStamp: 'pmm 1/10/2009 22:29' prior: 0!A WAInvalidUtf8Error signals that the input is not valid UTF-8.!!GRObject commentStamp: 'pmm 9/14/2013 15:52' prior: 0!A common superclass that ensures consistent initialization behaviour on all platforms and provides #error: methods that signal an instance of WAPlatformError.Packages that are using Seaside-Platform should normally subclass GRObject instead of Object.!!GRCodec commentStamp: 'lr 2/7/2009 09:55' prior: 0!A codec defines how Seaside communicates without the outside world and how outside data is converted into the image (decoding) and back outside the image (encoding). The codec is essentially a stream factory that provides wrappers around standard streams. All streams do support binary mode for non-converted transfer.!!GRNullCodec commentStamp: 'pmm 9/14/2013 15:52' prior: 0!The null codec always returns the original streams. It assumes that the outside world uses the same encoding as the inside world. This is highly efficient as no transformation is applied to the data, but has its drawbacks.!!GRDelayedSend commentStamp: 'NickAger 3/20/2012 09:04' prior: 0!A GRDelayedSend is a future message send of a message to an object. Some of the arguments can be predefined. Instances are intended to be interchangeable with blocks.This class should conform the ANSI (block) valuable protocol. Unlike a block, a GRDelayedSend is not a closure so doesn't hold onto the method context. GRDelayedSend provides similar, but portable, functionality to Pharo's MessageSend.This is an abstract class. Use the methods in the 'instance-creation' protocol on the class side to create intances.Instance Variables	receiver:		<Object>	selector:		<Symbol>receiver	- the object receiving the messageselector	- the message selector sent to the receiver!!GRDelayedSendMessage commentStamp: 'NickAger 3/19/2012 11:20' prior: 0!GRDelayedSendMessage is an abstract base for objects that provide currying functionality for GRDelayedSend!!GRBoundMessage commentStamp: 'jf 3/14/2009 11:04' prior: 0!A delayed send that has some or all of the arguments defined in advance. Additionally supplied arguments will be added, if possible, to these when the object is evaluate.Instance Variables	arguments:		<Array>arguments	- the predefined arguments!!GRUnboundMessage commentStamp: 'jf 3/14/2009 11:03' prior: 0!A delayed send that has none of the arguments defined in advance.!!GRDelegatingStream commentStamp: 'pmm 6/25/2012 20:20' prior: 0!A GRDelegatingStream is a wrapper around a write stream and defines common behavior.Instance Variables	stream:		<WriteStream>stream	- a WriteStream!!GRCodecStream commentStamp: 'pmm 6/25/2012 20:21' prior: 0!GRCodecStream is the abstract base class for codec streams!!GRNullCodecStream commentStamp: 'pmm 6/25/2012 20:21' prior: 0!A WANullCodecStream is a WriteStream on a String on which you can both put binary and character data without encoding happening.Instance Variables	stream:		<WriteStream>stream	- a WriteStream on a String!!GRCountingStream commentStamp: 'pmm 6/25/2012 20:39' prior: 0!A GRCountingStream counts how many elements have been added to it. This is necessary because the underlying stream may inflate the number of elements in the stream.Instance Variables:	count	<Integer>		count  - number of elements added to this stream!!GRInflector commentStamp: 'lr 12/27/2008 09:43' prior: 0!The Inflector transforms words from singular to plural.!!GRPackage commentStamp: 'pmm 9/14/2013 15:53' prior: 0!I am a platform independent package representation. I know my name, description, my dependencies, the license and the repository URL. Packages are declared by creating a class side extension method that answers a configured package instance. The expression    GRPackage packagesanswers the collection of the complete package graph.!!GRPlatform commentStamp: 'jf 2/6/2009 16:05' prior: 0!The abstract platform implementation. Each platform should provide a subclass implementing any abstract methods and overriding any other methods as necessary.Default implementations should be provided here when possible/useful but default implementations MUST be valid on ALL PLATFORMS so it is rarely practical. VA Smalltalk flags sends of uknown messages so even these must be known to exist on all platforms.Common cases where default implementations *are* appropriate are where there is a standard implementation that is valid on all platforms but one or more platforms have an additional, optimized implementation that should be used instead.All classes and methods used by methods of this class should be either:  + included in the Seaside-Platform package;  + defined by the ANSI Smalltalk standard; or  + (not ideal) referenced via 'Smalltalk at: #ClassName'.!!GRNumberPrinter commentStamp: 'pmm 2/1/2014 13:27' prior: 0!A GRNumberPrinter prints numbers (integers and floats) in various formats in a platform independent way.Instance Variables	accuracy:	<UndefinedObject|Float>	base:		<Integer>	delimiter:	<UndefinedObject|Character>	digits:		<UndefinedObject|Integer>	infinite:		<UndefinedObject|String>	nan:			<UndefinedObject|String>	padding:	<UndefinedObject|Character>	precision:	<Integer>	separator:	<UndefinedObject|Character>!!GRSmallDictionary commentStamp: 'jf 2/15/2010 15:51' prior: 0!I am an implementation of a dictionary. Compared to other dictionaries I am very efficient for small sizes, speed- and space-wise. I also mantain the order in which elements are added when iterating. My implementation features some ideas from the RefactoringBrowser.!!GROrderedMultiMap commentStamp: 'jf 2/15/2010 16:04' prior: 0!I am an implementation of an ordered multi-map. I allow multiple values to be associated with the same key and maintain the order of addition. #at: and its derivatives all operate on the first matching key, while #allAt: returns the complete list of values for a key in the order they were added.!!GRVersion commentStamp: 'lr 2/19/2012 12:57' prior: 0!I model version numbers. I am comparable and I define a natural order.!!GRDeprecatedApiNotification methodsFor: 'accessing' stamp: 'jf 9/24/2008 10:28'!details	^ details! !!GRDeprecatedApiNotification methodsFor: 'accessing' stamp: 'jf 9/24/2008 10:28'!details: anObject	details := anObject! !!String methodsFor: '*grease-core' stamp: 'lr 10/25/2009 11:19'!excerpt: aString	"Answer an excerpt of the receiver that matches the first occurence of aString. If aString isn't found, nil is answered."		^ self excerpt: aString radius: 100! !!String methodsFor: '*grease-core' stamp: 'lr 10/25/2009 11:19'!excerpt: aString radius: anInteger	"Answer an excerpt of the receiver that matches the first occurence of aString. The radius anInteger expands the excerpt on each side of the first occurrence by the number of characters defined in radius. If aString isn't found, nil is answered."		^ self excerpt: aString radius: anInteger ellipsis: '...'! !!String methodsFor: '*grease-core' stamp: 'jf 12/17/2009 10:49'!excerpt: aString radius: anInteger ellipsis: anEllipsisString	"Answer an excerpt of the receiver that matches the first occurence of aString. The radius anInteger expands the excerpt on each side of the first occurrence by the number of characters defined in radius. If aString isn't found, nil is answered."	| index start stop |	(index := self indexOfSubCollection: aString) = 0		ifTrue: [ ^ nil ].	start := index - anInteger max: 1.	stop := index + anInteger + aString size - 1 min: self size.	^ (start > 1 ifTrue: [ anEllipsisString ] ifFalse: [ '' ]) ,		(self copyFrom: start to: stop) ,	  	(stop < self size ifTrue: [ anEllipsisString ] ifFalse: [ '' ])! !!String methodsFor: '*grease-core' stamp: 'pmm 12/26/2010 21:46'!greaseInteger	"Convert the receiver to an integer, answer nil if this is not a number."	| number stream negated char |	number := nil.	stream := self readStream.	negated := stream peek = $-.	negated ifTrue: [ stream next ].	[ stream atEnd not and: [ (char := stream next) isDigit ] ] whileTrue: [		number := (number isNil  ifTrue: [ 0 ]ifFalse: [ 10 * number ])			+ (char greaseInteger - $0 greaseInteger) ].	^ (number isNil or: [ negated not ]) 		ifFalse: [ number negated ]		ifTrue: [ number ]! !!String methodsFor: '*grease-core' stamp: 'jf 9/30/2009 00:37'!pluralize	^ GRInflector pluralize: self! !!String methodsFor: '*grease-core' stamp: 'lr 7/24/2008 18:19'!print: anObject on: aStream	aStream nextPutAll: self! !!String methodsFor: '*grease-core' stamp: 'lr 10/25/2009 11:17'!truncate	"Truncate the receiver to 30 characters."		^ self truncate: 30! !!String methodsFor: '*grease-core' stamp: 'lr 10/25/2009 11:17'!truncate: anInteger	"Truncate the receiver to anInteger characters."		^ self truncate: anInteger ellipsis: '...'! !!String methodsFor: '*grease-core' stamp: 'lr 2/7/2008 09:22'!truncate: anInteger ellipsis: aString	"Truncate the receiver to anInteger characters and append aString as ellipsis if necessary."	^ anInteger < self size		ifTrue: [ (self copyFrom: 1 to: anInteger) , aString ]		ifFalse: [ self copy ]! !!Character methodsFor: '*grease-core' stamp: 'lr 7/24/2008 18:20'!print: anObject on: aStream	aStream nextPut: self! !!UndefinedObject methodsFor: '*grease-core' stamp: 'lr 2/7/2008 13:13'!print: anObject on: aStream! !!Integer methodsFor: '*grease-core' stamp: 'jf 9/30/2009 01:04'!greaseInteger	^ self! !!Integer methodsFor: '*grease-core' stamp: 'jf 9/30/2009 00:37'!pluralize: aSingularString 	^ self 		pluralize: aSingularString		with: (GRInflector pluralize: aSingularString)! !!Integer methodsFor: '*grease-core' stamp: 'lr 1/30/2008 22:39'!pluralize: aSingularString with: aPluralString	^ self printString , ' ' , (self abs = 1 ifTrue: [ aSingularString ] ifFalse: [ aPluralString ])! !!GRCodec class methodsFor: 'accessing' stamp: 'pmm 6/28/2009 16:35'!allCodecs	"Answer all codecs supported in this system. This is a collection of codec instances."	^ self subclasses		inject: self codecs asArray		into: [ :result :each | result , each allCodecs ]! !!GRCodec class methodsFor: 'private' stamp: 'pmm 6/28/2009 16:40'!basicForEncoding: aString	"Create the actual instance."	self subclassResponsibility! !!GRCodec class methodsFor: 'accessing' stamp: 'jf 2/7/2009 20:27'!codecs	"Answer a collection of possible codecs of the receiver. To be overridden by concrete subclasses."	^ #()! !!GRCodec class methodsFor: 'instance creation' stamp: 'lr 7/25/2011 19:46'!forEncoding: aString	"Answer a new codec instance for the given encoding name. Raise an WAUnsupportedEncodingError if the encoding name is not supported by this image."	self allSubclassesDo: [ :each | 		(each supportsEncoding: aString)			ifTrue: [ ^ each basicForEncoding: aString ] ].	^ self unsupportedEncoding: aString! !!GRCodec class methodsFor: 'testing' stamp: 'pmm 6/28/2009 16:40'!supportsEncoding: aString	"Answer whether the the given encoding name is supported by this codec class."	self subclassResponsibility! !!GRCodec class methodsFor: 'private' stamp: 'lr 7/25/2011 19:46'!unsupportedEncoding: aString	"Signal an unsupported encoding."	^ GRUnsupportedEncodingError signal: 'unsupported encoding: ' , aString! !!GRCodec methodsFor: 'convenience' stamp: 'pmm 8/26/2011 09:47'!decode: aString	| readStream writeStream |	readStream := self decoderFor: aString readStream.	writeStream := GRPlatform current writeCharacterStreamOn: (String new: aString size).	[ readStream atEnd ]		whileFalse: [ writeStream nextPutAll: (readStream next: 1024) ].	^ writeStream contents! !!GRCodec methodsFor: 'conversion' stamp: 'lr 2/7/2009 09:41'!decoderFor: aReadStream	"Wrap aReadStream with an decoder for the codec of the receiver. Answer a read stream that delegates to and shares the state of aReadStream." 		self subclassResponsibility! !!GRCodec methodsFor: 'convenience' stamp: 'pmm 8/26/2011 09:48'!encode: aString	| writeStream |	writeStream := self encoderFor: (GRPlatform current		writeCharacterStreamOn:  (String new: aString size)).	writeStream nextPutAll: aString.	^ writeStream contents! !!GRCodec methodsFor: 'conversion' stamp: 'lr 2/7/2009 09:41'!encoderFor: aWriteStream	"Wrap aWriteStream with an encoder for the codec of the receiver. Answer a write stream that delegates to and shares the state of aWriteStream."		self subclassResponsibility! !!GRCodec methodsFor: 'accessing' stamp: 'lr 2/7/2009 10:16'!name	"Answer a human readable string of the receivers encoding policy."	self subclassResponsibility! !!GRCodec methodsFor: 'printing' stamp: 'lr 2/7/2009 10:17'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' name: '; print: self name! !!GRCodec methodsFor: 'accessing' stamp: 'lr 2/7/2009 11:54'!url	"Answer a codec that is responsible to encode and decode URLs. In most cases an UTF-8 codec is the only valid choice, but subclasses might decide to do something else."	self subclassResponsibility! !!GRNullCodec class methodsFor: 'private' stamp: 'lr 7/25/2011 19:46'!basicForEncoding: aString	^ self new! !!GRNullCodec class methodsFor: 'accessing' stamp: 'pmm 5/26/2010 07:07'!codecName	^ '(none)'! !!GRNullCodec class methodsFor: 'accessing' stamp: 'jf 2/7/2009 20:27'!codecs	^ Array with: self new! !!GRNullCodec class methodsFor: 'testing' stamp: 'lr 7/25/2011 19:46'!supportsEncoding: aString	^ aString isNil! !!GRNullCodec methodsFor: 'convenience' stamp: 'pmm 8/19/2014 10:00'!decode: aString	"Overridden for efficiency."	^ aString! !!GRNullCodec methodsFor: 'conversion' stamp: 'jf 9/30/2009 00:28'!decoderFor: aReadStream 	"wrap to avoid String vs ByteArray issues"	^ GRNullCodecStream on: aReadStream! !!GRNullCodec methodsFor: 'convenience' stamp: 'pmm 8/19/2014 10:00'!encode: aString	"Overridden for efficiency."	^ aString! !!GRNullCodec methodsFor: 'conversion' stamp: 'jf 9/30/2009 00:28'!encoderFor: aWriteStream 	"wrap to avoid String vs ByteArray issues"	^ GRNullCodecStream on: aWriteStream! !!GRNullCodec methodsFor: 'accessing' stamp: 'pmm 5/26/2010 07:07'!name	^ GRNullCodec codecName! !!GRNullCodec methodsFor: 'accessing' stamp: 'lr 2/7/2009 12:06'!url	"The selfish method. Let's do it with ourselves."		^ self! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'jf 7/10/2011 23:48'!empty	^ self receiver: nil selector: #yourself! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'jf 7/10/2011 23:49'!new	^ self empty! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'jf 7/10/2011 23:33'!receiver: anObject selector: aSymbol 	^ self basicNew 		initializeWithReceiver: anObject			message: (GRUnboundMessage selector: aSymbol);		yourself! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'pmm 1/10/2009 23:44'!receiver: anObject selector: aSymbol argument: aParameter	^ self receiver: anObject selector: aSymbol arguments: (Array with: aParameter)! !!GRDelayedSend class methodsFor: 'instance creation' stamp: 'jf 7/10/2011 23:33'!receiver: anObject selector: aSymbol arguments: anArray 	^ self basicNew 		initializeWithReceiver: anObject			message: (GRBoundMessage selector: aSymbol arguments: anArray);		yourself! !!GRDelayedSend methodsFor: 'accessing' stamp: 'jf 7/10/2011 23:32'!argumentCount	"Answer the number of arguments that must be provided to the receiver when sending it."		^ message argumentCount! !!GRDelayedSend methodsFor: 'accessing' stamp: 'lr 1/11/2009 11:44'!fixCallbackTemps	"For polymorphism with BlockContext>>#fixCallbackTemps."! !!GRDelayedSend methodsFor: 'initialization' stamp: 'jf 7/10/2011 23:23'!initializeWithReceiver: anObject message: aDelayedSendMessage	self initialize.	receiver := anObject.	message := aDelayedSendMessage! !!GRDelayedSend methodsFor: 'printing' stamp: 'jf 7/10/2011 23:23'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' receiver: '; print: receiver.	aStream nextPut: $ .	message printOn: aStream! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'lr 1/11/2009 11:45'!value	^ self valueWithArguments: #()! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'lr 1/11/2009 11:45'!value: anObject	^ self valueWithArguments: (Array with: anObject)! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'lr 1/11/2009 11:46'!value: aFirstObject value: aSecondObject	^ self valueWithArguments: (Array with: aFirstObject with: aSecondObject)! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'jf 7/10/2011 23:24'!valueWithArguments: anArray	^ message valueFor: receiver withArguments: anArray! !!GRDelayedSend methodsFor: 'evaluating' stamp: 'jf 7/10/2011 23:24'!valueWithPossibleArguments: anArray	^ message valueFor: receiver withPossibleArguments: anArray! !!GRBoundMessage class methodsFor: 'instance creation' stamp: 'jf 7/10/2011 23:30'!selector: aSymbol	^ self selector: aSymbol arguments: #()! !!GRBoundMessage class methodsFor: 'instance creation' stamp: 'jf 7/10/2011 23:29'!selector: aSymbol arguments: anArray	^ self basicNew		initializeWithSelector: aSymbol arguments: anArray;		yourself! !!GRBoundMessage methodsFor: 'delegation' stamp: 'jf 7/10/2011 23:38'!argumentCount	^ selector numArgs - arguments size! !!GRBoundMessage methodsFor: 'initialization' stamp: 'jf 7/10/2011 23:21'!initializeWithSelector: aSymbol arguments: anArray	self initializeWithSelector: aSymbol.	arguments := anArray asArray! !!GRBoundMessage methodsFor: 'private' stamp: 'jf 7/10/2011 23:14'!mergeArguments: anArray	^ arguments , anArray! !!GRBoundMessage methodsFor: 'printing' stamp: 'lr 1/11/2009 11:50'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' arguments: '; print: arguments! !!GRDelayedSendMessage class methodsFor: 'instance creation' stamp: 'jf 7/10/2011 23:28'!new	^ self selector: #yourself! !!GRDelayedSendMessage class methodsFor: 'instance creation' stamp: 'jf 7/10/2011 23:27'!selector: aSymbol	^ self basicNew		initializeWithSelector: aSymbol;		yourself! !!GRDelayedSendMessage methodsFor: 'delegation' stamp: 'jf 7/10/2011 23:02'!argumentCount	"Answer the number of arguments that must be provided when sending this message."		self subclassResponsibility! !!GRDelayedSendMessage methodsFor: 'private' stamp: 'jf 7/10/2011 23:20'!basicPerformFor: receiver withArguments: anArray	^ anArray size = selector numArgs		ifTrue: [ receiver perform: selector withArguments: anArray ]		ifFalse: [ self invalidArgumentCount ]! !!GRDelayedSendMessage methodsFor: 'initialization' stamp: 'jf 7/10/2011 23:01'!initializeWithSelector: aSymbol	self initialize.	selector := aSymbol! !!GRDelayedSendMessage methodsFor: 'private' stamp: 'jf 7/10/2011 23:25'!invalidArgumentCount	GRInvalidArgumentCount signal! !!GRDelayedSendMessage methodsFor: 'private' stamp: 'jf 7/10/2011 23:14'!mergeArguments: anArray	self subclassResponsibility! !!GRDelayedSendMessage methodsFor: 'printing' stamp: 'jf 7/10/2011 23:36'!printOn: aStream	aStream nextPutAll: 'selector: '; print: selector! !!GRDelayedSendMessage methodsFor: 'delegation' stamp: 'jf 7/10/2011 23:37'!valueFor: receiver withArguments: anArray	"Send the message to receiver with the arguments in anArray. Answer the result.	Signal an error if the number of arguments does not match the selector."		^ self basicPerformFor: receiver withArguments: (self mergeArguments: anArray)! !!GRDelayedSendMessage methodsFor: 'delegation' stamp: 'jf 7/10/2011 23:19'!valueFor: receiver withPossibleArguments: anArray	"Send the message to receiver with as many of the arguments in anArray as possible. Answer the result.	Error if not enough arguments are available for the selector."	| allArguments |	allArguments := self mergeArguments: anArray.		^ allArguments size < selector numArgs		ifTrue: [ self invalidArgumentCount ]		ifFalse: [ self basicPerformFor: receiver withArguments: (allArguments first: selector numArgs) ]! !!GRUnboundMessage methodsFor: 'delegation' stamp: 'lr 1/11/2009 13:02'!argumentCount	^ selector numArgs! !!GRUnboundMessage methodsFor: 'private' stamp: 'lr 7/25/2011 19:52'!mergeArguments: anArray	^ anArray! !!GRNullCodecStream methodsFor: 'streaming' stamp: 'lr 7/25/2011 19:50'!next	^ stream next! !!GRNullCodecStream methodsFor: 'streaming' stamp: 'lr 7/25/2011 19:50'!next: anInteger	^ stream next: anInteger! !!GRNullCodecStream methodsFor: 'streaming' stamp: 'lr 7/16/2009 08:52'!nextPut: aCharacterOrByte	aCharacterOrByte isCharacter		ifTrue: [ stream nextPut: aCharacterOrByte ]		ifFalse: [ stream nextPut: (Character codePoint: aCharacterOrByte) ]! !!GRNullCodecStream methodsFor: 'streaming' stamp: 'lr 7/16/2009 08:52'!nextPutAll: aStringOrByteArray	aStringOrByteArray isString		ifTrue: [ stream nextPutAll: aStringOrByteArray ]		ifFalse: [			1 to: aStringOrByteArray size do: [ :index |				stream nextPut: (Character codePoint: (aStringOrByteArray at: index)) ] ]! !!GRCountingStream methodsFor: 'accessing' stamp: 'pmm 6/25/2012 20:26'!count	^ count! !!GRCountingStream methodsFor: 'streaming' stamp: 'pmm 6/25/2012 20:28'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	super greaseNext: anInteger putAll: aCollection startingAt: startIndex.	count := count + anInteger! !!GRCountingStream methodsFor: 'initialization' stamp: 'pmm 6/25/2012 20:26'!initialize	super initialize.	count := 0! !!GRCountingStream methodsFor: 'streaming' stamp: 'pmm 6/25/2012 20:46'!next	self shouldNotImplement! !!GRCountingStream methodsFor: 'streaming' stamp: 'pmm 6/25/2012 20:46'!next: anInteger	self shouldNotImplement! !!GRCountingStream methodsFor: 'streaming' stamp: 'pmm 6/25/2012 20:45'!nextPut: aCharacter	stream nextPut: aCharacter.	count := count + 1	! !!GRCountingStream methodsFor: 'streaming' stamp: 'pmm 6/25/2012 20:45'!nextPutAll: aString	stream nextPutAll: aString.	count := count + aString size	! !!GRCountingStream methodsFor: 'accessing' stamp: 'pmm 6/25/2012 20:27'!reset	super reset.	count := 0! !!GRDelegatingStream class methodsFor: 'instance creation' stamp: 'pmm 10/30/2010 18:53'!on: aStream	^ self basicNew initializeOn: aStream! !!GRDelegatingStream methodsFor: 'testing' stamp: 'pmm 2/20/2009 22:04'!atEnd	^ stream atEnd! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'pmm 2/20/2009 22:05'!contents	^ stream contents! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'pmm 2/20/2009 22:11'!crlf	self nextPut: Character cr; nextPut: Character lf! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'pmm 2/20/2009 22:06'!flush	stream flush! !!GRDelegatingStream methodsFor: 'initialization' stamp: 'pmm 9/1/2012 15:25'!initializeOn: aStream	self initialize.	stream := aStream! !!GRDelegatingStream methodsFor: 'testing' stamp: 'NorbertHartl 10/7/2010 08:21'!isStream	^ true! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'pmm 2/20/2009 22:11'!next	self subclassResponsibility! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'pmm 2/20/2009 22:12'!next: anInteger	self subclassResponsibility! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'pmm 2/20/2009 22:12'!nextPut: aCharacter	self subclassResponsibility! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'pmm 2/20/2009 22:12'!nextPutAll: aString	self subclassResponsibility! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'JohanBrichau 9/14/2013 12:20'!position	^ stream position! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'lr 9/25/2011 10:11'!print: anObject	anObject printOn: self! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'ar 8/4/2010 20:54'!reset	"Reset the stream"	stream reset! !!GRDelegatingStream methodsFor: 'accessing' stamp: 'pmm 2/20/2009 22:05'!size	^ stream size! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'jf 7/28/2009 15:55'!space	self nextPut: Character space! !!GRDelegatingStream methodsFor: 'streaming' stamp: 'jf 7/28/2009 15:56'!tab	self nextPut: Character tab! !!GRInflector class methodsFor: 'initialization' stamp: 'pmm 2/24/2008 18:31'!initialize	Uninflected := #('bison' 'bream' 'breeches' 'britches' 'carp' 'chassis' 'clippers' 'cod' 'contretemps' 'corps' 'debris' 'deer' 'diabetes' 'djinn' 'eland' 'elk' 'equipment' 'fish' 'flounder' 'gallows' 'graffiti' 'headquarters' 'herpes' 'high-jinks' 'homework' 'information' 'innings' 'ities' 'itis' 'jackanapes' 'mackerel' 'measles' 'mews' 'money' 'mumps' 'news' 'ois' 'pincers' 'pliers' 'pox' 'proceedings' 'rabies' 'rice' 'salmon' 'scissors' 'sea-bass' 'series' 'shears' 'sheep' 'species' 'swine' 'trout' 'tuna' 'whiting' 'wildebeest').	InflectionRules := #(('man' 'en' 2) ('child' 'ren' 0) ('cow' 'kine' 3) ('penis' 'es' 0) ('sex' 'es' 0) ('person' 'ople' 4) ('octopus' 'es' 0) ('quiz' 'zes' 0) ('ox' 'en' 0) ('louse' 'ice' 4) ('mouse' 'ice' 4) ('matrix' 'ices' 2) ('vertix' 'ices' 2) ('vertex' 'ices' 2) ('indix' 'ices' 2) ('index' 'ices' 2) ('x' 'es' 0) ('ch' 'es' 0) ('ss' 'es' 0) ('sh' 'es' 0) ('ay' 's' 0) ('ey' 's' 0) ('iy' 's' 0) ('oy' 's' 0) ('uy' 's' 0) ('y' 'ies' 1) ('alf' 'ves' 1) ('elf' 'ves' 1) ('olf' 'ves' 1) ('arf' 'ves' 1) ('nife' 'ves' 2) ('life' 'ves' 2) ('wife' 'ves' 2) ('sis' 'es' 2) ('tum' 'a' 2) ('ium' 'a' 2) ('buffalo' 'es' 0) ('tomato' 'es' 0) ('buffalo' 'es' 0) ('bus' 'es' 0) ('alias' 'es' 0) ('status' 'es' 0) ('octopus' 'i' 2) ('virus' 'i' 2) ('axis' 'es' 2) ('s' '' 0))! !!GRInflector class methodsFor: 'accessing' stamp: 'jok 3/22/2010 12:04'!pluralize: aString	| string |	string := aString asLowercase.	Uninflected do: [ :each |		(string endsWithSubCollection: each)			ifTrue: [ ^ aString ] ].	InflectionRules do: [ :rule |		(string endsWithSubCollection: rule first)			ifTrue: [ ^ (aString allButLast: rule third) , rule second ] ].	^ aString , 's'! !!GRObject class methodsFor: 'error handling' stamp: 'jf 9/30/2009 00:20'!defaultErrorClass	^ GRError! !!GRObject class methodsFor: 'error handling' stamp: 'jf 3/13/2009 16:40'!error: aString	^ self defaultErrorClass signal: aString! !!GRObject class methodsFor: 'instance creation' stamp: 'jf 3/13/2009 16:28'!new	^ self basicNew initialize! !!GRObject methodsFor: 'error handling' stamp: 'jf 3/13/2009 16:40'!error: aString	^ self class error: aString! !!GRObject methodsFor: 'initialization' stamp: 'jf 3/13/2009 16:14'!initialize! !!GRPackage class methodsFor: 'querying' stamp: 'JohanBrichau 12/15/2013 18:27'!grPackages	"Answer a list of all registered packages. A package is registered by adding a class extension to the receiving class answering an instance of the receiving class."	| packages package |	packages := Dictionary new.	self class selectors do: [ :each |		(each numArgs = 0 and: [ each ~= #grPackages ]) ifTrue: [ 			package := self perform: each.			packages at: package name put: package ] ].	packages do: [ :each | each resolveWith: packages ].	^ packages values! !!GRPackage class methodsFor: 'accessing' stamp: 'pmm 9/12/2013 16:00'!greaseCore	^ self new		name: 'Grease-Core';		description: 'The main package of the Grease compatibility layer.';		url: #greaseUrl;		yourself! !!GRPackage methodsFor: 'private' stamp: 'lr 9/5/2009 18:35'!addDependenciesTo: aCollection	(aCollection includes: self) ifFalse: [		self dependencies			do: [ :each | each addDependenciesTo: aCollection ].		aCollection add: self ].	^ aCollection! !!GRPackage methodsFor: 'dependencies' stamp: 'merged 10/20/2008 09:33'!addDependency: aString	dependencies add: aString! !!GRPackage methodsFor: 'dependencies' stamp: 'lr 2/17/2010 15:18'!allDependencies	"Answer all dependencies on which this package depends."	^ self addDependenciesTo: OrderedCollection new! !!GRPackage methodsFor: 'dependencies' stamp: 'jf 3/15/2009 17:00'!dependencies	"Return a collection of package names on which this package depends."	^ dependencies! !!GRPackage methodsFor: 'accessing' stamp: 'merged 10/20/2008 09:23'!description	"Answer a short description of the package."	^ description! !!GRPackage methodsFor: 'accessing' stamp: 'lr 10/25/2009 11:26'!description: aString	description := aString! !!GRPackage methodsFor: 'accessing-repositories' stamp: 'pmm 9/12/2013 15:57'!greaseUrl	^ 'http://smalltalkhub.com/mc/Seaside/Grease11/main'! !!GRPackage methodsFor: 'initialization' stamp: 'lr 2/17/2010 15:06'!initialize	super initialize.	dependencies := OrderedCollection new.	license := #MIT! !!GRPackage methodsFor: 'testing' stamp: 'lr 10/25/2009 15:19'!isLGPL	^ self license = #LGPL! !!GRPackage methodsFor: 'testing' stamp: 'lr 10/25/2009 15:19'!isMIT	^ self license = #MIT! !!GRPackage methodsFor: 'accessing' stamp: 'lr 2/10/2010 11:18'!license	"Answer the current license of this package, by default MIT is used."	^ license! !!GRPackage methodsFor: 'accessing' stamp: 'obi 10/8/2009 07:51'!license: aSymbol	license := aSymbol! !!GRPackage methodsFor: 'accessing' stamp: 'lr 2/17/2010 15:18'!name	"Answer the name of the package. This string should be useable to identify the platform specific native package object, e.g. the Monticello package name."	^ name! !!GRPackage methodsFor: 'accessing' stamp: 'lr 10/25/2009 11:26'!name: aString	name := aString! !!GRPackage methodsFor: 'printing' stamp: 'merged 10/20/2008 09:24'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(; nextPutAll: self name; nextPut: $)! !!GRPackage methodsFor: 'dependencies' stamp: 'JohanBrichau 3/26/2016 15:54'!resolveWith: aDictionary	dependencies := dependencies 		collect: [ :each |			aDictionary at: each ifAbsent: [				"if Foo-Pharo-Bar fails try Foo-Pharo20-Bar and Foo-Pharo30-Bar"				(each indexOfSubCollection: '-Pharo-' startingAt: 1) ~= 0 ifTrue: [ 					"try -Pharo20-"					aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo20-') ifAbsent: [						"try -Pharo30-"						aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo30-') ifAbsent: [							"try -Pharo40-"							aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo40-') ifAbsent: [								"try -Pharo50-"								aDictionary at: (each copyReplaceAll: '-Pharo-' with: '-Pharo50-') ifAbsent: [									self error: self name printString , ' depends on unknown package ' , each printString ] ] ] ] ] ] ]! !!GRPackage methodsFor: 'accessing-repositories' stamp: 'pmm 9/12/2013 15:59'!seasideAddonsUrl	^ 'http://smalltalkhub.com/mc/Seaside/Seaside30Addons/main'! !!GRPackage methodsFor: 'accessing-repositories' stamp: 'pmm 9/12/2013 15:59'!seasideLGPLUrl	^ 'http://smalltalkhub.com/mc/Seaside/Seaside30LGPL/main'! !!GRPackage methodsFor: 'accessing-repositories' stamp: 'pmm 9/12/2013 15:58'!seasideUrl	^ 'http://smalltalkhub.com/mc/Seaside/Seaside31/main'! !!GRPackage methodsFor: 'accessing' stamp: 'lr 2/10/2010 11:18'!url	"Answer the base-URL of the package. This string is only meaningful for platforms that can directly access Monticello repositories."	^ url isSymbol		ifTrue: [ self perform: url ]		ifFalse: [ url ]! !!GRPackage methodsFor: 'accessing' stamp: 'lr 2/17/2010 15:18'!url: aStringOrSymbol	"Set the base-URL of the package, or a symbol referring to a method in this class that answers the URL. This setting is only meaningful for platforms that can directly access Monticello repositories."	url := aStringOrSymbol! !!GRPlatform class methodsFor: 'registration' stamp: 'jgf 1/25/2009 12:06'!current	^ Current! !!GRPlatform class methodsFor: 'registration' stamp: 'jf 1/21/2009 17:08'!current: aPlatform	Current := aPlatform! !!GRPlatform class methodsFor: 'registration' stamp: 'jf 9/30/2009 00:19'!select	GRPlatform current: self new! !!GRPlatform class methodsFor: 'registration' stamp: 'jf 9/30/2009 00:19'!unselect	GRPlatform current class = self ifTrue: [ GRPlatform current: nil ]! !!GRPlatform methodsFor: 'startup' stamp: 'jf 1/22/2009 02:11'!addToShutDownList: anObject	"Add anObject to the shutdown-list of the system. On shutdown the message #shutDown will be sent to anObject."	self subclassResponsibility! !!GRPlatform methodsFor: 'startup' stamp: 'jf 1/22/2009 02:10'!addToStartUpList: anObject	"Add anObject to the startup-list of the system. On startup the message #startUp will be sent to anObject."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'jf 1/22/2009 02:11'!asMethodReturningByteArray: aByteArrayOrString named: aSymbol	"Generates the source of a method named aSymbol that returns aByteArrayOrString as a ByteArray"	self subclassResponsibility! !!GRPlatform methodsFor: 'encoding' stamp: 'pmm 8/27/2011 15:12'!base64Decode: aString	"Base64 decode the given String and answer the result as a String."	self subclassResponsibility! !!GRPlatform methodsFor: 'bindings' stamp: 'pmm 8/23/2014 11:42'!bindingOf: aClass	"Answer the binding of aClass.	The binding is the literal that get compiled into the method.	We need the binding to be updated when the class is changed.	The binding has to respond to #value.		This is mostly an issue on GemStone/S because when we hold on	to a class directly we will end up holding on to an old class version.		Dialects with namespaces will need to override this.		On VisualWorks this should like this	^ aClass fullyQualifiedReference"	^ Smalltalk associationAt: aClass name! !!GRPlatform methodsFor: 'file library' stamp: 'jf 1/22/2009 02:11'!compile: aString into: aClass classified: aSymbol	"The trick here is to be as silently a possible so that the package is not marked dirty when running WAFileLibrary test.	This also makes running tests much faster."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'jf 1/22/2009 02:11'!contentsOfFile: aString binary: aBoolean	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'lr 4/15/2010 19:15'!convertToSmalltalkNewlines: aString	"Convert any line endings (CR, CRLF, LF) to the default platform newline."		aString isNil 		ifTrue: [ ^ nil ].	^ String streamContents: [ :writeStream |		| readStream |		readStream := aString readStream.		[ readStream atEnd ] whileFalse: [			| next |			next := readStream next.			next = Character cr				ifTrue: [					readStream peek = Character lf						ifTrue: [ readStream skip: 1 ].					writeStream nextPutAll: self newline ]				ifFalse: [					next = Character lf						ifTrue: [ writeStream nextPutAll: self newline ]						ifFalse: [ writeStream nextPut: next ] ] ] ]! !!GRPlatform methodsFor: 'exceptions' stamp: 'pmm 9/6/2014 12:17'!deprecationExceptionSet	"Answer the exception set that should considered besides WADeprecation."	^ ExceptionSet new! !!GRPlatform methodsFor: 'file library' stamp: 'NickAger 3/9/2012 11:29'!directoriesIn: aPathString	"Answer a collection of absolute paths for all the directories (no files) in the directory given by aPathString	must not include directory names that start with ."	self subclassResponsibility! !!GRPlatform methodsFor: 'transactions' stamp: 'lr 7/25/2011 19:51'!doTransaction: aBlock	"for Gemstone/S compatibility	http://gemstonesoup.wordpress.com/2007/05/10/porting-application-specific-seaside-threads-to-gemstone/	use when modifying an object from an outside thread"	^ aBlock value! !!GRPlatform methodsFor: 'file library' stamp: 'pmm 2/5/2011 09:54'!ensureExistenceOfFolder: aString	"Create a folder named aString in the image directory."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'JohanBrichau 10/3/2014 20:02'!fileExists: aString	self subclassResponsibility ! !!GRPlatform methodsFor: 'file library' stamp: 'JohanBrichau 10/3/2014 20:00'!fileStreamOn: aString do: aBlock binary: aBoolean	self subclassResponsibility ! !!GRPlatform methodsFor: 'file library' stamp: 'pmm 2/5/2011 09:54'!filesIn: aPathString	"Answer a collection of absolute paths for all the files (no directories) in the directory given by aPathString	must not include file names that start with ."	self subclassResponsibility! !!GRPlatform methodsFor: 'processes' stamp: 'jf 2/6/2009 16:00'!isProcessTerminated: aProcess	"Return a boolean indicating whether aProcess has been terminated."		self subclassResponsibility! !!GRPlatform methodsFor: 'version info' stamp: 'jf 2/9/2010 00:57'!label	"Answer a descriptive label string for the platform implementation"		self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'pmm 8/19/2014 10:10'!localNameOf: aFilename	"Answer the local name of a file identified by an absolute file path.		Eg.	If the platform is Windwos and aFilename is 'C:\Windows\win32.dll' then it would answer 'win32.dll'.	If the platform is Unix and aFilename is '/usr/bin/vim' then it would answer 'vim'."	self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'jf 9/25/2009 16:40'!newRandom	"Answers the random number generator to be used to create session and continuation keys. Make sure it is seeded. They only methods that will be sent to it are:	  #nextInt: - should answer a random integer in the interval [1, anInteger]	  #randomFrom: - should answer a random element from the given collection		Make sure that both methods are safe under heavy concurrent load.		Used by Gemstone/S traditional Randoms which cannot be persisted.	Used by Squeak to use a secure random when avaiable."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'lr 4/15/2010 19:13'!newline	"Answer a String with the default newline character of this platform."		self subclassResponsibility! !!GRPlatform methodsFor: 'exceptions' stamp: 'jf 1/22/2009 02:11'!openDebuggerOn: anError	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'pmm 2/5/2011 09:53'!pathSeparator	"Answer the path separator as a String, eg. '/' on Unix and '\' on Windows."	self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'lr 7/25/2011 19:51'!readWriteByteStream	"Return a ReadWriteStream on a ByteArray that stores integers 0..255		^ReadWriteStream on: ByteArray new	"	^ self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'lr 7/25/2011 19:51'!readWriteCharacterStream	"Return a ReadWriteStream on a String that stores characters		^ReadWriteStream on: String new	"	^ self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'jf 1/22/2009 02:39'!reducedConflictDictionary	"used by Gemstone/S reduced conflict classes that can be used to avoid transaction conflicts"	^ Dictionary! !!GRPlatform methodsFor: 'startup' stamp: 'jf 1/22/2009 02:11'!removeFromShutDownList: anObject	"Remove anObject from the shutdown list in the system."	self subclassResponsibility! !!GRPlatform methodsFor: 'startup' stamp: 'jf 1/22/2009 02:11'!removeFromStartUpList: anObject	"Remove anObject from the startup list in the system."	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'jf 1/22/2009 02:11'!removeSelector: aSymbol from: aClass	self subclassResponsibility! !!GRPlatform methodsFor: 'cryptography' stamp: 'jf 1/22/2009 02:11'!secureHashFor: aString	self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'jf 1/22/2009 02:10'!semaphoreClass	"used by Gemstone/S traditional Semaphores which cannot be persisted"	self subclassResponsibility! !!GRPlatform methodsFor: 'exceptions' stamp: 'jf 1/22/2009 02:11'!stackDepth	self subclassResponsibility! !!GRPlatform methodsFor: 'processes' stamp: 'jf 2/6/2009 16:00'!terminateProcess: aProcess	"Permanently terminate the process, unwinding first to execute #ensure: and #ifCurtailed: blocks."		self subclassResponsibility! !!GRPlatform methodsFor: 'version info' stamp: 'JohanBrichau 7/20/2014 17:51'!version	"Answer the Grease version"	^ (GRVersion major: 1 minor: 1 revision: 10)		yourself! !!GRPlatform methodsFor: 'version info' stamp: 'jf 2/9/2010 00:57'!versionString	^ String streamContents: [ :stream |		stream			nextPutAll: (self version greaseString);			nextPutAll: ' (';			nextPutAll: (self label);			nextPut: $) ]! !!GRPlatform methodsFor: 'factory' stamp: 'jf 1/22/2009 02:11'!weakDictionaryOfSize: aNumber	self subclassResponsibility! !!GRPlatform methodsFor: 'file library' stamp: 'pmm 8/19/2014 10:11'!write: aStringOrByteArray toFile: aFileNameString inFolder: aFolderString	"Write aStringOrByteArray to a file named aFileNameString in the folder aFolderString."	self subclassResponsibility! !!GRPlatform methodsFor: 'factory' stamp: 'pmm 8/26/2011 09:45'!writeCharacterStreamOn: aString	"String based write stream"	^ WriteStream on: aString! !!GRMappedPrinter class methodsFor: 'instance creation' stamp: 'lr 7/24/2008 11:32'!block: aBlock next: aPrinter	^ self new 		block: aBlock;		next: aPrinter;		yourself! !!GRMappedPrinter methodsFor: 'accessing' stamp: 'lr 7/24/2008 11:29'!block: aBlock	block := aBlock! !!GRMappedPrinter methodsFor: 'initialization' stamp: 'lr 2/6/2010 10:26'!initialize	super initialize.	self block: [ :value | value ]! !!GRMappedPrinter methodsFor: 'accessing' stamp: 'lr 7/24/2008 11:27'!next: aPrinter	next := aPrinter! !!GRMappedPrinter methodsFor: 'printing' stamp: 'lr 7/24/2008 11:26'!print: anObject on: aStream	next print: (block value: anObject) on: aStream! !!GRNumberPrinter class methodsFor: 'initialization' stamp: 'lr 1/23/2009 21:18'!initialize	NumbersToCharactersLowercase := '0123456789abcdefghijklmnopqrstuvwxyz'.	NumbersToCharactersUppercase := '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 7/25/2008 19:13'!accuracy: aFloat	"Round towards the nearest number that is a multiple of aFloat."		accuracy := aFloat! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 7/25/2008 19:16'!base: anInteger	"The numeric base to which the number should be printed."	base := anInteger! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 2/6/2010 10:17'!characters: aString	"The characters to be used to convert a number to a string."	characters := aString! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 7/24/2008 14:36'!delimiter: aCharacter	"The delimiter to separate the integer and fraction part of the number."	delimiter := aCharacter! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 7/24/2008 11:50'!digits: anInteger	"The number of digits to be printed in the integer part."	digits := anInteger! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'lr 5/13/2010 12:26'!digitsOf: aNumber base: aBaseInteger	"Answer the absolute digits of aNumber in the base aBaseInteger."	| integer stream next |	integer := aNumber truncated abs.	integer = 0 ifTrue: [ ^ '0' ].	stream := WriteStream on: (String new: 10).	[ integer > 0 ] whileTrue: [		next := integer quo: aBaseInteger.		stream nextPut: (characters 			at: 1 + integer - (next * aBaseInteger)).		integer := next ].	^ stream contents reverse! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 3/24/2008 16:19'!infinite: aString	"The string that should be displayed if the number is positive or negative infinity."		infinite := aString! !!GRNumberPrinter methodsFor: 'initialization' stamp: 'lr 2/6/2010 10:58'!initialize	super initialize.	self lowercase.	self base: 10.	self delimiter: $..	self infinite: 'Infinite'.	self nan: 'NaN'.	self padding: $ .	self precision: 0! !!GRNumberPrinter methodsFor: 'actions' stamp: 'lr 2/6/2010 10:17'!lowercase	"Use lowercase characters for numbers of base 10 and higher."	self characters: NumbersToCharactersLowercase! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 3/24/2008 16:19'!nan: aString	"The string that should be displayed if the number is not a number."		nan := aString! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 7/24/2008 11:51'!padding: aCharacter	"The padding for the integer part."	padding := aCharacter! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 7/25/2008 19:16'!precision: anInteger	"The number of digits to be printed in the fraction part."		precision := anInteger! !!GRNumberPrinter methodsFor: 'printing' stamp: 'lr 3/24/2008 16:27'!print: aNumber on: aStream	aNumber isNaN		ifTrue: [ ^ self printNaN: aNumber on: aStream ].	aNumber isInfinite 		ifTrue: [ ^ self printInfinite: aNumber on: aStream ].	precision = 0		ifTrue: [ self printInteger: aNumber on: aStream ]		ifFalse: [ self printFloat: aNumber on: aStream ]! !!GRNumberPrinter methodsFor: 'printing' stamp: 'pmm 9/15/2013 11:45'!printFloat: aNumber on: aStream	| multiplier rounded |	multiplier := base raisedTo: precision.	rounded := aNumber roundTo: (accuracy ifNil: [ multiplier reciprocal ]).	self printInteger: rounded on: aStream.	delimiter isNil		ifFalse: [ aStream nextPut: delimiter ].	self printFraction: rounded fractionPart abs * multiplier on: aStream! !!GRNumberPrinter methodsFor: 'printing' stamp: 'lr 6/4/2009 21:41'!printFraction: aNumber on: aStream	| result |	result := self		pad: (self digitsOf: aNumber rounded base: base)		left: $0 to: precision.	separator isNil		ifFalse: [ result := self separate: result left: separator ].	aStream nextPutAll: result! !!GRNumberPrinter methodsFor: 'printing' stamp: 'lr 3/24/2008 16:39'!printInfinite: aNumber on: aStream	infinite isNil		ifFalse: [ aStream nextPutAll: infinite ]! !!GRNumberPrinter methodsFor: 'printing' stamp: 'lr 7/24/2008 12:39'!printInteger: aNumber on: aStream	| result |	result := self digitsOf: aNumber integerPart base: base.	separator isNil		ifFalse: [ result := self separate: result right: separator ].	(digits isNil or: [ padding isNil ])		ifFalse: [ result := self pad: result left: padding to: digits ].	aStream nextPutAll: result! !!GRNumberPrinter methodsFor: 'printing' stamp: 'lr 3/24/2008 16:39'!printNaN: anInteger on: aStream	nan isNil		ifFalse: [ aStream nextPutAll: nan ]! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'lr 7/24/2008 14:34'!separate: aString left: aCharacter	"Separate from the left side every 3 characters with aCharacter."			| size stream |	size := aString size.	stream := WriteStream on: (String new: 2 * size).	1 to: size do: [ :index |		(index ~= 1 and: [ index \\ 3 = 1 ])			ifTrue: [ stream nextPut: aCharacter ].		stream nextPut: (aString at: index) ].	^ stream contents! !!GRNumberPrinter methodsFor: 'utilities' stamp: 'lr 7/24/2008 14:34'!separate: aString right: aCharacter	"Separate from the right side every 3 characters with aCharacter."			| size stream |	size := aString size.	stream := WriteStream on: (String new: 2 * size).	1 to: size do: [ :index |		(index ~= 1 and: [ size - index \\ 3 = 2 ])			ifTrue: [ stream nextPut: aCharacter ].		stream nextPut: (aString at: index) ].	^ stream contents! !!GRNumberPrinter methodsFor: 'accessing' stamp: 'lr 7/24/2008 14:35'!separator: aCharacter	"Separator character to be used to group digits."	separator := aCharacter! !!GRNumberPrinter methodsFor: 'actions' stamp: 'lr 2/6/2010 10:17'!uppercase	"Use uppercase characters for numbers of base 10 and higher."		self characters: NumbersToCharactersUppercase! !!GROrdinalizePrinter methodsFor: 'private' stamp: 'lr 2/16/2008 19:37'!ordinalize: anInteger	^ (anInteger \\ 100 between: 11 and: 13)		ifTrue: [ 'th' ]		ifFalse: [ 			#('st' 'nd' 'rd')				at: anInteger \\ 10 				ifAbsent: [ 'th' ] ]! !!GROrdinalizePrinter methodsFor: 'printing' stamp: 'lr 2/16/2008 19:32'!print: anObject on: aStream	aStream nextPutAll: (self ordinalize: anObject integerPart)! !!GRPluggablePrinter class methodsFor: 'instance creation' stamp: 'lr 7/24/2008 13:59'!on: aBlock	^ self new block: aBlock! !!GRPluggablePrinter methodsFor: 'accessing' stamp: 'lr 7/24/2008 12:49'!block: aBlock	block := aBlock! !!GRPluggablePrinter methodsFor: 'initialization' stamp: 'lr 2/6/2010 10:15'!initialize	super initialize.	self block: [ :value | String new ]! !!GRPluggablePrinter methodsFor: 'printing' stamp: 'lr 7/24/2008 12:49'!print: anObject on: aStream	aStream nextPutAll: (block value: anObject)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'lr 7/24/2008 13:59'!abbreviatedMonthName	^ self monthName: #('Jan' 'Feb' 'Mar' 'Apr' 'May' 'Jun' 'Jul' 'Aug' 'Sep' 'Oct' 'Nov' 'Dec')! !!GRPrinter class methodsFor: 'parts-date' stamp: 'lr 7/24/2008 14:25'!abbreviatedWeekName	^ self weekName: #('Sun' 'Mon' 'Tue' 'Wed' 'Thu' 'Fri' 'Sat')! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!absOffsetHoursPadded	^ GRMappedPrinter 		block: [ :date | date offset hours abs ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!absOffsetMinutesPadded	^ GRMappedPrinter 		block: [ :date | date offset minutes abs ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-units' stamp: 'lr 2/19/2012 13:00'!binaryFileSize	^ GRUnitPrinter base: 1024 units: #('byte' 'bytes' 'KiB' 'MiB' 'GiB' 'TiB' 'PiB' 'EiB' 'ZiB' 'YiB')! !!GRPrinter class methodsFor: 'factory-http' stamp: 'lr 2/19/2012 13:01'!cookieTimestamp	"Netscape's original proposal defined an Expires header that took a date value in a fixed-length variant format in place of Max-Age: Wdy, DD-Mon-YY HH:MM:SS GMT"	^ GRMappedPrinter		block: [ :timestamp | timestamp asUTC ]		next: self abbreviatedWeekName , ', ' , self paddedDay , '-' , self abbreviatedMonthName , '-' , self paddedYear , ' ' , self isoTime , ' GMT'! !!GRPrinter class methodsFor: 'parts-units' stamp: 'lr 2/19/2012 13:00'!decimalFileSize	^ GRUnitPrinter base: 1000 units: #('byte' 'bytes' 'kB' 'MB' 'GB' 'TB' 'PB' 'EB' 'ZB' 'YB')! !!GRPrinter class methodsFor: 'parts-date' stamp: 'lr 7/24/2008 13:59'!fullMonthName	^ self monthName: #('January' 'February' 'March' 'April' 'May' 'June' 'July' 'August' 'September' 'October' 'November' 'December')! !!GRPrinter class methodsFor: 'parts-date' stamp: 'lr 7/24/2008 14:25'!fullWeekName	^ self weekName: #('Sunday' 'Monday' 'Tuesday' 'Wednesday' 'Thursday' 'Friday' 'Saturday')! !!GRPrinter class methodsFor: 'factory-http' stamp: 'lr 2/19/2012 13:01'!httpDate	"Answers a printer that formats dates for HTTP1.1 (RFC 2616)"	^ self rfc1123! !!GRPrinter class methodsFor: 'factory-http' stamp: 'pmm 8/19/2014 10:06'!isoDate	"Ansers a printer that formats dates according to ISO(YYYY-MM-DD) E.g. 2003-12-24"	^ self paddedYear , $- , self paddedMonth , $- , self paddedDay! !!GRPrinter class methodsFor: 'factory-http' stamp: 'pmm 8/19/2014 10:05'!isoTime	"Ansers a printer that formats time according to ISO(HH:MM:SS) E.g. 12:23:34"		^ self paddedHour24 , $: , self paddedMinute , $: , self paddedSecond! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!monthName: anArray 	^ GRPluggablePrinter on: [ :date | anArray at: date monthIndex ]! !!GRPrinter class methodsFor: 'parts-units' stamp: 'lr 2/19/2012 13:00'!numberWithAtLeastDigits: anInteger	^ GRNumberPrinter new		padding: $0;		digits: anInteger;		yourself! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:33'!offsetSign	^ GRMappedPrinter 		block: [ :date | date offset ]		next: (GRSignPrinter new				positivePrinter: $+;				negativePrinter: $-;				yourself)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!paddedCentury	^ GRMappedPrinter 		block: [ :date | date year \\ 100 ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!paddedDay	^ GRMappedPrinter 		block: [ :date | date dayOfMonth ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-time' stamp: 'jf 9/30/2009 00:32'!paddedHour12	^ GRMappedPrinter 		block: [ :time | (time hour - 1) \\ 12 + 1 ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-time' stamp: 'jf 9/30/2009 00:32'!paddedHour24	^ GRMappedPrinter 		block: [ :time | time hour ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-time' stamp: 'jf 9/30/2009 00:32'!paddedMinute	^ GRMappedPrinter 		block: [ :time | time minute ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!paddedMonth	^ GRMappedPrinter 		block: [ :date | date monthIndex ]		next: (self numberWithAtLeastDigits: 2)! !!GRPrinter class methodsFor: 'parts-time' stamp: 'jf 9/30/2009 00:32'!paddedSecond	^ GRMappedPrinter 		block: [ :time | time second ]		next: (GRNumberPrinter new				padding: $0;				digits: 2)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!paddedYear	^ GRMappedPrinter 		block: [ :date | date year ]		next: (self numberWithAtLeastDigits: 4)! !!GRPrinter class methodsFor: 'factory-http' stamp: 'lr 2/19/2012 13:01'!rfc1123	"Answers a printer that formats dates for HTTP1.1 (RFC 1123). Eg.	Sun, 06 Nov 1994 08:49:37 GMT "		^ GRMappedPrinter 		block: [ :date | 			"For the purposes of HTTP, GMT is exactly equal to UTC (Coordinated Universal Time)"			date asUTC ]		next: GRSequentialPrinter new , self abbreviatedWeekName , ', ' , self paddedDay , Character space , self abbreviatedMonthName , Character space , self paddedYear , Character space , self isoTime , ' GMT'! !!GRPrinter class methodsFor: 'factory-http' stamp: 'pmm 8/19/2014 10:06'!rfc822	"Answers a printer that formats dates according to RFC 822 (email). Eg.	Sun, 31 Aug 2008 19:41:46 +0200"	^ self abbreviatedWeekName , ', ' , self paddedDay , Character space , self abbreviatedMonthName , Character space , self paddedYear , Character space , self isoTime , Character space , self offsetSign , self absOffsetHoursPadded , self absOffsetMinutesPadded! !!GRPrinter class methodsFor: 'factory-http' stamp: 'lr 2/19/2012 13:02'!rfc822WithTimeZone: aString	"Answers a privter that formats dates according to RFC 822 (email) with the given time zone String. Eg.	Sun, 31 Aug 2008 19:41:46 <aString>"	^ self abbreviatedWeekName , ', ' , self paddedDay , Character space , self abbreviatedMonthName , Character space , self paddedYear , Character space , self isoTime , Character space , aString! !!GRPrinter class methodsFor: 'factory-currency' stamp: 'jf 9/30/2009 00:33'!swissCurrency	^ GRSequentialPrinter new , 'CHF ' , GRSignPrinter new , (GRNumberPrinter new			separator: $';			precision: 2;			accuracy: 0.05;			yourself)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!unpaddedCentury	^ GRMappedPrinter 		block: [ :date | date year \\ 100 ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!unpaddedDay	^ GRMappedPrinter 		block: [ :date | date dayOfMonth ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-time' stamp: 'jf 9/30/2009 00:32'!unpaddedHour12	^ GRMappedPrinter 		block: [ :time | (time hour - 1) \\ 12 + 1 ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-time' stamp: 'jf 9/30/2009 00:32'!unpaddedHour24	^ GRMappedPrinter 		block: [ :time | time hour ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-time' stamp: 'jf 9/30/2009 00:32'!unpaddedMinute	^ GRMappedPrinter 		block: [ :time | time minute ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!unpaddedMonth	^ GRMappedPrinter 		block: [ :date | date monthIndex ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-time' stamp: 'jf 9/30/2009 00:32'!unpaddedSecond	^ GRMappedPrinter 		block: [ :time | time second ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!unpaddedYear	^ GRMappedPrinter 		block: [ :date | date year ]		next: GRNumberPrinter new! !!GRPrinter class methodsFor: 'factory-currency' stamp: 'jf 9/30/2009 00:33'!usCurrency	^ GRSignPrinter new , $$ , (GRNumberPrinter new			separator: $,;			precision: 2;			yourself)! !!GRPrinter class methodsFor: 'parts-date' stamp: 'jf 9/30/2009 00:32'!weekName: anArray 	^ GRPluggablePrinter on: [ :date | anArray at: date dayOfWeek ]! !!GRPrinter methodsFor: 'operators' stamp: 'jf 9/30/2009 00:33'!, aPrinter 	^ GRSequentialPrinter new , self , aPrinter! !!GRPrinter methodsFor: 'utilities' stamp: 'jok 1/26/2010 09:56'!pad: aString center: aCharacter to: anInteger	"Pad to the center of aString with aCharacter to at least anInteger characters."	| result index |	anInteger <= aString size		ifTrue: [ ^ aString ].	index := (anInteger - aString size) // 2.	result := (String new: anInteger) atAllPut: aCharacter.	result		replaceFrom: index + 1		to: index + aString size		with: aString		startingAt: 1.	^ result! !!GRPrinter methodsFor: 'utilities' stamp: 'jok 1/26/2010 09:56'!pad: aString left: aCharacter to: anInteger	"Pad to the left side of aString with aCharacter to at least anInteger characters."	| result |	anInteger <= aString size		ifTrue: [ ^ aString ].	result := (String new: anInteger) atAllPut: aCharacter.	result		replaceFrom: anInteger - aString size + 1		to: anInteger		with: aString		startingAt: 1.	^ result! !!GRPrinter methodsFor: 'utilities' stamp: 'jok 1/26/2010 09:56'!pad: aString right: aCharacter to: anInteger	"Pad to the right side of aString with aCharacter to at least anInteger characters."	| result |	anInteger <= aString size		ifTrue: [ ^ aString ].	result := (String new: anInteger) atAllPut: aCharacter.	result		replaceFrom: 1		to: aString size		with: aString		startingAt: 1.	^ result! !!GRPrinter methodsFor: 'printing' stamp: 'lr 2/7/2008 10:37'!print: anObject	^ String streamContents: [ :stream | self print: anObject on: stream ]! !!GRPrinter methodsFor: 'printing' stamp: 'lr 7/25/2008 19:51'!print: anObject on: aStream	"Subclasses override this method to produce some output."! !!GRSequentialPrinter methodsFor: 'operators' stamp: 'lr 2/7/2008 11:33'!, aConverter	parts add: aConverter! !!GRSequentialPrinter methodsFor: 'initialization' stamp: 'lr 2/7/2008 10:28'!initialize	super initialize.	parts := OrderedCollection new! !!GRSequentialPrinter methodsFor: 'printing' stamp: 'lr 2/7/2008 10:29'!print: anObject on: aStream 	parts do: [ :each | each print: anObject on: aStream ]! !!GRSignPrinter methodsFor: 'initialization' stamp: 'lr 2/6/2010 10:15'!initialize	super initialize.	self negativePrinter: $-.	self positivePrinter: nil! !!GRSignPrinter methodsFor: 'accessing' stamp: 'lr 2/7/2008 13:28'!negativePrinter: aPrinter	"The printer to be used when the number is negative."		negativePrinter := aPrinter! !!GRSignPrinter methodsFor: 'accessing' stamp: 'lr 2/7/2008 13:28'!positivePrinter: aPrinter	"The printer to be used when the number is zero or positive."		positivePrinter := aPrinter! !!GRSignPrinter methodsFor: 'printing' stamp: 'lr 2/7/2008 13:27'!print: anObject on: aStream 	anObject negative		ifTrue: [ negativePrinter print: anObject on: aStream ]		ifFalse: [ positivePrinter print: anObject on: aStream ]! !!GRStringPrinter methodsFor: 'accessing' stamp: 'lr 1/23/2009 21:40'!character: aCharacter	"The character to pad the string with."		character := aCharacter! !!GRStringPrinter methodsFor: 'initialization' stamp: 'lr 2/6/2010 10:11'!initialize	super initialize.	self character: $ ; length: nil.	self trimNone; padNone! !!GRStringPrinter methodsFor: 'accessing' stamp: 'lr 1/23/2009 22:00'!length: anInteger	"The maximal size of the string, or the size to pad to."	length := anInteger! !!GRStringPrinter methodsFor: 'padding' stamp: 'lr 1/23/2009 22:01'!padCenter	"Pad to the center."		pad := #pad:center:to:! !!GRStringPrinter methodsFor: 'padding' stamp: 'lr 1/23/2009 22:02'!padLeft	"Pad to the left."		pad := #pad:left:to:! !!GRStringPrinter methodsFor: 'padding' stamp: 'lr 2/6/2010 10:11'!padNone	"Do not pad the input."		pad := nil! !!GRStringPrinter methodsFor: 'padding' stamp: 'lr 1/23/2009 22:01'!padRight	"Pad to the right."		pad := #pad:right:to:! !!GRStringPrinter methodsFor: 'printing' stamp: 'lr 2/6/2010 10:10'!print: anObject on: aStream 	| string |	string := anObject greaseString.	trim isNil		ifFalse: [ string := string perform: trim ].	length isNil ifFalse: [		length < string size 			ifTrue: [ string := string copyFrom: 1to: length ].		(pad isNil or: [ character isNil ])			ifFalse: [ string := self perform: pad with: string with: character with: length ] ].	aStream nextPutAll: string! !!GRStringPrinter methodsFor: 'trimming' stamp: 'lr 1/23/2009 21:59'!trimBoth	"Trim to the left and to the right."	trim := #trimBoth! !!GRStringPrinter methodsFor: 'trimming' stamp: 'lr 1/23/2009 21:59'!trimLeft	"Trim to the left and to the right."	trim := #trimLeft! !!GRStringPrinter methodsFor: 'trimming' stamp: 'lr 2/6/2010 10:11'!trimNone	"Do not trim the input."	trim := nil! !!GRStringPrinter methodsFor: 'trimming' stamp: 'lr 1/23/2009 21:59'!trimRight	"Trim to the left and to the right."	trim := #trimRight! !!GRUnitPrinter class methodsFor: 'instance creation' stamp: 'lr 9/22/2008 23:34'!base: anInteger units: anArray	^ self new 		base: anInteger;		units: anArray;		yourself! !!GRUnitPrinter methodsFor: 'accessing' stamp: 'lr 9/22/2008 23:27'!base: anInteger	base := anInteger! !!GRUnitPrinter methodsFor: 'accessing' stamp: 'lr 2/7/2008 13:23'!fractionPrinter: aPrinter	fractionPrinter := aPrinter! !!GRUnitPrinter methodsFor: 'initialization' stamp: 'lr 2/6/2010 10:07'!initialize	super initialize.	self integerPrinter: (GRNumberPrinter new		precision: 0;		yourself).	self fractionPrinter: (GRNumberPrinter new		precision: 1;		yourself)! !!GRUnitPrinter methodsFor: 'accessing' stamp: 'lr 2/7/2008 13:23'!integerPrinter: aPrinter	integerPrinter := aPrinter! !!GRUnitPrinter methodsFor: 'printing' stamp: 'lr 9/22/2008 23:28'!print: anObject on: aStream	anObject = 1		ifTrue: [ ^ self print: anObject unit: units first on: aStream ].	units allButFirst		inject: anObject asFloat		into: [ :value :each |			value < base				ifFalse: [ value / base ]				ifTrue: [ ^ self print: value unit: each on: aStream ] ]! !!GRUnitPrinter methodsFor: 'printing' stamp: 'lr 9/22/2008 23:36'!print: aNumber unit: aString on: aStream	(units first = aString or: [ units second = aString ])		ifTrue: [ integerPrinter print: aNumber on: aStream ]		ifFalse: [ fractionPrinter print: aNumber on: aStream ].	aStream nextPut: $ ; nextPutAll: aString! !!GRUnitPrinter methodsFor: 'accessing' stamp: 'lr 9/22/2008 23:27'!units: anArray	units := anArray! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'lr 7/25/2011 19:52'!add: anAssociation	self privateAt: anAssociation key put: anAssociation value.	^ anAssociation! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'jf 2/15/2010 15:39'!allAt: aKey	^ Array streamContents: [ :stream |		1 to: size do: [ :index |			(keys at: index) = aKey				ifTrue: [ stream nextPut: (values at: index) ] ] ]! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'jf 2/15/2010 15:39'!allAt: aKey ifAbsent: absentBlock	| results |	results := self allAt: aKey.	^ results isEmpty		ifTrue: [ absentBlock value ]		ifFalse: [ results ]! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'jf 2/15/2010 13:24'!at: aKey add: aValue	"Add an association between aKey and aValue. Do not replace existing	values with the same key."		^ self privateAt: aKey put: aValue! !!GROrderedMultiMap methodsFor: 'accessing' stamp: 'jf 2/15/2010 14:43'!removeKey: aKey ifAbsent: aBlock	"Remove aKey from the receiver, evaluate aBlock if the element is missing."	"This is inefficient and could be optimized."	| removed |	removed := Array streamContents: [ :stream |		| index |		[ (index := self findIndexFor: aKey) = 0 ] whileFalse: [			stream nextPut: (self removeIndex: index) ] ].	^ removed isEmpty		ifTrue: [ aBlock value ]		ifFalse: [ removed ]! !!GRSmallDictionary class methodsFor: 'instance creation' stamp: 'lr 1/24/2008 12:34'!new	^ self new: 3! !!GRSmallDictionary class methodsFor: 'instance creation' stamp: 'jf 3/13/2009 18:19'!new: anInteger	^ self basicNew initialize: anInteger; yourself! !!GRSmallDictionary class methodsFor: 'instance creation' stamp: 'jf 2/15/2010 22:50'!withAll: aDictionary	^ (self new: aDictionary size)		addAll: aDictionary;		yourself! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 7/25/2011 19:51'!add: anAssociation	self at: anAssociation key put: anAssociation value.	^ anAssociation! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'jf 2/15/2010 22:56'!addAll: aDictionary	aDictionary keysAndValuesDo: [ :key :value | self add: key -> value ].	^ aDictionary! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 10/28/2007 14:42'!associations	"Answer a Collection containing the receiver's associations."	| result |	result := WriteStream on: (Array new: self size).	self associationsDo: [ :assoc | result nextPut: assoc ].	^ result contents! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'lr 8/20/2007 13:45'!associationsDo: aBlock	self keysAndValuesDo: [ :key :value | aBlock value: key -> value ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 10/28/2007 14:42'!at: aKey	"Answer the value associated with aKey. Raise an exception, if no such key is defined."	^ self at: aKey ifAbsent: [ self errorKeyNotFound ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 10/28/2007 14:42'!at: aKey ifAbsent: aBlock	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ values at: index ]		ifTrue: [ aBlock value ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 10/28/2007 14:42'!at: aKey ifAbsentPut: aBlock	"Answer the value associated with aKey. Evaluate aBlock, if no such key is defined and store the return value."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ values at: index ]		ifTrue: [ self privateAt: aKey put: aBlock value ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 10/28/2007 14:42'!at: aKey ifPresent: aBlock	"Lookup aKey in the receiver. If it is present, answer the value of evaluating the given block with the value associated with the key. Otherwise, answer nil."	| index |	index := self findIndexFor: aKey.	^ index = 0 ifFalse: [ aBlock value: (values at: index) ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 10/28/2007 14:42'!at: aKey put: aValue	"Set the value of aKey to be aValue."	| index |	index := self findIndexFor: aKey.	^ index = 0		ifFalse: [ values at: index put: aValue ]		ifTrue: [ self privateAt: aKey put: aValue ]! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'jf 12/29/2009 20:38'!do: aBlock	1 to: size do: [ :index | aBlock value: (values at: index) ]! !!GRSmallDictionary methodsFor: 'private' stamp: 'lr 7/12/2007 13:18'!errorKeyNotFound	self error: 'Key not found'! !!GRSmallDictionary methodsFor: 'private' stamp: 'lr 10/28/2007 14:42'!findIndexFor: aKey	1 to: size do: [ :index |		(keys at: index) = aKey			ifTrue: [ ^ index ] ].	^ 0! !!GRSmallDictionary methodsFor: 'private' stamp: 'lr 6/6/2007 19:12'!grow	| newKeys newValues |	newKeys := Array new: 2 * size.	newValues := Array new: 2 * size.	1 to: size do: [ :index |		newKeys at: index put: (keys at: index).		newValues at: index put: (values at: index) ].	keys := newKeys.	values := newValues! !!GRSmallDictionary methodsFor: 'testing' stamp: 'lr 10/28/2007 14:42'!includesKey: aKey	"Answer whether the receiver has a key equal to aKey."	^ (self findIndexFor: aKey) ~= 0! !!GRSmallDictionary methodsFor: 'initialization' stamp: 'jf 3/13/2009 17:48'!initialize: anInteger	self initialize.	size := 0.	keys := Array new: anInteger.	values := Array new: anInteger! !!GRSmallDictionary methodsFor: 'testing' stamp: 'jf 2/15/2010 15:47'!isCollection	^ true! !!GRSmallDictionary methodsFor: 'testing' stamp: 'lr 7/9/2007 08:13'!isEmpty	^ size = 0! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'lr 7/9/2007 10:37'!keys	^ keys copyFrom: 1 to: size! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'lr 6/7/2007 08:04'!keysAndValuesDo: aBlock	1 to: size do: [ :index | aBlock value: (keys at: index) value: (values at: index) ]! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'lr 8/17/2007 11:52'!keysDo: aBlock	1 to: size do: [ :each | aBlock value: (keys at: each) ]! !!GRSmallDictionary methodsFor: 'copying' stamp: 'lr 7/9/2007 07:50'!postCopy	super postCopy.	keys := keys copy.	values := values copy! !!GRSmallDictionary methodsFor: 'printing' stamp: 'pmm 1/22/2012 16:32'!printOn: aStream	super printOn: aStream.		aStream nextPut: $(.	self size <= 100		ifTrue: [			| first |			first := true.			self keysAndValuesDo: [ :key :value |				"keysAndValuesDo:separatedBy: would be nice"				first					ifTrue: [ first := false ]					ifFalse: [ aStream space ].				aStream					print: key;					nextPutAll: '->';									print: value ] ]		ifFalse: [			aStream				nextPutAll: 'size ';				print: self size ].	aStream nextPut: $)	! !!GRSmallDictionary methodsFor: 'private' stamp: 'lr 6/6/2007 19:28'!privateAt: aKey put: aValue	size = keys size ifTrue: [ self grow ].	keys at: (size := size + 1) put: aKey.	^ values at: size put: aValue! !!GRSmallDictionary methodsFor: 'private' stamp: 'jf 2/15/2010 14:33'!removeIndex: index	| value |	value := values at: index.	index to: size - 1 do:			[ :i | 			keys at: i put: (keys at: i + 1).			values at: i put: (values at: i + 1) ].	keys at: size put: nil.	values at: size put: nil.	size := size - 1.	^ value! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 7/12/2007 13:18'!removeKey: aKey	"Remove aKey from the receiver, raise an exception if the element is missing."	^ self removeKey: aKey ifAbsent: [ self errorKeyNotFound ]! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'jf 2/15/2010 14:40'!removeKey: aKey ifAbsent: aBlock	"Remove aKey from the receiver, evaluate aBlock if the element is missing."	| index |	index := self findIndexFor: aKey.	index = 0 ifTrue: [ ^ aBlock value ].	^ self removeIndex: index! !!GRSmallDictionary methodsFor: 'accessing' stamp: 'lr 7/9/2007 10:38'!size	^ size! !!GRSmallDictionary methodsFor: 'enumerating' stamp: 'lr 7/9/2007 10:38'!values	^ values copyFrom: 1 to: size! !!GRVersion class methodsFor: 'instance creation' stamp: 'jf 2/8/2010 23:14'!major: majorInteger	^ self major: majorInteger minor: nil! !!GRVersion class methodsFor: 'instance creation' stamp: 'jf 2/8/2010 23:14'!major: majorInteger minor: minorInteger	^ self major: majorInteger minor: minorInteger revision: nil! !!GRVersion class methodsFor: 'instance creation' stamp: 'jf 2/8/2010 23:08'!major: majorInteger minor: minorInteger revision: revisionInteger	^ self basicNew		initializeWithMajor: majorInteger minor: minorInteger revision: revisionInteger;		yourself! !!GRVersion class methodsFor: 'instance creation' stamp: 'jf 2/9/2010 01:01'!new	^ self major: 1! !!GRVersion methodsFor: 'comparing' stamp: 'jf 2/9/2010 00:18'!< otherVersion	(major < otherVersion major) ifTrue: [ ^ true ].	(otherVersion major < major) ifTrue: [ ^ false ].	((minor ifNil: [ 0 ]) < (otherVersion minor ifNil: [ 0 ])) ifTrue: [ ^ true ].	((otherVersion minor ifNil: [ 0 ]) < (minor ifNil: [ 0 ])) ifTrue: [ ^ false ].	((revision ifNil: [ 0 ]) < (otherVersion revision ifNil: [ 0 ])) ifTrue: [ ^ true ].	((otherVersion revision ifNil: [ 0 ]) < (revision ifNil: [ 0 ])) ifTrue: [ ^ false ].	(stageLabel = otherVersion stage) ifTrue: [		^ ((stageNumber ifNil: [ 1 ]) < (otherVersion stageNumber ifNil: [ 1 ])) ].	stageLabel isNil ifTrue: [ ^ false ].	otherVersion stage isNil ifTrue: [ ^ true ].	^ stageLabel < otherVersion stage		! !!GRVersion methodsFor: 'comparing' stamp: 'jf 2/9/2010 00:06'!<= otherVersion	^ (self > otherVersion) not! !!GRVersion methodsFor: 'comparing' stamp: 'jf 2/9/2010 00:16'!= otherVersion	^ (major = otherVersion major) and: [		((minor ifNil: [ 0 ]) = (otherVersion minor ifNil: [ 0 ])) and: [		((revision ifNil: [ 0 ] ) = (otherVersion revision ifNil: [ 0 ])) and: [		(stageLabel = otherVersion stage) and: [		(stageNumber ifNil: [ 1 ]) = (otherVersion stageNumber ifNil: [ 1 ]) ] ] ] ]! !!GRVersion methodsFor: 'comparing' stamp: 'jf 2/9/2010 00:07'!> otherVersion	^ otherVersion < self! !!GRVersion methodsFor: 'comparing' stamp: 'jf 2/9/2010 00:07'!>= otherVersion	^ (self < otherVersion) not! !!GRVersion methodsFor: 'convenience' stamp: 'jf 2/8/2010 23:18'!beAlpha	self beAlpha: nil! !!GRVersion methodsFor: 'convenience' stamp: 'jf 2/8/2010 23:18'!beAlpha: anInteger	self stage: #alpha number: anInteger! !!GRVersion methodsFor: 'convenience' stamp: 'jf 2/8/2010 23:18'!beBeta	self beBeta: nil! !!GRVersion methodsFor: 'convenience' stamp: 'jf 2/8/2010 23:18'!beBeta: anInteger	self stage: #beta number: anInteger! !!GRVersion methodsFor: 'convenience' stamp: 'jf 2/9/2010 00:35'!beFinal	self stage: nil number: nil! !!GRVersion methodsFor: 'convenience' stamp: 'jf 5/22/2010 23:38'!beReleaseCandidate	self beReleaseCandidate: nil! !!GRVersion methodsFor: 'convenience' stamp: 'jf 5/22/2010 23:37'!beReleaseCandidate: anInteger	self stage: #rc number: anInteger! !!GRVersion methodsFor: 'converting' stamp: 'pmm 1/22/2012 16:32'!greaseString	^ String streamContents: [ :stream |		stream nextPutAll: major greaseString.		stream nextPut: $..		stream nextPutAll: (minor ifNil: [ 0 ]) greaseString.		revision isNil ifFalse: [			stream nextPut: $..			stream nextPutAll: revision greaseString ].		stageLabel isNil ifFalse: [			stream nextPutAll: stageLabel greaseString.			stageNumber isNil ifFalse: [ stream nextPutAll: stageNumber greaseString ] ] ]! !!GRVersion methodsFor: 'comparing' stamp: 'lr 2/16/2010 20:55'!hash	^ (major hash bitXor: minor hash) bitXor: revision hash! !!GRVersion methodsFor: 'initialization' stamp: 'jf 2/8/2010 23:08'!initializeWithMajor: majorInteger minor: minorInteger revision: revisionInteger	self initialize.	major := majorInteger.	minor := minorInteger.	revision := revisionInteger! !!GRVersion methodsFor: 'testing' stamp: 'jf 2/9/2010 00:34'!isAlpha	^ stageLabel = #alpha! !!GRVersion methodsFor: 'testing' stamp: 'jf 2/9/2010 00:34'!isBeta	^ stageLabel = #beta! !!GRVersion methodsFor: 'testing' stamp: 'jf 2/9/2010 00:34'!isFinal	^ stageLabel isNil! !!GRVersion methodsFor: 'testing' stamp: 'jf 5/22/2010 23:38'!isReleaseCandidate	^ stageLabel = #rc! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/8/2010 23:16'!major	^ major! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/8/2010 23:16'!major: anInteger	major := anInteger! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/8/2010 23:16'!minor	^ minor! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/8/2010 23:17'!minor: anInteger	minor := anInteger! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/8/2010 23:16'!revision	^ revision! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/8/2010 23:17'!revision: anInteger	revision := anInteger! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/9/2010 00:01'!stage	^ stageLabel! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/8/2010 23:17'!stage: aSymbol number: anInteger	stageLabel := aSymbol.	stageNumber := anInteger! !!GRVersion methodsFor: 'accessing' stamp: 'jf 2/9/2010 00:01'!stageNumber	^ stageNumber! !!Object methodsFor: '*grease-core' stamp: 'jf 9/30/2009 01:02'!greaseDeprecatedApi: apiString details: detailsString 	GRDeprecatedApiNotification new		details: detailsString;		signal: apiString! !!Number methodsFor: '*grease-core' stamp: 'jf 9/30/2009 01:04'!greaseInteger	"Answer an integer of the receiver, in our case we simply truncate the number."	^ self truncated! !"Grease-Core"!!GRPharoLatin1Codec commentStamp: '<historical>' prior: 0!A GRPharoLatin1Codec is a WACodec optimized for ISO-8859-1 (direct byte to character mapping).!!GRWorkingWriteStream commentStamp: 'pmm 8/25/2011 18:30' prior: 0!I'm a work around for bugs in the Pharo stream classes.!!GRPharoPlatform commentStamp: 'pmm 6/1/2008 01:03' prior: 0!A WASqueakPlatform is the Squeak implementation of SeasidePlatformSupport, the Seaside class that provides functionality that can not be implemented in a platform independent way.!!GRPharoConverterCodecStream commentStamp: 'pmm 6/25/2012 20:22' prior: 0!A WAConverterCodecStream is a WACodec stream around a TextConverter. It is always in text mode.Instance Variables	converter:		<TextConverter>converter	- the TextConverter used to do the encoding conversion!!GRPharoUtf8CodecStream commentStamp: 'pmm 2/20/2009 12:27' prior: 0!A WAUtf8CodecStream is a WACodecStream optimized for UTF-8 performance in the case where most of the characters are ASCII.!!GRPharoLatin1CodecStream commentStamp: '<historical>' prior: 0!A GRPharoLatin1CodecStream is a WACodecStream optimized for ISO-8859-1 (direct byte to character mapping).!!GRPharoUtf8Codec commentStamp: 'pmm 2/20/2009 12:51' prior: 0!A WAUtf8Codec is a WACodec optimized for UTF-8.!!Number methodsFor: '*Grease-Pharo30-Core' stamp: 'jf 2/6/2010 00:12'!milliseconds	^ self milliSeconds! !!GRPharoRandomProvider class methodsFor: 'private' stamp: 'jgf 1/25/2009 12:05'!initialize	Smalltalk addToStartUpList: self.	self startUp! !!GRPharoRandomProvider class methodsFor: 'public' stamp: 'lr 7/25/2011 19:46'!nextInt: anInteger	"Answer a random integer in the interval [1, anInteger]"	^ mutex critical: [ generator nextInt: anInteger ]! !!GRPharoRandomProvider class methodsFor: 'private' stamp: 'lr 7/25/2011 19:46'!randomClass	^ Random! !!GRPharoRandomProvider class methodsFor: 'public' stamp: 'lr 7/25/2011 18:28'!randomFrom: aCollection	| random count |	random := self nextInt: aCollection size.	^ aCollection isSequenceable		ifTrue: [ aCollection at: random ]		ifFalse: [			count := 1.			aCollection do: [ :ea |				count = random ifTrue: [ ^ ea ].				count := count + 1 ] ]! !!GRPharoRandomProvider class methodsFor: 'class initialization' stamp: 'pmm 1/10/2009 16:01'!startUp	generator := self randomClass new.	mutex := Semaphore forMutualExclusion! !!GRPharoRandomProvider class methodsFor: 'private' stamp: 'jf 9/30/2009 00:19'!unload	GRPlatform current removeFromStartUpList: self! !!GRPharoLatin1Codec class methodsFor: 'private' stamp: 'pmm 8/16/2010 00:36'!basicForEncoding: aString	(self supportsEncoding: aString)		ifFalse: [ self unsupportedEncoding: aString ].	^ self basicNew initializeWithName: aString! !!GRPharoLatin1Codec class methodsFor: 'accessing' stamp: 'lr 7/25/2011 19:46'!codecs	^ Array with: (self basicForEncoding: 'iso-8859-1')! !!GRPharoLatin1Codec class methodsFor: 'private' stamp: 'lr 7/25/2011 19:46'!supportedEncodingNames	^ #('iso-8859-1' 'ISO-8859-1' 'latin-1' 'latin1')! !!GRPharoLatin1Codec class methodsFor: 'private' stamp: 'pmm 8/16/2010 00:36'!supportsEncoding: aString	"Answer whether the the given encoding name is supported."	^ self supportedEncodingNames includes: aString! !!GRPharoLatin1Codec methodsFor: 'conversion' stamp: 'pmm 8/16/2010 09:20'!decode: aStringOrByteArray	"Overridden for efficencey."	^ aStringOrByteArray asString! !!GRPharoLatin1Codec methodsFor: 'conversion' stamp: 'pmm 8/16/2010 00:32'!decoderFor: aReadStream 	"wrap to avoid String vs ByteArray issues"	^ GRPharoLatin1CodecStream on: aReadStream! !!GRPharoLatin1Codec methodsFor: 'conversion' stamp: 'pmm 8/16/2010 00:32'!encoderFor: aWriteStream 	"wrap to avoid String vs ByteArray issues"	^ GRPharoLatin1CodecStream on: aWriteStream! !!GRPharoLatin1Codec methodsFor: 'initialization' stamp: 'pmm 8/16/2010 00:35'!initializeWithName: aString 	self initialize.	name := aString.! !!GRPharoLatin1Codec methodsFor: 'accessing' stamp: 'pmm 8/16/2010 00:32'!name	^ name! !!Interval methodsFor: '*Grease-Pharo30-Core' stamp: 'jf 2/6/2010 03:25'!any	"#first (used by SequenceableCollection>>anyOne) is an accessor of	Interval and does not error on an empty Interval."		^ self at: 1! !!Point methodsFor: '*Grease-Pharo30-Core' stamp: 'pmm 3/4/2012 20:24'!greaseString	"Reimplemented because in Pharo 1.4	(4 @ 2) greaseString	ansers  '(4@2)'"	^ String streamContents: [ :stream |		x printOn: stream.		stream nextPut: $@.		(y notNil and: [y negative])			ifTrue: [				"Avoid ambiguous @- construct"				stream space].		y printOn: stream ]! !!ByteArray methodsFor: '*Grease-Pharo30-Core' stamp: 'jf 9/30/2009 01:10'!greaseString	"ByteArrays should not automatically be converted to Strings. You should use a GRCodec for this."	^ self printString! !!GRSmallDictionary methodsFor: '*Grease-Pharo30-Core' stamp: 'lr 7/25/2011 19:51'!customizeExplorerContents	^ true! !!GRSmallDictionary methodsFor: '*Grease-Pharo30-Core' stamp: 'lr 7/25/2011 19:51'!explorerContents	| contents |		contents := OrderedCollection new.	self keysAndValuesDo: [ :key :value |		contents add: (ObjectExplorerWrapper			with: value			name: (key printString contractTo: 32)			model: self) ].	^ contents! !!GRSmallDictionary methodsFor: '*Grease-Pharo30-Core' stamp: 'lr 7/25/2011 19:51'!hasContentsInExplorer	^ true! !!ScaledDecimal methodsFor: '*Grease-Pharo30-Core' stamp: 'JohanBrichau 5/25/2015 08:55'!greaseString	| converter |	converter := GRSignPrinter new, (GRNumberPrinter new precision: self scale).	^ converter print: self! !!GRWorkingWriteStream methodsFor: 'positioning' stamp: 'pmm 8/26/2011 09:39'!reset	self resetToStart! !!WriteStream methodsFor: '*Grease-Pharo30-Core' stamp: 'jf 5/22/2010 20:26'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	"Store the next anInteger elements from the given collection."	^ self next: anInteger putAll: aCollection startingAt: startIndex! !!GRPharoPlatform class methodsFor: 'class initialization' stamp: 'pmm 5/20/2010 11:49'!initialize	self initializeXmlTable.	self initializeUrlTable.	self select! !!GRPharoPlatform class methodsFor: 'class initialization' stamp: 'pmm 5/20/2010 20:56'!initializeUrlTable	UrlTable := ByteArray new: 256.	1 to: 256 do: [ :index |		('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.~' includes: (Character codePoint: index - 1))			ifTrue: [ UrlTable at: index put: 0 ]			ifFalse: [ UrlTable at: index put: 1 ] ]! !!GRPharoPlatform class methodsFor: 'class initialization' stamp: 'pmm 5/20/2010 20:56'!initializeXmlTable	XmlTable := ByteArray new: 256.	1 to: 256 do: [ :index |		('"<&>' includes: (Character codePoint: index - 1))			ifTrue: [ XmlTable at: index put: 1 ]			ifFalse: [ XmlTable at: index put: 0 ] ]! !!GRPharoPlatform class methodsFor: 'class initialization' stamp: 'jf 1/22/2009 02:45'!unload	self unselect! !!GRPharoPlatform methodsFor: 'startup' stamp: 'jf 1/21/2009 17:31'!addToShutDownList: anObject	"Add anObject to the shutdown-list of the system. On shutdown the message #shutDown will be sent to anObject."	Smalltalk addToShutDownList: anObject! !!GRPharoPlatform methodsFor: 'startup' stamp: 'jf 1/21/2009 17:31'!addToStartUpList: anObject	"Add anObject to the startup-list of the system. On startup the message #startUp will be sent to anObject."	Smalltalk addToStartUpList: anObject! !!GRPharoPlatform methodsFor: 'file library' stamp: 'lr 7/25/2011 19:51'!asMethodReturningByteArray: aByteArrayOrString named: aSymbol	"Generates the source of a method named aSymbol that returns aByteArrayOrString as a ByteArray"	^ self useByteArrayLiterals		ifTrue: [ self asMethodReturningByteArrayLiteral: aByteArrayOrString named: aSymbol ]		ifFalse: [ self asMethodReturningByteArrayWithCache: aByteArrayOrString named: aSymbol ]! !!GRPharoPlatform methodsFor: 'private-file library' stamp: 'lr 7/25/2011 19:51'!asMethodReturningByteArrayLiteral: aByteArrayOrString named: aSymbol	"Generates the source of a method named aSymbol that returns aByteArrayOrString as a byte array using VW/NewCompiler byte array literal syntax."	^ String streamContents: [ :stream |		stream nextPutAll: aSymbol; nextPut: Character cr.		stream tab; nextPutAll: '^ #['.		aByteArrayOrString asByteArray			do: [ :each | each printOn: stream ]			separatedBy: [ stream space ].		stream nextPutAll: ']' ]! !!GRPharoPlatform methodsFor: 'private-file library' stamp: 'pmm 2/20/2009 17:44'!asMethodReturningByteArrayWithCache: aByteArrayOrString named: aSymbol	"Generates the source of a method named aSymbol that returns aByteArrayOrString as a byte array and caching this array in a literal array of size 1."	^ String streamContents: [ :stream |		stream nextPutAll: aSymbol; nextPut: Character cr.		stream tab; nextPutAll: '^ #('.		aByteArrayOrString asByteArray			do: [ :each | each printOn: stream ]			separatedBy: [ stream space ].		stream nextPutAll: ') asByteArray' ]! !!GRPharoPlatform methodsFor: 'encoding' stamp: 'jf 1/21/2009 17:31'!base64Decode: aString	^ (Base64MimeConverter mimeDecodeToChars: aString readStream) contents! !!GRPharoPlatform methodsFor: 'bindings' stamp: 'JohanBrichau 7/12/2015 14:45'!bindingOf: aClass		^ Smalltalk globals associationAt: aClass name! !!GRPharoPlatform methodsFor: 'file library' stamp: 'pmm 9/12/2013 11:24'!compile: aString into: aClass classified: aSymbol 	aClass compile: aString classified: aSymbol! !!GRPharoPlatform methodsFor: 'file library' stamp: 'JohanBrichau 10/3/2014 19:59'!contentsOfFile: aString binary: aBoolean	^ self fileStreamOn: aString do: [ :stream | stream contents ] binary: aBoolean! !!GRPharoPlatform methodsFor: 'file library' stamp: 'pmm 8/19/2012 10:19'!directoriesIn: aPathString	"Answer a collection of absolute paths for all the directories (no files) in the directory given by aPathString	must not include directory names that start with ."	^ Array streamContents: [ :stream | 		FileSystem disk directoriesAt: aPathString do: [ :each |			each basename first = $. ifFalse: [				stream nextPut: each asFileReference fullName  ] ] ]! !!GRPharoPlatform methodsFor: 'private' stamp: 'pmm 9/12/2013 17:55'!doSilently: aBlock	^ SystemAnnouncer uniqueInstance suspendAllWhile:  aBlock! !!GRPharoPlatform methodsFor: 'file library' stamp: 'pmm 9/12/2013 12:05'!ensureExistenceOfFolder: aString	"creates a folder named aString in the image directory"	FileSystem disk ensureCreateDirectory: aString! !!GRPharoPlatform methodsFor: 'file library' stamp: 'JohanBrichau 10/3/2014 20:02'!fileExists: aString	^ aString asFileReference exists ! !!GRPharoPlatform methodsFor: 'file library' stamp: 'JohanBrichau 10/3/2014 19:59'!fileStreamOn: aString do: aBlock binary: aBoolean	^ aBoolean		ifTrue: [			FileStream fileNamed: aString do: [ :stream |				stream binary.				aBlock value: stream ] ]		ifFalse: [			MultiByteFileStream fileNamed: aString do: [ :stream |				stream					ascii;					wantsLineEndConversion: true.					aBlock value: stream ] ]! !!GRPharoPlatform methodsFor: 'file library' stamp: 'pmm 8/19/2012 10:18'!filesIn: aPathString	"Return a collection of absolute paths for all the files (no directories) in the directory given by aPathString	must not include file names that start with ."	^ Array streamContents: [ :stream | 		FileSystem disk filesAt: aPathString do: [ :each |			each basename first = $. ifFalse: [				stream nextPut: each asFileReference fullName  ] ] ]! !!GRPharoPlatform methodsFor: 'processes' stamp: 'jf 2/6/2009 15:58'!isProcessTerminated: aProcess	"Return a boolean indicating whether aProcess has been terminated."	^ aProcess isTerminated! !!GRPharoPlatform methodsFor: 'version info' stamp: 'jf 2/9/2010 00:56'!label	^ 'Pharo'! !!GRPharoPlatform methodsFor: 'file library' stamp: 'pmm 8/19/2012 10:19'!localNameOf: aFilename	^ (FileSystem disk resolveString: aFilename) basename! !!GRPharoPlatform methodsFor: 'factory' stamp: 'pmm 10/7/2010 13:10'!newRandom	"Answers the random number generator to be used to create session and continuation keys. Make sure it is seeded. They only methods that will be sent to it are:	  #nextInt: - should answer a random integer in the interval [1, anInteger]	  #randomFrom: - should answer a random element from the given collection		Make sure that both methods are safe under heavy concurrent load.		Used by Gemstone/S traditional Randoms which cannot be persisted.."	^ GRPharoRandomProvider! !!GRPharoPlatform methodsFor: 'file library' stamp: 'lr 4/15/2010 19:14'!newline	^ String cr! !!GRPharoPlatform methodsFor: 'exceptions' stamp: 'pmm 1/22/2012 16:31'!openDebuggerOn: anError	| process |	process := Processor activeProcess.	"If we are running in the UI process, we don't want to suspend the active process. The	error was presumably triggered while stepping in the Debugger. If we simply immediately	signal an UnhandledError, the debugger will catch this and display the signaling context.	It isn't perfect or pretty but it works."	(ProcessBrowser isUIProcess: process)		ifTrue: [			UnhandledError signalForException: anError ]		ifFalse: [			WorldState addDeferredUIMessage: [				process					debug: anError signalerContext					title: anError description					full: true ].			process suspend ]! !!GRPharoPlatform methodsFor: 'file library' stamp: 'pmm 8/4/2012 12:38'!pathSeparator	^ String with: FileSystem disk delimiter! !!GRPharoPlatform methodsFor: 'factory' stamp: 'JohanBrichau 1/18/2014 07:05'!readWriteByteStream	"ByteArray based read write stream"		^ RWBinaryOrTextStream on: (ByteArray new: 4096)! !!GRPharoPlatform methodsFor: 'factory' stamp: 'dkh 9/4/2009 09:14'!readWriteCharacterStream	"String based read write stream"	^ ReadWriteStream on: (String new: 4096)! !!GRPharoPlatform methodsFor: 'startup' stamp: 'jf 1/21/2009 17:31'!removeFromShutDownList: anObject	"Remove anObject from the shutdown list in the system."	Smalltalk removeFromShutDownList: anObject! !!GRPharoPlatform methodsFor: 'startup' stamp: 'jf 1/21/2009 17:31'!removeFromStartUpList: anObject	"Remove anObject from the startup list in the system."	Smalltalk removeFromStartUpList: anObject! !!GRPharoPlatform methodsFor: 'file library' stamp: 'JohanBrichau 4/19/2014 13:44'!removeSelector: aSymbol from: aClass	aClass removeSelector: aSymbol! !!GRPharoPlatform methodsFor: 'cryptography' stamp: 'DamienCassou 8/27/2013 18:30'!secureHashFor: aString	^ SHA1 new hashMessage: aString! !!GRPharoPlatform methodsFor: 'factory' stamp: 'lr 7/25/2011 19:51'!semaphoreClass	"used by Gemstone/S traditional Semaphores which cannot be persisted"	^ Semaphore! !!GRPharoPlatform methodsFor: 'exceptions' stamp: 'jf 1/21/2009 17:31'!stackDepth	| depth current |	depth := 0.	current := thisContext.	[ current isNil ] whileFalse: [		current := current sender.		depth := depth + 1 ].	^ depth - 1! !!GRPharoPlatform methodsFor: 'processes' stamp: 'jf 2/6/2009 15:59'!terminateProcess: aProcess	"Permanently terminate the process, unwinding first to execute #ensure: and #ifCurtailed: blocks."	aProcess terminate! !!GRPharoPlatform methodsFor: 'private-file library' stamp: 'pmm 8/4/2012 12:39'!useByteArrayLiterals	"whether ByteArray literals can/should be used"	^ true! !!GRPharoPlatform methodsFor: 'factory' stamp: 'lr 7/25/2011 19:51'!weakDictionaryOfSize: aNumber	^ IdentityDictionary new: aNumber! !!GRPharoPlatform methodsFor: 'file library' stamp: 'pmm 8/4/2012 13:02'!write: aStringOrByteArray toFile: aFileNameString inFolder: aFolderString	"writes aStringOrByteArray to a file named aFilenameString in the folder aFolderString"	| folder stream fullFilePath |	folder := FileSystem disk resolveString: aFolderString.	fullFilePath := (folder / aFileNameString) asFileReference.	stream := aStringOrByteArray isString		ifTrue: [			(MultiByteFileStream forceNewFileNamed: fullFilePath fullName)				ascii;				wantsLineEndConversion: true;				yourself ]		ifFalse: [ (FileStream forceNewFileNamed: fullFilePath fullName) binary ].	[ stream nextPutAll: aStringOrByteArray ]		ensure: [ stream close ]! !!GRPharoPlatform methodsFor: 'factory' stamp: 'pmm 8/26/2011 09:45'!writeCharacterStreamOn: aString	^ GRWorkingWriteStream on: aString! !!Duration class methodsFor: '*Grease-Pharo30-Core' stamp: 'jf 2/6/2010 00:12'!milliseconds: anInteger	^ self milliSeconds: anInteger! !!Duration methodsFor: '*Grease-Pharo30-Core' stamp: 'jf 2/5/2010 23:58'!asMilliseconds	^ self asMilliSeconds! !!Duration methodsFor: '*Grease-Pharo30-Core' stamp: 'jf 2/6/2010 00:02'!milliseconds	^ nanos quo: NanosInMillisecond! !!Behavior methodsFor: '*Grease-Pharo30-Core' stamp: 'lr 7/25/2011 19:45'!fullName	"In VW, will include the namespace"	^ self name! !!GRPharoConverterCodecStream class methodsFor: 'instance creation' stamp: 'pmm 10/30/2010 18:58'!on: aStream converter: aConverter	^ self basicNew initializeOn: aStream converter: aConverter! !!GRPharoConverterCodecStream methodsFor: 'streaming' stamp: 'pmm 12/28/2010 22:12'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	self nextPutAll: (aCollection copyFrom: startIndex to: startIndex + anInteger - 1)! !!GRPharoConverterCodecStream methodsFor: 'initialization' stamp: 'pmm 10/30/2010 18:58'!initializeOn: aStream converter: aConverter	self initializeOn: aStream.	converter := aConverter! !!GRPharoConverterCodecStream methodsFor: 'streaming' stamp: 'pmm 4/10/2010 13:32'!next	| character |	character := converter nextFromStream: stream.	^ character isNil		ifFalse: [ character asCharacter ]! !!GRPharoConverterCodecStream methodsFor: 'streaming' stamp: 'lr 2/7/2009 12:57'!next: anInteger	| writeStream |	writeStream := WriteStream on: (String new: anInteger).	anInteger timesRepeat: [		writeStream nextPut: (self next			ifNil: [ ^ writeStream contents ]) ].	^ writeStream contents! !!GRPharoConverterCodecStream methodsFor: 'streaming' stamp: 'pmm 4/10/2010 13:30'!nextPut: aCharacter	converter nextPut: aCharacter asCharacter toStream: stream! !!GRPharoConverterCodecStream methodsFor: 'streaming' stamp: 'lr 2/7/2009 12:54'!nextPutAll: aString	aString asString do: [ :each | self nextPut: each ]! !!GRPharoUtf8CodecStream class methodsFor: 'class initialization' stamp: 'lr 7/25/2011 19:46'!initialize	(Smalltalk hasClassNamed: #UTF8TextConverter) "guard for Squeak 37"		ifFalse: [ ^ self ].	Latin1ToUtf8Map := ByteArray new: 256.	Latin1ToUtf8Encodings := Array new: 256.	0 to: 255 do:[ :index |		| latin1 utf8 |		latin1 := String with: (Character codePoint: index).		utf8 := latin1 convertToWithConverter: UTF8TextConverter new.		latin1 = utf8			ifTrue:[				Latin1ToUtf8Map at: index + 1 put: 0 ] "no translation needed"			ifFalse:[				Latin1ToUtf8Map at: index + 1 put: 1. "no translation needed"				Latin1ToUtf8Encodings at: index + 1 put: utf8 ] ]! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'pmm 4/10/2010 13:28'!crlf	stream nextPut: Character cr.	stream nextPut: Character lf! !!GRPharoUtf8CodecStream methodsFor: 'private' stamp: 'lr 7/25/2011 18:36'!encodeDefault: aString	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	1 to: aString size by: 1 do: [ :index |		converter nextPut: (aString at: index) toStream: stream ]! !!GRPharoUtf8CodecStream methodsFor: 'private' stamp: 'lr 7/25/2011 19:51'!encodeFast: aByteString	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| lastIndex nextIndex |	lastIndex := 1.	nextIndex := ByteString findFirstInString: aByteString inSet: Latin1ToUtf8Map startingAt: lastIndex.	nextIndex = 0 ifTrue: [ ^ stream nextPutAll: aByteString ].	[	nextIndex > lastIndex ifTrue: [			stream greaseNext: nextIndex - lastIndex putAll: aByteString startingAt: lastIndex ].		stream nextPutAll: (Latin1ToUtf8Encodings at: (aByteString byteAt: nextIndex) + 1).		lastIndex := nextIndex + 1.		nextIndex := ByteString findFirstInString: aByteString inSet: Latin1ToUtf8Map startingAt: lastIndex.		nextIndex = 0 ] whileFalse.	stream greaseNext: aByteString size - lastIndex + 1 putAll: aByteString startingAt: lastIndex.! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'pmm 8/15/2011 21:32'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	aCollection isByteString		ifTrue: [ self greaseNext: anInteger putAllFast: aCollection startingAt: startIndex ]		ifFalse: [ super greaseNext: anInteger putAll: aCollection startingAt: startIndex ]! !!GRPharoUtf8CodecStream methodsFor: 'private' stamp: 'pmm 5/21/2014 21:28'!greaseNext: anInteger putAllFast: aByteString startingAt: startIndex	| lastIndex nextIndex |	lastIndex := startIndex.	nextIndex := ByteString findFirstInString: aByteString inSet: Latin1ToUtf8Map startingAt: lastIndex.	nextIndex = 0 ifTrue: [ ^ stream greaseNext: anInteger putAll: aByteString startingAt: startIndex ].	[			nextIndex >= (startIndex + anInteger) ifTrue: [			^ stream greaseNext: startIndex + anInteger - lastIndex  putAll: aByteString startingAt: lastIndex ].		nextIndex > lastIndex ifTrue: [			stream greaseNext: nextIndex - lastIndex putAll: aByteString startingAt: lastIndex ].		stream nextPutAll: (Latin1ToUtf8Encodings at: (aByteString byteAt: nextIndex) + 1).		lastIndex := nextIndex + 1.		nextIndex := ByteString findFirstInString: aByteString inSet: Latin1ToUtf8Map startingAt: lastIndex.		(nextIndex = 0 or: [ nextIndex >= (startIndex + anInteger) ]) ] whileFalse.	lastIndex >= (startIndex + anInteger) ifFalse: [		stream greaseNext: startIndex + anInteger - lastIndex putAll: aByteString startingAt: lastIndex ]! !!GRPharoUtf8CodecStream methodsFor: 'private' stamp: 'jf 9/30/2009 00:39'!invalidUtf8	^ GRInvalidUtf8Error signal: 'Invalid UTF-8 input'! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'pmm 2/17/2010 20:09'!next	^ (self next: 1) first! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'pmm 2/17/2012 08:00'!next: anInteger	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| output byte1 byte2 byte3 byte4 unicode count alreadyWide |	output := ByteString new: anInteger.	count := 0.	alreadyWide := false.	[ count < anInteger and: [ stream atEnd not ] ] whileTrue: [		byte1 := stream next.		unicode := byte1.		(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"			byte2 := stream next.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63) ].		(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"			byte2 := stream next.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte3 := stream next.			(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6)				+ (byte3 bitAnd: 63).			alreadyWide ifFalse: [				output := WideString withAll: output.				alreadyWide := true ] ].		(byte1 bitAnd: 16rF8) = 240 ifTrue: [ "four bytes"			byte2 := stream next.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte3 := stream next.			(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte4 := stream next.			(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 16r7) bitShift: 18) +							((byte2 bitAnd: 63) bitShift: 12) + 							((byte3 bitAnd: 63) bitShift: 6) +							(byte4 bitAnd: 63).			alreadyWide ifFalse: [				output := WideString withAll: output.				alreadyWide := true ] ].		unicode ifNil: [ self invalidUtf8 ].		unicode = 16rFEFF "ignore BOM" ifFalse: [			count := count + 1.			output at: count put: (Character codePoint: unicode). ].		unicode := nil ].	^ count < anInteger		ifTrue: [ output first: count ]		ifFalse: [ output ]! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'lr 7/25/2011 19:51'!nextPut: aCharacter	| codePoint shouldEncode |	codePoint := aCharacter codePoint.	codePoint > 255		ifTrue: [ ^ self nextPutAll: (String with: aCharacter) ].	shouldEncode := Latin1ToUtf8Map at: codePoint + 1.	shouldEncode = 1		ifTrue: [ stream nextPutAll: (Latin1ToUtf8Encodings at: codePoint + 1) ]		ifFalse: [ stream nextPut: aCharacter ]	! !!GRPharoUtf8CodecStream methodsFor: 'streaming' stamp: 'pmm 4/10/2010 13:28'!nextPutAll: aString	aString isByteString		ifTrue: [ self encodeFast: aString ]		ifFalse: [ self encodeDefault: aString ]! !!SequenceableCollection methodsFor: '*Grease-Pharo30-Core' stamp: 'jok 3/22/2010 11:48'!beginsWithSubCollection: aSequenceableCollection	"Some platforms implement #beginsWith: to answer true for an empty argument."	^ self beginsWith: aSequenceableCollection! !!SequenceableCollection methodsFor: '*Grease-Pharo30-Core' stamp: 'jok 3/22/2010 11:47'!endsWithSubCollection: aSequenceableCollection	"Some platforms implement #endsWith: to answer true for an empty argument."	^ self endsWith: aSequenceableCollection! !!SequenceableCollection methodsFor: '*Grease-Pharo30-Core' stamp: 'jf 2/6/2010 02:01' prior: 57561984!sorted	^ self sorted: [ :a :b | a <= b ]! !!GRDelegatingStream methodsFor: '*Grease-Pharo30-Core' stamp: 'pmm 12/28/2010 22:13'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	stream greaseNext: anInteger putAll: aCollection startingAt: startIndex! !!PositionableStream methodsFor: '*Grease-Pharo30-Core' stamp: 'jf 9/30/2009 01:06'!greaseUpToAll: aCollection 	"Needed for Seaside ports to other dialects where #upToAll: may have	different semantics"	^ self upToAll: aCollection! !!GRPackage class methodsFor: '*Grease-Pharo30-Core' stamp: 'pmm 9/12/2013 16:00'!greasePharo30Core	^ self new		name: 'Grease-Pharo30-Core';		addDependency: 'Grease-Core';		url: #greaseUrl;		yourself! !!MessageSend methodsFor: '*Grease-Pharo30-Core' stamp: 'pmm 1/10/2009 19:22'!argumentCount	^ selector numArgs - self arguments size! !!MessageSend methodsFor: '*Grease-Pharo30-Core' stamp: 'pmm 4/23/2007 20:02'!fixCallbackTemps	"for polymorphism with BlockContext >> #fixCallbackTemps"! !!MessageSend methodsFor: '*Grease-Pharo30-Core' stamp: 'lr 7/25/2011 19:52'!valueWithPossibleArguments: anArray	"Evaluate the block represented by the receiver.     If the block requires one argument, use anArg, if it requires more than one,     fill up the rest with nils."	^ self valueWithEnoughArguments: anArray! !!Collection methodsFor: '*Grease-Pharo30-Core' stamp: 'jf 2/6/2010 00:41'!any	^ self anyOne! !!GRPharoLatin1CodecStream methodsFor: 'streaming' stamp: 'pmm 8/16/2010 09:16'!next	^ Character value: stream next! !!GRPharoLatin1CodecStream methodsFor: 'streaming' stamp: 'lr 7/25/2011 19:50'!next: anInteger	^ (stream next: anInteger) asString! !!SocketStream methodsFor: '*Grease-Pharo30-Core' stamp: 'pmm 5/23/2010 08:17'!greaseNext: anInteger putAll: aCollection startingAt: startIndex	"Put a String or a ByteArray onto the stream starting at the given position.	Currently a large collection will allocate a large buffer."	| toPut |	anInteger = 0 ifTrue: [		^ aCollection ].	toPut := binary ifTrue: [ aCollection asByteArray ] ifFalse: [ aCollection asString ].	self adjustOutBuffer: anInteger.	outBuffer replaceFrom: outNextToWrite to: outNextToWrite + anInteger - 1 with: toPut startingAt: startIndex.	outNextToWrite := outNextToWrite + anInteger.	self checkFlush! !!Character methodsFor: '*Grease-Pharo30-Core' stamp: 'jf 9/30/2009 01:04'!greaseInteger	"Answer an unicode code point of the receiver."	^ self charCode! !!Object methodsFor: '*Grease-Pharo30-Core' stamp: 'jf 9/30/2009 01:10'!greaseString	^ self asString! !!BlockClosure methodsFor: '*Grease-Pharo30-Core' stamp: 'lr 4/8/2009 13:33'!fixCallbackTemps! !!BlockClosure methodsFor: '*Grease-Pharo30-Core' stamp: 'lr 4/8/2009 13:36'!valueWithPossibleArguments: anArray	| args |	(anArray size == self numArgs)		ifTrue: [ ^ self valueWithArguments: anArray ].	args := Array new: self numArgs.	args replaceFrom: 1		to: (anArray size min: args size)		with: anArray		startingAt: 1.	^ self valueWithArguments: args! !!GRPharoGenericCodec class methodsFor: 'private' stamp: 'pmm 6/28/2009 15:43'!basicForEncoding: aString	(self supportsEncoding: aString)		ifFalse: [ self unsupportedEncoding: aString ].	^ self basicNew initializeWithName: aString! !!GRPharoGenericCodec class methodsFor: 'accessing' stamp: 'pmm 8/16/2010 00:19'!codecs	^ (TextConverter allEncodingNames		select:  [ :each | 			"exclude UFT-8 which is handeled by WAUtf8Codec"			self supportsEncoding: each ])		collect: [ :each |			self basicForEncoding: each greaseString ]! !!GRPharoGenericCodec class methodsFor: 'private' stamp: 'lr 7/25/2011 19:46'!supportedEncodingNames	"answers the names of the encodings supported by this class"	^ TextConverter allEncodingNames		removeAllFoundIn: GRPharoLatin1Codec supportedEncodingNames;		removeAllFoundIn: UTF8TextConverter encodingNames;		yourself! !!GRPharoGenericCodec class methodsFor: 'testing' stamp: 'pmm 6/28/2009 16:43'!supportsEncoding: aString	"Answer whether the the given encoding name is supported."	^ self supportedEncodingNames includes: aString! !!GRPharoGenericCodec methodsFor: 'private' stamp: 'lr 7/25/2011 19:51'!converter	^ TextConverter newForEncoding: self name! !!GRPharoGenericCodec methodsFor: 'conversion' stamp: 'lr 2/7/2009 12:52'!decoderFor: aStream	^ self encoderFor: aStream! !!GRPharoGenericCodec methodsFor: 'conversion' stamp: 'jf 9/30/2009 00:46'!encoderFor: aStream 	^ GRPharoConverterCodecStream 		on: aStream		converter: self converter! !!GRPharoGenericCodec methodsFor: 'initialization' stamp: 'pmm 8/16/2010 11:52'!initializeWithName: aString 	self initialize.	name := aString.	urlCodec := (#('iso-8859-15' 'cp-1252') includes: aString) 		ifFalse: [ GRCodec forEncoding: 'utf-8' ]		ifTrue: [ self ]! !!GRPharoGenericCodec methodsFor: 'accessing' stamp: 'lr 2/7/2009 10:16'!name	^ name! !!GRPharoGenericCodec methodsFor: 'accessing' stamp: 'lr 2/7/2009 12:36'!url	"RFC 3986: When a new URI scheme defines a component that represents textual data consisting of characters from the Universal Character Set [UCS], the data should first be encoded as octets according to the UTF-8 character encoding."	^ urlCodec! !!GRPharoUtf8Codec class methodsFor: 'private' stamp: 'lr 7/25/2011 19:46'!basicForEncoding: aString	^ self new! !!GRPharoUtf8Codec class methodsFor: 'accessing' stamp: 'lr 7/25/2011 19:46'!codecs	^ Array with: self new! !!GRPharoUtf8Codec class methodsFor: 'testing' stamp: 'lr 7/25/2011 19:46'!supportsEncoding: aString	^ (#('utf-8' 'UTF-8') includes: aString) or: [ UTF8TextConverter encodingNames includes: aString ]! !!GRPharoUtf8Codec methodsFor: 'decoding' stamp: 'pmm 2/17/2012 19:45'!decode: aString	"Convert the given string from UTF-8 using the fast path if converting to Latin-1"	| outStream byte1 byte2 byte3 byte4 unicode stream |	stream := aString readStream.	outStream := WriteStream on: (String new: aString size).	[ stream atEnd not ] whileTrue: [		byte1 := stream next asInteger.		unicode := byte1.		(byte1 bitAnd: 16rE0) = 192 ifTrue: [ "two bytes"			byte2 := stream next asInteger.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 31) bitShift: 6) + (byte2 bitAnd: 63) ].		(byte1 bitAnd: 16rF0) = 224 ifTrue: [ "three bytes"			byte2 := stream next asInteger.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte3 := stream next asInteger.			(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 15) bitShift: 12) + ((byte2 bitAnd: 63) bitShift: 6)				+ (byte3 bitAnd: 63) ].		(byte1 bitAnd: 16rF8) = 240 ifTrue: [ "four bytes"			byte2 := stream next asInteger.			(byte2 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte3 := stream next asInteger.			(byte3 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			byte4 := stream next asInteger.			(byte4 bitAnd: 16rC0) = 16r80 ifFalse: [ self invalidUtf8 ].			unicode := ((byte1 bitAnd: 16r7) bitShift: 18) +							((byte2 bitAnd: 63) bitShift: 12) + 							((byte3 bitAnd: 63) bitShift: 6) +							(byte4 bitAnd: 63) ].		unicode ifNil: [ self invalidUtf8 ].		unicode = 16rFEFF "ignore BOM" ifFalse: [			outStream nextPut: (Character codePoint: unicode) ].		unicode := nil ].	^ outStream contents! !!GRPharoUtf8Codec methodsFor: 'conversion' stamp: 'jf 9/30/2009 00:46'!decoderFor: aStream 	^ GRPharoUtf8CodecStream 		on: aStream		converter: UTF8TextConverter new! !!GRPharoUtf8Codec methodsFor: 'conversion' stamp: 'jf 9/30/2009 00:46'!encoderFor: aStream 	^ GRPharoUtf8CodecStream 		on: aStream		converter: UTF8TextConverter new! !!GRPharoUtf8Codec methodsFor: 'private' stamp: 'JohanBrichau 1/18/2016 08:13'!invalidUtf8	^ GRInvalidUtf8Error signal: 'Invalid UTF-8 input'! !!GRPharoUtf8Codec methodsFor: 'accessing' stamp: 'pmm 2/20/2009 13:25'!name	^ 'utf-8'! !!GRPharoUtf8Codec methodsFor: 'accessing' stamp: 'pmm 2/20/2009 12:50'!url	^ self! !"Grease-Pharo30-Core"!!MAAdaptiveModel commentStamp: 'lr 6/2/2006 00:30' prior: 0!I am an adaptive model referencing a dynamic description of myself and a dictionary mapping those descriptions to actual values.!!MAFileModel commentStamp: 'lr 9/28/2007 08:04' prior: 0!I represent a file with filename, mimetype and contents within the Magritte framework.There are different file-models that you can use with Magritte. The idea is that you set the ==#kind:== of an MAFileDescription to one of the subclasses of ==*MAFileModel*==.!!MAMemoryFileModel commentStamp: 'lr 9/28/2007 08:06' prior: 0!I represent a file using a ByteArray in the object memory. I am not practicable for big files: use me for development and testing only.!!MAObject commentStamp: 'lr 5/17/2006 14:07' prior: 0!I provide functionality available to all Magritte objects. I implement a dictionary of properties, so that extensions can easily store additional data.!!MAAccessor commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am the abstract superclass to all accessor strategies. Accessors are used to implement different ways of accessing (reading and writing) data from instances using a common protocol: data can be uniformly read and written using ==#readFrom:== respectively ==#write:to:==.!!MADelegatorAccessor commentStamp: 'lr 2/14/2008 09:56' prior: 0!My access strategy is to delegate to the next accessor. I am not that useful all by myself, but subclasses might override certain methods to intercept access.!!MAChainAccessor commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am an access strategy used to chain two access strategies. To read and write a value the ==accessor== is performed on the given model and the result is passed into the ==next== accessor.!!MADictionaryAccessor commentStamp: '<historical>' prior: 0!I am an access strategy to be used on dictionaries. I use my ==key== to read from and write to indexed collections. I am mainly used for prototyping as it allows one to treat dictionaries like objects with object-based instance variables.!!MAIdentityAccessor commentStamp: 'lr 2/12/2006 20:09' prior: 0!I am a read-only access strategy and I answer the model itself when being read.!!MANullAccessor commentStamp: 'lr 5/29/2006 09:21' prior: 0!I am a null access strategy and I should be neither read nor written. I am still comparable to other strategies by holding onto a unique-identifier.!!MAPluggableAccessor commentStamp: 'lr 2/12/2006 20:04' prior: 0!I am an access strategy defined by two block-closures. The read-block expects the model as its first argument and is used to retrieve a value. The write-block expects the model as its first and the value as its second argument and is used to write a value to the model.!!MASelectorAccessor commentStamp: 'lr 6/2/2006 10:03' prior: 0!I am the most common access strategy defined by a read- and a write-selector. I am mostly used together with standard getters and setters as usually defined by the accessing protocol. If there is only a read-selector specified, the write selector will be deduced automatically by adding a colon to the read-selector.!!MAVariableAccessor commentStamp: 'lr 5/27/2006 17:20' prior: 0!I am an access strategy that directly reads from and writes to instance variables. I strongly violate encapsulation and most of the time I should be replaced by an instance of *MASelectorAccessor*.!!MADescription commentStamp: 'lr 2/5/2009 12:42' prior: 0!I am the root of the description hierarchy in Magritte and I provide most of the basic properties available to all descriptions. If you would like to annotate your model with a description have a look at the different subclasses of myself.!!ExampleIf your model has an instance variable called ==title== that should be used to store the title of the object, you could add the following description to your class:=Document class>>descriptionTitle=	^ MAStringDescription new=		autoAccessor: #title;=		label: 'Title';=		priority: 20;=		beRequired;=		yourself.The selector ==#title== is the name of the accessor method used by Magritte to retrieve the value from the model. In the above case Magritte creates the accessor method and the instance variable automatically, if necessary. The label is used to give the field a name and will be printed next to the input box if a visual GUI is created from this description.The write-accessor is automatically deduced by adding a colon to the read-selector, in this example ==#title:==. You can specify your own accessor strategy using one of the subclasses of ==*MAAccessor*==. If you have multiple description within the same object, the ==#priority:== field is used to order them. Assign a low priority to have descriptions traversed first.!!MAContainer commentStamp: 'lr 4/10/2007 21:06' prior: 0!I am a container holding a collection of descriptions, all instances of subclasses of *MAElementDescription*. I keep my children within an ==OrderedCollection==, but I don't sort them according to their priority.I fully support the collection protocol: descriptions can be added and removed. Moreover I implement most enumeration methods, so that users are able to iterate (==do:==), filter (==select:==, ==reject:==), transform (==collect:==), extract (==detect:==, ==detect:ifNone:==), and test (==allSatisfy:==, ==anySatisfy:==, ==noneSatisfy:==) my elements.!!MAPriorityContainer commentStamp: 'lr 2/12/2006 19:34' prior: 0!I am a container holding a collection of descriptions and I keep them sorted according to their priority.!!MAElementDescription commentStamp: '<historical>' prior: 0!I am an abstract description for all basic description types.!!MABooleanDescription commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am a description of the Boolean values ==true== and ==false==. My visual representation could be a check-box.!!MAClassDescription commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am a description of Smalltalk classes, possible values can be any of ==Smalltalk allClasses==.!!MAColorDescription commentStamp: 'lr 4/10/2007 21:03' prior: 0!I am a description of colors, possible values are instances of ==Color==. My visual representation could be a color-chooser.!!MAFileDescription commentStamp: 'lr 5/17/2006 14:44' prior: 0!I am a description of files, their contents, filename and mime-type. Possible values include instances of *MAFileModel*. My visual representation could be a file-upload dialog.!!MAMagnitudeDescription commentStamp: 'lr 4/10/2007 21:08' prior: 0!I am an abstract description for subclasses of ==Magnitude==. The range of accepted values can be limited using the accessors ==min:== and ==max:==.!!MADateAndTimeDescription commentStamp: 'pmm 8/31/2009 20:11' prior: 0!I am a description of date and times, possible values are instances of ==DateAndTime==. My visual representation could be a date- and time-picker.!!MADateDescription commentStamp: 'lr 4/10/2007 21:06' prior: 0!I am a description of dates, possible values are instances of ==Date==. My visual representation could be a date-picker.!!MADurationDescription commentStamp: 'lr 4/10/2007 21:07' prior: 0!I am a description of durations, possible values are instances of ==Duration==.!!MANumberDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am a description of numbers, possible values are instances of ==Number== and all its subclasses, including ==Integer== and ==Float==. My visual representation could be a number input-box or even a slider-control.!!MATimeDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a description of times, possible values are instances of ==Time==. My visual representation could be a time-picker.!!MATimeStampDescription commentStamp: 'lr 4/10/2007 21:11' prior: 0!I am a description of timestamps, possible values are instances of ==TimeStamp==. My visual representation could be a date- and time-picker.!!MAReferenceDescription commentStamp: 'lr 2/12/2006 19:38' prior: 0!I am an abstract superclass for descriptions holding onto another description.!!MAOptionDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am an abstract description of different options the user can choose from. My instance variable ==options== references the options I am representing. The options can be sorted or unsorted.!!MAMultipleOptionDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am a description of multiple options, possible options are stored within the ==options== field, possible values are instances of ==Collection==. My visual representation could be a multi-select list or a group of check-boxes.!!MASingleOptionDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a description of a single option, possible values are stored within the ==options== field, but I might also be extensible so that the user can add its own option. My visual representation could be a drop-down list or a group of option-buttons.!!MARelationDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am an abstract description for descriptions representing a relation. My instance variable ==classes== references a collection of possible classes that I can relate to. If required the reference description will be automatically built from this list of classes.!!MAToManyRelationDescription commentStamp: 'lr 4/10/2007 21:11' prior: 0!I am a description of an one-to-many relationship, possible values are instances of ==Collection==.!!MAToManyScalarRelationDescription commentStamp: 'pmm 11/3/2006 17:48' prior: 0!Like MAToManyRelationDescription but for scalar values.!!MAToOneRelationDescription commentStamp: '<historical>' prior: 0!I am a description of an one-to-one relationship.!!MATableDescription commentStamp: 'lr 5/17/2006 14:44' prior: 0!I am a description of tables, their cells and labels. I hold a reference to the description of my cells, that are all described using the same description. Possible values include instances of *MATableModel*.!!MATokenDescription commentStamp: 'lr 4/10/2007 21:11' prior: 0!I am a description of tokens all described by the referenced description, possible values are instances of ==SequenceableCollection==.!!MAStringDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a description of strings, possible values are instances of ==String==. My visual representation could be a single line text-field. Use ==*MAMemoDescription*== for multi-line strings.!!MAMemoDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am a description of multiline strings, possible values are instances of ==String==. My visual representation could be a text-area field.!!MAPasswordDescription commentStamp: 'lr 4/10/2007 21:09' prior: 0!I am a description of a password string, possible values are instances of ==String==. My visual representation could be a password field, where there are stars printed instead of the characters the user enters.!!MASymbolDescription commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a description of symbols, possible values are instances of ==Symbol==.!!MAMemento commentStamp: 'SeanDeNigris 4/10/2015 20:07' prior: 0!I am an abstract memento. I reference the model I am working on and the description currently used to describe this model.!!MACachedMemento commentStamp: 'lr 5/29/2006 09:22' prior: 0!I cache values being read and written without touching the model. When committing changes, the modifications will be propagated to the model all at once.!!MACheckedMemento commentStamp: 'lr 5/17/2006 15:12' prior: 0!I cache values as my superclass and also remember the original values of the model at the time the cache is built. With this information I am able to detect edit conflicts and can prevent accidental loss of data by merging the changes.!!MAStraightMemento commentStamp: 'lr 5/17/2006 15:02' prior: 0!I am a memento that forwards read- and write-access directly to the model. I can mostly be replaced with the model itself.!!MAPragmaBuilder commentStamp: 'NickAger 3/7/2012 09:30' prior: 0!I dynamically build container descriptions from instance-side methods decorated pragmas. The pragmas used are:# ==#magritteContainer== to identify the method generating the container instance.# ==#magritteDescription== for unary methods returning valid Magritte descriptions which are added to the container.# ==#magritteDescription:== for single parameter methods returning Magritte description extensions, where the pragma parameter defines the related Magritte description method. The extension method will be called after the related method to refine the description definition.!!MATableModel commentStamp: 'lr 4/10/2007 21:10' prior: 0!I am a model class representing a table within the Magritte framework. Internally I store my cells within a flat array, however users may access data giving ''row'' and ''column'' coordinates with ==#at:at:== and ==#at:at:put:==. I can support reshaping myself, but of course this might lead to loss of data-cells.!!MAVisitor commentStamp: 'SeanDeNigris 4/10/2015 20:06' prior: 0!I am a visitor responsible for visiting Magritte descriptions. I am an abstract class providing a default implementation for concrete visitors. The protocol I implement reflects the hierarchy of *MADescription* and its subclasses. Visiting a class which my subclasses don't implement specifically automatically defaults to a less-specific implementation. The code was automatically created using code on my class-side.!!MAStringReader commentStamp: 'SeanDeNigris 4/13/2015 07:57' prior: 0!I recreate Magritte-described domain objects from strings. Typically I am used to convert string values entered into a Magritte form back to the objects they represent. For example, a user may have typed '10/01/2020' into a date field.!!MAError commentStamp: 'lr 5/17/2006 15:14' prior: 0!I represent a generic Magritte error.!!MAReadError commentStamp: 'lr 5/17/2006 15:14' prior: 0!I am an error that gets raised when there is problem reading serialized data.!!MAValidationError commentStamp: 'lr 5/17/2006 15:15' prior: 0!I am a generic validation error. I reference the description that caused the validation error.!!MAConditionError commentStamp: 'lr 5/30/2006 23:33' prior: 0!I am an error that is raised whenever a user-defined condition is failing.!!MAConflictError commentStamp: 'lr 5/17/2006 15:16' prior: 0!I am an error that is raised whenever there is an edit conflict.!!MAKindError commentStamp: 'lr 5/17/2006 15:16' prior: 0!I am an error that is raised whenever a description is applied to the wrong type of data.!!MAMultipleErrors commentStamp: 'lr 5/17/2006 15:18' prior: 0!I am an error that is raised whenever there are multiple validation rules failing.!!MARangeError commentStamp: 'lr 5/17/2006 15:17' prior: 0!I am an error that is raised whenever a described value is out of bounds.!!MARequiredError commentStamp: 'lr 5/17/2006 15:17' prior: 0!I am an error that is raised whenever a required value is not supplied.!!MAWriteError commentStamp: 'lr 5/17/2006 15:14' prior: 0!I am an error that gets raised when there is problem writing serialized data.!!MADynamicDescriptionCache commentStamp: 'NickAger 1/18/2012 13:59' prior: 0!I am a dyanmic variable and cache descriptions defined in the current call stack. I prevent infinite recursion when a description refers to itself.!!MAActionDescription methodsFor: 'accessing' stamp: 'SeanDeNigris 10/8/2013 18:31'!comment: aString	comment := aString.! !!MAActionDescription methodsFor: 'accessing' stamp: 'SeanDeNigris 11/29/2013 17:31'!enableBlock: aBlock	"aBlock		- one argument (optional); the model object		- returns a boolean indicating whether the button should be enabled"		enableBlock := aBlock.! !!MAActionDescription methodsFor: 'initialize-release' stamp: 'SeanDeNigris 11/21/2013 18:15'!initialize	super initialize.	enableBlock := [ true ].! !!MAActionDescription methodsFor: 'testing' stamp: 'SeanDeNigris 10/6/2013 19:59'!isEnabled	^ enableBlock cull: model.! !!MAActionDescription methodsFor: 'accessing' stamp: 'SeanDeNigris 11/21/2013 18:13'!label	^ label ifNil: [ selector capitalized normalizeCamelCase ].! !!MAActionDescription methodsFor: 'accessing' stamp: 'SeanDeNigris 11/21/2013 18:12'!label: aString	label := aString.! !!MAActionDescription methodsFor: 'private' stamp: 'SeanDeNigris 10/6/2013 17:38'!perform	model perform: selector.! !!MAActionDescription methodsFor: 'accessing' stamp: 'SeanDeNigris 11/21/2013 18:11'!priority: anInteger 	priority := anInteger.! !!MAActionDescription methodsFor: 'accessing' stamp: 'SeanDeNigris 8/13/2015 09:14'!selector	^ selector! !!MAActionDescription methodsFor: 'accessing' stamp: 'SeanDeNigris 10/6/2013 17:35'!selector: aSymbol	selector := aSymbol.! !!MAActionDescription methodsFor: 'accessing' stamp: 'SeanDeNigris 8/13/2015 09:29'!shortcut	^ shortcut! !!MAActionDescription methodsFor: 'accessing' stamp: 'SeanDeNigris 8/13/2015 09:29'!shortcut: anObject	shortcut := anObject! !!Object class methodsFor: '*magritte-model-description' stamp: 'StephanEggermont 8/26/2014 10:12'!magritteTemplate	"Allow subclasses to have a prototype instance for creating a Magritte description (especially reference description)."	^self new! !!Object methodsFor: '*magritte-model-accessing' stamp: 'NickAger 1/18/2012 17:17'!basicMagritteDescription	^ MAPragmaBuilder for: self! !!Object methodsFor: '*magritte-model-accessing' stamp: 'NickAger 1/17/2012 13:35'!descriptionContainer	"Return the default description container."	<magritteContainer>	^ MAPriorityContainer new		label: self class label;		yourself! !!Object methodsFor: '*magritte-model-model' stamp: 'NickAger 1/18/2012 15:08'!initializeMagritte	"Initializes the receiving object with the default values of its description."	self magritteDescription do: [ :each |		each isReadonly			ifFalse: [ self write: each default using: each ] ]! !!Object methodsFor: '*magritte-model-testing' stamp: 'lr 3/9/2006 11:31'!isDescription	^ false! !!Object methodsFor: '*magritte-model-actions' stamp: 'SeanDeNigris 8/13/2015 09:43'!magritteActionDescriptions	^ self uniqueActionSelectors collect: [ :each | self perform: each ]! !!Object methodsFor: '*magritte-model-accessing' stamp: 'NickAger 1/18/2012 17:16'!magritteDescription	^ self basicMagritteDescription! !!Object methodsFor: '*magritte-model-accessing' stamp: 'lr 3/9/2006 11:31'!mementoClass	"Return a class to be used to remember or cache the receiver, namely a memento object."	^ MACheckedMemento! !!Object methodsFor: '*magritte-model-model' stamp: 'lr 3/9/2006 11:31'!readUsing: aDescription	"Dispatch the read-access to the receiver using the accessor of aDescription."	^ aDescription accessor read: self! !!Object methodsFor: '*magritte-model-actions' stamp: 'SeanDeNigris 11/21/2013 18:09'!uniqueActionSelectors	| descriptionPragmas selectors |		descriptionPragmas := Pragma 		allNamed: #magritteActionDescription		from: self class to: Object.			selectors := descriptionPragmas collect: [ :each | each method selector ].		^ Set withAll: selectors! !!Object methodsFor: '*magritte-model-model' stamp: 'lr 3/9/2006 11:31'!write: anObject using: aDescription	"Dispatch the write-access to the receiver of anObject using the accessor of aDescription."	aDescription accessor write: anObject to: self! !!Symbol methodsFor: '*magritte-model-converting' stamp: 'lr 4/10/2008 13:33'!asAccessor	^ MASelectorAccessor selector: self! !!Symbol methodsFor: '*magritte-model-description' stamp: 'DiegoLont 1/24/2014 10:46'!optionFor: anObject ifPresent: aBlock	aBlock value: (anObject perform: self)! !!Dictionary methodsFor: '*magritte-model-description' stamp: 'DiegoLont 1/24/2014 10:47'!optionFor: anObject ifPresent: aBlock	self at: anObject ifPresent: aBlock! !!MAAdaptiveModel class methodsFor: 'instance creation' stamp: 'NickAger 1/17/2012 14:15'!description: aDescription	^ self new		magritteDescription: aDescription;		yourself! !!MAAdaptiveModel methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:32'!defaultDescription	^ MAContainer new! !!MAAdaptiveModel methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:32'!defaultDictionary	^ Dictionary new! !!MAAdaptiveModel methodsFor: 'initialization' stamp: 'NickAger 1/17/2012 14:16'!initialize	super initialize.	self magritteDescription: self defaultDescription.	self values: self defaultDictionary! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'NickAger 1/17/2012 14:14'!magritteDescription	"Answer the description of the receiver."	^ magritteDescription! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'NickAger 1/17/2012 14:15'!magritteDescription: aDescription	magritteDescription := aDescription! !!MAAdaptiveModel methodsFor: 'model' stamp: 'lr 4/10/2007 21:23'!readUsing: aDescription	"Answer the actual value of ==aDescription== within the receiver, ==nil== if not present."	^ self values at: aDescription ifAbsent: [ nil ]! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'lr 5/17/2006 14:14'!values	"Answer a dictionary mapping description to actual values."	^ values! !!MAAdaptiveModel methodsFor: 'accessing' stamp: 'lr 6/2/2006 00:12'!values: aDictionary	values := aDictionary! !!MAAdaptiveModel methodsFor: 'model' stamp: 'lr 4/10/2007 21:23'!write: anObject using: aDescription	"Set ==anObject== to be that actual value of the receiver for ==aDescription==."	self values at: aDescription put: anObject! !!MABasicObject class methodsFor: 'error handling' stamp: 'jf 9/16/2009 13:16'!defaultErrorClass	^ MAError! !!MAFileModel class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMimeType	^ 'application/octet-stream'! !!MAFileModel class methodsFor: 'accessing-defaults' stamp: 'lr 4/9/2009 09:57'!defaultMimeTypes	^ #( '323' 'text/h323' 'acx' 'application/internet-property-stream' 'ai' 'application/postscript' 'aif' 'audio/x-aiff' 'aifc' 'audio/x-aiff' 'aiff' 'audio/x-aiff' 'asc' 'text/plain' 'asf' 'video/x-ms-asf' 'asr' 'video/x-ms-asf' 'asx' 'video/x-ms-asf' 'au' 'audio/basic' 'avi' 'video/x-msvideo' 'axs' 'application/olescript' 'bas' 'text/plain' 'bcpio' 'application/x-bcpio' 'bin' 'application/octet-stream' 'bmp' 'image/bmp' 'c' 'text/plain' 'cat' 'application/vnd.ms-pkiseccat' 'cc' 'text/plain' 'ccad' 'application/clariscad' 'cdf' 'application/x-netcdf' 'cer' 'application/x-x509-ca-cert' 'class' 'application/octet-stream' 'clp' 'application/x-msclip' 'cmx' 'image/x-cmx' 'cod' 'image/cis-cod' 'cpio' 'application/x-cpio' 'cpt' 'application/mac-compactpro' 'crd' 'application/x-mscardfile' 'crl' 'application/pkix-crl' 'crt' 'application/x-x509-ca-cert' 'csh' 'application/x-csh' 'css' 'text/css' 'dcr' 'application/x-director' 'der' 'application/x-x509-ca-cert' 'dir' 'application/x-director' 'dll' 'application/x-msdownload' 'dms' 'application/octet-stream' 'doc' 'application/msword' 'dot' 'application/msword' 'drw' 'application/drafting' 'dtd' 'application/xml-dtd' 'dvi' 'application/x-dvi' 'dwg' 'application/acad' 'dxf' 'application/dxf' 'dxr' 'application/x-director' 'eps' 'application/postscript' 'etx' 'text/x-setext' 'evy' 'application/envoy' 'exe' 'application/octet-stream' 'ez' 'application/andrew-inset' 'f' 'text/plain' 'f90' 'text/plain' 'fif' 'application/fractals' 'fli' 'video/x-fli' 'flr' 'x-world/x-vrml' 'gif' 'image/gif' 'gtar' 'application/x-gtar' 'gz' 'application/x-gzip' 'h' 'text/plain' 'hdf' 'application/x-hdf' 'hh' 'text/plain' 'hlp' 'application/winhlp' 'hqx' 'application/mac-binhex40' 'hta' 'application/hta' 'htc' 'text/x-component' 'htm' 'text/html' 'html' 'text/html' 'htt' 'text/webviewhtml' 'ice' 'x-conference/x-cooltalk' 'ico' 'image/vnd.microsoft.icon' 'ief' 'image/ief' 'iges' 'model/iges' 'igs' 'model/iges' 'iii' 'application/x-iphone' 'ins' 'application/x-internet-signup' 'ips' 'application/x-ipscript' 'ipx' 'application/x-ipix' 'isp' 'application/x-internet-signup' 'jfif' 'image/pipeg' 'jpe' 'image/jpeg' 'jpeg' 'image/jpeg' 'jpg' 'image/jpeg' 'js' 'application/javascript' 'json' 'application/json' 'kar' 'audio/midi' 'latex' 'application/x-latex' 'lha' 'application/octet-stream' 'lsf' 'video/x-la-asf' 'lsp' 'application/x-lisp' 'lsx' 'video/x-la-asf' 'lzh' 'application/octet-stream' 'm' 'text/plain' 'm13' 'application/x-msmediaview' 'm14' 'application/x-msmediaview' 'm3u' 'audio/x-mpegurl' 'man' 'application/x-troff-man' 'mdb' 'application/x-msaccess' 'me' 'application/x-troff-me' 'mesh' 'model/mesh' 'mht' 'message/rfc822' 'mhtml' 'message/rfc822' 'mid' 'audio/midi' 'midi' 'audio/midi' 'mif' 'application/vnd.mif' 'mime' 'www/mime' 'mny' 'application/x-msmoney' 'mov' 'video/quicktime' 'movie' 'video/x-sgi-movie' 'mp2' 'audio/mpeg' 'mp3' 'audio/mpeg' 'mpa' 'video/mpeg' 'mpe' 'video/mpeg' 'mpeg' 'video/mpeg' 'mpg' 'video/mpeg' 'mpga' 'audio/mpeg' 'mpp' 'application/vnd.ms-project' 'mpv2' 'video/mpeg' 'ms' 'application/x-troff-ms' 'msh' 'model/mesh' 'mvb' 'application/x-msmediaview' 'nc' 'application/x-netcdf' 'nws' 'message/rfc822' 'oda' 'application/oda' 'ogg' 'application/ogg' 'p10' 'application/pkcs10' 'p12' 'application/x-pkcs12' 'p7b' 'application/x-pkcs7-certificates' 'p7c' 'application/x-pkcs7-mime' 'p7m' 'application/x-pkcs7-mime' 'p7r' 'application/x-pkcs7-certreqresp' 'p7s' 'application/x-pkcs7-signature' 'pbm' 'image/x-portable-bitmap' 'pdb' 'chemical/x-pdb' 'pdf' 'application/pdf' 'pfx' 'application/x-pkcs12' 'pgm' 'image/x-portable-graymap' 'pgn' 'application/x-chess-pgn' 'pko' 'application/ynd.ms-pkipko' 'pma' 'application/x-perfmon' 'pmc' 'application/x-perfmon' 'pml' 'application/x-perfmon' 'pmr' 'application/x-perfmon' 'pmw' 'application/x-perfmon' 'png' 'image/png' 'pnm' 'image/x-portable-anymap' 'pot' 'application/mspowerpoint' 'ppm' 'image/x-portable-pixmap' 'pps' 'application/mspowerpoint' 'ppt' 'application/mspowerpoint' 'ppz' 'application/mspowerpoint' 'pre' 'application/x-freelance' 'prf' 'application/pics-rules' 'prt' 'application/pro_eng' 'ps' 'application/postscript' 'pub' 'application/x-mspublisher' 'qt' 'video/quicktime' 'ra' 'audio/x-realaudio' 'ram' 'audio/x-pn-realaudio' 'ras' 'image/cmu-raster' 'rgb' 'image/x-rgb' 'rm' 'audio/x-pn-realaudio' 'rmi' 'audio/mid' 'roff' 'application/x-troff' 'rpm' 'audio/x-pn-realaudio-plugin' 'rtf' 'application/rtf' 'rtx' 'text/richtext' 'scd' 'application/x-msschedule' 'scm' 'application/x-lotusscreencam' 'sct' 'text/scriptlet' 'set' 'application/set' 'setpay' 'application/set-payment-initiation' 'setreg' 'application/set-registration-initiation' 'sgm' 'text/sgml' 'sgml' 'text/sgml' 'sh' 'application/x-sh' 'shar' 'application/x-shar' 'silo' 'model/mesh' 'sit' 'application/x-stuffit' 'skd' 'application/x-koan' 'skm' 'application/x-koan' 'skp' 'application/x-koan' 'skt' 'application/x-koan' 'smi' 'application/smil' 'smil' 'application/smil' 'snd' 'audio/basic' 'sol' 'application/solids' 'spc' 'application/x-pkcs7-certificates' 'spl' 'application/futuresplash' 'src' 'application/x-wais-source' 'sst' 'application/vnd.ms-pkicertstore' 'step' 'application/STEP' 'stl' 'application/vnd.ms-pkistl' 'stm' 'text/html' 'stp' 'application/STEP' 'sv4cpio' 'application/x-sv4cpio' 'sv4crc' 'application/x-sv4crc' 'svg' 'image/svg+xml' 'swf' 'application/x-shockwave-flash' 't' 'application/x-troff' 'tar' 'application/x-tar' 'tcl' 'application/x-tcl' 'tex' 'application/x-tex' 'texi' 'application/x-texinfo' 'texinfo' 'application/x-texinfo' 'tgz' 'application/x-compressed' 'tif' 'image/tiff' 'tiff' 'image/tiff' 'tr' 'application/x-troff' 'trm' 'application/x-msterminal' 'tsi' 'audio/TSP-audio' 'tsp' 'application/dsptype' 'tsv' 'text/tab-separated-values' 'txt' 'text/plain' 'uls' 'text/iuls' 'unv' 'application/i-deas' 'ustar' 'application/x-ustar' 'vcd' 'application/x-cdlink' 'vcf' 'text/x-vcard' 'vda' 'application/vda' 'viv' 'video/vnd.vivo' 'vivo' 'video/vnd.vivo' 'vrml' 'model/vrml' 'wav' 'audio/x-wav' 'wcm' 'application/vnd.ms-works' 'wdb' 'application/vnd.ms-works' 'wks' 'application/vnd.ms-works' 'wmf' 'application/x-msmetafile' 'wps' 'application/vnd.ms-works' 'wri' 'application/x-mswrite' 'wrl' 'model/vrml' 'wrz' 'x-world/x-vrml' 'xaf' 'x-world/x-vrml' 'xbm' 'image/x-xbitmap' 'xhtml' 'application/xhtml+xml' 'xla' 'application/vnd.ms-excel' 'xlc' 'application/vnd.ms-excel' 'xll' 'application/vnd.ms-excel' 'xlm' 'application/vnd.ms-excel' 'xls' 'application/vnd.ms-excel' 'xlt' 'application/vnd.ms-excel' 'xlw' 'application/vnd.ms-excel' 'xml' 'text/xml' 'xof' 'x-world/x-vrml' 'xpm' 'image/x-xpixmap' 'xwd' 'image/x-xwindowdump' 'xyz' 'chemical/x-pdb' 'z' 'application/x-compress' 'zip' 'application/zip' )! !!MAFileModel class methodsFor: 'initialization' stamp: 'lr 4/9/2009 09:57'!initialize	MimeTypes := Dictionary new.	1 to: self defaultMimeTypes size by: 2 do: [ :index |		MimeTypes 			at: (self defaultMimeTypes at: index)			put: (self defaultMimeTypes at: index + 1) ]! !!MAFileModel class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!mimetypeFor: aString	^ self mimetypes at: aString ifAbsent: [ self defaultMimeType ]! !!MAFileModel class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!mimetypes	^ MimeTypes! !!MAFileModel class methodsFor: 'accessing-defaults' stamp: 'lr 11/3/2009 22:12'!validCharacters	"Answer a string with all the valid characters for filenames."		^ '-.0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz'! !!MAFileModel methodsFor: 'comparing' stamp: 'lr 2/16/2007 08:49'!= anObject	^ self species = anObject species		and: [ self filename = anObject filename		and: [ self mimetype = anObject mimetype ] ]! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 10/18/2007 18:15'!contents	"Answer the contents of the file. This method is supposed to be overridden by concrete subclasses."	self subclassResponsibility! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 2/12/2007 19:06'!contents: aByteArray	"Set the contents of the receiver. This method is supposed to be overridden by concrete subclasses."	filesize := aByteArray size! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'lr 3/21/2006 19:56'!extension	"Answer the file-extension."	^ self filename copyAfterLast: $.! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 2/12/2007 19:06'!filename	"Answer the filename of the receiver."	^ filename! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 11/3/2009 22:12'!filename: aString	"Normalize the filenames. Don't just allow any stupid windows filename.'"	filename := aString isNil ifFalse: [ 		aString collect: [ :char |			(self class validCharacters includes: char)				ifTrue: [ char ]				ifFalse: [ 					char = Character space						ifTrue: [ $- ]						ifFalse: [ $_ ] ] ] ]! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'lr 1/26/2007 18:20'!filesize	"Answer the size of the file."	^ filesize! !!MAFileModel methodsFor: 'initialization' stamp: 'lr 1/14/2008 16:53'!finalize	"Cleanup after a file is removed, subclasses might require to specialize this method."		self initialize! !!MAFileModel methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ self filename hash bitXor: self mimetype hash! !!MAFileModel methodsFor: 'initialization' stamp: 'jf 9/16/2009 13:18'!initialize	super initialize.	filesize := 0.	filename := 'unknown'.	mimetype := self class defaultMimeType! !!MAFileModel methodsFor: 'testing-types' stamp: 'lr 4/10/2007 21:39'!isApplication	"Return ==true== if the mimetype of the receiver is application-data. This message will match types like: application/postscript, application/zip, application/pdf, etc."	^ self maintype = 'application'! !!MAFileModel methodsFor: 'testing-types' stamp: 'lr 4/10/2007 21:40'!isAudio	"Return ==true== if the mimetype of the receiver is audio-data. This message will match types like: audio/basic, audio/tone, audio/mpeg, etc."	^ self maintype = 'audio'! !!MAFileModel methodsFor: 'testing' stamp: 'lr 1/26/2007 18:20'!isEmpty	^ self filesize isZero! !!MAFileModel methodsFor: 'testing-types' stamp: 'lr 4/10/2007 21:40'!isImage	"Return ==true== if the mimetype of the receiver is image-data. This message will match types like: image/jpeg, image/gif, image/png, image/tiff, etc."	^ self maintype = 'image'! !!MAFileModel methodsFor: 'testing-types' stamp: 'lr 4/10/2007 21:40'!isText	"Return ==true== if the mimetype of the receiver is text-data. This message will match types like: text/plain, text/html, text/sgml, text/css, text/xml, text/richtext, etc."	^ self maintype = 'text'! !!MAFileModel methodsFor: 'testing-types' stamp: 'lr 4/10/2007 21:40'!isVideo	"Return ==true== if the mimetype of the receiver is video-data. This message will match types like: video/mpeg, video/quicktime, etc."	^ self maintype = 'video'! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!maintype	"Answer the first part of the mime-type."	^ self mimetype copyUpTo: $/! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 2/12/2007 19:06'!mimetype	"Answer the mimetype of the receiver."	^ mimetype! !!MAFileModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!mimetype: aString	mimetype := aString! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'DamienCassou 9/23/2010 09:56'!readStream	^ self contents readStream! !!MAFileModel methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!subtype	"Answer the second part of the mime-type."	^ self mimetype copyAfter: $/! !!MAMemoryFileModel methodsFor: 'comparing' stamp: 'lr 11/6/2009 15:38'!= anObject    ^ super = anObject and: [ self contents = anObject contents ]! !!MAMemoryFileModel methodsFor: 'accessing' stamp: 'lr 10/18/2007 18:22'!contents	^ contents ifNil: [ contents := ByteArray new ]! !!MAMemoryFileModel methodsFor: 'accessing' stamp: 'lr 9/30/2007 18:20'!contents: aByteArray	super contents: aByteArray.	contents := aByteArray asByteArray! !!MAMemoryFileModel methodsFor: 'initialization' stamp: 'lr 9/30/2007 18:11'!finalize	super finalize.	contents := nil! !!MAMemoryFileModel methodsFor: 'comparing' stamp: 'lr 11/6/2009 15:38'!hash	^ super hash bitXor: self contents hash! !!MAAccessor methodsFor: 'converting' stamp: 'lr 4/10/2008 13:31'!asAccessor	^ self! !!MAAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:44'!canRead: aModel	"Test if ==aModel== can be read."	^ false! !!MAAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:44'!canWrite: aModel	"Test if ==aModel== can be written."	^ false! !!MAAccessor methodsFor: 'printing' stamp: 'lr 3/9/2006 11:31'!printOn: aStream	self storeOn: aStream! !!MAAccessor methodsFor: 'model' stamp: 'lr 5/6/2008 17:45'!read: aModel	"Read from ==aModel== using the access-strategy of the receiver."	^ nil! !!MAAccessor methodsFor: 'printing' stamp: 'lr 9/3/2009 17:14'!storeOn: aStream	self class storeOn: aStream.	aStream nextPutAll: ' new'! !!MAAccessor methodsFor: 'model' stamp: 'lr 5/6/2008 17:45'!write: anObject to: aModel	"Write ==anObject== to ==aModel== using the access-strategy of the receiver."! !!MAChainAccessor class methodsFor: 'instance creation' stamp: 'lr 5/6/2008 18:11'!accessors: aSequenceableCollection	aSequenceableCollection isEmpty		ifTrue: [ self error: 'Unable to create accessor sequence from empty collection.' ].	aSequenceableCollection size = 1		ifTrue: [ ^ aSequenceableCollection first asAccessor ].	^ self 		on: aSequenceableCollection first asAccessor 		accessor: (self accessors: aSequenceableCollection allButFirst)! !!MAChainAccessor class methodsFor: 'instance creation' stamp: 'lr 5/6/2008 18:10'!on: anAccessor accessor: anotherAccessor	^ (self on: anAccessor) accessor: anotherAccessor! !!MAChainAccessor methodsFor: 'comparing' stamp: 'lr 5/6/2008 17:43'!= anObject	^ super = anObject and: [ self accessor = anObject accessor ]! !!MAChainAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!accessor	^ accessor! !!MAChainAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!accessor: anAccessor	accessor := anAccessor! !!MAChainAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:48'!canRead: aModel	^ (super canRead: aModel) and: [ self accessor canRead: (self next read: aModel) ]! !!MAChainAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:48'!canWrite: aModel	^ (super canRead: aModel) and: [ self accessor canWrite: (self next read: aModel) ]! !!MAChainAccessor methodsFor: 'comparing' stamp: 'lr 5/6/2008 17:43'!hash	^ super hash bitXor: self accessor hash! !!MAChainAccessor methodsFor: 'copying' stamp: 'lr 5/6/2008 17:44'!postCopy	super postCopy.	accessor := accessor copy! !!MAChainAccessor methodsFor: 'model' stamp: 'lr 5/6/2008 17:49'!read: aModel	^ self accessor read: (super read: aModel)! !!MAChainAccessor methodsFor: 'printing' stamp: 'lr 9/3/2009 17:14'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' on: ';		store: self next;		nextPutAll: ' accessor: ';		store: self accessor;		nextPut: $)! !!MAChainAccessor methodsFor: 'model' stamp: 'lr 5/6/2008 17:49'!write: anObject to: aModel	self accessor write: anObject to: (super read: aModel)! !!MADelegatorAccessor class methodsFor: 'testing' stamp: 'lr 2/14/2008 09:45'!isAbstract	^ false! !!MADelegatorAccessor class methodsFor: 'instance creation' stamp: 'lr 2/14/2008 09:45'!on: anAccessor	^ self new next: anAccessor! !!MADelegatorAccessor methodsFor: 'comparing' stamp: 'lr 2/14/2008 09:53'!= anObject	^ super = anObject and: [ self next = anObject next ]! !!MADelegatorAccessor methodsFor: 'testing' stamp: 'lr 2/14/2008 09:52'!canRead: aModel	^ self next canRead: aModel! !!MADelegatorAccessor methodsFor: 'testing' stamp: 'lr 2/14/2008 09:52'!canWrite: aModel	^ self next canWrite: aModel! !!MADelegatorAccessor methodsFor: 'comparing' stamp: 'lr 2/14/2008 09:54'!hash	^  super hash bitXor: self next hash! !!MADelegatorAccessor methodsFor: 'accessing' stamp: 'lr 2/14/2008 09:44'!next	^ next! !!MADelegatorAccessor methodsFor: 'accessing' stamp: 'kph 6/12/2008 01:42'!next: anAccessor 	next := anAccessor asAccessor! !!MADelegatorAccessor methodsFor: 'copying' stamp: 'lr 5/6/2008 17:44'!postCopy	super postCopy.	next := next copy! !!MADelegatorAccessor methodsFor: 'model' stamp: 'lr 2/14/2008 09:53'!read: aModel	^ self next read: aModel! !!MADelegatorAccessor methodsFor: 'printing' stamp: 'lr 9/3/2009 17:14'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' on: ';		store: self next;		nextPut: $)! !!MADelegatorAccessor methodsFor: 'model' stamp: 'lr 2/14/2008 09:53'!write: anObject to: aModel	self next write: anObject to: aModel! !!MADictionaryAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MADictionaryAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!key: aSymbol	^ self new		key: aSymbol;		yourself! !!MADictionaryAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!= anObject	^ super = anObject		and: [ self key = anObject key ]! !!MADictionaryAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:50'!canRead: aModel	^ true! !!MADictionaryAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:50'!canWrite: aModel	^ true! !!MADictionaryAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ super hash bitXor: self key hash! !!MADictionaryAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!key	^ key! !!MADictionaryAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!key: aKey	key := aKey! !!MADictionaryAccessor methodsFor: 'model' stamp: 'lr 10/25/2007 23:53'!read: aModel	^ aModel at: self key ifAbsent: [ nil ]! !!MADictionaryAccessor methodsFor: 'printing' stamp: 'lr 9/3/2009 17:14'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' key: ';		store: self key;		nextPut: $)! !!MADictionaryAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!write: anObject to: aModel	aModel at: self key put: anObject! !!MAIdentityAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAIdentityAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:50'!canRead: aModel	^ true! !!MAIdentityAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!read: aModel	^ aModel! !!MAIdentityAccessor methodsFor: 'model' stamp: 'jf 9/30/2009 01:10'!write: anObject to: aModel 	MAWriteError signal: 'Not supposed to write to ' , aModel greaseString , '.'! !!MANullAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MANullAccessor class methodsFor: 'instance creation' stamp: 'jf 10/28/2009 15:23'!new	| random uuid |	random := GRPlatform current newRandom.	uuid := Array new: 16.	1 to: 16 do: [ :i | uuid at: i put: (random nextInt: 256) -1 ].	^ self uuid: uuid! !!MANullAccessor class methodsFor: 'instance creation' stamp: 'jf 10/18/2009 13:22'!uuid: anObject	^ self basicNew		uuid: anObject;		yourself! !!MANullAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!= anObject	^ super = anObject		and: [ self uuid = anObject uuid ]! !!MANullAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ super hash bitXor: self uuid hash! !!MANullAccessor methodsFor: 'model' stamp: 'lr 4/10/2008 14:11'!read: aModel 	MAReadError signal: 'This message is not appropriate for this object'! !!MANullAccessor methodsFor: 'printing' stamp: 'lr 9/3/2009 17:14'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' uuid: ';		store: self uuid;		nextPut: $)! !!MANullAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!uuid	^ uuid! !!MANullAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!uuid: anObject	uuid := anObject! !!MANullAccessor methodsFor: 'model' stamp: 'lr 4/10/2008 14:11'!write: anObject to: aModel 	MAWriteError signal: 'This message is not appropriate for this object'! !!MAPluggableAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAPluggableAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!read: aReadBlock write: aWriteBlock	^ self new		readBlock: aReadBlock;		writeBlock: aWriteBlock;		yourself! !!MAPluggableAccessor methodsFor: 'comparing' stamp: 'lr 2/16/2007 08:48'!= anObject	^ super = anObject		and: [ self readBlock = anObject readBlock		and: [ self writeBlock = anObject writeBlock ] ]! !!MAPluggableAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:42'!canRead: aModel	^ self readBlock notNil! !!MAPluggableAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:43'!canWrite: aModel	^ self writeBlock notNil! !!MAPluggableAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:31'!hash	^ super hash bitXor: (self readBlock hash bitXor: self writeBlock hash)! !!MAPluggableAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:31'!read: aModel	^ self readBlock value: aModel! !!MAPluggableAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!readBlock	^ readBlock! !!MAPluggableAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!readBlock: aBlock	readBlock := aBlock! !!MAPluggableAccessor methodsFor: 'printing' stamp: 'jf 9/30/2009 01:10'!storeBlock: aBlock on: aStream 	aStream nextPutAll: aBlock decompile greaseString allButFirst allButLast! !!MAPluggableAccessor methodsFor: 'printing' stamp: 'lr 9/3/2009 17:14'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream nextPutAll: ' read: '.	self storeBlock: self readBlock on: aStream.	aStream nextPutAll: ' write: '.	self storeBlock: self writeBlock on: aStream.	aStream nextPut: $)! !!MAPluggableAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:31'!write: anObject to: aModel	self writeBlock value: aModel value: anObject! !!MAPluggableAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!writeBlock	^ writeBlock! !!MAPluggableAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!writeBlock: aBlock	writeBlock := aBlock! !!MASelectorAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MASelectorAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!read: aReadSelector write: aWriteSelector	^ self new		readSelector: aReadSelector;		writeSelector: aWriteSelector;		yourself! !!MASelectorAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!selector: aSelector	^ self new		selector: aSelector;		yourself! !!MASelectorAccessor methodsFor: 'comparing' stamp: 'lr 2/16/2007 08:49'!= anObject	^ super = anObject		and: [ self readSelector = anObject readSelector		and: [ self writeSelector = anObject writeSelector ] ]! !!MASelectorAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:51'!canRead: aModel	^ self readSelector notNil and: [ aModel respondsTo: self readSelector ]! !!MASelectorAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:51'!canWrite: aModel	^ self writeSelector notNil and: [ aModel respondsTo: self writeSelector ]! !!MASelectorAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^  super hash bitXor: (self readSelector hash bitXor: self writeSelector hash)! !!MASelectorAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!read: aModel	^ aModel perform: self readSelector! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!readSelector	^ readSelector! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!readSelector: aSelector	readSelector := aSelector! !!MASelectorAccessor methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!selector	^ self readSelector! !!MASelectorAccessor methodsFor: 'accessing-dynamic' stamp: 'jf 9/30/2009 01:10'!selector: aSelector 	self readSelector: aSelector asSymbol.	self writeSelector: (aSelector greaseString copyWith: $:) asSymbol! !!MASelectorAccessor methodsFor: 'printing' stamp: 'lr 9/3/2009 17:15'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' read: ';		store: self readSelector;		nextPutAll: ' write: ';		store: self writeSelector;		nextPut: $)! !!MASelectorAccessor methodsFor: 'model' stamp: 'fbs 6/2/2011 17:59'!write: anObject to: aModel	^ aModel perform: self writeSelector with: anObject! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!writeSelector	^ writeSelector! !!MASelectorAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!writeSelector: aSelector	writeSelector := aSelector! !!MAVariableAccessor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAVariableAccessor class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!name: aString	^ self new		name: aString;		yourself! !!MAVariableAccessor methodsFor: 'comparing' stamp: 'lr 5/6/2008 17:51'!= anObject	^ super = anObject and: [ self name = anObject name ]! !!MAVariableAccessor methodsFor: 'testing' stamp: 'DaleHenrichs 06/04/2010 17:18'!canRead: aModel	^ aModel class allInstVarNames includes: self name asSymbol! !!MAVariableAccessor methodsFor: 'testing' stamp: 'lr 5/6/2008 17:52'!canWrite: aModel	^ self canRead: aModel! !!MAVariableAccessor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ super hash bitXor: self name hash! !!MAVariableAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!name	^ name! !!MAVariableAccessor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!name: aString	name := aString! !!MAVariableAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!read: aModel	^ aModel instVarNamed: self name! !!MAVariableAccessor methodsFor: 'printing' stamp: 'lr 9/3/2009 17:15'!storeOn: aStream	aStream nextPut: $(.	self class storeOn: aStream.	aStream		nextPutAll: ' name: ';		store: self name;		nextPut: $)! !!MAVariableAccessor methodsFor: 'model' stamp: 'lr 3/9/2006 11:32'!write: anObject to: aModel	aModel instVarNamed: self name put: anObject! !!MACondition class methodsFor: 'testing' stamp: 'lr 2/5/2009 21:05'!isAbstract	^ self name = #MACondition! !!MACondition class methodsFor: 'convenience' stamp: 'lr 2/5/2009 21:30'!receiver: anObject selector: aSelector	^ self receiver: anObject selector: aSelector arguments: #(nil) index: 1! !!MACondition class methodsFor: 'instance creation' stamp: 'lr 2/5/2009 21:30'!receiver: anObject selector: aSelector arguments: anArray index: anInteger	(aSelector numArgs = anArray size)		ifFalse: [ self error: 'Invalid number of arguments.' ].	(anInteger between: 0 and: anArray size)		ifFalse: [ self error: 'Index out of bounds.' ].	^ MAPluggableCondition new 		initializeReceiver: anObject		selector: aSelector		arguments: anArray		index: anInteger! !!MACondition class methodsFor: 'convenience' stamp: 'lr 2/5/2009 21:30'!selector: aSelector	^ self receiver: nil selector: aSelector arguments: #() index: 0! !!MACondition class methodsFor: 'convenience' stamp: 'lr 2/5/2009 21:30'!selector: aSelector argument: anObject	^ self receiver: nil selector: aSelector arguments: (Array with: anObject) index: 0! !!MACondition methodsFor: 'operators' stamp: 'lr 2/5/2009 20:40'!& aCondition 	^ MAConjunctiveCondition new & self & aCondition! !!MACondition methodsFor: 'operators' stamp: 'lr 2/5/2009 21:56'!not	^ MANegationCondition with: self! !!MACondition methodsFor: 'accessing' stamp: 'lr 2/5/2009 20:56'!numArgs	^ 1! !!MACondition methodsFor: 'evaluating' stamp: 'lr 2/5/2009 20:43'!value: anObject	self subclassResponsibility! !!MACondition methodsFor: 'operators' stamp: 'lr 2/5/2009 20:40'!| aCondition 	^ (self not & aCondition not) not! !!MAConjunctiveCondition methodsFor: 'operators' stamp: 'lr 2/5/2009 20:42'!& aCondition	conditions := conditions copyWith: aCondition! !!MAConjunctiveCondition methodsFor: 'initialization' stamp: 'lr 2/5/2009 20:42'!initialize	conditions := #()! !!MAConjunctiveCondition methodsFor: 'evaluating' stamp: 'lr 2/5/2009 20:44'!value: anObject	^ conditions allSatisfy: [ :each | each value: anObject ]! !!MANegationCondition class methodsFor: 'instance creation' stamp: 'lr 2/5/2009 20:45'!with: aCondition	^ self new initializeWith: aCondition! !!MANegationCondition methodsFor: 'initialization' stamp: 'lr 2/5/2009 21:55'!initializeWith: aCondition	condition := aCondition! !!MANegationCondition methodsFor: 'evaluating' stamp: 'lr 2/5/2009 20:44'!value: anObject	^ (condition value: anObject) not! !!MAPluggableCondition methodsFor: 'initialization' stamp: 'lr 2/5/2009 21:30'!initializeReceiver: anObject selector: aSelector arguments: anArray index: anInteger	receiver := anObject.	selector := aSelector.	arguments := anArray.	index := anInteger! !!MAPluggableCondition methodsFor: 'evaluating' stamp: 'lr 2/5/2009 21:31'!value: anObject	| actualReceiver actualArguments |	actualReceiver := index = 0		ifFalse: [ receiver ]		ifTrue: [ anObject ].	actualArguments := index > 0		ifFalse: [ arguments ]		ifTrue: [			arguments copy 				at: index put: anObject;				yourself ].	^ actualReceiver		perform: selector		withArguments: actualArguments! !!MAContainer class methodsFor: 'accessing-defaults' stamp: 'lr 4/10/2008 13:55'!defaultAccessor	^ MAIdentityAccessor new! !!MAContainer class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultCollection	^ OrderedCollection new! !!MAContainer class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAContainer class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!with: aDescription	^ self new		add: aDescription;		yourself! !!MAContainer class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:32'!withAll: aCollection	^ self new		addAll: aCollection;		yourself! !!MAContainer methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!= anObject	^ super = anObject		and: [ self children = anObject children ]! !!MAContainer methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitContainer: self! !!MAContainer methodsFor: 'adding' stamp: 'lr 3/9/2006 11:32'!add: aDescription	self children add: aDescription! !!MAContainer methodsFor: 'adding' stamp: 'lr 3/9/2006 11:32'!addAll: aCollection	self children addAll: aCollection! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 5/29/2006 10:09'!allSatisfy: aBlock	^ self children allSatisfy: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 5/29/2006 10:09'!anySatisfy: aBlock	^ self children anySatisfy: aBlock! !!MAContainer methodsFor: 'converting' stamp: 'lr 3/9/2006 11:32'!asContainer	^ self! !!MAContainer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!at: anIndex	^ self children at: anIndex! !!MAContainer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!at: anIndex ifAbsent: aBlock	^ self children at: anIndex ifAbsent: aBlock! !!MAContainer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!children	^ children! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!collect: aBlock	^ self copy		setChildren: (self children collect: aBlock);		yourself! !!MAContainer methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!copyEmpty	^ self copy		setChildren: self class defaultCollection;		yourself! !!MAContainer methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!copyFrom: aStartIndex to: anEndIndex	^ self copy		setChildren: (self children			copyFrom: aStartIndex			to: anEndIndex);		yourself! !!MAContainer methodsFor: 'copying' stamp: 'lr 2/12/2007 19:06'!copyWithout: anObject	^self reject: [:each | each = anObject]! !!MAContainer methodsFor: 'copying' stamp: 'lr 2/12/2007 19:06'!copyWithoutAll: aCollection	^self reject: [:each | aCollection includes: each]! !!MAContainer methodsFor: 'acessing-magritte' stamp: 'NickAger 1/18/2012 16:55'!descriptionChildren	<magritteDescription>	^ MAToManyRelationDescription new		accessor: (MASelectorAccessor read: #children write: #setChildren:);		classes: MAElementDescription withAllConcreteClasses;		default: self class defaultCollection;		label: 'Elements';		priority: 400;		beOrdered;		yourself! !!MAContainer methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 17:27'!descriptionDefault	<magritteDescription>	^ nil! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!detect: aBlock	^ self children detect: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!detect: aBlock ifNone: anExceptionBlock	^ self children detect: aBlock ifNone: anExceptionBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!do: aBlock	self children do: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!do: aBlock separatedBy: aSeparatorBlock	self children do: aBlock separatedBy: aSeparatorBlock! !!MAContainer methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!errorNotFound: aDescription	self error: aDescription class label , ' not found.'! !!MAContainer methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!hasChildren	^ self notEmpty! !!MAContainer methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ super hash bitXor: self children hash! !!MAContainer methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!includes: aDescription	^ self children includes: aDescription! !!MAContainer methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!initialize	super initialize.	self setChildren: self class defaultCollection! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!inject: anObject into: aBlock	^ self children inject: anObject into: aBlock! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!intersection: aCollection	^ self copy		setChildren: (self children intersection: aCollection);		yourself! !!MAContainer methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isContainer	^ true! !!MAContainer methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isEmpty	^ self children isEmpty! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 4/10/2008 14:05'!keysAndValuesDo: aBlock	self children keysAndValuesDo: aBlock! !!MAContainer methodsFor: 'moving' stamp: 'lr 3/9/2006 11:32'!moveDown: aDescription	self children moveDown: aDescription! !!MAContainer methodsFor: 'moving' stamp: 'lr 3/9/2006 11:32'!moveUp: aDescription	self children moveUp: aDescription! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 5/29/2006 10:08'!noneSatisfy: aBlock	^ self children noneSatisfy: aBlock! !!MAContainer methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!notEmpty	^ self children notEmpty! !!MAContainer methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!postCopy	super postCopy.	self setChildren: self children copy! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!reject: aBlock	^ self copy		setChildren: (self children reject: aBlock);		yourself! !!MAContainer methodsFor: 'removing' stamp: 'lr 3/9/2006 11:32'!remove: aDescription	self children remove: aDescription ifAbsent: [ self errorNotFound: aDescription ]! !!MAContainer methodsFor: 'removing' stamp: 'lr 3/9/2006 11:32'!removeAll	self setChildren: self class defaultCollection! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!select: aBlock	^ self copy		setChildren: (self children select: aBlock);		yourself! !!MAContainer methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setChildren: aCollection	children := aCollection! !!MAContainer methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!size	^ self children size! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 5/29/2006 10:09'!union: aContainer	^ self copy		addAll: (aContainer reject: [ :each | self includes: each ]);		yourself! !!MAContainer methodsFor: 'enumerating' stamp: 'lr 3/9/2006 11:32'!with: aCollection do: aBlock	self children with: aCollection do: aBlock! !!MAPriorityContainer class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultCollection	^ SortedCollection new! !!MAPriorityContainer methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitPriorityContainer: self! !!MAPriorityContainer methodsFor: 'moving' stamp: 'lr 3/9/2006 11:32'!moveDown: aDescription	self shouldNotImplement! !!MAPriorityContainer methodsFor: 'moving' stamp: 'lr 3/9/2006 11:32'!moveUp: aDescription	self shouldNotImplement! !!MAPriorityContainer methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!resort	self setChildren: self children copy! !!MAPriorityContainer methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setChildren: aCollection	super setChildren: aCollection asSortedCollection! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultAccessor	^ MANullAccessor new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultComment	^ nil! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultConditions	^ Array new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultDefault	^ nil! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 10/27/2007 12:01'!defaultGroup	^ nil! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:22'!defaultKind	^ Object! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 10/27/2007 12:01'!defaultLabel	^ String new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultPersistent	^ true! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultPriority	^ 0! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultReadonly	^ false! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultRequired	^ false! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultStringReader	^ MAStringReader! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultStringWriter	^ MAStringWriter! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultUndefined	^ String new! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 2/16/2007 08:39'!defaultValidator	^ MAValidatorVisitor! !!MADescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultVisible	^ true! !!MADescription class methodsFor: 'as yet unclassified' stamp: 'EstebanMaringolo 11/21/2014 16:29'!defaultVisibleInReport	^true! !!MADescription class methodsFor: 'accessing-examples' stamp: 'lr 11/1/2009 08:36'!grouping	^ MADescriptionHolder groupOf: self! !!MADescription methodsFor: 'operators' stamp: 'lr 4/10/2007 21:32'!, aDescription	"Concatenate the receiver and ==aDescription== to one composed description. Answer a description container containing both descriptions."	^ self asContainer copy		addAll: aDescription asContainer;		yourself! !!MADescription methodsFor: 'operators' stamp: 'lr 4/10/2007 21:33'!<= anObject	"Answer whether the receiver should precede ==anObject== in a priority container."	^ self priority <= anObject priority! !!MADescription methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!= anObject	^ super = anObject		and: [ self accessor = anObject accessor ]! !!MADescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitDescription: self! !!MADescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!accessor	"Answer the access-strategy of the model-value described by the receiver."	^ accessor ifNil: [ accessor := self class defaultAccessor ]! !!MADescription methodsFor: 'accessing' stamp: 'lr 4/10/2008 13:34'!accessor: anObject	accessor := anObject asAccessor! !!MADescription methodsFor: 'validation' stamp: 'jf 9/30/2009 01:10'!addCondition: aCondition 	self 		addCondition: aCondition		labelled: aCondition greaseString! !!MADescription methodsFor: 'validation' stamp: 'lr 2/5/2009 12:25'!addCondition: aCondition labelled: aString	"Add ==aCondition== as an additional validation condition to the receiver and give it the label ==aString==. The first argument is either a block-context or any other object that responds to ==#value:== with ==true== or ==false==."	self conditions: (self conditions		copyWith: (Association			key: aCondition			value: aString))! !!MADescription methodsFor: 'converting' stamp: 'lr 3/9/2006 11:32'!asContainer	"Answer a description container of the receiver."	self subclassResponsibility! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beHidden	self visible: false! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beOptional	self required: false! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beReadonly	self readonly: true! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beRequired	self required: true! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beVisible	self visible: true! !!MADescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beWriteable	self readonly: false! !!MADescription methodsFor: 'accessors' stamp: 'kph 6/9/2008 17:50'!chainAccessor: anArray	"Uses ==anArray== of selectors to read from the model."	self accessor: (MAChainAccessor accessors: anArray)! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!comment	"Answer a comment or help-text giving a hint what this description is used for. GUIs that are built from this description might display it as a tool-tip."	^ self propertyAt: #comment ifAbsent: [ self class defaultComment ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!comment: aString	self propertyAt: #comment put: aString! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 2/5/2009 12:24'!conditions	"Answer a collection of additional conditions that need to be fulfilled so that the described model is valid. Internally the collection associates conditions with an error string."	^ self propertyAt: #conditions ifAbsent: [ self class defaultConditions ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!conditions: anArray	self propertyAt: #conditions put: anArray! !!MADescription methodsFor: 'accessing-messages' stamp: 'lr 11/14/2006 17:42'!conflictErrorMessage	^ self propertyAt: #conflictErrorMessage ifAbsent: [ 'Input is conflicting with concurrent modification' ]! !!MADescription methodsFor: 'accessing-messages' stamp: 'lr 3/25/2009 19:29'!conflictErrorMessage: aString	self propertyAt: #conflictErrorMessage put: aString! !!MADescription methodsFor: 'accessing' stamp: 'lr 12/7/2006 15:44'!default	^ nil! !!MADescription methodsFor: 'accessing' stamp: 'lr 12/7/2006 15:44'!default: anObject! !!MADescription methodsFor: 'owning object' stamp: 'NickAger 2/3/2012 13:55'!describedObject	^ MADynamicDescribedObject value! !!MADescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:15'!descriptionComment	<magritteDescription>	^ MAMemoDescription new		accessor: #comment;		label: 'Comment';		priority: 110;		default: self class defaultComment;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:42'!descriptionDefault	<magritteDescription>	^ self class isAbstract		ifFalse: [ 			self class new				accessor: #default;				label: 'Default';				priority: 130;				default: self class defaultDefault;				yourself ]! !!MADescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:15'!descriptionGroup	<magritteDescription>	^ MAStringDescription new		accessor: #group;		default: self class defaultGroup;		label: 'Group';		priority: 105;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:16'!descriptionLabel	<magritteDescription>	^ MAStringDescription new		accessor: #label;		label: 'Label';		priority: 100;		default: self class defaultLabel;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 17:27'!descriptionName	<magritteDescription>	^ MAStringDescription new		accessor: #name;		label: 'Kind';		priority: 0;		beReadonly;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:16'!descriptionPriority	<magritteDescription>	^ MANumberDescription new		accessor: #priority;		label: 'Priority';		priority: 130;		default: self class defaultPriority;		beRequired;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:16'!descriptionReadonly	<magritteDescription>	^ MABooleanDescription new		accessor: #readonly;		label: 'Readonly';		priority: 200;		default: self class defaultReadonly;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:16'!descriptionRequired	<magritteDescription>	^ MABooleanDescription new		accessor: #required;		label: 'Required';		priority: 220;		default: self class defaultRequired;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/18/2012 16:55'!descriptionStringReader	<magritteDescription>	^ MASingleOptionDescription new		accessor: #stringReader;		label: 'String Reader';		priority: 300;		default: self class defaultStringReader;		options: self class defaultStringReader withAllSubclasses;		reference: MAClassDescription new;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/18/2012 16:56'!descriptionStringWriter	<magritteDescription>	^ MASingleOptionDescription new		accessor: #stringWriter;		label: 'String Writer';		priority: 310;		default: self class defaultStringWriter;		options: self class defaultStringWriter withAllSubclasses;		reference: MAClassDescription new;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:16'!descriptionUndefined	<magritteDescription>	^ MAStringDescription new		accessor: #undefined;		label: 'Undefined String';		priority: 140;		default: self class defaultUndefined;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/18/2012 16:56'!descriptionValidator	<magritteDescription>	^ MASingleOptionDescription new		accessor: #validator;		label: 'Validator';		priority: 250;		default: self class defaultValidator;		options: self class defaultValidator withAllSubclasses;		reference: MAClassDescription new;		yourself! !!MADescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:17'!descriptionVisible	<magritteDescription>	^ MABooleanDescription new		accessor: #visible;		label: 'Visible';		priority: 210;		default: self class defaultVisible;		yourself! !!MADescription methodsFor: 'strings' stamp: 'lr 4/10/2007 21:33'!fromString: aString	"Answer an object being parsed from ==aString==."	^ self fromString: aString reader: self stringReader! !!MADescription methodsFor: 'strings' stamp: 'lr 9/12/2007 17:26'!fromString: aString reader: aParser	"Answer an object being parsed from ==aString== using ==aParser==."	^ aParser read: aString readStream description: self! !!MADescription methodsFor: 'strings' stamp: 'lr 4/10/2007 21:33'!fromStringCollection: aCollection	"Answer a collection of objects being parsed from ==aCollection== of strings."	^ self fromStringCollection: aCollection reader: self stringReader! !!MADescription methodsFor: 'strings' stamp: 'lr 4/10/2007 21:34'!fromStringCollection: aCollection reader: aParser	"Answer a collection of objects being parsed from ==aCollection== of strings using ==aParser==."	^ aCollection collect: [ :each | self fromString: each reader: aParser ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 2/8/2009 19:20'!group	"Answer the group of the receiving description. The group is a string used to categorize and group descriptions. Certain display interpreters with be able to use this information to improve the usability."	^ self propertyAt: #group ifAbsent: [ self class defaultGroup ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/25/2009 19:30'!group: aString	"Answer the group of the receiving description. The group is a string used to categorize and group descriptions. Certain display interpreters with be able to use this information to improve the usability."	self propertyAt: #group put: aString! !!MADescription methodsFor: 'testing' stamp: 'lr 4/10/2007 21:34'!hasChildren	"Answer ==true== if the receiver has any child-descriptions. A description container usually has children."	^ false! !!MADescription methodsFor: 'testing' stamp: 'lr 8/13/2008 23:48'!hasComment	"Answer ==true== if the the receiver has got a non empty comment."	^ self comment notNil and: [ self comment isEmpty not ]! !!MADescription methodsFor: 'testing' stamp: 'lr 8/13/2008 23:48'!hasLabel	"Answer ==true== if the the receiver has got a non empty label."	^ self label notNil and: [ self label isEmpty not ]! !!MADescription methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ super hash bitXor: self accessor hash! !!MADescription methodsFor: 'testing' stamp: 'lr 4/10/2007 21:34'!isContainer	"Answer ==true== if the receiver is a description container."	^ false! !!MADescription methodsFor: 'testing' stamp: 'lr 4/10/2007 21:34'!isDescription	"Answer ==true== if the receiver is a description."	^ true! !!MADescription methodsFor: 'testing' stamp: 'lr 7/25/2008 17:33'!isGrouped	^ false! !!MADescription methodsFor: 'accessing' stamp: 'NickAger 2/3/2012 16:14'!isKindDefined	^ self propertyAt: #kind ifPresent: [ :theKind | true] ifAbsent: [ false ]! !!MADescription methodsFor: 'testing' stamp: 'lr 6/2/2006 09:18'!isReadonly	^ self readonly! !!MADescription methodsFor: 'testing' stamp: 'lr 6/2/2006 09:18'!isRequired	^ self required! !!MADescription methodsFor: 'validation' stamp: 'lr 4/10/2007 21:34'!isSatisfiedBy: anObject	"Answer ==true== if ==anObject== is a valid instance of the receiver's description."	[ self validate: anObject ]		on: MAValidationError		do: [ :err | ^ false ].	^ true! !!MADescription methodsFor: 'testing' stamp: 'lr 8/18/2007 11:14'!isSortable	"Answer ==true== if the described object can be trivially sorted, e.g. it answers to #<=."	^ false! !!MADescription methodsFor: 'testing' stamp: 'lr 6/2/2006 09:18'!isVisible	^ self visible! !!MADescription methodsFor: 'accessing' stamp: 'DiegoLont 3/18/2014 15:09'!kind	"Answer the base-class (type) the receiver is describing. The default implementation answers the most generic class: Object, the root of the Smalltalk class hierarchy. Subclasses might refine this choice."	^ self propertyAt: #kind ifAbsent: [ self class defaultKind ]! !!MADescription methodsFor: 'accessing' stamp: 'lr 9/3/2009 17:22'!kind: aClass	self propertyAt: #kind put: aClass! !!MADescription methodsFor: 'accessing-messages' stamp: 'lr 11/14/2006 17:42'!kindErrorMessage	^ self propertyAt: #kindErrorMessage ifAbsent: [ 'Invalid input given' ]! !!MADescription methodsFor: 'accessing-messages' stamp: 'lr 3/25/2009 19:29'!kindErrorMessage: aString	self propertyAt: #kindErrorMessage put: aString! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!label	"Answer the label of the receiving description. The label is mostly used as an identifier that is printed next to the input field when building a GUI from the receiver."	^ self propertyAt: #label ifAbsent: [ self class defaultLabel ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!label: aString	self propertyAt: #label put: aString! !!MADescription methodsFor: 'accessing-messages' stamp: 'lr 11/14/2006 17:42'!multipleErrorsMessage	^ self propertyAt: #multipleErrorsMessage ifAbsent: [ 'Multiple errors' ]! !!MADescription methodsFor: 'accessing-messages' stamp: 'lr 3/25/2009 19:29'!multipleErrorsMessage: aString	self propertyAt: #multipleErrorsMessage put: aString! !!MADescription methodsFor: 'accessing-configuration' stamp: 'lr 4/10/2006 10:31'!name	"Answer the name of the description, a human-readable string describing the type."	^ self class label! !!MADescription methodsFor: 'copying' stamp: 'lr 3/26/2007 11:45'!postCopy	super postCopy.	accessor := accessor copy! !!MADescription methodsFor: 'printing' stamp: 'lr 3/9/2006 11:32'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' label: '; print: self label.	aStream nextPutAll: ' comment: '; print: self comment! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 5/29/2006 09:19'!priority	"Answer a number that is the priority of the receiving description. Priorities are used to give descriptions an explicit order by sorting them according to this number."	^ self propertyAt: #priority ifAbsent: [ self class defaultPriority ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!priority: aNumber	self propertyAt: #priority put: aNumber! !!MADescription methodsFor: 'accessors' stamp: 'lr 7/8/2008 08:31'!propertyAccessor: aSelector	"Uses ==aSelector== to read from the property dictionary of the model."	self accessor: ((MAChainAccessor on: #properties) 		accessor: (MADictionaryAccessor key: aSelector))! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 4/10/2007 21:35'!readonly	"Answer ==true== if the model described by the receiver is read-only."	^ self propertyAt: #readonly ifAbsent: [ self class defaultReadonly ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!readonly: aBoolean	self propertyAt: #readonly put: aBoolean! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 4/10/2007 21:35'!required	"Answer ==true== if the model described by the receiver is required, this is it cannot be ==nil==."	^ self propertyAt: #required ifAbsent: [ self class defaultRequired ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!required: aBoolean	self propertyAt: #required put: aBoolean! !!MADescription methodsFor: 'accessing-messages' stamp: 'lr 11/14/2006 17:44'!requiredErrorMessage	^ self propertyAt: #requiredErrorMessage ifAbsent: [ 'Input is required but no input given' ]! !!MADescription methodsFor: 'accessing-messages' stamp: 'lr 3/25/2009 19:30'!requiredErrorMessage: aString	self propertyAt: #requiredErrorMessage put: aString! !!MADescription methodsFor: 'accessors' stamp: 'lr 9/12/2007 17:26'!selectorAccessor: aSelector	"Uses ==aSelector== to read from the model."	self accessor: (MASelectorAccessor selector: aSelector)! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 6/2/2006 09:07'!stringReader	"Answer a Visitor that can be used to parse the model described by the receiver from a string."	^ self propertyAt: #stringReader ifAbsent: [ self class defaultStringReader ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 3/9/2006 11:32'!stringReader: aClass	self propertyAt: #stringReader put: aClass! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 6/2/2006 09:10'!stringWriter	"Answer a Visitor that can be used to convert the model described by the receiver to a string."	^ self propertyAt: #stringWriter ifAbsent: [ self class defaultStringWriter ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 3/9/2006 11:32'!stringWriter: aClass	self propertyAt: #stringWriter put: aClass! !!MADescription methodsFor: 'strings' stamp: 'lr 4/10/2007 21:35'!toString: anObject	"Answer a string being formatted from ==anObject==."	^ self toString: anObject writer: self stringWriter! !!MADescription methodsFor: 'strings' stamp: 'lr 4/10/2007 21:35'!toString: anObject writer: aFormatter	"Answer a string being formatted from ==anObject== using ==aFormatter==."	^ aFormatter write: anObject description: self! !!MADescription methodsFor: 'strings' stamp: 'lr 4/10/2007 21:36'!toStringCollection: aCollection	"Answer a collection of strings being formatted from ==aCollection==."	^ self toStringCollection: aCollection writer: self stringWriter! !!MADescription methodsFor: 'strings' stamp: 'lr 4/10/2007 21:36'!toStringCollection: aCollection writer: aFormatter	"Answer a collection of strings being formatted from ==aCollection== using ==aFormatter==."	^ aCollection collect: [ :each | self toString: each writer: aFormatter ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 4/10/2007 21:37'!undefined	"Answer a string that is printed whenever the model described by the receiver is ==nil==."	^ (self propertyAt: #undefined ifAbsent: [ self class defaultUndefined ])		ifNil: [ self class defaultUndefined ]! !!MADescription methodsFor: 'accessing-strings' stamp: 'lr 3/9/2006 11:32'!undefined: aString	self propertyAt: #undefined put: aString! !!MADescription methodsFor: 'validation' stamp: 'lr 9/12/2007 17:26'!validate: anObject	"Validate ==anObject== in the context of the describing-receiver, raises an error in case of a problem. If ==anObject== is ==nil== and not required, most tests will be skipped. Do not override this message, instead have a look at ==#validateSpecific:== what is usually a better place to define the behaviour your description requires."	self validator on: anObject description: self! !!MADescription methodsFor: 'validation-private' stamp: 'lr 4/10/2007 21:38'!validateConditions: anObject	"Validate ==anObject== to satisfy all its custom conditions."	self conditions do: [ :each |		(each key value: anObject)			ifFalse: [ MAConditionError description: self signal: each value ] ]! !!MADescription methodsFor: 'validation-private' stamp: 'lr 4/10/2007 21:39'!validateKind: anObject	"Validate ==anObject== to be of the right kind."	(anObject isKindOf: self kind)		ifFalse: [ MAKindError description: self signal: self kindErrorMessage ]! !!MADescription methodsFor: 'validation-private' stamp: 'lr 4/10/2007 21:39'!validateRequired: anObject	"Validate ==anObject== not to be ==nil== if it is required."	(self isRequired and: [ anObject isNil ])		ifTrue: [ MARequiredError description: self signal: self requiredErrorMessage ]! !!MADescription methodsFor: 'validation-private' stamp: 'lr 4/10/2007 21:39'!validateSpecific: anObject	"Validate ==anObject== to satisfy its descriptions specific validation rules. Subclasses mostly want to override this method."! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 2/16/2007 08:39'!validator	"Answer a Visitor that can be used to validate the model described by the receiver."	^ self propertyAt: #validator ifAbsent: [ self class defaultValidator ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 2/16/2007 08:39'!validator: aClass	self propertyAt: #validator put: aClass! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 4/10/2007 21:39'!visible	"Answer ==true== if the model described by the receiver is visible, as an opposite to hidden."	^ self propertyAt: #visible ifAbsent: [ self class defaultVisible ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!visible: aBoolean	self propertyAt: #visible put: aBoolean! !!MADescription methodsFor: 'accessing-properties' stamp: 'StephanEggermont 4/16/2015 10:02'!visibleInReport	^self propertyAt: #visibleInReport ifAbsent: [ self class defaultVisibleInReport ]! !!MADescription methodsFor: 'accessing-properties' stamp: 'EstebanMaringolo 11/21/2014 16:26'!visibleInReport: aBoolean 	self propertyAt: #visibleInReport put: aBoolean! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultFalseString	^ self defaultFalseStrings first! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultFalseStrings	^ #( 'false' 'f' 'no' 'n' '0' 'off' )! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ Boolean! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultTrueString	^ self defaultTrueStrings first! !!MABooleanDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:32'!defaultTrueStrings	^ #( 'true' 't' 'yes' 'y' '1' 'on' )! !!MABooleanDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MABooleanDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!label	^ 'Boolean'! !!MABooleanDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitBooleanDescription: self! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'lr 3/9/2006 11:31'!allOptions	^ self options! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'lr 3/9/2006 11:31'!allOptionsWith: anObject	^ self options! !!MABooleanDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:13'!descriptionFalseString	<magritteDescription>	^ MAStringDescription new		accessor: #falseString;		default: self class defaultFalseString;		label: 'False String';		priority: 410;		yourself! !!MABooleanDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 17:27'!descriptionRequired	<magritteDescription>	^ nil! !!MABooleanDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:14'!descriptionTrueString	<magritteDescription>	^ MAStringDescription new		accessor: #trueString;		default: self class defaultTrueString;		label: 'True String';		priority: 400;		yourself! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:31'!falseString	^ self propertyAt: #falseString ifAbsent: [ self class defaultFalseString ]! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'lr 3/25/2009 19:30'!falseString: aString	self propertyAt: #falseString put: aString! !!MABooleanDescription methodsFor: 'accessing-readonly' stamp: 'lr 3/9/2006 11:31'!falseStrings	^ self class defaultFalseStrings! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'lr 3/9/2006 11:31'!isExtensible	^ false! !!MABooleanDescription methodsFor: 'private' stamp: 'lr 4/21/2007 17:45'!labelForOption: anObject	anObject == true		ifTrue: [ ^ self trueString ].	anObject == false		ifTrue: [ ^ self falseString ].	^ self undefined! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'lr 3/9/2006 11:31'!options	^ Array with: false with: true! !!MABooleanDescription methodsFor: 'accessing-selection' stamp: 'lr 3/9/2006 11:31'!reference	^ self! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:31'!trueString	^ self propertyAt: #trueString ifAbsent: [ self class defaultTrueString ]! !!MABooleanDescription methodsFor: 'accessing-properties' stamp: 'lr 3/25/2009 19:30'!trueString: aString	self propertyAt: #trueString put: aString! !!MABooleanDescription methodsFor: 'accessing-readonly' stamp: 'lr 3/9/2006 11:31'!trueStrings	^ self class defaultTrueStrings! !!MAClassDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ Class! !!MAClassDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAClassDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!label	^ 'Class'! !!MAClassDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitClassDescription: self! !!MAColorDescription class methodsFor: 'accessing-defaults' stamp: 'jf 9/30/2009 00:19'!defaultKind	^ GRPlatform current magritteColorClass! !!MAColorDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MAColorDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!label	^ 'Color'! !!MAColorDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitColorDescription: self! !!MAElementDescription class methodsFor: 'accessing-defaults' stamp: 'SeanDeNigris 10/8/2013 18:25'!defaultDisplayProperty	^ #greaseString! !!MAElementDescription class methodsFor: 'instance creation' stamp: 'NickAger 1/17/2012 12:48'!new	"override #new so that we can create an object without adding it to the collection returned by: MAElementDescription withAllConcreteClasses,	that is so we can call  MAElementDescription new magritteDescription  and it works as expected, which is used in MADescriptionEditor>>#buildReport .	Yes it's a hack, but it works... (better ideas gratefully received)"	^ self basicNew initialize! !!MAElementDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitElementDescription: self! !!MAElementDescription methodsFor: 'converting' stamp: 'lr 3/9/2006 11:32'!asContainer	^ MAContainer with: self! !!MAElementDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!default	^ self propertyAt: #default ifAbsent: [ self class defaultDefault ]! !!MAElementDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!default: anObject	self propertyAt: #default put: anObject! !!MAElementDescription methodsFor: 'accessing-properties' stamp: 'SeanDeNigris 10/8/2013 18:20'!display: aBlockOrSymbol	"Transform how the file is converted to a string.	aSymbol		- is performed on the object	aBlock		- takes one argument, which is the domain object		- returns the string to display"	self propertyAt: #displayBlockOrSymbol put: aBlockOrSymbol.! !!MAElementDescription methodsFor: 'accessing-properties' stamp: 'SeanDeNigris 10/8/2013 18:25'!displayBlockOrSymbol	^self propertyAt: #displayBlockOrSymbol ifAbsent: [ self class defaultDisplayProperty ]! !!MAElementDescription methodsFor: 'displaying' stamp: 'SeanDeNigris 10/8/2013 18:20'!displayStringFor: anObject	"Convert object to a string. If a block was passed to #display: use that, otherwise send #greaseString by default"	^self displayBlockOrSymbol value: anObject.! !!MADirectoryDescription class methodsFor: 'acessing' stamp: 'StephanEggermont 4/16/2015 10:25'!label	^'Directory'! !!MADirectoryDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitDirectoryDescription: self! !!MAFileDescription class methodsFor: 'accessing-defaults' stamp: 'SeanDeNigris 11/21/2013 22:08'!defaultDisplayProperty	^ [ :e | e fullName ].! !!MAFileDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:32'!defaultKind	^ MAMemoryFileModel! !!MAFileDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAFileDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'File'! !!MAFileDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitFileDescription: self! !!MAFileDescription methodsFor: 'accessing' stamp: 'SeanDeNigris 9/29/2013 10:28'!defaultDirectory	^ self propertyAt: #defaultDirectory ifAbsent: [ MAFileSystem imageDirectory ].! !!MAFileDescription methodsFor: 'accessing' stamp: 'SeanDeNigris 9/29/2013 10:57'!defaultDirectory: fileReference	"fileReference - a FileSystem FileReference, or an MAFileReference if FileSystem is not installed"	self propertyAt: #defaultDirectory put: fileReference! !!MADateAndTimeDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ DateAndTime! !!MADateAndTimeDescription class methodsFor: 'testing' stamp: 'pmm 8/31/2009 20:07'!isAbstract	^ false! !!MADateAndTimeDescription class methodsFor: 'accessing' stamp: 'pmm 8/31/2009 20:13'!label	^ 'Date and Time'! !!MADateAndTimeDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitDateAndTimeDescription: self! !!MADateDescription class methodsFor: 'accessing-defaults' stamp: 'SeanDeNigris 7/28/2015 16:52'!defaultDisplayProperty	^ [ :aDateOrNil | 				aDateOrNil					ifNotNil: [ aDateOrNil greaseString ]					ifNil: [ '' ] ]! !!MADateDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ Date! !!MADateDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MADateDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!label	^ 'Date'! !!MADateDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitDateDescription: self! !!MADurationDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ Duration! !!MADurationDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MADurationDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Duration'! !!MADurationDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitDurationDescription: self! !!MAMagnitudeDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMax	^ nil! !!MAMagnitudeDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMin	^ nil! !!MAMagnitudeDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitMagnitudeDescription: self! !!MAMagnitudeDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 19:00'!descriptionMax	<magritteDescription>	^ self class new		accessor: #max;		label: 'Maximum';		priority: 410;		yourself! !!MAMagnitudeDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 19:01'!descriptionMin	<magritteDescription>	^ self class new		accessor: #min;		label: 'Min';		priority: 400;		yourself! !!MAMagnitudeDescription methodsFor: 'testing' stamp: 'lr 8/18/2007 10:47'!isSortable	^ true! !!MAMagnitudeDescription methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isWithinRange: anObject	^ (self min isNil or: [ self min <= anObject ])		and: [ self max isNil or: [ self max >= anObject ] ]! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!max	^ self propertyAt: #max ifAbsent: [ self class defaultMax ]! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'lr 3/25/2009 19:31'!max: aMagnitudeOrNil	"Set the maximum for accepted values, or ==nil== if open."	self propertyAt: #max put: aMagnitudeOrNil! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!min	^ self propertyAt: #min ifAbsent: [ self class defaultMin ]! !!MAMagnitudeDescription methodsFor: 'accessing' stamp: 'lr 3/25/2009 19:31'!min: aMagnitudeOrNil	"Set the minimum for accepted values, or ==nil== if open."	self propertyAt: #min put: aMagnitudeOrNil! !!MAMagnitudeDescription methodsFor: 'conveniance' stamp: 'lr 4/10/2007 21:40'!min: aMinimumObject max: aMaximumObject	"Set the minimum and maximum of accepted values, or ==nil== if open."	self min: aMinimumObject; max: aMaximumObject! !!MAMagnitudeDescription methodsFor: 'accessing-messages' stamp: 'lr 7/25/2008 17:46'!rangeErrorMessage	| min max |	^ self propertyAt: #rangeErrorMessage ifAbsent: [		min := self toString: self min. max := self toString: self max.		(self min notNil and: [ self max notNil ])			ifTrue: [ ^ 'Input must be between ' , min , ' and ' , max ].		(self min notNil and: [ self max isNil ])			ifTrue: [ ^ 'Input must be above or equeal to ' , min ].		(self min isNil and: [ self max notNil ])			ifTrue: [ ^ 'Input must be below or equal to ' , max ] ]! !!MAMagnitudeDescription methodsFor: 'accessing-messages' stamp: 'lr 3/25/2009 19:31'!rangeErrorMessage: aString	self propertyAt: #rangeErrorMessage put: aString! !!MAMagnitudeDescription methodsFor: 'validation-private' stamp: 'lr 9/12/2007 17:27'!validateSpecific: anObject	super validateSpecific: anObject.	(self isWithinRange: anObject)		ifFalse: [ MARangeError description: self signal: self rangeErrorMessage ]! !!MANumberDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ Number! !!MANumberDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MANumberDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Number'! !!MANumberDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitNumberDescription: self! !!MANumberDescription methodsFor: 'convenience' stamp: 'lr 2/5/2009 21:16'!beInteger	self addCondition: (MACondition selector: #isInteger) labelled: 'No integer was entered'! !!MANumberDescription methodsFor: 'convenience' stamp: 'lr 2/5/2009 21:16'!beNegative	self addCondition: (MACondition selector: #negative) labelled: 'No negative number was entered'! !!MANumberDescription methodsFor: 'convenience' stamp: 'lr 2/5/2009 21:16'!bePositive	self addCondition: (MACondition selector: #positive) labelled: 'No positive number was entered'! !!MATimeDescription class methodsFor: 'accessing-defaults' stamp: 'SeanDeNigris 11/21/2013 22:09'!defaultDisplayProperty	^ [ :time | 		time hour greaseString, ':',		time minute greaseString, ':',		time second greaseString ].! !!MATimeDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ Time! !!MATimeDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MATimeDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Time'! !!MATimeDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitTimeDescription: self! !!MATimeStampDescription class methodsFor: 'accessing-defaults' stamp: 'jf 9/30/2009 00:19'!defaultKind	^ GRPlatform current magritteTimeStampClass! !!MATimeStampDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MATimeStampDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Timestamp'! !!MATimeStampDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitTimeStampDescription: self! !!MAMultipleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultDistinct	^ false! !!MAMultipleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ Collection! !!MAMultipleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultOrdered	^ false! !!MAMultipleOptionDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAMultipleOptionDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Multiple-Option'! !!MAMultipleOptionDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitMultipleOptionDescription: self! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beDistinct	self distinct: true! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beIndefinite	self distinct: false! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beOrdered	self ordered: true! !!MAMultipleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beUnordered	self ordered: false! !!MAMultipleOptionDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:18'!descriptionDistinct	<magritteDescription>	^ MABooleanDescription new		accessor: #distinct;		label: 'Distinct';		priority: 250;		default: self class defaultDistinct;		yourself! !!MAMultipleOptionDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:19'!descriptionOrdered	<magritteDescription>	^ MABooleanDescription new		accessor: #ordered;		label: 'Ordered';		priority: 260;		default: self class defaultOrdered;		yourself! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!distinct	^ self propertyAt: #distinct ifAbsent: [ self class defaultDistinct ]! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!distinct: aBoolean	self propertyAt: #distinct put: aBoolean! !!MAMultipleOptionDescription methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isDistinct	^ self distinct! !!MAMultipleOptionDescription methodsFor: 'testing' stamp: 'DiegoLont 6/4/2014 14:36'!isMultiple	^true! !!MAMultipleOptionDescription methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isOrdered	^ self ordered! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!ordered	^ self propertyAt: #ordered ifAbsent: [ self class defaultOrdered ]! !!MAMultipleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!ordered: aBoolean	self propertyAt: #ordered put: aBoolean! !!MAMultipleOptionDescription methodsFor: 'validating' stamp: 'lr 11/14/2006 17:59'!validateKind: anObject	super validateKind: anObject.	(anObject allSatisfy: [ :each | self options includes: each ])		ifFalse: [ MAKindError description: self signal: self kindErrorMessage ]! !!MAMultipleOptionDescription methodsFor: 'validating' stamp: 'lr 2/16/2007 08:49'!validateRequired: anObject	super validateRequired: anObject.	(self isRequired and: [ anObject isCollection and: [ anObject isEmpty ] ])		ifTrue: [ MARequiredError description: self signal: self requiredErrorMessage ]! !!MAOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultOptions	^ OrderedCollection new! !!MAOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultSorted	^ false! !!MAOptionDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitOptionDescription: self! !!MAOptionDescription methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!allOptions	^ self prepareOptions: self options copy! !!MAOptionDescription methodsFor: 'accessing-dynamic' stamp: 'lr 5/5/2006 19:31'!allOptionsWith: anObject	^ self prepareOptions: ((self shouldNotInclude: anObject)		ifFalse: [ self options copyWith: anObject ]		ifTrue: [ self options copy ])! !!MAOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beSorted	self sorted: true! !!MAOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beUnsorted	self sorted: false! !!MAOptionDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 17:27'!descriptionDefault	<magritteDescription>	^ nil! !!MAOptionDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:19'!descriptionOptions	<magritteDescription>	^ MAMemoDescription new		accessor: #optionsTextual;		label: 'Options';		priority: 410;		default: self class defaultOptions;		yourself! !!MAOptionDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:19'!descriptionSorted	<magritteDescription>	^ MABooleanDescription new		accessor: #sorted;		label: 'Sorted';		priority: 240;		default: self class defaultSorted;		yourself! !!MAOptionDescription methodsFor: 'testing' stamp: 'DiegoLont 6/4/2014 14:36'!isMultiple	^false! !!MAOptionDescription methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isSorted	^ self sorted! !!MAOptionDescription methodsFor: 'private' stamp: 'DiegoLont 1/24/2014 10:43'!labelForOption: anObject	self propertyAt: #labels ifPresent: [ :labels | labels optionFor: anObject ifPresent: [ :value | ^value ] ].	^ self reference toString: anObject! !!MAOptionDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!options	^ options ifNil: [ options := self class defaultOptions ]! !!MAOptionDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!options: anArray	options := anArray! !!MAOptionDescription methodsFor: 'accessing' stamp: 'lr 9/12/2007 17:27'!optionsAndLabels: aCollection	"Set the options to be the keys of aCollection and the labels to be the values of aCollection."	self options: (aCollection collect: [ :assoc | assoc key ]).	self propertyAt: #labels put: (aCollection		inject: IdentityDictionary new		into: [ :result :assoc | result add: assoc; yourself ])! !!MAOptionDescription methodsFor: 'accessing-textual' stamp: 'lr 3/9/2006 11:32'!optionsTextual	^ (self reference toStringCollection: self options)		asMultilineString! !!MAOptionDescription methodsFor: 'accessing-textual' stamp: 'lr 4/21/2007 18:30'!optionsTextual: aString	| lines |	lines := (aString ifNil: [ String new ]) lines.	^ self options: (self reference fromStringCollection: lines)! !!MAOptionDescription methodsFor: 'copying' stamp: 'lr 3/26/2007 11:45'!postCopy	super postCopy.	options := options copy! !!MAOptionDescription methodsFor: 'private' stamp: 'lr 9/24/2007 19:18'!prepareOptions: aCollection	^ self isSorted		ifFalse: [ aCollection asArray ]		ifTrue: [ 			aCollection asArray				sort: self sortBlock;				yourself ]! !!MAOptionDescription methodsFor: 'accessing-dynamic' stamp: 'lr 5/5/2006 19:31'!shouldNotInclude: anObject	^ anObject isNil or: [ self options includes: anObject ]! !!MAOptionDescription methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!sortBlock	^ [ :a :b | (self reference toString: a) caseInsensitiveLessOrEqual: (self reference toString: b) ]! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!sorted	^ self propertyAt: #sorted ifAbsent: [ self class defaultSorted ]! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/25/2009 19:31'!sorted: aBoolean	self propertyAt: #sorted put: aBoolean! !!MAOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!undefined: aString	super undefined: aString.	self reference isNil		ifFalse: [ self reference undefined: aString ]! !!MASingleOptionDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultExtensible	^ false! !!MASingleOptionDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MASingleOptionDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Single-Option'! !!MASingleOptionDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitSingleOptionDescription: self! !!MASingleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beExtensible	self extensible: true! !!MASingleOptionDescription methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!beLimited	self extensible: false! !!MASingleOptionDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:20'!descriptionExtensible	<magritteDescription>	^ MABooleanDescription new		accessor: #extensible;		label: 'Extensible';		priority: 250;		default: self class defaultExtensible;		yourself! !!MASingleOptionDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 17:27'!descriptionGroupBy	<magritteDescription>	^ MASymbolDescription new		selectorAccessor: #groupBy;		label: 'Grouped by';		priority: 260;		default: nil;		yourself! !!MASingleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!extensible	^ self propertyAt: #extensible ifAbsent: [ self class defaultExtensible ]! !!MASingleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!extensible: aBoolean	self propertyAt: #extensible put: aBoolean! !!MASingleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 9/3/2008 11:43'!groupBy	^ self propertyAt: #groupBy ifAbsent: [ nil ]! !!MASingleOptionDescription methodsFor: 'accessing-properties' stamp: 'lr 3/25/2009 19:31'!groupBy: anAccessor	"anAccessor to be sent to the options objects for getting their group."		self propertyAt: #groupBy put: anAccessor asAccessor! !!MASingleOptionDescription methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isExtensible	^ self extensible! !!MASingleOptionDescription methodsFor: 'testing' stamp: 'mb 4/10/2008 00:37'!isGrouped	^ self groupBy notNil! !!MASingleOptionDescription methodsFor: 'private' stamp: 'lr 10/12/2010 13:09'!prepareOptions: aCollection	^ self isRequired		ifTrue: [ super prepareOptions: aCollection ]		ifFalse: [ (Array with: nil) , (super prepareOptions: aCollection) ]! !!MASingleOptionDescription methodsFor: 'accessing-dynamic' stamp: 'lr 10/12/2010 13:09'!shouldNotInclude: anObject	^ self isExtensible not or: [ super shouldNotInclude: anObject ]! !!MASingleOptionDescription methodsFor: 'validating' stamp: 'lr 10/12/2010 13:08'!validateKind: anObject	super validateKind: anObject.	(self options includes: anObject)		ifTrue: [ ^ self ].	self isExtensible		ifTrue: [ self reference validate: anObject ]		ifFalse: [ MAKindError description: self signal: self kindErrorMessage ]! !!MAReferenceDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultReference	^ MAStringDescription new! !!MAReferenceDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitReferenceDescription: self! !!MAReferenceDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/18/2012 16:56'!descriptionReference	<magritteDescription>	^ MAToOneRelationDescription new		accessor: #reference;		classes: MADescription withAllConcreteClasses;		label: 'Description';		priority: 400;		beRequired;		yourself! !!MAReferenceDescription methodsFor: 'copying' stamp: 'lr 3/26/2007 11:44'!postCopy	super postCopy.	reference := reference copy! !!MAReferenceDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!reference	^ reference ifNil: [ reference := self class defaultReference ]! !!MAReferenceDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!reference: aDescription	reference := aDescription! !!MARelationDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultClasses	^ Set new! !!MARelationDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultReference	^ nil! !!MARelationDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitRelationDescription: self! !!MARelationDescription methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:32'!allClasses	^ (Array withAll: self classes)		sort: [ :a :b | a label caseInsensitiveLessOrEqual: b label ];		yourself! !!MARelationDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!classes	^ classes ifNil: [ classes := self class defaultClasses ]! !!MARelationDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!classes: aCollection	classes := aCollection! !!MARelationDescription methodsFor: 'accessing-dynamic' stamp: 'NickAger 1/31/2012 17:47'!commonClass	"Answer a common superclass of the classes of the receiver. The algorithm is implemented to be as efficient as possible. The inner loop will be only executed the first few iterations."	| current |	self classes isEmpty		ifTrue: [ ^ self descriptionContainer ].	current := self classes anyOne.	self classes do: [ :each |		[ each includesBehavior: current ]			whileFalse: [ current := current superclass ] ].	^ current! !!MARelationDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/18/2012 16:57'!descriptionClasses	<magritteDescription>	^ MAMultipleOptionDescription new		accessor: #classes;		label: 'Classes';		priority: 400;		options: Smalltalk allClasses;		reference: MAClassDescription new;		yourself! !!MARelationDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/18/2012 16:57'!descriptionReference	<magritteDescription>	^ super descriptionReference		classes: MAContainer withAllConcreteClasses;		beOptional;		yourself! !!MARelationDescription methodsFor: 'accessing' stamp: 'SeanDeNigris 8/12/2015 00:39'!initializer	^ self propertyAt: #initializer ifAbsent: [ #yourself ]! !!MARelationDescription methodsFor: 'accessing' stamp: 'SeanDeNigris 8/12/2015 00:39'!initializer: valuable	self propertyAt: #initializer put: valuable! !!MARelationDescription methodsFor: 'copying' stamp: 'lr 3/26/2007 11:45'!postCopy	super postCopy.	classes := classes copy! !!MARelationDescription methodsFor: 'accessing-dynamic' stamp: 'StephanEggermont 8/25/2014 16:36'!reference	"The reference within a ==*MARelationDescription*== is calculated automatically from all the classes of the receiver, if set to ==nil==. By setting the reference to a ==*MAContainer*== instance it is possible to customize the reference description."	^ super reference ifNil: [ self commonClass magritteTemplate magritteDescription ]! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'dc 4/16/2006 18:53'!defaultDefinitive	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:24'!defaultKind	^ Collection! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'dc 4/15/2006 15:02'!defaultOrdered	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing-defaults' stamp: 'dc 4/16/2006 19:16'!defaultSorted	^ false! !!MAToManyRelationDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAToManyRelationDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ '1:m Relation'! !!MAToManyRelationDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitToManyRelationDescription: self! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/16/2006 18:51'!beDefinitive	self definitive: true! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/16/2006 18:56'!beModifiable	self definitive: false! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/15/2006 15:01'!beOrdered	self ordered: true! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/16/2006 19:16'!beSorted	self sorted: true! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/15/2006 15:01'!beUnordered	self ordered: false! !!MAToManyRelationDescription methodsFor: 'actions' stamp: 'dc 4/16/2006 19:16'!beUnsorted	self sorted: false! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'SeanDeNigris 6/8/2013 14:28'!definitive	"Return true if the field is non-modifiable"	^ self propertyAt: #definitive ifAbsent: [ self class defaultDefinitive ]! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'dc 4/16/2006 18:51'!definitive: aBoolean	self propertyAt: #definitive put: aBoolean! !!MAToManyRelationDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:21'!descriptionDefinitive	<magritteDescription>	^ MABooleanDescription new		accessor: #definitive;		label: 'Definitive';		priority: 265;		default: self class defaultDefinitive;		yourself! !!MAToManyRelationDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:21'!descriptionOrdered	<magritteDescription>	^ MABooleanDescription new		accessor: #ordered;		label: 'Ordered';		priority: 260;		default: self class defaultOrdered;		yourself! !!MAToManyRelationDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:21'!descriptionSorted	<magritteDescription>	^ MABooleanDescription new		accessor: #sorted;		label: 'Sorted';		priority: 240;		default: self class defaultSorted;		yourself! !!MAToManyRelationDescription methodsFor: 'testing' stamp: 'SeanDeNigris 6/8/2013 14:28'!isDefinitive	"Return true if the field is non-modifiable"	^ self definitive.! !!MAToManyRelationDescription methodsFor: 'testing' stamp: 'dc 4/15/2006 15:01'!isOrdered	^ self ordered! !!MAToManyRelationDescription methodsFor: 'testing' stamp: 'dc 4/16/2006 19:15'!isSorted	^ self sorted! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'dc 4/15/2006 15:01'!ordered	^ self propertyAt: #ordered ifAbsent: [ self class defaultOrdered ]! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'dc 4/15/2006 15:01'!ordered: aBoolean	self propertyAt: #ordered put: aBoolean! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'dc 4/16/2006 19:15'!sorted	^ self propertyAt: #sorted ifAbsent: [ self class defaultSorted ]! !!MAToManyRelationDescription methodsFor: 'accessing-properties' stamp: 'lr 3/25/2009 19:32'!sorted: aBoolean	self propertyAt: #sorted put: aBoolean! !!MAToManyRelationDescription methodsFor: 'validating' stamp: 'lr 11/14/2006 18:00'!validateKind: anObject	super validateKind: anObject.	anObject do: [ :object |		(self classes anySatisfy: [ :class | object species includesBehavior: class ])			ifFalse: [ MAKindError description: self signal: self kindErrorMessage ] ]! !!MAToManyRelationDescription methodsFor: 'validating' stamp: 'lr 2/16/2007 08:50'!validateRequired: anObject	super validateRequired: anObject.	(self isRequired and: [ anObject isCollection and: [ anObject isEmpty ] ])		ifTrue: [ MARequiredError description: self signal: self requiredErrorMessage ]! !!MAToManyScalarRelationDescription class methodsFor: 'accessing' stamp: 'pmm 11/3/2006 21:09'!label	^ '1:m scalar Relation'! !!MAToManyScalarRelationDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitToManyScalarRelationDescription: self! !!MAToOneRelationDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAToOneRelationDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ '1:1 Relation'! !!MAToOneRelationDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitToOneRelationDescription: self! !!MAToOneRelationDescription methodsFor: 'ToMany compatibility' stamp: 'SeanDeNigris 8/13/2015 15:24'!isDefinitive	"I'm really not sure what this does, but we need to respond to it to get MAElementRow to work, which was copied over from ToMany"	^ false! !!MAToOneRelationDescription methodsFor: 'ToMany compatibility' stamp: 'SeanDeNigris 8/13/2015 15:32'!isOrdered	"See #isDefinitive comment"	^ false! !!MAToOneRelationDescription methodsFor: 'validating' stamp: 'lr 10/12/2010 10:01'!validateKind: anObject	super validateKind: anObject.	(self classes anySatisfy: [ :class | anObject species includesBehavior: class ])		ifFalse: [ MAKindError description: self signal: self kindErrorMessage ]! !!MATableDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultColumnLabels	^ OrderedCollection with: 'a' with: 'b' with: 'c'! !!MATableDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ MATableModel! !!MATableDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultRowLabels	^ OrderedCollection with: '1' with: '2' with: '3'! !!MATableDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MATableDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Table'! !!MATableDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitTableDescription: self! !!MATableDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!columnCount	^ self columnLabels size! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!columnLabels	^ self propertyAt: #columnLabels ifAbsent: [ self class defaultColumnLabels ]! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!columnLabels: aCollection	self propertyAt: #columnLabels put: aCollection! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'lr 3/9/2006 11:32'!columnLabelsTextual	^ (MAStringDescription new toStringCollection: self columnLabels)		asMultilineString! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'lr 3/9/2006 11:32'!columnLabelsTextual: aString	self columnLabels: (MAStringDescription new fromStringCollection: aString lines)! !!MATableDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 17:27'!descriptionColumnLabels	<magritteDescription>	^ MAMemoDescription new		accessor: #columnLabelsTextual;		label: 'Column Labels';		priority: 250;		yourself! !!MATableDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 17:27'!descriptionDefault	<magritteDescription>	^ nil! !!MATableDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 17:27'!descriptionRequired	<magritteDescription>	^ nil! !!MATableDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 17:27'!descriptionRowLabels	<magritteDescription>	^ MAMemoDescription new		accessor: #rowLabelsTextual;		label: 'Row Labels';		priority: 250;		yourself! !!MATableDescription methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!rowCount	^ self rowLabels size! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!rowLabels	^ self propertyAt: #rowLabels ifAbsent: [ self class defaultRowLabels ]! !!MATableDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!rowLabels: aCollection	self propertyAt: #rowLabels put: aCollection! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'lr 3/9/2006 11:32'!rowLabelsTextual	^ (MAStringDescription new toStringCollection: self rowLabels)		asMultilineString! !!MATableDescription methodsFor: 'accessing-textual' stamp: 'lr 3/9/2006 11:32'!rowLabelsTextual: aString	self rowLabels: (MAStringDescription new fromStringCollection: aString lines)! !!MATableDescription methodsFor: 'validation-private' stamp: 'lr 10/12/2010 13:18'!validateSpecific: anObject	| errors |	super validateSpecific: anObject.	(anObject rowCount ~= self rowCount or: [ anObject columnCount ~= self columnCount ])		ifTrue: [ MAKindError description: self signal: self kindErrorMessage ].	errors := OrderedCollection new.	anObject do: [ :row :value :each | 		[ self reference validate: each ]			on: MAValidationError			do: [ :err | errors add: err ] ].	errors isEmpty ifFalse: [		MAMultipleErrors			description: self 			errors: errors			signal: self label ]! !!MATokenDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:24'!defaultKind	^ Array! !!MATokenDescription class methodsFor: 'accessing-defaults' stamp: 'jf 9/18/2009 14:28'!defaultSeparators	^ ' ,;', (String with: Character cr with: Character lf with: Character tab)! !!MATokenDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MATokenDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Token'! !!MATokenDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitTokenDescription: self! !!MATokenDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 17:27'!descriptionSeparators	<magritteDescription>	^ MAStringDescription new		accessor: #separators;		label: 'Separators';		priority: 250;		yourself! !!MATokenDescription methodsFor: 'accessing' stamp: 'lr 2/5/2009 10:46'!separators	^ separators ifNil: [ separators := self class defaultSeparators ]! !!MATokenDescription methodsFor: 'accessing' stamp: 'lr 2/5/2009 10:57'!separators: aString	"A string with the separator characters to split tokens, the first character is used as a default for printing."	separators := aString! !!MAMemoDescription class methodsFor: 'accessing-defaults' stamp: 'lr 3/9/2006 11:33'!defaultLineCount	^ 3! !!MAMemoDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Memo'! !!MAMemoDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitMemoDescription: self! !!MAMemoDescription methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:18'!descriptionLineCount	<magritteDescription>	^ MANumberDescription new		accessor: #lineCount;		label: 'Number of Lines';		priority: 400;		default: self class defaultLineCount;		beInteger;		min: 1;		yourself! !!MAMemoDescription methodsFor: 'accessing-properties' stamp: 'lr 3/9/2006 11:32'!lineCount	^ self propertyAt: #lineCount ifAbsent: [ self class defaultLineCount ]! !!MAMemoDescription methodsFor: 'accessing-properties' stamp: 'lr 3/25/2009 19:31'!lineCount: anInteger	self propertyAt: #lineCount put: anInteger! !!MAPasswordDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Password'! !!MAPasswordDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitPasswordDescription: self! !!MAPasswordDescription methodsFor: 'testing' stamp: 'lr 9/26/2007 18:32'!isObfuscated: anObject	^ anObject notNil		and: [ anObject isString		and: [ anObject isEmpty not		and: [ anObject allSatisfy: [ :each | each = $* ] ] ] ]! !!MAPasswordDescription methodsFor: 'testing' stamp: 'lr 8/18/2007 10:47'!isSortable	^ false! !!MAPasswordDescription methodsFor: 'operators' stamp: 'lr 3/9/2006 11:32'!obfuscated: anObject	^ String new: (self toString: anObject) size withAll: $*! !!MAStringDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ String! !!MAStringDescription class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAStringDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'String'! !!MAStringDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitStringDescription: self! !!MAStringDescription methodsFor: 'testing' stamp: 'lr 8/18/2007 10:47'!isSortable	^ true! !!MASymbolDescription class methodsFor: 'accessing-defaults' stamp: 'lr 9/3/2009 17:23'!defaultKind	^ Symbol! !!MASymbolDescription class methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!label	^ 'Symbol'! !!MASymbolDescription methodsFor: 'visiting' stamp: 'StephanEggermont 4/16/2015 11:06'!acceptMagritte: aVisitor	aVisitor visitSymbolDescription: self! !!MAUrlDescription methodsFor: 'visiting' stamp: 'SeanDeNigris 8/6/2015 17:46'!acceptMagritte: aVisitor	aVisitor visitUrlDescription: self! !!MACachedMemento class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:32'!isAbstract	^ false! !!MACachedMemento methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!cache	^ cache! !!MACachedMemento methodsFor: 'actions' stamp: 'lr 3/9/2006 11:31'!commit	super commit.	self push: self cache.	self reset! !!MACachedMemento methodsFor: 'testing' stamp: 'lr 5/14/2008 20:28'!hasChanged	"Answer ==true==, if the cached data is different to the data in the model."	^ self isDifferent: self cache to: self pullRaw! !!MACachedMemento methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!readUsing: aDescription	^ self cache at: aDescription! !!MACachedMemento methodsFor: 'actions' stamp: 'lr 3/9/2006 11:31'!reset	super reset.	self setCache: self pull! !!MACachedMemento methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:31'!setCache: aDictionary	cache := aDictionary! !!MACachedMemento methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!write: anObject using: aDescription	self cache at: aDescription put: anObject! !!MACheckedMemento methodsFor: 'testing' stamp: 'lr 5/14/2008 20:26'!hasConflict	"Answer ==true==, if there is an edit conflict."	^ self hasChanged and: [ self isDifferent: self original to: self pullRaw ]! !!MACheckedMemento methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:31'!original	^ original! !!MACheckedMemento methodsFor: 'actions' stamp: 'lr 3/9/2006 11:31'!reset	super reset.	self setOriginal: self pullRaw! !!MACheckedMemento methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:31'!setOriginal: aDictionary	original := aDictionary! !!MACheckedMemento methodsFor: 'actions' stamp: 'NickAger 1/17/2012 14:26'!validate	self hasConflict		ifFalse: [ ^ super validate ].	self reset.	MAConflictError		description: self magritteDescription		signal: self magritteDescription conflictErrorMessage! !!MAMemento class methodsFor: 'instance creation' stamp: 'NickAger 1/17/2012 14:55'!model: aModel	^ self model: aModel description: aModel magritteDescription! !!MAMemento class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!model: aModel description: aDescription	^ self new		setModel: aModel;		setDescription: aDescription;		reset; yourself! !!MAMemento methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!commit	"Commit the receiver into the model."! !!MAMemento methodsFor: 'private' stamp: 'NickAger 1/17/2012 14:24'!isDifferent: firstDictionary to: secondDictionary	| firstValue secondValue |	self magritteDescription do: [ :each |		(each isVisible and: [ each isReadonly not ]) ifTrue: [			firstValue := firstDictionary at: each ifAbsent: [ nil ].			secondValue := secondDictionary at: each ifAbsent: [ nil ].			firstValue = secondValue ifFalse: [ ^ true ] ] ].	^ false! !!MAMemento methodsFor: 'accessing' stamp: 'NickAger 1/17/2012 14:24'!magritteDescription	^ description! !!MAMemento methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!model	^ model! !!MAMemento methodsFor: 'printing' stamp: 'lr 3/9/2006 11:32'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' model: '; print: self model! !!MAMemento methodsFor: 'private' stamp: 'lr 2/8/2009 19:20'!pull	"Utility method to pull the model into a dictionary mapping descriptions to values. nil values are replaced with the default ones of the model."	| result |	result := self pullRaw.	result keysAndValuesDo: [ :key :value |		value isNil			ifTrue: [ result at: key put: key default yourself ] ].	^ result! !!MAMemento methodsFor: 'private' stamp: 'NickAger 1/17/2012 14:24'!pullRaw	| result |	result := Dictionary new.	self magritteDescription do: [ :each |		result at: each put: (self model			readUsing: each) ].	^ result! !!MAMemento methodsFor: 'private' stamp: 'lr 2/8/2009 19:20'!push: aDictionary	"Utility method to push a dictionary mapping descriptions to values into the model."	aDictionary keysAndValuesDo: [ :key :value |		(key isVisible and: [ key isReadonly not ]) 			ifTrue: [ self model write: value using: key ] ]! !!MAMemento methodsFor: 'actions' stamp: 'lr 3/9/2006 11:32'!reset	"Reset the memento from the model."! !!MAMemento methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setDescription: aDescription	description := aDescription! !!MAMemento methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setModel: aModel	model := aModel! !!MAMemento methodsFor: 'actions' stamp: 'NickAger 1/17/2012 14:25'!validate	"Check if the data in the receiver would be valid if committed. In case of problems an exception is raised."	self magritteDescription validate: self! !!MAStraightMemento class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ false! !!MAStraightMemento methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!readUsing: aDescription	^ (self model readUsing: aDescription)		ifNil: [ aDescription default ]! !!MAStraightMemento methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!write: anObject using: aDescription	self model write: anObject using: aDescription! !!MAObject class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:33'!isAbstract	^ true! !!MAObject class methodsFor: 'instance creation' stamp: 'jf 9/16/2009 12:27'!new	"Create a new instance of the receiving class and checks if it is concrete."	self isAbstract		ifTrue: [ self error: self name , ' is abstract.' ].	^ super new! !!MAObject class methodsFor: 'reflection' stamp: 'lr 3/9/2006 11:33'!withAllConcreteClasses	^ Array streamContents: [ :stream |		self withAllConcreteClassesDo: [ :each |			stream nextPut: each ] ]! !!MAObject class methodsFor: 'reflection' stamp: 'lr 3/9/2006 11:33'!withAllConcreteClassesDo: aBlock	self withAllSubclassesDo: [ :each |		each isAbstract ifFalse: [			aBlock value: each ] ]! !!MAObject methodsFor: 'comparing' stamp: 'lr 4/10/2007 21:40'!= anObject	"Answer whether the receiver and the argument represent the same object. This default implementation checks if the species of the compared objects are the same, so that superclasses might call super before performing their own check. Also redefine the message ==#hash== when redefining this message."	^ self species = anObject species! !!MAObject methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!acceptMagritte: aVisitor! !!MAObject methodsFor: 'private' stamp: 'lr 4/10/2008 14:11'!errorPropertyNotFound: aSelector 	MAPropertyError signal: 'Property ' , aSelector , ' not found.'! !!MAObject methodsFor: 'testing' stamp: 'lr 4/10/2007 21:40'!hasProperty: aKey	"Test if the property ==aKey== is defined within the receiver."	^ self properties includesKey: aKey! !!MAObject methodsFor: 'comparing' stamp: 'lr 4/10/2007 21:40'!hash	"Answer a SmallInteger whose value is related to the receiver's identity. Also redefine the message ==#= == when redefining this message."	^ self species hash! !!MAObject methodsFor: 'copying' stamp: 'lr 5/29/2006 09:05'!postCopy	"This method is called whenever a shallow copy of the receiver is made. Redefine this method in subclasses to copy other fields as necessary. Never forget to call super, else class invariants might be violated."	super postCopy.	properties := properties copy! !!MAObject methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!properties	"Answer the property dictionary of the receiver."	^ properties ifNil: [ properties := Dictionary new ]! !!MAObject methodsFor: 'accessing' stamp: 'lr 4/10/2007 21:41'!propertyAt: aKey	"Answer the value of the property ==aKey==, raises an error if the property doesn't exist."	^ self propertyAt: aKey ifAbsent: [ self errorPropertyNotFound: aKey ]! !!MAObject methodsFor: 'accessing' stamp: 'lr 4/10/2007 21:54'!propertyAt: aKey ifAbsent: aBlock	"Answer the value of the property ==aKey==, or the result of ==aBlock== if the property doesn't exist."	^ self properties at: aKey ifAbsent: aBlock! !!MAObject methodsFor: 'accessing' stamp: 'lr 4/10/2007 21:41'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the value of the property ==aKey==, or if the property doesn't exist adds and answers the result of evaluating ==aBlock==."	^ self properties at: aKey ifAbsentPut: aBlock! !!MAObject methodsFor: 'accessing' stamp: 'lr 4/12/2007 19:49'!propertyAt: aKey ifPresent: aBlock	"Lookup the property ==aKey==, if it is present, answer the value of evaluating ==aBlock== block with the value. Otherwise, answer ==nil==."	^ self properties at: aKey ifPresent: aBlock! !!MAObject methodsFor: 'accessing' stamp: 'NickAger 2/3/2012 13:37'!propertyAt: aKey ifPresent: oneArgBlock ifAbsent: absentBlock	"Lookup ==aKey==, if it is present, answer the value of evaluating the oneArgBlock with the value associated with the key, otherwise answer the value of absentBlock."	^ self properties at: aKey ifPresent: oneArgBlock ifAbsent: absentBlock! !!MAObject methodsFor: 'accessing' stamp: 'lr 4/10/2007 21:41'!propertyAt: aKey put: aValue	"Adds or replaces the property ==aKey== with ==aValue==."	^ self properties at: aKey put: aValue! !!MAPragmaBuilder class methodsFor: 'constants' stamp: 'NickAger 1/18/2012 14:02'!containerPragma 	^ #magritteContainer! !!MAPragmaBuilder class methodsFor: 'instance creation' stamp: 'NickAger 1/18/2012 14:42'!for: anObject	^ self new for: anObject! !!MAPragmaBuilder class methodsFor: 'constants' stamp: 'NickAger 1/18/2012 14:02'!magritteDescriptionExtensionPragma 	^ #magritteDescription:! !!MAPragmaBuilder class methodsFor: 'constants' stamp: 'NickAger 1/18/2012 14:02'!magritteDescriptionPragma 	^ #magritteDescription! !!MAPragmaBuilder class methodsFor: 'constants' stamp: 'NickAger 1/16/2012 17:26'!magritteSelectors	^ Array with: self containerPragma with: self magritteDescriptionExtensionPragma with: self magritteDescriptionPragma! !!MAPragmaBuilder methodsFor: 'private' stamp: 'NickAger 1/18/2012 14:25'!build: anObject cache: cache	| container |	container := cache at: anObject put: (self buildContainer: anObject).		^ container		addAll: (self buildDescriptions: anObject);		yourself.! !!MAPragmaBuilder methodsFor: 'private' stamp: 'NickAger 3/7/2012 09:36'!buildContainer: anObject	| containerPragmas containerPragma containerSelector extensionSelectors container |		containerPragmas := Pragma 		allNamed: self class containerPragma 		from: anObject class to: Object.			containerPragma := containerPragmas detect: [ :each | each method numArgs = 0 ].	containerSelector := containerPragma method selector.	extensionSelectors := (containerPragmas 		select: [ :each | each method numArgs = 1 ]) 		collect: [ :each | each method selector ]. 	MADynamicDescribedObject use: anObject during: [			container := anObject perform: containerSelector.		extensionSelectors do: [ :each | 			anObject perform: each with: container ] ].	^ container! !!MAPragmaBuilder methodsFor: 'private' stamp: 'NickAger 3/7/2012 09:35'!buildDescriptions: anObject	| descriptionExtensions descriptionSelectors |		descriptionSelectors := self uniqueDescriptionSelectors: anObject.	descriptionExtensions := self descriptionExtensions: anObject.	^ (descriptionSelectors 		collect:  [ :each |			| description |			description := anObject perform: each.						description notNil ifTrue: [				descriptionExtensions at: each ifPresent: [ :extensions | 					extensions do: [ :extensionSelector | 						description := anObject perform: extensionSelector with: description ] ] ].			description ])		select: #notNil.! !!MAPragmaBuilder methodsFor: 'private' stamp: 'NickAger 3/7/2012 09:11'!descriptionExtensions: anObject	| extensionPragmas |		extensionPragmas := Pragma		allNamed: self class magritteDescriptionExtensionPragma		from: anObject class to: Object.		^ extensionPragmas inject: Dictionary new into: [ :extensionSelectors :each | 		| extensionSelectorTarget |		extensionSelectorTarget := each arguments first.		(extensionSelectors at: extensionSelectorTarget ifAbsentPut: [ SortedCollection new ]) add: each method selector.		extensionSelectors ].! !!MAPragmaBuilder methodsFor: 'description building' stamp: 'NickAger 3/7/2012 09:02'!for: anObject	| cache |	cache := MADynamicDescriptionCache value.		MADynamicDescriptionCache use: cache during: [		^ cache at: anObject ifAbsentPut: [ self build: anObject cache: cache ] ]! !!MAPragmaBuilder methodsFor: 'private' stamp: 'NickAger 2/23/2012 12:12'!uniqueDescriptionSelectors: anObject	| descriptionPragmas selectors |		descriptionPragmas := Pragma 		allNamed: self class magritteDescriptionPragma 		from: anObject class to: Object.			selectors := descriptionPragmas collect: [ :each | each method selector ].		^ Set withAll: selectors! !!MASortBlock class methodsFor: 'instance creation' stamp: 'lr 4/10/2008 13:50'!accessor: anAccessor selector: aSelector	^ self basicNew initializeAccessor: anAccessor selector: aSelector! !!MASortBlock class methodsFor: 'instance creation' stamp: 'lr 4/10/2008 13:55'!selector: aSelector 	^ self 		accessor: MAIdentityAccessor new		selector: aSelector! !!MASortBlock methodsFor: 'actions' stamp: 'lr 4/10/2008 14:01'!fixTemps! !!MASortBlock methodsFor: 'initialization' stamp: 'lr 4/10/2008 13:41'!initializeAccessor: anAccessor selector: aSelector	accessor := anAccessor asAccessor.	selector := aSelector! !!MASortBlock methodsFor: 'evaluating' stamp: 'lr 4/10/2008 13:42'!value: aFirstObject value: aSecondObject	^ (accessor read: aFirstObject)		perform: selector		with: (accessor read: aSecondObject)! !!MATableModel class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!rows: aRowCount columns: aColumnCount	^ self rows: aRowCount columns: aColumnCount contents: (Array new: aRowCount * aColumnCount)! !!MATableModel class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!rows: aRowCount columns: aColumnCount contents: anArray	^ self new		setRowCount: aRowCount;		setColumnCount: aColumnCount;		setContents: anArray;		yourself! !!MATableModel methodsFor: 'comparing' stamp: 'lr 2/16/2007 08:50'!= aTable	^ self species = aTable species		and: [ self rowCount = aTable rowCount		and: [ self columnCount = aTable columnCount		and: [ self contents = aTable contents ] ] ]! !!MATableModel methodsFor: 'accessing' stamp: 'lr 4/10/2007 21:42'!at: aRowIndex at: aColumnIndex	"Answer the contents of ==aRowIndex== and ==aColumnIndex==. Raises an error if the coordinates are out of bounds."	self checkAt: aRowIndex at: aColumnIndex.	^ self uncheckedAt: aRowIndex at: aColumnIndex! !!MATableModel methodsFor: 'accessing' stamp: 'lr 4/10/2007 21:43'!at: aRowIndex at: aColumnIndex put: aValue	"Set the contents of ==aRowIndex== and ==aColumnIndex==> to ==aValue==. Raises an error if the coordinates are out of bounds."	self checkAt: aRowIndex at: aColumnIndex.	^ self uncheckedAt: aRowIndex at: aColumnIndex put: aValue! !!MATableModel methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!checkAt: aRowIndex at: aColumnIndex	(aRowIndex between: 1 and: self rowCount)		ifFalse: [ self error: 'Row subscript out of range.' ].	(aColumnIndex between: 1 and: self columnCount)		ifFalse: [ self error: 'Column subscript out of range.' ]! !!MATableModel methodsFor: 'enumeration' stamp: 'lr 3/28/2007 10:28'!collect: aBlock	| copy |	copy := self copyEmpty.	self do: [ :row :col :val |		copy			at: row at: col			put: (aBlock value: row value: col value: val) ].	^ copy! !!MATableModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!columnCount	"Answer the column count of the table."	^ columnCount! !!MATableModel methodsFor: 'accessing' stamp: 'lr 10/12/2010 13:14'!contents	"Answer the contents array of the receiver."	^ contents! !!MATableModel methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!copyEmpty	^ self class rows: self rowCount columns: self columnCount! !!MATableModel methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!copyRows: aRowCount columns: aColumnCount	| table |	table := self class rows: aRowCount columns: aColumnCount.	1 to: (self rowCount min: aRowCount) do: [ :row |		1 to: (self columnCount min: aColumnCount) do: [ :col |			table				uncheckedAt: row at: col				put: (self uncheckedAt: row at: col) ] ].	^ table! !!MATableModel methodsFor: 'enumeration' stamp: 'lr 3/9/2006 11:32'!do: aBlock	1 to: self rowCount do: [ :row |		1 to: self columnCount do: [ :col |			aBlock				value: row value: col				value: (self uncheckedAt: row at: col) ] ]! !!MATableModel methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:32'!hash	^ self contents hash! !!MATableModel methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!indexAt: aRowIndex at: aColumnIndex	^ (aRowIndex - 1) * self columnCount + aColumnIndex! !!MATableModel methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!pointAt: anIndex	^ Point x: (anIndex - 1 // self columnCount + 1) y: (anIndex - 1 \\ self columnCount + 1)! !!MATableModel methodsFor: 'copying' stamp: 'lr 3/9/2006 11:32'!postCopy	super postCopy.	self setContents: self contents copy! !!MATableModel methodsFor: 'operations' stamp: 'lr 4/10/2007 21:43'!reshapeRows: aRowCount columns: aColumnCount	"Change the size of the receiving table to ==aRowCount== times ==aColumnCount==, throwing away elements that are cut off and initializing empty cells with ==nil==."	self setContents: (self copyRows: aRowCount columns: aColumnCount) contents.	self setRowCount: aRowCount; setColumnCount: aColumnCount! !!MATableModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!rowCount	"Answer the row count of the table."	^ rowCount! !!MATableModel methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setColumnCount: anInteger	columnCount := anInteger! !!MATableModel methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setContents: anArray	contents := anArray! !!MATableModel methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setRowCount: anInteger	rowCount := anInteger! !!MATableModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!uncheckedAt: aRowIndex at: aColumnIndex	^ self contents at: (self indexAt: aRowIndex at: aColumnIndex)! !!MATableModel methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!uncheckedAt: aRowIndex at: aColumnIndex put: aValue	^ self contents at: (self indexAt: aRowIndex at: aColumnIndex) put: aValue! !!MADescriptionHolder class methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:35'!descriptionClasses	^ MAElementDescription withAllConcreteClasses asOrderedCollection! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'lr 10/29/2009 20:59'!groupChoice	^ Set new		add: MABooleanDescription;		add: MASingleOptionDescription;		add: MAMultipleOptionDescription;		add: MAToOneRelationDescription;		add: MAToManyRelationDescription;		add: MAToManyScalarRelationDescription;				yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'lr 10/29/2009 20:58'!groupMagnitude	^ Set new		add: MANumberDescription;		add: MADurationDescription;		add: MADateDescription;		add: MATimeDescription;		add: MATimeStampDescription;		add: MADateAndTimeDescription;		yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'lr 10/29/2009 20:55'!groupMisc	^ Set new		add: MAFileDescription;		add: MAClassDescription;		add: MATableDescription;		yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'lr 10/29/2009 20:57'!groupOf: aClass 	(self groupText includes: aClass)		ifTrue: [ ^ 'Text' ].	(self groupChoice includes: aClass)		ifTrue: [ ^ 'Choice' ].	(self groupMagnitude includes: aClass)		ifTrue: [ ^ 'Magnitude' ].	(self groupPick includes: aClass)		ifTrue: [ ^ 'Pick' ].	(self groupMisc includes: aClass)		ifTrue: [ ^ 'Miscellaneous' ].	^ 'Other'! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'lr 10/29/2009 20:56'!groupPick	^ Set new		add: MAColorDescription;		add: MATokenDescription;		yourself! !!MADescriptionHolder class methodsFor: 'groups' stamp: 'lr 10/29/2009 20:56'!groupText	^ Set new		add: MAStringDescription;		add: MAMemoDescription;		add: MASymbolDescription;		add: MAPasswordDescription;		yourself! !!MADescriptionHolder methodsFor: 'acessing-magritte' stamp: 'NickAger 1/16/2012 18:36'!descriptionValue	<magritteDescription>	^ MASingleOptionDescription new		reference: MAClassDescription new;		options: self class descriptionClasses;		selectorAccessor: 'contents';		groupBy: #grouping;		label: 'Type';		priority: 20;		yourself! !!MADescriptionHolder methodsFor: 'initialization' stamp: 'NickAger 1/16/2012 18:36'!initialize	super initialize.	self contents: self class descriptionClasses first! !!MAValueHolder class methodsFor: 'instance creation' stamp: 'lr 8/14/2008 11:45'!on: anObject	^ self new contents: anObject! !!MAValueHolder methodsFor: 'accessing' stamp: 'lr 8/14/2008 11:43'!contents	^ contents! !!MAValueHolder methodsFor: 'accessing' stamp: 'lr 8/14/2008 11:43'!contents: anObject	contents := anObject! !!MAReader class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!read: aStream description: aDescription	^ self new read: aStream description: aDescription! !!MAReader methodsFor: 'private' stamp: 'lr 4/10/2008 14:11'!error: aString 	MAReadError signal: aString! !!MAReader methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!read: aStream description: aDescription	self		stream: aStream;		visit: aDescription.	^ self object! !!MAStringReader methodsFor: 'private' stamp: 'lr 5/21/2009 13:36'!nextMatchAll: aCollection on: aStream	"Tries to match ==aCollection== on ==aStream==. Answer ==true== if ==aCollection== was consumed, otherwise ==false==."	| position |	(aCollection isNil or: [ aCollection isEmpty ])		ifTrue: [ ^ false ].	position := aStream position.	aCollection do: [ :char |		(aStream atEnd or: [ aStream next ~= char ]) ifTrue: [			aStream position: position.			^ false ] ].	^ true! !!MAStringReader methodsFor: 'visiting' stamp: 'lr 5/21/2009 13:34'!read: aStream description: aDescription	(aStream atEnd or: [ self nextMatchAll: aDescription undefined on: aStream ])		ifTrue: [ ^ nil ].	^ super read: aStream description: aDescription! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 4/10/2008 14:10'!visitBooleanDescription: aDescription	(aDescription trueString = self contents		or: [ aDescription trueStrings includes: self contents ])			ifTrue: [ ^ self object: true ].	(aDescription falseString = self contents		or: [ aDescription falseStrings includes: self contents ])			ifTrue: [ ^ self object: false ].	MAReadError signal! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitClassDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 4/10/2008 14:10'!visitColorDescription: aDescription	(self contents notEmpty and: [ self contents allSatisfy: [ :each | '#0123456789ABCDEFabcdef.' includes: each ] ])		ifFalse: [ MAReadError signal ].	self object: (aDescription kind fromString: self contents)! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitContainer: anObject	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 4/10/2008 14:10'!visitDurationDescription: aDescription	| contents |	contents := self contents.	contents isEmpty		ifTrue: [ MAReadError signal ].	(contents occurrencesOf: $-) > 1		ifTrue: [ MAReadError signal ].	(contents indexOf: $-) > 1		ifTrue: [ MAReadError signal ].	(contents occurrencesOf: $.) > 1		ifTrue: [ MAReadError signal ].	(contents allSatisfy: [:each | '-0123456789.:' includes: each])		ifFalse: [ MAReadError signal ].	super visitDurationDescription: aDescription! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 4/10/2008 14:11'!visitElementDescription: aDescription	"This implementation can be very dangerous and might lead to a potential security hole (this is tested), since the default implementation of #readFrom: in Object evaluates the expression to find its value. Most subclasses like Number, Date, Time, ... override this implementation, but some others (like Boolean) do not."	self object: ([ aDescription kind readFrom: self stream ]		on: Error do: [ :err | MAReadError signal: err messageText ])! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitFileDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 1/18/2008 19:18'!visitMultipleOptionDescription: aDescription	self object: (Array streamContents: [ :output |		[ self stream atEnd ] whileFalse: [			output nextPut: (aDescription reference				fromString: (self stream upTo: $,)).			self stream peek = Character space				ifTrue: [ self stream next ] ] ])! !!MAStringReader methodsFor: 'visiting-description' stamp: 'SeanDeNigris 4/12/2015 10:20'!visitNumberDescription: aDescription	| isContentsValid |	isContentsValid := NumberParser isNumber: self contents.	isContentsValid ifFalse: [ MAReadError signal ].	super visitNumberDescription: aDescription! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitRelationDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 5/21/2009 13:39'!visitSingleOptionDescription: aDescription	aDescription propertyAt: #labels ifPresent: [ :labels |		labels keysAndValuesDo: [ :key :value |			(self nextMatchAll: value on: self stream)				ifTrue: [ ^ self object: key ] ] ].	self visit: aDescription reference! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitStringDescription: aDescription	self object: self contents! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitSymbolDescription: aDescription	self object: self contents asSymbol! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTableDescription: aDescription	self shouldNotImplement! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 4/10/2008 14:10'!visitTimeDescription: aDescription	| string |	string := self contents.	(string notEmpty and: [ string allSatisfy: [ :each | '0123456789: apm' includes: each ] ])		ifFalse: [ MAReadError signal ].	self object: (aDescription kind readFrom: string readStream)! !!MAStringReader methodsFor: 'visiting-description' stamp: 'lr 2/5/2009 10:52'!visitTokenDescription: aDescription	| token |	self object: (aDescription kind streamContents: [ :output |		[ self stream atEnd ] whileFalse: [			token := WriteStream on: String new.			[ self stream atEnd or: [ aDescription separators includes: self stream peek ] ]				whileFalse: [ token nextPut: self stream next ].			self stream atEnd 				ifFalse: [ self stream next ].			token contents isEmpty				ifFalse: [ output nextPut: (aDescription reference fromString: token contents) ] ] ])! !!MAStringReader methodsFor: 'visiting-description' stamp: 'SeanDeNigris 8/6/2015 17:52'!visitUrlDescription: aDescription	self object: self contents asUrl! !!MAStreamingVisitor methodsFor: 'streaming' stamp: 'lr 3/9/2006 11:32'!contents	^ self stream contents! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!object	^ object! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!object: anObject	object := anObject! !!MAStreamingVisitor methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!object: anObject during: aBlock	| previous |	previous := self object. self object: anObject.	aBlock ensure: [ self object: previous ]! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!stream	^ stream! !!MAStreamingVisitor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!stream: aStream	stream := aStream! !!MAStringWriter methodsFor: 'private' stamp: 'lr 5/21/2009 13:24'!defaultWriteStream	^ WriteStream on: String new! !!MAStringWriter methodsFor: 'private' stamp: 'SeanDeNigris 10/6/2013 21:24'!printObjectDescribedBy: aDescription	| string |	string := aDescription displayStringFor: self object.	self stream nextPutAll: string.! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitBooleanDescription: aDescription	self stream nextPutAll: (self object		ifTrue: [ aDescription trueString ]		ifFalse: [ aDescription falseString ])! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitClassDescription: aDescription	self stream nextPutAll: self object label! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitColorDescription: aDescription	stream nextPut: $#.	stream nextPutAll: ((255 * self object red) asInteger		printPaddedWith: $0 to: 2 base: 16).	stream nextPutAll: ((255 * self object green) asInteger		printPaddedWith: $0 to: 2 base: 16).	stream nextPutAll: ((255 * self object blue) asInteger		printPaddedWith: $0 to: 2 base: 16)! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitContainer: aDescription	aDescription do: [ :each |		each isVisible ifTrue: [			each stringWriter				write: (self object readUsing: each)				description: each to: stream.			^ self ] ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'SeanDeNigris 10/6/2013 21:24'!visitDateAndTimeDescription: aDescription	self printObjectDescribedBy: aDescription.! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'jf 9/30/2009 01:10'!visitElementDescription: aDescription 	self stream nextPutAll: self object greaseString! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitFileDescription: aDescription	self stream nextPutAll: self object filename! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 5/21/2009 13:23'!visitMultipleOptionDescription: aDescription	self object isEmpty		ifTrue: [ self stream nextPutAll: aDescription undefined ]		ifFalse: [			self object				do: [ :each | self stream nextPutAll: (aDescription labelForOption: each) ]				separatedBy: [ self stream nextPutAll: ', ' ] ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 5/21/2009 13:21'!visitSingleOptionDescription: aDescription	self stream nextPutAll: (aDescription labelForOption: self object)! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'SeanDeNigris 10/6/2013 21:23'!visitStringDescription: aDescription	self printObjectDescribedBy: aDescription.! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'SeanDeNigris 10/6/2013 21:33'!visitTimeDescription: aDescription 		self printObjectDescribedBy: aDescription.! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'DamienCassou 11/21/2013 15:06'!visitTimeStampDescription: aDescription	self stream print: self object asDate; space.	self stream print: self object asTime! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'NickAger 1/19/2012 17:02'!visitToManyRelationDescription: aDescription	self object		do: [ :each | self object: each during: [ self visit: each magritteDescription ] ]		separatedBy: [ self stream nextPutAll: ', ' ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'NickAger 1/19/2012 17:02'!visitToOneRelationDescription: aDescription	self visit: self object magritteDescription! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'lr 2/5/2009 10:48'!visitTokenDescription: aDescription	self object		do: [ :each | self object: each during: [ self visit: aDescription reference ] ]		separatedBy: [ self stream nextPut: aDescription separators first ]! !!MAStringWriter methodsFor: 'visiting-description' stamp: 'SeanDeNigris 8/6/2015 17:50'!visitUrlDescription: aMAUrlDescription 	self stream nextPutAll: self object asString! !!MAStringWriter methodsFor: 'visiting' stamp: 'lr 5/21/2009 13:25'!write: anObject description: aDescription to: aStream	anObject isNil 		ifTrue: [ aStream nextPutAll: aDescription undefined ]		ifFalse: [ super write: anObject description: aDescription to: aStream ].	^ aStream contents! !!MAWriter class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!write: anObject	^ self new write: anObject! !!MAWriter class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!write: anObject description: aDescription	^ self new write: anObject description: aDescription! !!MAWriter class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!write: anObject description: aDescription to: aStream	^ self new write: anObject description: aDescription to: aStream! !!MAWriter methodsFor: 'private' stamp: 'lr 3/9/2006 11:32'!defaultWriteStream	self subclassResponsibility! !!MAWriter methodsFor: 'private' stamp: 'lr 4/10/2008 14:12'!error: aString 	MAWriteError signal: aString! !!MAWriter methodsFor: 'visiting' stamp: 'NickAger 1/19/2012 17:02'!write: anObject	^ self write: anObject description: anObject magritteDescription! !!MAWriter methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!write: anObject description: aDescription	^ self write: anObject description: aDescription to: self defaultWriteStream! !!MAWriter methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:32'!write: anObject description: aDescription to: aStream	self		object: anObject;		stream: aStream;		visit: aDescription.	^ self contents! !!MAValidatorVisitor class methodsFor: 'instance creation' stamp: 'lr 2/16/2007 08:32'!on: anObject description: aDescription	^ self new on: anObject description: aDescription! !!MAValidatorVisitor methodsFor: 'accessing' stamp: 'lr 10/12/2010 09:56'!object	"Answer the currently validated object."	^ object! !!MAValidatorVisitor methodsFor: 'initialization' stamp: 'lr 11/6/2009 15:50'!on: anObject description: aDescription	self use: anObject during: [ self visit: aDescription ]! !!MAValidatorVisitor methodsFor: 'private' stamp: 'lr 10/12/2010 09:55'!use: anObject during: aBlock	| previous |	previous := object. object := anObject.	^ aBlock ensure: [ object := previous ]! !!MAValidatorVisitor methodsFor: 'private' stamp: 'lr 10/12/2010 09:52'!validate: anObject using: aDescription	aDescription validateRequired: anObject.	anObject isNil ifTrue: [ ^ self ].	aDescription		validateKind: anObject;		validateSpecific: anObject;		validateConditions: anObject! !!MAValidatorVisitor methodsFor: 'visiting' stamp: 'lr 10/12/2010 09:53'!visit: aDescription	"Only visit objects that are visible and that can be changed."		(aDescription isVisible and: [ aDescription isReadonly not ])		ifTrue: [ super visit: aDescription ].	! !!MAValidatorVisitor methodsFor: 'visiting-descriptions' stamp: 'lr 10/12/2010 09:57'!visitContainer: aDescription	| errors |	super visitContainer: aDescription.	self object isNil ifTrue: [ ^ self ].	errors := OrderedCollection new.	aDescription do: [ :description |		[ self			use: (self object readUsing: description)			during: [ self visit: description ] ]				on: MAValidationError				do: [ :err | errors add: err ] ].	errors isEmpty ifFalse: [		MAMultipleErrors			description: aDescription 			errors: errors			signal: aDescription label ]! !!MAValidatorVisitor methodsFor: 'visiting-descriptions' stamp: 'lr 11/6/2009 09:23'!visitDescription: aDescription	self validate: self object using: aDescription! !!MAVisitor class methodsFor: 'private' stamp: 'SeanDeNigris 4/10/2015 20:23'!buildVisitorHierarchyForClass: aClass selector: aBlock classified: aSelector	" self buildVisitorHierarchyForClass: MADescription selector: [ :class | 'visit' , (class name allButFirst: 2) , ':' ] classified: #'visiting-description' "	| visitSourceCode acceptSourceCode classesOwnedByMagritte |	classesOwnedByMagritte := aClass withAllSubclasses select: [ :class | class category beginsWith: 'Magritte' ].	classesOwnedByMagritte do: [ :class | | visitSelector |			visitSelector := aBlock value: class.			visitSourceCode := String streamContents: [ :stream |					stream nextPutAll: visitSelector; nextPutAll: ' anObject'; cr.					class = aClass ifFalse: [						stream tab; nextPutAll: 'self '; nextPutAll: (aBlock value: class superclass); nextPutAll: ' anObject' ] ].			self compile: visitSourceCode classified: aSelector.							acceptSourceCode := String streamContents: [ :stream |					stream nextPutAll: 'acceptMagritte: aVisitor'; cr.					stream tab; nextPutAll: 'aVisitor '; nextPutAll: visitSelector; nextPutAll: ' self' ].			class compile: acceptSourceCode classified: #visiting ]! !!MAVisitor methodsFor: 'visiting' stamp: 'lr 4/10/2007 21:43'!visit: anObject	"Visit ==anObject== with the receiving visitor."	anObject acceptMagritte: self! !!MAVisitor methodsFor: 'visiting' stamp: 'lr 4/10/2007 21:43'!visitAll: aCollection	"Visit all elements of ==aCollection== with the receiving visitor."	aCollection do: [ :each | self visit: each ]! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitBooleanDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitClassDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitColorDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitContainer: anObject	self visitDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitDateAndTimeDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitDateDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitDirectoryDescription: anObject	self visitFileDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitDurationDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitElementDescription: anObject	self visitDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitFileDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitMagnitudeDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitMemoDescription: anObject	self visitStringDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitMultipleOptionDescription: anObject	self visitOptionDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitNumberDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitOptionDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitPasswordDescription: anObject	self visitStringDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitPriorityContainer: anObject	self visitContainer: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitReferenceDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitRelationDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitReportContainer: anObject	self visitContainer: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitSingleOptionDescription: anObject	self visitOptionDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitStringDescription: anObject	self visitElementDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitSymbolDescription: anObject	self visitStringDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitTableDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'lr 3/9/2006 11:32'!visitTableReference: anObject	^ self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitTimeDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitTimeStampDescription: anObject	self visitMagnitudeDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitToManyRelationDescription: anObject	self visitRelationDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitToManyScalarRelationDescription: anObject	self visitToManyRelationDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitToOneRelationDescription: anObject	self visitRelationDescription: anObject! !!MAVisitor methodsFor: 'visiting-description' stamp: 'StephanEggermont 4/16/2015 11:06'!visitTokenDescription: anObject	self visitReferenceDescription: anObject! !!MAVisitor methodsFor: 'visiting-descriptions' stamp: 'SeanDeNigris 8/6/2015 17:52'!visitUrlDescription: aMAUrlDescription 	self visitElementDescription: aMAUrlDescription! !!UndefinedObject methodsFor: '*magritte-model-converting' stamp: 'lr 4/10/2008 13:35'!asAccessor	^ MANullAccessor new! !!UndefinedObject methodsFor: '*magritte-model-accessing' stamp: 'lr 3/9/2006 11:31'!label	^ 'n/a'! !!UndefinedObject methodsFor: '*magritte-model-accessing' stamp: 'NickAger 2/24/2012 08:39'!magritteDescription	^ MAContainer new! !!String methodsFor: '*magritte-model-testing' stamp: 'lr 3/9/2006 11:31'!matches: aString	aString isEmpty ifTrue: [ ^ true ].	^ (aString includesAnyOf: '*#')		ifTrue: [ aString match: self ]		ifFalse: [ self includesSubstring: aString caseSensitive: false ]! !!String methodsFor: '*magritte-model' stamp: 'SeanDeNigris 9/26/2013 10:33'!normalizeCamelCase	^ String streamContents: [ :out |		self do: [ :e |			(e isUppercase and: [ out position > 0 ]) ifTrue: [ out nextPut: Character space ].			out nextPut: e ] ]! !!SequenceableCollection methodsFor: '*magritte-model' stamp: 'kph 6/9/2008 17:51'!asAccessor	^ MAChainAccessor accessors: self! !!SequenceableCollection methodsFor: '*magritte-model' stamp: 'jf 10/5/2009 08:40'!moveDown: anObject	| first second |	first := self findFirst: [ :value | value == anObject ].	second := (first > 0 and: [ first < self size ])		ifTrue: [ first + 1 ]		ifFalse: [ ^ first ].	self swap: first with: second.	^ second! !!SequenceableCollection methodsFor: '*magritte-model' stamp: 'jf 10/5/2009 08:38'!moveUp: anObject	| first second |	first := self findFirst: [ :value | value == anObject ].	second := first > 1 ifTrue: [ first - 1 ] ifFalse: [ ^ first ].	self swap: first with: second.	^ second! !!GRPackage class methodsFor: '*magritte-model' stamp: 'lr 2/18/2010 10:29'!magritteModel	^ self new		name: 'Magritte-Model';		description: 'The Magritte metamodel.';		addDependency: 'Grease-Core';		url: #magritteUrl;		yourself! !!GRPackage methodsFor: '*magritte-model' stamp: 'lr 2/16/2010 09:15'!magritteUrl	^ 'http://source.lukas-renggli.ch/magritte2'! !!Integer methodsFor: '*magritte-model-converting' stamp: 'lr 3/9/2006 11:31'!asFileSize	#( 'B' 'KB' 'MB' 'GB' 'TB' 'PB' 'EB' 'ZB' 'YB' )		inject: self		into: [ :value :each |			value < 1024				ifFalse: [ value // 1024 ]				ifTrue: [ ^ value asString , ' ' , each ] ]! !!MAMultipleErrors class methodsFor: 'instance creation' stamp: 'lr 4/10/2008 14:12'!description: aDescription errors: aCollection signal: aString 	^ self new		setDescription: aDescription;		setCollection: aCollection;		signal: aString;		yourself! !!MAMultipleErrors methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:32'!collection	^ collection! !!MAMultipleErrors methodsFor: 'printing' stamp: 'lr 11/14/2006 17:55'!printOn: aStream	self collection		do: [ :each | aStream print: each ]		separatedBy: [ aStream nextPut: Character cr ]! !!MAMultipleErrors methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:32'!setCollection: aCollection	collection := aCollection! !!MAValidationError class methodsFor: 'instance creation' stamp: 'lr 4/10/2008 14:12'!description: aDescription signal: aString 	^ self new		setDescription: aDescription;		signal: aString;		yourself! !!MAValidationError methodsFor: 'printing' stamp: 'DiegoLont 2/25/2014 11:22'!printOn: aStream	(self tag isDescription and: [ self tag label notNil ])		ifTrue: [ aStream nextPutAll: self tag label greaseString; nextPutAll: ': ' ].	aStream nextPutAll: self messageText greaseString ! !!MAValidationError methodsFor: 'initialization' stamp: 'lr 9/3/2008 14:32'!setDescription: aDescription	self tag: aDescription! !!Class methodsFor: '*magritte-model-configuration' stamp: 'EstebanLorenzano 1/4/2012 15:35'!descriptionContainer	"Return the default description container."	<magritteContainer>	^ MAPriorityContainer new		label: self label;		yourself! !!Class methodsFor: '*magritte-model-accessing' stamp: 'lr 3/9/2006 11:31'!label	"Answer a human-readable name of the receiving class. This implementation tries to be smart and return a nice label, unfortunately for a lot of classes this doesn't work well so subclasses might want to override this method and return soemthing more meaningfull to end-users."	| start input |	start := self name findFirst: [ :each | each isLowercase ].	input := (self name copyFrom: (1 max: start - 1) to: self name size)		readStream.	^ String streamContents: [ :stream |		[ input atEnd ] whileFalse: [			stream nextPut: input next.			(input atEnd or: [ input peek isLowercase ])				ifFalse: [ stream nextPut: Character space ] ] ]! !!BlockClosure methodsFor: '*magritte-model-description' stamp: 'DiegoLont 1/24/2014 10:44'!optionFor: anObject ifPresent: aBlock	aBlock value: (self cull: anObject)! !!ArrayedCollection methodsFor: '*magritte-model' stamp: 'lr 7/31/2007 21:29'!copyWithAll: aCollection	^ (self species new: self size + aCollection size)		replaceFrom: 1 to: self size with: self startingAt: 1;		replaceFrom: self size + 1 to: self size + aCollection size with: aCollection startingAt: 1;		yourself! !!GRPlatform methodsFor: '*magritte-model' stamp: 'jf 9/16/2009 13:39'!magritteAllSubInstancesOf: aClass do: aBlock	"Evaluate the aBlock for all instances of aClass and all its subclasses."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'jf 9/16/2009 13:33'!magritteClassNamed: aString	"Return the class named aString, nil if the class can't be found."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'jf 9/15/2009 18:35'!magritteColorClass	"Return a Color class"		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'jf 9/17/2009 17:09'!magritteEvaluatorClassFor: aClass	"Answer an evaluator class appropriate for evaluating expressions in the 	context of this class."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'jf 9/16/2009 14:27'!magritteTimeStampClass	"Return the platform's TimeStamp class. It is currently assumed that all platforms	have one, though this may not be correct and could require moving timestamp stuff	to its own package in order to resolve."		self subclassResponsibility! !!GRPlatform methodsFor: '*magritte-model' stamp: 'jf 9/16/2009 13:31'!magritteUniqueObject	"Answer a random object, such as a UUID, that is extremely likely to	be unique over space and time."		self subclassResponsibility! !!Collection methodsFor: '*magritte-model' stamp: 'lr 3/9/2006 11:31'!asMultilineString	^ String streamContents: [ :stream |		self			do: [ :each | stream nextPutAll: each ]			separatedBy: [ stream nextPut: Character cr ] ]! !!Collection methodsFor: '*magritte-model' stamp: 'lr 3/9/2006 11:31'!copyWithAll: aCollection	^ self copy		addAll: aCollection;		yourself! !!Collection methodsFor: '*magritte-model' stamp: 'jf 9/18/2009 11:01'!copyWithoutFirst: anObject	| done |	done := false.	^ self reject: [ :each |		(each = anObject			and: [ done not ])				and: [ done := true ] ]! !!Collection methodsFor: '*magritte-model' stamp: 'lr 7/6/2010 18:32'!copyWithoutFirstOccurrenceOf: anObject	| done |	done := false.	^ self reject: [ :each |		each = anObject			and: [ done not			and: [ done := true ] ] ]! !!NumberParser class methodsFor: '*Magritte-Model' stamp: 'SeanDeNigris 4/12/2015 10:18' prior: 51048296!isNumber: aStringOrStream	| stream |	stream := aStringOrStream readStream.	NumberParser parse: stream onError: [ ^ false ].	^ stream atEnd! !!MADynamicDescriptionCache class methodsFor: 'defaults' stamp: 'NickAger 2/3/2012 12:39'!defaultValue	^ IdentityDictionary new! !!MADynamicVariable class methodsFor: 'defaults' stamp: 'NickAger 2/3/2012 12:38'!defaultValue	^ nil! !!MADynamicVariable class methodsFor: 'private' stamp: 'NickAger 2/3/2012 12:38'!use: anObject during: aBlock	"Set the dynamic value of the receiver to anObject during the evaluation of aBlock."		^ aBlock on: self do: [ :notification | notification resume: anObject ]! !!MADynamicVariable class methodsFor: 'evaluating' stamp: 'NickAger 2/3/2012 12:38'!value	"Answer the dynamic value of the receiver."		^ self signal! !!MADynamicVariable methodsFor: 'defaults' stamp: 'NickAger 2/3/2012 12:37'!defaultAction	^ self class defaultValue! !"Magritte-Model"!!MAExternalFileModel commentStamp: '<historical>' prior: 0!I manage the file-data I represent on the file-system. From the programmer this looks the same as if the file would be in memory (==*MAMemoryFileModel*==), as it is transparently loaded and written out as necessary.I delegate my actual location on disk to MAFileDatabase (see class comment).!!MAFileDatabase commentStamp: '<historical>' prior: 0!I provide locations for external files.- The ==#baseDirectory== is the place where Magritte puts its file-database. Keep this value to nil to make it default to a subdirectory next to the Smalltalk image.- The ==#baseUrl== is a nice optimization to allow Apache (or any other Web Server) to directly serve the files. ==#baseUrl== is an absolute URL-prefix that is used to generate the path to the file. If you have specified one the file data does not go trough the image anymore, but instead is directly served trough the properly configured Web Server.The files are currently stored using the following scheme:=/files/9d/bsy8kyp45g0q7blphknk48zujap2wd/earthmap1k.jpg=1     2   3                            						  41. is the #baseDirectory as specified in the settings.2. Are 256 directories named '00' to 'ff' to avoid having thousands of files in the same directory. Unfortunately this leads to problems with the Squeak file primitives and some filesystems don't handle that well. This part is generated at random.3. This is a secure ID, similar to the Seaside session key. It is generated at random and provides a security system that even works through Apache (you have to disable directory listings of course): if you don't know the filename you can not access the file.4. This is the original filename. Subclasses might want to store other cached versions of the same file there, for example resized images, etc.!!MAExternalFileModel class methodsFor: 'accessing' stamp: 'DiegoLont 2/4/2014 14:11'!baseDirectoryPath	" deprecated: use MAFileDatabase baseDirectoryPath instead "	^MAFileDatabase baseDirectory fullName! !!MAExternalFileModel class methodsFor: 'accessing' stamp: 'DiegoLont 7/31/2014 10:13'!baseDirectoryPath: aString 	" deprecated, but still used by pier "	MAFileDatabase baseDirectory: aString! !!MAExternalFileModel class methodsFor: 'accessing' stamp: 'DiegoLont 2/4/2014 14:23'!baseUrl	" deprecated: use MAFileDatabase baseDirectoryPath instead "	^ MAFileDatabase baseUrl! !!MAExternalFileModel class methodsFor: 'accessing' stamp: 'DiegoLont 7/31/2014 10:14'!baseUrl: aString	" deprecated: use MAFileDatabase baseUrl instead "	^ MAFileDatabase baseUrl: aString! !!MAExternalFileModel methodsFor: 'comparing' stamp: 'SeanDeNigris 9/29/2013 09:50'!= anObject    ^ super = anObject and: [ self directory = anObject directory ]! !!MAExternalFileModel methodsFor: 'configuration' stamp: 'SeanDeNigris 9/29/2013 11:16'!baseUrl	^ self database baseUrl! !!MAExternalFileModel methodsFor: 'accessing' stamp: 'DiegoLont 7/24/2013 14:01'!contents	| stream |	^ self file exists		ifFalse: [ ByteArray new ]		ifTrue: [			stream := self readStream.			[ stream contents ]				ensure: [ stream close ] ]! !!MAExternalFileModel methodsFor: 'accessing' stamp: 'nfr 10/17/2007 12:26'!contents: aByteArray	| stream |	stream := self writeStream.	[ stream nextPutAll: aByteArray asByteArray ]		ensure: [ stream close ].	super contents: aByteArray! !!MAExternalFileModel methodsFor: 'private' stamp: 'SeanDeNigris 9/29/2013 09:30'!database	^ MAFileDatabase new.! !!MAExternalFileModel methodsFor: 'accessing-dynamic' stamp: 'SeanDeNigris 9/29/2013 09:49'!directory	^ directory ifNil: [ directory := self database uniqueLocation ].! !!MAExternalFileModel methodsFor: 'accessing-dynamic' stamp: 'DiegoLont 7/24/2013 14:17'!file	^(self directory / self filename) asFileReference! !!MAExternalFileModel methodsFor: 'initialization' stamp: 'DamienCassou 6/1/2014 12:12'!finalize	|  dir |	dir := self directory.	dir exists		ifTrue: [ dir deleteAll ].	[ (dir := dir parent) hasChildren ]		whileFalse: [ dir ensureDelete ].	super finalize.	location := nil! !!MAExternalFileModel methodsFor: 'comparing' stamp: 'SeanDeNigris 9/29/2013 09:53'!hash	^ super hash bitXor: self directory hash! !!MAExternalFileModel methodsFor: 'copying' stamp: 'lr 3/28/2007 10:27'!postCopy	| previous |	super postCopy.	previous := self contents.	location := nil.	self contents: previous! !!MAExternalFileModel methodsFor: 'accessing-dynamic' stamp: 'SeanDeNigris 9/29/2013 09:13'!readStream	^ self file readStream binary.! !!MAExternalFileModel methodsFor: 'accessing-dynamic' stamp: 'SeanDeNigris 9/29/2013 09:15'!writeStream	^ self file writeStream binary! !!MorphicUIManager methodsFor: '*Magritte-Pharo3-Model' stamp: 'SeanDeNigris 9/29/2013 12:00'!chooseFile: windowTitle in: directoryString	| chooser |	chooser := FileDialogWindow newWithTheme: UITheme current.	chooser		title: windowTitle;		selectDirectory: directoryString;		answerFileEntry.	^ chooser openModal answer ifNotNil: [ :answer | answer asFileReference ].! !!GRPharoPlatform methodsFor: '*Magritte-Pharo3-Model' stamp: 'jf 9/16/2009 13:39'!magritteAllSubInstancesOf: aClass do: aBlock	"Evaluate the aBlock for all instances of aClass and all its subclasses."	aClass allSubInstancesDo: aBlock! !!GRPharoPlatform methodsFor: '*Magritte-Pharo3-Model' stamp: 'jf 9/16/2009 13:32'!magritteClassNamed: aString	"Return the class named aString, nil if the class can't be found."	^ Smalltalk classNamed: aString! !!GRPharoPlatform methodsFor: '*Magritte-Pharo3-Model' stamp: 'jf 9/15/2009 18:43'!magritteColorClass	"Return a Color class"		^ Color! !!GRPharoPlatform methodsFor: '*Magritte-Pharo3-Model' stamp: 'DamienCassou 11/21/2013 14:58'!magritteEvaluatorClassFor: aClass	"Answer an evaluator class appropriate for evaluating expressions in the 	context of this class."		^ aClass compilerClass! !!GRPharoPlatform methodsFor: '*Magritte-Pharo3-Model' stamp: 'JohnCBorden 4/26/2015 13:42'!magritteTimeStampClass	"Return the platform's TimeStamp class. It is currently assumed that all platforms	have one, though this may not be correct and could require moving timestamp stuff	to its own package in order to resolve."		^ DateAndTime! !!GRPharoPlatform methodsFor: '*Magritte-Pharo3-Model' stamp: 'JohnCBorden 4/26/2015 13:42'!magritteTimeStampIfAbsent: absentBlock	"Return the TimeStamp class, or if the platform does not have a TimeStamp	return the result of evaluating absentBlock."		^ DateAndTime! !!GRPharoPlatform methodsFor: '*Magritte-Pharo3-Model' stamp: 'lr 1/11/2010 23:04'!magritteUniqueObject	"Answer a random object, such as a UUID, that is extremely likely to	be unique over space and time."	^ ByteArray withAll: UUID new! !!MAFileDatabase class methodsFor: 'accessing' stamp: 'SeanDeNigris 9/29/2013 08:28'!baseDirectory	^ baseDirectory ifNil: [ FileLocator imageDirectory / 'files' ].! !!MAFileDatabase class methodsFor: 'accessing' stamp: 'SeanDeNigris 9/29/2013 08:31'!baseDirectory: aStringOrDirectory	"Defines where the files are stored. If this value is set to nil, it defaults to a subdirectory of of the current image-location."	baseDirectory := aStringOrDirectory asFileReference.! !!MAFileDatabase class methodsFor: 'accessing' stamp: 'SeanDeNigris 9/29/2013 09:51'!baseUrl	^ baseUrl! !!MAFileDatabase class methodsFor: 'accessing' stamp: 'DamienCassou 1/16/2014 09:55'!baseUrl: aString	"Defines the base-URL where the files are served from, when using an external web server. This setting is left to nil by default, causing the files to be served trough the image."	baseUrl := aString isNil ifFalse: [		aString last = $/			ifFalse: [ aString ]			ifTrue: [ aString copyUpToLast: $/ ] ]! !!MAFileDatabase class methodsFor: 'public' stamp: 'SeanDeNigris 9/29/2013 08:53'!garbageCollect	"Remove obsolete files from the file-system that are not referenced from the image anymore. This method has to be called manually and is not intended to be portable."		| mark sweep |	mark := self allInstances		collect: [ :each | each directory ].	sweep := Array with: self baseDirectory.	self locationDefinition do: [ :definition |		sweep := sweep gather: [ :directory |			directory hasChildren ifFalse: [ directory delete ].			FileLocator imageDirectory directories select: [ :e | e basename size = definition first ] ] ].	sweep do: [ :directory |		(mark includes: directory) ifFalse: [ directory recursiveDelete ] ]! !!MAFileDatabase class methodsFor: 'public' stamp: 'SeanDeNigris 9/29/2013 09:01'!locationDefinition	^ #( ( 2 '63450af8d9c2e17b' ) ( 30 'iaojv41bw67e0tud5m9rgplqfy8x3cs2kznh' ) )! !!MAFileDatabase methodsFor: 'accessing' stamp: 'SeanDeNigris 9/29/2013 09:45'!baseDirectory	^ self class baseDirectory.! !!MAFileDatabase methodsFor: 'accessing' stamp: 'DamienCassou 1/16/2014 09:57'!baseUrl	^ self class baseUrl.! !!MAFileDatabase methodsFor: 'private' stamp: 'SeanDeNigris 9/29/2013 09:44'!randomIdentifierName	| digits idLength allowedCharacters |	digits := $0 to: $9.	allowedCharacters := digits, Character alphabet.	idLength := 30.	^ String streamContents: [ :str |		idLength timesRepeat: [ str nextPut: allowedCharacters atRandom ] ].! !!MAFileDatabase methodsFor: 'private' stamp: 'SeanDeNigris 9/29/2013 09:38'!randomPartitionFolderName	"Returns a string between '00' to 'FF'"	| twoCharacterHexString |	twoCharacterHexString := 16rFF atRandom printStringBase: 16 length: 2 padded: true.	^ twoCharacterHexString asLowercase.! !!MAFileDatabase methodsFor: 'public' stamp: 'StephanEggermont 3/4/2014 12:58'!uniqueLocation	"Finds an unique path to be used and create the necessary sub directories."	| partition id result |	[		partition := self randomPartitionFolderName.		id := self randomIdentifierName.		result := self baseDirectory ensureCreateDirectory / partition / id.	] doWhileTrue: [ result exists ].		^ result ensureCreateDirectory.! !!MAFileSystem class methodsFor: 'paths' stamp: 'SeanDeNigris 9/26/2013 13:01'!extensionFor: aString 	^ aString asFileReference extension.! !!MAFileSystem class methodsFor: 'entries' stamp: 'SeanDeNigris 9/26/2013 12:49'!fileSizeFor: filenameString 	^ filenameString asFileReference size! !!MAFileSystem class methodsFor: 'paths' stamp: 'SeanDeNigris 9/26/2013 12:37'!fullNameFor: aString 	^ aString asFileReference fullName.! !!MAFileSystem class methodsFor: 'locations' stamp: 'SeanDeNigris 9/29/2013 12:14'!imageDirectory	^ FileLocator imageDirectory.! !!MAFileSystem class methodsFor: 'mime types' stamp: 'SeanDeNigris 9/26/2013 13:13'!mimeTypesForExtension: aString 	| types |	types := MIMEType forExtensionReturnMimeTypesOrNil: aString.	^ types ifNotNil: [ types collect: [ :e | e asString ] ].! !!GRPackage class methodsFor: '*Magritte-Pharo3-Model' stamp: 'lr 2/16/2010 09:16'!magrittePharoModel	^ self new		name: 'Magritte-Pharo-Model';		addDependency: 'Magritte-Model';		url: #magritteUrl;		yourself! !"Magritte-Pharo3-Model"!!MASilentContainerMorph commentStamp: 'tg 5/6/2009 13:26' prior: 0!The only difference to the superclass is that on answer it does not delete the morph. This is useful when we want the morph to be embedded.!!MADirectoryDescription class methodsFor: '*magritte-morph-defaults' stamp: 'SeanDeNigris 11/21/2013 21:57'!defaultMorphClasses	^ Array with: MADirectoryMorph! !!MAFileDescription class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array with: MAFileMorph! !!Object methodsFor: '*magritte-morph-converting' stamp: 'TudorGirba 3/15/2013 22:18'!asMagritteMorph	^ self magritteDescription asMorphOn: self! !!Object methodsFor: '*Magritte-Morph' stamp: 'SeanDeNigris 10/11/2013 18:08'!maEdit 	self asMagritteMorph		addButtons;		addWindow;		openInWorld.! !!Object methodsFor: '*Magritte-Morph' stamp: 'SeanDeNigris 8/13/2015 09:44'!magritteActionButtons	^ self magritteActionDescriptions collect: [ :e | e buttonOn: self ].! !!MADescription class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphClass	^ self defaultMorphClasses notEmpty		ifTrue: [ self defaultMorphClasses first ]! !!MADescription class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array new! !!MADescription class methodsFor: '*magritte-morph-defaults' stamp: 'lr 2/21/2008 11:36'!defaultMorphColor	^ Color white! !!MADescription methodsFor: '*magritte-morph-accessing' stamp: 'NickAger 1/16/2012 18:12'!descriptionMorphClass	<magritteDescription>	^ MASingleOptionDescription new		accessor: #morphClass;		label: 'Morph Class';		priority: 2000;		reference: MAClassDescription new;		options: self class defaultMorphClasses;		default: self class defaultMorphClass;		yourself! !!MADescription methodsFor: '*magritte-morph-accessing' stamp: 'lr 3/9/2006 11:33'!morphClass	^ self propertyAt: #morphClass ifAbsent: [ self class defaultMorphClass ]! !!MADescription methodsFor: '*magritte-morph-accessing' stamp: 'lr 3/9/2006 11:33'!morphClass: aClass	^ self propertyAt: #morphClass put: aClass! !!MADescription methodsFor: '*magritte-morph-accessing' stamp: 'lr 3/9/2006 11:33'!morphColor	^ self propertyAt: #morphColor ifAbsent: [ self class defaultMorphColor ]! !!MADescription methodsFor: '*magritte-morph-accessing' stamp: 'lr 3/9/2006 11:33'!morphColor: aColor	^ self propertyAt: #morphColor put: aColor! !!MAElementDescription class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array with: MATextMorph! !!MAActionDescription methodsFor: '*magritte-morph' stamp: 'SeanDeNigris 11/21/2013 18:13'!buttonOn: anObject	model := anObject.	^ UITheme current builder newButtonFor: self action: #perform getEnabled: #isEnabled label: self label help: comment.! !!MASingleOptionDescription class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array with: MASingleSelectListMorph! !!MAToOneRelationDescription class methodsFor: '*magritte-morph-defaults' stamp: 'SeanDeNigris 6/9/2013 00:19'!defaultMorphClasses	^ Array with: MAExternalEditorMorph with: MAInternalEditorMorph! !!MAElementRow class methodsFor: 'instance creation' stamp: 'SeanDeNigris 6/11/2013 01:28'!addMorphFor: anObject of: aDescriptionMorph to: aMorph	| instance |	instance := self for: anObject of: aDescriptionMorph.	aMorph addMorphBack: instance.! !!MAElementRow class methodsFor: 'instance creation' stamp: 'SeanDeNigris 6/11/2013 01:27'!for: anObject of: aDescriptionMorph	^ self basicNew		object: anObject;		container: aDescriptionMorph;		initialize.! !!MAElementRow methodsFor: 'private' stamp: 'SeanDeNigris 6/11/2013 00:27'!buildButton: aSymbol 	^ UITheme current builder newButtonFor: self action: aSymbol label: aSymbol capitalized help: ''.! !!MAElementRow methodsFor: 'private' stamp: 'SeanDeNigris 6/11/2013 00:56'!buildCommands	| commands |	commands := self rectangleMorph		listDirection: #leftToRight;		cellInset: self cellInset;		yourself.	container magritteDescription isDefinitive ifFalse: [		commands			addMorphBack: (self buildButton: #edit);			addMorphBack: (self buildButton: #remove) ].	container magritteDescription isOrdered ifTrue: [		self shouldBeImplemented.		"commands			addCommandOn: self selector: #up: text: 'up';			addCommandOn: self selector: #down: text: 'down'" ].	^ commands! !!MAElementRow methodsFor: 'private' stamp: 'SeanDeNigris 6/11/2013 00:02'!cellInset	^ 4@4.! !!MAElementRow methodsFor: 'private' stamp: 'SeanDeNigris 6/11/2013 00:55'!container: aDescriptionMorph	container := aDescriptionMorph! !!MAElementRow methodsFor: 'callbacks' stamp: 'SeanDeNigris 9/26/2013 10:36'!edit	object asMagritteMorph		onAnswer: [ :result | self summary: result printString ];		addButtons;		addWindow;		openInWorld.! !!MAElementRow methodsFor: 'private' stamp: 'SeanDeNigris 11/29/2013 17:18'!initialize	super initialize.	self		borderWidth: 0;		color: Color transparent;		layoutPolicy: TableLayout new;		cellPositioning: #topLeft;		vResizing: #shrinkWrap;		hResizing: #spaceFill;		listDirection: #leftToRight;		cellInset: self cellInset;		layoutInset: 0@2.	self		addMorphBack: (container magritteDescription displayStringFor: object) asMorph;		addMorphBack: self buildCommands! !!MAElementRow methodsFor: 'private' stamp: 'SeanDeNigris 6/11/2013 00:25'!object: anObject	object := anObject! !!MAElementRow methodsFor: 'private' stamp: 'SeanDeNigris 6/11/2013 00:04'!rectangleMorph	^ MADescriptionMorph new rectangleMorph.! !!MAElementRow methodsFor: 'callbacks' stamp: 'SeanDeNigris 6/11/2013 01:17'!remove	container value: (container value copyWithout: object).	self delete.! !!MAElementRow methodsFor: 'private' stamp: 'SeanDeNigris 6/11/2013 01:16'!summary: aString	submorphs first contents: aString! !!MAElementRow methodsFor: 'private' stamp: 'SeanDeNigris 6/11/2013 00:40'!value	^ self memento readUsing: self magritteDescription! !!MAElementRow methodsFor: 'private' stamp: 'SeanDeNigris 6/11/2013 00:40'!value: anObject	self memento write: anObject using: self magritteDescription! !!MAMultipleOptionDescription class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array with: MAMultiSelectListMorph! !!MAPasswordDescription class methodsFor: '*magritte-morph-default' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array with: MAPasswordMorph! !!MAToManyRelationDescription class methodsFor: '*magritte-morph-defaults' stamp: 'SeanDeNigris 6/11/2013 12:01'!defaultMorphClasses	^ Array with: MAOneToManyMorph! !!MAMemoDescription class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array with: MAMemoMorph! !!GRPackage class methodsFor: '*magritte-morph' stamp: 'lr 2/18/2010 10:30'!magritteMorph	^ self new		name: 'Magritte-Morph';		description: 'Morphic integration for the Magritte metamodel.';		addDependency: 'Magritte-Model';		url: #magritteUrl;		yourself! !!MABooleanDescription class methodsFor: '*magritte-morph-default' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array with: MACheckboxMorph with: MASingleSelectListMorph! !!MADateDescription class methodsFor: '*magritte-morph-default' stamp: 'SeanDeNigris 6/12/2013 08:30'!defaultMorphClasses	^ Array with: MADateMorph.! !!MAContainer class methodsFor: '*magritte-morph-defaults' stamp: 'lr 3/9/2006 11:33'!defaultMorphClasses	^ Array with: MAContainerMorph! !!MAContainer methodsFor: '*magritte-morph-converting' stamp: 'lr 3/9/2006 11:33'!asMorphOn: anObject	^ self morphClass		memento: (anObject mementoClass			model: anObject			description: self)! !!MAContainerMorph methodsFor: 'decorating' stamp: 'lr 3/9/2006 11:33'!addButtons	self addButtons: #( save cancel )! !!MAContainerMorph methodsFor: 'decorating' stamp: 'lr 10/30/2006 13:41'!addButtons: anArray	morph := self rectangleMorph		addMorphBack: self morph;		addMorphBack: (self barMorph: anArray);		yourself! !!MAContainerMorph methodsFor: 'decorating' stamp: 'TudorGirba 5/7/2011 23:29'!addWindow	| scrollPane newMorph |	scrollPane := GeneralScrollPane new.	newMorph := self morph 		vResizing: #spaceFill;		hResizing: #spaceFill.	scrollPane changeScrollerTableLayout; scrollTarget: newMorph.		morph := self windowMorph		model: self;		vResizing: #shrinkWrap;		addMorph: (scrollPane layoutInset: 5 @ 5)			frame: (0 @ 0 corner: 1 @ 1);		yourself! !!MAContainerMorph methodsFor: 'answering' stamp: 'SeanDeNigris 9/29/2013 15:35'!answer: anObject	| didUserCancel |	self morph delete.		didUserCancel := anObject isNil.	didUserCancel | answerBlock isNil ifTrue: [ ^ self ].	answerBlock value: anObject.! !!MAContainerMorph methodsFor: 'private' stamp: 'NickAger 1/17/2012 15:57'!buildChildren	^ Array streamContents: [ :stream |		self magritteDescription do: [ :each |			each isVisible ifTrue: [				stream nextPut: (each morphClass					memento: self memento					description: each					parent: self) ] ] ]! !!MAContainerMorph methodsFor: 'private' stamp: 'SeanDeNigris 8/13/2015 09:44'!buildMorphViewOn: aMorph	| toolbar |	aMorph		listDirection: #topToBottom;		cellInset: 3.	self children do: [ :each |		aMorph addMorphBack: each morph ].	toolbar := self rectangleMorph		listDirection: #leftToRight;		cellInset: 4@0;		layoutInset: 4@4;		yourself.	self model magritteActionButtons do: [ :e | toolbar addMorphBack: e ].	aMorph addMorphBack: toolbar.		! !!MAContainerMorph methodsFor: 'morphic' stamp: 'lr 3/9/2006 11:33'!callInHand	| result |	result := nil.	self onAnswer: [ :value | result := value ].	self openInHand; waitUntilClosed.	^ result! !!MAContainerMorph methodsFor: 'morphic' stamp: 'lr 3/9/2006 11:33'!callInWorld	| result |	result := nil.	self onAnswer: [ :value | result := value ].	self openInWorld; waitUntilClosed.	^ result! !!MAContainerMorph methodsFor: 'actions' stamp: 'lr 4/5/2007 17:12'!cancel	self reset; answer: nil! !!MAContainerMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!children	^ children! !!MAContainerMorph methodsFor: 'error handling' stamp: 'SeanDeNigris 6/13/2013 22:07'!doesNotUnderstand: aMessage	"Forward callbacks from #addButtons: to the model if appropriate"	(self model respondsTo: aMessage selector)		ifTrue: [ self model perform: aMessage selector ]		ifFalse: [ super doesNotUnderstand: aMessage ].! !!MAContainerMorph methodsFor: 'answering' stamp: 'SeanDeNigris 9/29/2013 15:29'!onAnswer: aBlock	answerBlock := aBlock! !!MAContainerMorph methodsFor: 'morphic' stamp: 'lr 3/9/2006 11:33'!openInHand	^ self morph openInHand! !!MAContainerMorph methodsFor: 'morphic' stamp: 'SeanDeNigris 11/29/2013 23:16'!openInWindow	^ self		addWindow;		openInWorld.! !!MAContainerMorph methodsFor: 'morphic' stamp: 'lr 3/9/2006 11:33'!openInWorld	^ self morph openInWorld! !!MAContainerMorph methodsFor: 'actions' stamp: 'jf 10/28/2009 15:28'!save	[ self validate ]		on: MAValidationError		do: [ :err | ^ self inform: err greaseString ].	self commit; answer: self model! !!MAContainerMorph methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setChildren: aCollection	children := aCollection! !!MAContainerMorph methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setDescription: aDescription	super setDescription: aDescription.	self setChildren: self buildChildren! !!MAContainerMorph methodsFor: 'morphic' stamp: 'TudorGirba 5/7/2011 23:34'!waitUntilClosed	[ self morph world notNil ]		whileTrue: [ self morph outermostWorldMorph doOneCycle ]! !!MASilentContainerMorph methodsFor: 'answering' stamp: 'SeanDeNigris 9/29/2013 15:29'!answer: anObject	answerBlock isNil		ifFalse: [ answerBlock value: anObject ].! !!MADescriptionMorph class methodsFor: 'instance creation' stamp: 'NickAger 1/19/2012 17:00'!memento: aMemento	^ self memento: aMemento description: aMemento magritteDescription! !!MADescriptionMorph class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!memento: aMemento description: aDescription	^ self memento: aMemento description: aDescription parent: nil! !!MADescriptionMorph class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:33'!memento: aMemento description: aDescription parent: aComponent	^ self new		setMemento: aMemento;		setDescription: aDescription;		setParent: aComponent;		yourself! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'lr 3/9/2006 11:33'!barMorph: anArray	| bar |	bar := self rectangleMorph		hResizing: #spaceFill;		vResizing: #spaceFill;		listDirection: #leftToRight;		listCentering: #center;		wrapCentering: #bottomRight;		cellInset: self defaultSpacerSize;		yourself.	anArray do: [ :selector |		bar addMorphBack: (self buttonMorph: selector) ].	^ bar! !!MADescriptionMorph methodsFor: 'private' stamp: 'SeanDeNigris 6/10/2013 21:55'!buildMorph	| result |	result := self rectangleMorph		setBalloonText: self magritteDescription comment;		yourself.	self magritteDescription isReadonly		ifTrue: [ self buildMorphViewOn: result ]		ifFalse: [ self buildMorphEditorOn: result ].	^ result! !!MADescriptionMorph methodsFor: 'private' stamp: 'SeanDeNigris 6/10/2013 21:55'!buildMorphEditorOn: aMorph	self buildMorphViewOn: aMorph! !!MADescriptionMorph methodsFor: 'private' stamp: 'SeanDeNigris 6/10/2013 21:55'!buildMorphViewOn: aMorph	self subclassResponsibility! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'lr 2/21/2008 11:33'!buttonMorph: aSelector	| button |	button := PluggableButtonMorph		on: self		getState: #buttonState		action: aSelector.	button		label: aSelector;		hResizing: #spaceFill;		shortcutCharacter: aSelector first.	^ button! !!MADescriptionMorph methodsFor: 'private-morphic' stamp: 'lr 3/9/2006 11:33'!buttonState	^ true! !!MADescriptionMorph methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!commit	self memento commit! !!MADescriptionMorph methodsFor: 'accessing-configuration' stamp: 'NickAger 1/17/2012 15:56'!defaultBackgroundColor	^ self magritteDescription morphColor! !!MADescriptionMorph methodsFor: 'accessing-configuration' stamp: 'lr 3/9/2006 11:33'!defaultSpacerSize	^ 5! !!MADescriptionMorph methodsFor: 'accessing' stamp: 'NickAger 1/17/2012 15:56'!magritteDescription	^ description! !!MADescriptionMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!memento	^ memento! !!MADescriptionMorph methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!model	^ self memento model! !!MADescriptionMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!morph	^ morph ifNil: [ morph := self buildMorph ]! !!MADescriptionMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!parent	^ parent! !!MADescriptionMorph methodsFor: 'private-morphic' stamp: 'lr 3/9/2006 11:33'!perform: selector orSendTo: otherTarget	^ (self respondsTo: selector)		ifTrue: [ self perform: selector ]		ifFalse: [ otherTarget perform: selector ]! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'TudorGirba 11/4/2013 06:11'!rectangleMorph	^ BorderedMorph new		borderWidth: 0;		color: Color transparent;		layoutPolicy: TableLayout new;		cellPositioning: #topLeft;		vResizing: #shrinkWrap;		hResizing: #spaceFill;		yourself! !!MADescriptionMorph methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!reset	self memento reset! !!MADescriptionMorph methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:33'!root	^ self parent isNil		ifTrue: [ self ]		ifFalse: [ self parent root ]! !!MADescriptionMorph methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setDescription: aDescription	description := aDescription! !!MADescriptionMorph methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setMemento: aMemento	memento := aMemento! !!MADescriptionMorph methodsFor: 'initialization' stamp: 'lr 3/9/2006 11:33'!setParent: aMorph	parent := aMorph! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'lr 3/9/2006 11:33'!stringMorph	^ StringMorph new! !!MADescriptionMorph methodsFor: 'actions' stamp: 'lr 3/9/2006 11:33'!validate	"Flushes the cached state of some morphic elements (such as text-morphs) to the memento and then does the validation. I don't know of a better flush the morphic contents (happy flickering), probably morphic is just too limited to customize that easily or I am too dumb to find out."	self morph allMorphsDo: [ :each |		(each respondsTo: #accept)			ifTrue: [ each accept ] ].	self memento validate! !!MADescriptionMorph methodsFor: 'prototypes' stamp: 'NickAger 1/19/2012 17:00'!windowMorph	^ SystemWindow labelled: self magritteDescription label! !!MACheckboxMorph methodsFor: 'private' stamp: 'SeanDeNigris 6/13/2013 15:57'!buildMorphView	^ UITheme current 		newCheckboxIn: nil		for: self		getSelected: #selected		setSelected: #selected:		getEnabled: #enabled		label: ''		help: self magritteDescription comment! !!MACheckboxMorph methodsFor: 'actions' stamp: 'tg 5/14/2009 22:03'!enabled	^ true! !!MACheckboxMorph methodsFor: 'actions' stamp: 'NickAger 1/17/2012 15:58'!selected	^ (self value ifNil: [ self magritteDescription default ]) ifNil: [ false ]! !!MACheckboxMorph methodsFor: 'actions' stamp: 'tg 5/14/2009 22:03'!selected: aBoolean	self value: aBoolean ! !!MADateMorph methodsFor: 'private-building' stamp: 'SeanDeNigris 7/28/2015 12:13'!buildMorphView	| model |	model := DateModel new		displayBlock: [ :e | description displayStringFor: e ];		date: self value;		whenDateChanged: [ :newDate | self value: newDate ];		yourself.	^ model buildWithSpec			yourself.! !!MAElementMorph methodsFor: 'private-building' stamp: 'NickAger 1/17/2012 15:58'!buildMorphLabel	^ self stringMorph		contents: self magritteDescription label , ':';		width: 100;		yourself! !!MAElementMorph methodsFor: 'private-building' stamp: 'lr 3/9/2006 11:33'!buildMorphRequired	^ self stringMorph		contents: ' *';		color: Color red;		yourself! !!MAElementMorph methodsFor: 'private-building' stamp: 'SeanDeNigris 6/10/2013 21:55'!buildMorphView	^ self stringMorph		contents: self string;		yourself! !!MAElementMorph methodsFor: 'private-building' stamp: 'SeanDeNigris 6/10/2013 21:55'!buildMorphViewOn: aMorph	aMorph		layoutInset: 1 @ 1;		listDirection: #leftToRight;		addMorphBack: self buildMorphLabel;		addMorphBack: self buildMorphView.	self magritteDescription hasComment		ifTrue: [ aMorph setBalloonText: self magritteDescription comment ].	self magritteDescription isRequired		ifTrue: [ aMorph addMorphBack: self buildMorphRequired ]! !!MAElementMorph methodsFor: 'accessing' stamp: 'NickAger 1/17/2012 15:58'!string	^ self magritteDescription toString: self value! !!MAElementMorph methodsFor: 'accessing' stamp: 'SeanDeNigris 4/21/2015 11:21'!string: aString	| value |	value := self magritteDescription fromString: aString greaseString.	self value: value; changed: #string! !!MAElementMorph methodsFor: 'accessing' stamp: 'NickAger 1/17/2012 15:58'!value	^ self memento readUsing: self magritteDescription! !!MAElementMorph methodsFor: 'accessing' stamp: 'NickAger 1/17/2012 15:58'!value: anObject	self memento write: anObject using: self magritteDescription.	self changed: #value! !!MADirectoryMorph methodsFor: 'private' stamp: 'SeanDeNigris 11/21/2013 22:03'!choose: titleString in: defaultDirectory	^ UIManager default chooseDirectory: titleString from: defaultDirectory.! !!MAFileMorph methodsFor: 'private-building' stamp: 'SeanDeNigris 9/29/2013 11:58'!buildMorphView	| button |	rectangleMorph := self rectangleMorph		listDirection: #leftToRight;		yourself.	button := self buttonMorph: #choose.	button		hResizing: #shrinkWrap.	rectangleMorph addMorphBack: button.	self value ifNotNil: [ self displayCurrentValue ].	^ rectangleMorph.! !!MAFileMorph methodsFor: 'actions' stamp: 'SeanDeNigris 11/21/2013 22:01'!choose	| file |	file := self		choose: 'Choose ', self magritteDescription label		in: self magritteDescription defaultDirectory. 	file ifNil: [ ^ self ].	self value: file.	self displayCurrentValue.! !!MAFileMorph methodsFor: 'private' stamp: 'SeanDeNigris 11/21/2013 22:02'!choose: titleString in: defaultDirectory	^ UIManager default chooseFile: titleString in: defaultDirectory.	"We're using UIManager apparently for two reasons:		1. To maintain compatibility between Pharo and Squeak.		2. If this is a Seaside app, we may be headless	However, none of the Squeak/Pharo common UIManager API does what's needed e.g. to specify a starting folder. So I'm implementing the #chooseFile:in: for headful Pharo. At such time when someone tries in another scenario i.e. headless/Squeak, we have an entry point to implement support for those"! !!MAFileMorph methodsFor: 'private' stamp: 'SeanDeNigris 9/29/2013 12:08'!currentValueMorph	| exists |	exists := rectangleMorph submorphs size = 2.	exists ifFalse: [ rectangleMorph addMorph: StringMorph new ].	^ rectangleMorph submorphs first.! !!MAFileMorph methodsFor: 'private' stamp: 'SeanDeNigris 9/29/2013 13:29'!displayCurrentValue	| displayString |	displayString := description displayStringFor: self value.	self currentValueMorph contents: displayString.! !!MADropListMorph methodsFor: 'private-building' stamp: 'EstebanLorenzano 1/12/2014 20:21'!buildMorphView		| list |	list := DropListModel new.	list		items: self options;		displayBlock: [ :e | 			e				ifNil: [ '' ]				ifNotNil: [ self magritteDescription reference toString: e ] ];		setSelectedItem: self value;		whenSelectedItemChanged: [ :e | self value: e ].		^ list buildWithSpec.! !!MAListMorph methodsFor: 'accessing-dynamic' stamp: 'EstebanLorenzano 1/12/2014 20:18'!options	^ self magritteDescription allOptions! !!MAListMorph methodsFor: 'accessing-dynamic' stamp: 'NickAger 1/17/2012 15:59'!strings	^ self options collect: [ :each | self magritteDescription reference toString: each ]! !!MAMultiSelectListMorph methodsFor: 'private' stamp: 'SeanDeNigris 6/10/2013 22:31'!buildMorph			^ super buildMorph.! !!MAMultiSelectListMorph methodsFor: 'private' stamp: 'SeanDeNigris 6/10/2013 22:30'!buildMorphView	^ (PluggableListMorph on: self list: #strings primarySelection: #selected changePrimarySelection: #selected: listSelection: #selectionAt: changeListSelection: #selectionAt:put: menu: nil)		hResizing: #spaceFill;		borderColor: #inset;		borderWidth: 1;		beMultipleSelection;		yourself! !!MAMultiSelectListMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!selected	^ selected ifNil: [ selected := 0 ]! !!MAMultiSelectListMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!selected: anInteger	selected := anInteger.	self changed: #selected! !!MAMultiSelectListMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!selectionAt: anInteger	^ self value includes: (self options at: anInteger)! !!MAMultiSelectListMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!selectionAt: anInteger put: aBoolean	| option |	option := self options at: anInteger.	self value: (aBoolean		ifTrue: [ self value copyWith: option ]		ifFalse: [ self value copyWithout: option ]).	self changed: #selected! !!MASingleSelectListMorph methodsFor: 'private' stamp: 'SeanDeNigris 6/10/2013 22:00'!buildMorphView	^ (PluggableListMorph on: self list: #strings selected: #selected changeSelected: #selected:)		hResizing: #spaceFill;		borderColor: #inset;		borderWidth: 1;		yourself! !!MASingleSelectListMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!selected	^ self options indexOf: self value! !!MASingleSelectListMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!selected: anInteger	self value: (self options at: anInteger ifAbsent: [ nil ]).	self changed: #selected! !!MAMemoMorph methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:33'!annotation	^ self string! !!MAMemoMorph methodsFor: 'private' stamp: 'SeanDeNigris 10/24/2013 17:15'!buildMorphView	"The selector #annotation should be #string instead, but we use this one and dispatch since this prevents morphic to draw a thin red border around changed fields. Stupid hack, really, but doesn't work otherwise."	| result lineSpacingFactor height |	result := PluggableTextMorph on: self text: #annotation accept: #string:.		"We want to set the height to honor the #lineCount from the description, but PluggableTextMorph doesn't seem to have an API to get the height of a hypothetical block of text e.g. 5 lines in the current font. So we work out an approximation as follows..."	lineSpacingFactor := 1.1. "This seems to account well for space between lines"	height := (description lineCount * result font height * lineSpacingFactor) + (result borderWidth * 2).		^ result			height: height;			hResizing: #spaceFill;			borderColor: #inset;			borderWidth: 1! !!MAMemoMorph methodsFor: 'accessing' stamp: 'SeanDeNigris 3/26/2015 11:56'!enabled	^ self magritteDescription readonly not! !!MAMemoMorph methodsFor: 'accessing' stamp: 'NickAger 1/17/2012 15:59'!selected	^ (self value ifNil: [ self magritteDescription default ]) ifNil: [ false ]! !!MAMemoMorph methodsFor: 'accessing' stamp: 'tg 5/15/2009 00:03'!selected: aBoolean	self value: aBoolean ! !!MAPasswordMorph methodsFor: 'private' stamp: 'SeanDeNigris 6/10/2013 22:00'!buildMorphView	^ super buildMorphView		font: (StrikeFont passwordFontSize: 12);		yourself! !!MATextMorph methodsFor: 'private' stamp: 'SeanDeNigris 6/10/2013 22:01'!buildMorphView	^ UITheme current 			newTextEntryIn: nil 			for: self  			get: #string  			set: #string: 			class: String			getEnabled: #enabled 			help: self magritteDescription comment! !!MAOneToManyMorph methodsFor: 'actions' stamp: 'SeanDeNigris 9/26/2013 10:35'!add	self selected new asMagritteMorph		onAnswer: [ :result |			result isNil ifFalse: [ self value: (self value copyWith: result) ].			self add: result ];		addButtons; 		addWindow;		openInWorld! !!MAOneToManyMorph methodsFor: 'private' stamp: 'SeanDeNigris 9/29/2013 15:17'!add: anObject	| rowParent lastRowIndex newRow |	rowParent := morph submorphs second.	newRow := MAElementRow for: anObject of: self.	lastRowIndex := rowParent submorphs findLast: [ :e | e isKindOf: MAElementRow ].	lastRowIndex = 0 		ifTrue: [ rowParent addMorph: newRow ]		ifFalse: [ rowParent 			addMorph: newRow 			after: (rowParent submorphs at: lastRowIndex) ].! !!MAOneToManyMorph methodsFor: 'private' stamp: 'SeanDeNigris 6/11/2013 00:58'!buildMorphView	| table |	table := self rectangleMorph		listDirection: #topToBottom;		yourself.	self value do: [ :e | MAElementRow addMorphFor: e of: self to: table ].	self magritteDescription isDefinitive		ifFalse: [ self addSelectListTo: table ].	^ table.! !!MAOneToManyMorph methodsFor: 'private' stamp: 'SeanDeNigris 6/8/2013 14:59'!buildSelectButton	^ UITheme current builder newButtonFor: self action: #add label: 'Add' help: ''.! !!MAExternalEditorMorph class methodsFor: 'testing' stamp: 'SeanDeNigris 6/10/2013 21:58'!isAbstract	^ false! !!MAExternalEditorMorph methodsFor: 'actions' stamp: 'SeanDeNigris 8/12/2015 00:50'!create	self newRelation asMagritteMorph		onAnswer: [ :result | result isNil ifFalse: [ self value: result ] ];		addButtons; 		addWindow;		openInWorld! !!MAExternalEditorMorph methodsFor: 'actions' stamp: 'SeanDeNigris 6/10/2013 21:56'!edit	self chooser: (self editorFor: self value)! !!MAExternalEditorMorph methodsFor: 'rendering' stamp: 'SeanDeNigris 6/10/2013 21:56'!renderButtonsOn: html	html submitButton on: #remove of: self.	html submitButton on: #edit of: self! !!MAExternalEditorMorph methodsFor: 'rendering' stamp: 'SeanDeNigris 6/10/2013 21:57'!renderViewerOn: html	html render: (self reference toString: self value)! !!MAInternalEditorMorph class methodsFor: 'testing' stamp: 'SeanDeNigris 6/8/2013 23:24'!isAbstract	^ false! !!MAInternalEditorMorph methodsFor: 'private' stamp: 'SeanDeNigris 6/10/2013 21:58'!buildComponent	^ self value isNil ifFalse: [ 		(self magritteDescription reference asComponentOn: self value)			setParent: self;			yourself ]! !!MAInternalEditorMorph methodsFor: 'accessing' stamp: 'SeanDeNigris 6/8/2013 23:24'!children	^ Array with: self component! !!MAInternalEditorMorph methodsFor: 'accessing' stamp: 'SeanDeNigris 6/8/2013 23:24'!component	^ component ifNil: [ component := self buildComponent ]! !!MAInternalEditorMorph methodsFor: 'actions' stamp: 'SeanDeNigris 8/12/2015 00:49'!create	self value: self newRelation.	component := nil! !!MAInternalEditorMorph methodsFor: 'rendering' stamp: 'SeanDeNigris 6/8/2013 23:24'!renderViewerOn: html	html render: (self component		readonly: self isReadonly;		yourself)! !!MAOneToOneMorph methodsFor: 'as yet unclassified' stamp: 'SeanDeNigris 8/13/2015 15:23'!buildMorphView	| table |	table := self rectangleMorph		listDirection: #topToBottom;		yourself.	self value		ifNotNil: [ MAElementRow addMorphFor: self value of: self to: table ]		ifNil: [ self addSelectListTo: table ].	^ table.! !!MAOneToOneMorph methodsFor: 'private' stamp: 'SeanDeNigris 6/8/2013 23:31'!buildSelectButton	^ UITheme current builder newButtonFor: self action: #create label: 'Create' help: ''.! !!MAOneToOneMorph methodsFor: 'actions' stamp: 'SeanDeNigris 6/8/2013 23:24'!create	self subclassResponsibility! !!MAOneToOneMorph methodsFor: 'private' stamp: 'SeanDeNigris 8/12/2015 00:51'!newRelation	| instance |	instance := self selected new.	self magritteDescription initializer value: instance.	^ instance! !!MARelationMorph methodsFor: 'private-building' stamp: 'SeanDeNigris 6/10/2013 22:00'!addSelectListTo: aMorph	| list |	self classes ifEmpty: [ ^ self ].	list := self rectangleMorph		listDirection: #leftToRight;		yourself.	self classes size > 1 ifTrue: [ list addMorphBack: self buildClassChooser ].	list addMorphBack: self buildSelectButton.	aMorph addMorphBack: list! !!MARelationMorph methodsFor: 'private-building' stamp: 'SeanDeNigris 6/10/2013 23:03'!buildClassChooser	| items |	items := self classes collect: [ :e | e label ].	^ UITheme current builder newDropListFor: self list: items getSelected: #selectedIndex setSelected: #selectedIndex: help: ''.! !!MARelationMorph methodsFor: 'private-building' stamp: 'SeanDeNigris 6/8/2013 14:35'!buildMorph	self flag: 'hook for testing. delete me before committing. spd.'.	^ super buildMorph.! !!MARelationMorph methodsFor: 'private-building' stamp: 'SeanDeNigris 6/10/2013 22:00'!buildMorphViewOn: aMorph	self flag: 'hook for testing. delete me before committing. spd.'.	^ super buildMorphViewOn: aMorph! !!MARelationMorph methodsFor: 'private-building' stamp: 'SeanDeNigris 6/8/2013 15:23'!buildSelectButton	self subclassResponsibility! !!MARelationMorph methodsFor: 'accessing-dynamic' stamp: 'SeanDeNigris 6/8/2013 15:02'!classes	^ self magritteDescription classes.! !!MARelationMorph methodsFor: 'accessing' stamp: 'SeanDeNigris 6/10/2013 22:00'!selected	^ self classes at: self selectedIndex! !!MARelationMorph methodsFor: 'private' stamp: 'SeanDeNigris 6/8/2013 15:42'!selectedIndex	^ selectedIndex ifNil: [ selectedIndex := 1 ]! !!MARelationMorph methodsFor: 'private' stamp: 'SeanDeNigris 6/8/2013 15:41'!selectedIndex: anInteger	selectedIndex := anInteger.! !"Magritte-Morph"!!GLMCompositePresentation methodsFor: '*Glamour-Magritte-Presentations' stamp: 'TudorGirba 1/2/2012 01:15'!magritte	^ self custom: GLMMagrittePresentation new! !!GLMBasicExamples methodsFor: '*Glamour-Magritte-Presentations' stamp: 'AndreiChis 11/10/2015 18:38'!magritte	<glmBrowser: 'Magritte presentation' input: 'GLMMagrittePersonExample sampleData'>	"self new magritte openOn: GLMMagrittePersonExample sampleData"	"GLMMagrittePersonExample sampleReset"  	"note, sampleData is aGLMAnnouncingCollection"		| browser |				browser := GLMTabulator new initialExtent: 600@300.	browser column: #list; column: #detail.	browser transmit to: #list ; andShow: [ :a | 		a list			title: 'Contacts';			format: [ :person | person name ] ;			updateOn: GLMItemAdded from: [ GLMMagrittePersonExample sampleData ] ;			updateOn: GLMItemRemoved from: [ GLMMagrittePersonExample sampleData ] ;			updateOn: GLMItemChanged from: [ GLMMagrittePersonExample sampleData ] ;			act: [ :listPresentation :glmAC | 					| newItem | 					newItem := GLMMagrittePersonExample new name: 'New...'  .					glmAC add: newItem beforeOrLast: listPresentation selection.					listPresentation selection: newItem.				]	icon: GLMUIThemeExtraIcons glamorousAdd 					entitled: 'Add' ;			act: [ :listPresentation :glmAC | 					glmAC remove: listPresentation selection ifAbsent: []				]	icon: GLMUIThemeExtraIcons glamorousRemove 					entitled: 'Remove' .	].	browser transmit from: #list ; to: #detail ; andShow: [ :a | 		a magritte			title: 'Details';			description: [:person | person magritteDescription] ;			onAnswer: [ :person :presentation | 				"browser update -- this works only if the current broser is not embedded in any other browser." 				GLMMagrittePersonExample sampleData announce: GLMItemChanged ] . 	].	^ browser! !!GLMMagrittePresentation methodsFor: 'accessing' stamp: 'tg 5/15/2009 13:53'!description: anObject	"convenience method for scripting"		magritteDescription := anObject! !!GLMMagrittePresentation methodsFor: 'accessing' stamp: 'TudorGirba 11/24/2012 22:27'!magritteDescription	"By default the we read it via the #description selector"	^ magritteDescription ifNil: [ magritteDescription := #magritteDescription ]! !!GLMMagrittePresentation methodsFor: 'accessing' stamp: 'TudorGirba 9/16/2011 10:41'!onAnswer: aBlock	answerBlock := aBlock! !!GLMMagrittePresentation methodsFor: 'accessing' stamp: 'BenComan 3/10/2012 01:55'!reactOnAnswerFor: aValue	self update.	^ answerBlock glamourValue:		(aValue asGlamorousMultiValue, 		self asGlamorousMultiValue, 		self entity asGlamorousMultiValue)! !!GLMMagrittePresentation methodsFor: 'rendering' stamp: 'tg 5/6/2009 13:17'!renderGlamorouslyOn: aRenderer 	^ aRenderer renderMagrittePresentation: self! !!GLMMorphicRenderer methodsFor: '*Glamour-Magritte-Presentations' stamp: 'TudorGirba 1/13/2011 13:46'!renderMagrittePresentation: aMagrittePresentation 	^ GLMMorphicMagritteRenderer render: aMagrittePresentation from: self! !!GLMMorphicMagritteRenderer methodsFor: 'rendering' stamp: 'TudorGirba 4/30/2011 15:54'!actOnPresentationUpdated: ann	scrollPane scrollTarget: (self magritteMorphFrom: ann presentation) ! !!GLMMorphicMagritteRenderer methodsFor: 'rendering' stamp: 'AndreiChis 11/10/2015 18:12'!magritteMorphFrom: aMagrittePresentation	| toShow description magritteMorph magritteDescriptionMorph |	toShow := aMagrittePresentation displayValue.	description := (aMagrittePresentation magritteDescription glamourValue: toShow) copy.	"Using MAContainerMorph can raise some problems, as it try to delete morphs after commiting. We don't want this behavior."	(description morphClass = MAContainerMorph)		ifTrue: [description morphClass: MASilentContainerMorph]. 	magritteDescriptionMorph :=  (description asMorphOn: toShow)		onAnswer: [ :value | aMagrittePresentation reactOnAnswerFor: value ].	magritteMorph := magritteDescriptionMorph		addButtons;		morph.	magritteMorph		hResizing: #spaceFill;		vResizing: #shrinkWrap;		layoutChanged.	^ magritteMorph! !!GLMMorphicMagritteRenderer methodsFor: 'rendering' stamp: 'AlexandreBergel 9/22/2015 12:31'!render: aMagrittePresentation		.	scrollPane := GeneralScrollPane new.	scrollPane changeScrollerTableLayout.	scrollPane scrollTarget: (self magritteMorphFrom: aMagrittePresentation).	scrollPane layoutFrame: (LayoutFrame fractions: (0 @ 0 corner: 1 @ 1) offsets: (0 @ 25 corner: 0 @ 0)).	aMagrittePresentation when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.	^ scrollPane! !"Glamour-Magritte-Presentations"!!MAElementDescription methodsFor: '*Magritte-GT-private' stamp: 'SeanDeNigris 3/24/2016 10:39'!glmAddSelectionActionsTo: presentation	presentation dynamicActionsOnSelection: [ :pres |		| actions |		actions := OrderedCollection new.		pres selection magritteActionDescriptions do: [ :desc |			| action |			action := GLMGenericAction new				action: [ pres selection perform: desc selector ];				title: desc label;				shortcut: (desc shortcut ifNil: [ desc label first lowercase ]);				yourself.			actions add: action ].		actions ].! !!MAElementDescription methodsFor: '*Magritte-GT-private' stamp: 'SeanDeNigris 8/22/2015 15:24'!glmCustomizePresentation: presentation for: domainObject	presentation hasTitle ifFalse: [ presentation title: self label ].	presentation hasTransformation ifFalse: [ presentation display: (self accessor read: domainObject) ].	self glmAddSelectionActionsTo: presentation! !!MAElementDescription methodsFor: '*Magritte-GT' stamp: 'SeanDeNigris 8/22/2015 15:16'!glmPresentation	^ self propertyAt: #glmPresentation! !!MAElementDescription methodsFor: '*Magritte-GT' stamp: 'SeanDeNigris 8/22/2015 15:22'!glmPresentation: aBlock	| wrapper |	wrapper := [ :composite :context :subject |		| presentation |		presentation := aBlock cull: composite cull: context.		self glmCustomizePresentation: presentation for: subject ].	self propertyAt: #glmPresentation put: wrapper! !!Object methodsFor: '*Magritte-GT' stamp: 'SeanDeNigris 6/3/2015 18:19'!gtInspectorMagritteIn: composite	<gtInspectorPresentationOrder: 40>	composite magritte		title: 'Form';		display: [ self ];		when: [ self magritteDescription notEmpty ]! !!Object methodsFor: '*Magritte-GT' stamp: 'SeanDeNigris 6/3/2015 18:35'!gtInspectorReadOnlyMagritteIn: composite	"<gtInspectorPresentationOrder: 300>"	"A simple GT presentation. Disabled by default because we have one that shows the full editable form, but could be useful..."	| table |	table := composite table		title: 'Magritte';		display: [ self magritteDescription children collect: [ :desc |			desc label -> (desc toString: (desc accessor read: self)) ] ];		when: [ self magritteDescription notEmpty ];		column: 'Field' evaluated: #key;		column: 'Value' evaluated: #value;		send: #value! !!Symbol methodsFor: '*Magritte-GT' stamp: 'SeanDeNigris 8/22/2015 15:34'!cull: anObject cull: anotherObject 	^ self cull: anObject! !"Magritte-GT"!!CCDocumentationGeneration commentStamp: 'CyrilFerlicot 4/2/2015 16:37' prior: 0!I generate a documentation of the parameters of a CCConfiguration.To use it it's simple. On a property's method add this pragma: 	<cocoonParameter: 'The documentation of my property'>The default value's property need to be named like this: if your property is 'author' so the default value's method will be named 'defaultAuthor'.Inside the default method add this pragma: 	<cocoonDefaultParameter: 'The description of the default value.'>If the default value is a litteral you can also write 	<cocoonDefaultParameter: ''>This will print the litteral value.Now you can generate your documentation like this.Create a stream and use this simple command:	stream := String new writeStream.	CCDocumentationGeneration of: myClassWhoExtendsCCConfiguration on: stream.!!CCMagritteConfigurationReader commentStamp: 'CyrilFerlicot 6/19/2015 17:20' prior: 0!I am a class that take a Cocoon Configuration and create a Dictionary with the Magritte descriptions from the configuration.!!CCMagritteDictionaryReader commentStamp: 'CyrilFerlicot 6/19/2015 17:20' prior: 0!I am a class that take a Dictionary and create a Cocoon Configuration with the Magritte descriptions from the configuration.!!CCConfigurationError commentStamp: 'StephaneDucasse 3/31/2015 10:26' prior: 0!I manage error related to configuration.!!PropertyError commentStamp: 'StephaneDucasse 3/31/2015 10:23' prior: 0!An error related to the property access.!!CCMagritteConfigurationDescription commentStamp: 'CyrilFerlicot 6/19/2015 17:21' prior: 0!I am the Magritte description of a cocoon configuration.!!CCMagrigtteToManyRelationConfigurationDescription commentStamp: 'CyrilFerlicot 6/19/2015 17:21' prior: 0!I am the Magritte description of a Collection of Cocoon configuration!!CCMagritteToManyRelationFileDescription commentStamp: 'CyrilFerlicot 6/19/2015 17:21' prior: 0!I am the Magritte description of a collection of files.!!CCMagritteToManyRelationFileMatchingDescription commentStamp: 'CyrilFerlicot 8/13/2015 14:59' prior: 0!I am a Maggrite description to a collection of file. I have a different visitor that CCMagritteToManyRelationFileDescription because during the visit I can match some files with a description as '**/*.st'.As the CCMagritteToManyRelationFileDescription I will contains I describe a collection of file but for Cocoon we need two different visitor.!!CCConfiguration commentStamp: 'CyrilFerlicot 7/10/2015 17:03' prior: 0!I am a class managing configuration used  by an application.In fact I managed a set of properties. I am implementing a composite pattern since a configuration can contain other sub-configurations.Information not found in a configuration is looked up in its parent (and it's done recursively).I have a Dictionnary call 'properties' which contains the properties of the configuration. On CCConfiguration I contains the 'baseDirectory' where to search the config and a collection of configurations call 'configurations'. I stock the magritte descriptions to not have to rebuild them all the time. For create a new Configuration you need to extands CCConfiguration. In your XXCocoonConfiguration's class you'll need to define new properties with a Magritte Description. For example if you need some input files you can create this method : descriptionInputFiles	<magritteDescription>	^ CCMagritteToManyRelationFileDescription new		defaultDirectory: self baseDirectory;		priority: 100;		accessor: #inputFiles;		label:				'Input files to export.';		cocoonDocumentation: 'List the Pillar files that must be exported (can be a FileReference, a relative path from baseDirectory or an absolute path).';		classes: {FileReference};		default: Array new;		yourself!!MADescription class methodsFor: '*Cocoon-Core' stamp: 'CyrilFerlicot 6/29/2015 14:19'!defaultCocoonDefaultDocumentation	^ nil! !!MADescription class methodsFor: '*Cocoon-Core' stamp: 'CyrilFerlicot 6/29/2015 14:18'!defaultCocoonDocumentation	^ ''! !!MADescription methodsFor: '*Cocoon-Core' stamp: 'CyrilFerlicot 6/29/2015 14:19'!cocoonDefaultDocumentation	"Answer the default documentation of the receiving description. This is use by Cocoon to generate documentation about default value"	^ self propertyAt: #cocoonDefaultDocumentation ifAbsent: [ self class defaultCocoonDefaultDocumentation ]! !!MADescription methodsFor: '*Cocoon-Core' stamp: 'CyrilFerlicot 6/29/2015 14:20'!cocoonDefaultDocumentation: aString	self propertyAt: #cocoonDefaultDocumentation put: aString! !!MADescription methodsFor: '*Cocoon-Core' stamp: 'CyrilFerlicot 6/29/2015 14:17'!cocoonDocumentation	"Answer the documentation of the receiving description. This is use by Cocoon to generate documentation about  a parameter"	^ self propertyAt: #cocoonDocumentation ifAbsent: [ self class defaultCocoonDocumentation ]! !!MADescription methodsFor: '*Cocoon-Core' stamp: 'CyrilFerlicot 6/29/2015 14:18'!cocoonDocumentation: aString	self propertyAt: #cocoonDocumentation put: aString! !!CCDocumentationGeneration class methodsFor: 'class initialization' stamp: 'CyrilFerlicot 4/1/2015 16:03'!of: aClassConfiguration on: aStream 		"I generate the documentation of the parameters of a configuration on a Stream."		^self new 		stream: aStream;		generateDocOf: aClassConfiguration;		stream! !!CCDocumentationGeneration methodsFor: 'accessing' stamp: 'DamienCassou 4/8/2016 14:11'!defaultCommentFrom: aDescription	^ aDescription cocoonDefaultDocumentation ifNil: [ '==' , aDescription default printString , '==' ]! !!CCDocumentationGeneration methodsFor: 'action' stamp: 'DamienCassou 4/8/2016 14:58'!generateDocOf: aClassConfiguration	"I return a Stream with the documentation of the properties of Cocoon."	self visitAll: (self sortedChildrenOf: aClassConfiguration).	^ self stream! !!CCDocumentationGeneration methodsFor: 'initialization' stamp: 'CyrilFerlicot 4/2/2015 14:35'!initialize	super initialize.	self stream: String new writeStream! !!CCDocumentationGeneration methodsFor: 'action' stamp: 'DamienCassou 4/8/2016 14:59'!sortedChildrenOf: aConfigurationClass	^ aConfigurationClass new magritteDescription children		sorted: [ :description1 :description2 | description1 accessor readSelector < description2 accessor readSelector ]! !!CCDocumentationGeneration methodsFor: 'accessing' stamp: 'CyrilFerlicot 4/1/2015 15:32'!stream	^ stream! !!CCDocumentationGeneration methodsFor: 'accessing' stamp: 'CyrilFerlicot 4/1/2015 15:32'!stream: anObject	stream := anObject! !!CCDocumentationGeneration methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 6/22/2015 16:21'!visitDescription: aDescription	self writeAccesorOf: aDescription.	self writeCommentOf: aDescription.	self writeDefaultCommentFor: aDescription! !!CCDocumentationGeneration methodsFor: 'writing' stamp: 'CyrilFerlicot 6/22/2015 16:20'!writeAccesorOf: aDescription	stream		nextPutAll: '!!!!!!!! ';		nextPutAll: aDescription accessor readSelector;		lf! !!CCDocumentationGeneration methodsFor: 'writing' stamp: 'CyrilFerlicot 6/29/2015 14:34'!writeCommentOf: aDescription	| parameterComment |	parameterComment := aDescription cocoonDocumentation.	stream		nextPutAll: '@sec:confParam:';		nextPutAll: aDescription accessor readSelector;		lf;		nextPutAll:				(parameterComment = aDescription class defaultCocoonDocumentation						ifTrue: [ 'uncommented' ]						ifFalse: [ parameterComment ]);		lf;		lf! !!CCDocumentationGeneration methodsFor: 'writing' stamp: 'DamienCassou 4/8/2016 16:10'!writeDefaultCommentFor: aDescription	stream		lf;		lf;		nextPutAll: 'Default value: ';		nextPutAll: (self defaultCommentFrom: aDescription);		lf;		lf! !!CCMagritteConfigurationReader class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 6/29/2015 15:29'!writeConfiguration: aConf toDictionary: aDictionary	^ self new write: aConf to: aDictionary! !!CCMagritteConfigurationReader methodsFor: 'action' stamp: 'CyrilFerlicot 7/30/2015 12:03'!completeConfiguration	"I'm here to add the input without description to the dictionary"	configuration properties keysDo: [ :each | dictionary at: each put: (configuration properties at: each) ]! !!CCMagritteConfigurationReader methodsFor: 'action' stamp: 'CyrilFerlicot 6/19/2015 15:31'!createDictionaryFrom: value	^ CCMagritteConfigurationReader writeConfiguration: value toDictionary: Dictionary new! !!CCMagritteConfigurationReader methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/26/2015 11:33'!pathOf: each	^ (each relativeTo: baseDirectory) printWithDelimiter: $/! !!CCMagritteConfigurationReader methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/19/2015 15:57'!readSelectorFor: aDescription	^ aDescription accessor readSelector! !!CCMagritteConfigurationReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 6/29/2015 15:33'!tryToAddFrom: aDescription withInterpretation: aBlock	"I take a description, check if the element describe by the description is on the Configuration, if I find it, I interpret it and I add it to the dictionary."	| accessor |	accessor := self readSelectorFor: aDescription.	configuration properties		at: accessor		ifPresent: [ :value | 			aDescription validate: value.			dictionary at: accessor put: (aBlock value: value).			configuration properties removeKey: accessor ]! !!CCMagritteConfigurationReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 6/19/2015 16:51'!visitConfigurationDescription: aConfigurationDescription	self tryToAddFrom: aConfigurationDescription withInterpretation: [ :value | self createDictionaryFrom: value ]! !!CCMagritteConfigurationReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 6/19/2015 16:49'!visitElementDescription: aDescription	self tryToAddFrom: aDescription withInterpretation: [ :value | value ]! !!CCMagritteConfigurationReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 6/19/2015 16:52'!visitFileDescription: aDescription	self tryToAddFrom: aDescription withInterpretation: [ :value | self pathOf: value ]! !!CCMagritteConfigurationReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 9/11/2015 13:51'!visitToManyRelationConfigurationDescription: aToManyRelationConfigurationDescription	self		tryToAddFrom: aToManyRelationConfigurationDescription		withInterpretation:			[ :value | | collection |			collection := Dictionary new.			value				do:					[ :each | collection at: each configurationName put: (self createDictionaryFrom: each) ].			collection ]! !!CCMagritteConfigurationReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 6/19/2015 16:54'!visitToManyRelationFileDescription: aToManyRelationFileDescription	self		tryToAddFrom: aToManyRelationFileDescription		withInterpretation: [ :value | 			| index |			index := 1.			value				do: [ :each | 					value at: index put: (self pathOf: each).					index := index + 1 ].			value ]! !!CCMagritteConfigurationReader methodsFor: 'action' stamp: 'CyrilFerlicot 6/29/2015 15:33'!write: aConfiguration to: aDictionary	"I write the content of a Configuration to a Dictionary following a Magritte Description."	configuration := aConfiguration.	dictionary := aDictionary.	baseDirectory := aConfiguration baseDirectory.	aConfiguration magritteDescription children		detect: [ :each | each accessor readSelector = 'baseDirectory' ]		ifFound: [ :description | self visitDirectoryDescription: description ].	"We do that in order to have the base directory to interprete the files later."	self visitAll: aConfiguration magritteDescription children.	"We rebuild the description because the default directory might have changed."	self visitAll: aConfiguration magritteDescription children.	self completeConfiguration.	^ dictionary! !!CCMagritteDictionaryReader class methodsFor: 'instance-creation' stamp: 'CyrilFerlicot 6/29/2015 15:34'!writeDictionary: aCollection toConfiguration: aConf	^ self new write: aCollection to: aConf! !!CCMagritteDictionaryReader methodsFor: 'action' stamp: 'CyrilFerlicot 7/30/2015 12:00'!completeConfiguration	"I'm here to add the input without description to the configuration"	dictionary		keysDo: [ :each | 			| accessor |			accessor := each , ':'.			configuration perform: accessor with: (dictionary at: each) ]! !!CCMagritteDictionaryReader methodsFor: 'action' stamp: 'CyrilFerlicot 9/11/2015 13:47'!createConfigurationFrom: anAssociation	| config |	config := configuration class new		configurationName: anAssociation key;		parent: configuration;		yourself.	^ self class writeDictionary: anAssociation value toConfiguration: config! !!CCMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 8/10/2015 11:49'!directoriesFor: path from: dirs	| directories |	directories := Set new.	path first = '**'		ifTrue:			[ 			dirs				do:					[ :dir | directories addAll: (dir allDirectoriesMatching: path first) ] ]		ifFalse:			[ 			dirs				do:					[ :dir | directories addAll: (dir directoriesMatching: path first) ] ].	^ directories! !!CCMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 8/18/2015 15:38'!extractSubFolderContentsInto: aCollection	| temp |	temp := aCollection copy.	temp		do: [ :each | 			each isDirectory				ifTrue: [ aCollection addAll: (CollectVisitor breadthFirst: each collect: [ :file | file asFileReference ]) ] ]! !!CCMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 8/18/2015 16:11'!filesMatching: regexPath	| path result dirs |	self flag: #todo. "Latter the user should be able to reject some files with a annotation as '- *.pillar'"	path := regexPath splitOn: $/.	result := Set new.	dirs := OrderedCollection with: configuration baseDirectory.	"We begin to search from the base directory."	[ path size = 1 ]		whileFalse:			[ 			dirs := self directoriesFor: path from: dirs.			path removeFirst ].	dirs do:		[ :dir | result addAll: (dir childrenMatching: path first) ].	^ result! !!CCMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 8/19/2015 23:33'!resolve: path with: aDescription	^ path class = FileReference		ifTrue: [ path ]		ifFalse: [ 			| file |			file := configuration baseDirectory resolve: path.			file exists				ifFalse: [ CCConfigurationError signal: path , ' is not a valid file name into ' , configuration baseDirectory asString , '.' ].			file ]! !!CCMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 8/10/2015 16:10'!resolveDirectory: aPath	"If you want the Directory to exist add "	"addCondition: [ :dir | directory exists and: [ directory isDirectory ] ]"	" to the description."	^ configuration baseDirectory resolve: aPath! !!CCMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 6/29/2015 15:36'!tryToAddFrom: aDescription withInterpretation: aBlock	"I take a Description, check if an object of the dictionary match with the description, if I find one, I interpret it and add it to the configuration."	| accessor |	accessor := aDescription accessor selector.	dictionary		at: accessor		ifPresent: [ :value | 			| newValue |			newValue := aBlock value: value.			aDescription validate: newValue.			dictionary removeKey: accessor.			configuration write: newValue using: aDescription ]! !!CCMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 9/11/2015 13:49'!visitConfigurationDescription: aConfigurationDescription	self		tryToAddFrom: aConfigurationDescription		withInterpretation:			[ :value | self createConfigurationFrom: configuration defaultConfigurationName -> value ]! !!CCMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 6/26/2015 11:05'!visitDirectoryDescription: aDescription	self tryToAddFrom: aDescription withInterpretation: [ :value | self resolveDirectory: value ]! !!CCMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 6/19/2015 16:56'!visitElementDescription: aDescription	self tryToAddFrom: aDescription withInterpretation: [ :value | value ]! !!CCMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 6/19/2015 16:57'!visitFileDescription: aDescription	self tryToAddFrom: aDescription withInterpretation: [ :value | self resolve: value with: aDescription ]! !!CCMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 9/11/2015 13:47'!visitToManyRelationConfigurationDescription: aToManyRelationConfigurationDescription	self		tryToAddFrom: aToManyRelationConfigurationDescription		withInterpretation:			[ :collection | | configurations |			configurations := OrderedCollection new.			collection associationsDo: [ :value | configurations add: (self createConfigurationFrom: value) ].			configurations ]! !!CCMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 6/26/2015 11:32'!visitToManyRelationFileDescription: aToManyRelationFileDescription	self		tryToAddFrom: aToManyRelationFileDescription		withInterpretation: [ :collection | 			| index |			index := 1.			collection				do: [ :value | 					collection at: index put: (self resolve: value with: aToManyRelationFileDescription).					index := index + 1 ].			collection ]! !!CCMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 8/18/2015 15:38'!visitToManyRelationFileMatchingDescription: aToManyRelationFileMatchingDescription	self		tryToAddFrom: aToManyRelationFileMatchingDescription		withInterpretation: [ :collection | 			| result |			result := Set new.			collection do: [ :path | result addAll: (self filesMatching: path) ].			self extractSubFolderContentsInto: result.			result ]! !!CCMagritteDictionaryReader methodsFor: 'action' stamp: 'CyrilFerlicot 7/30/2015 14:54'!write: aDictionary to: aConfiguration	dictionary := aDictionary.	configuration := aConfiguration.	aDictionary		at: 'baseDirectory'		ifPresent: [ :elem | 			aConfiguration baseDirectory: elem.			aDictionary removeKey: 'baseDirectory' ].	self visitAll: aConfiguration magritteDescription children.	"We rebuild the description because the default directory might have changed."	self completeConfiguration.	^ configuration! !!MAVisitor methodsFor: '*Cocoon-Core-Description' stamp: 'CyrilFerlicot 6/18/2015 18:10'!visitConfigurationDescription: aConfigurationDescription	self visitElementDescription: aConfigurationDescription! !!MAVisitor methodsFor: '*Cocoon-Core-Description' stamp: 'CyrilFerlicot 6/19/2015 10:04'!visitToManyRelationConfigurationDescription: aToManyRelationConfigurationDescription	self visitToManyRelationDescription: aToManyRelationConfigurationDescription! !!MAVisitor methodsFor: '*Cocoon-Core-Description' stamp: 'CyrilFerlicot 6/18/2015 16:18'!visitToManyRelationFileDescription: aToManyRelationFileDescription	self visitToManyRelationDescription: aToManyRelationFileDescription! !!MAVisitor methodsFor: '*Cocoon-Core-Description' stamp: 'CyrilFerlicot 8/11/2015 14:57'!visitToManyRelationFileMatchingDescription: aToManyRelationFileMatchingDescription	self visitToManyRelationDescription: aToManyRelationFileMatchingDescription! !!CCMagritteConfigurationDescription class methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/19/2015 10:02'!label	^ 'Configuration'! !!CCMagritteConfigurationDescription methodsFor: 'visiting' stamp: 'CyrilFerlicot 6/18/2015 18:09'!acceptMagritte: aVisitor	aVisitor visitConfigurationDescription: self! !!CCMagrigtteToManyRelationConfigurationDescription class methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/19/2015 10:01'!label	^ '1:m Configuration Relation'! !!CCMagrigtteToManyRelationConfigurationDescription methodsFor: 'visitor' stamp: 'CyrilFerlicot 6/19/2015 10:03'!acceptMagritte: aVisitor	aVisitor visitToManyRelationConfigurationDescription: self! !!CCMagritteToManyRelationFileDescription class methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/18/2015 16:12'!label	^ '1:m File Relation'! !!CCMagritteToManyRelationFileDescription methodsFor: 'visiting' stamp: 'CyrilFerlicot 6/18/2015 16:11'!acceptMagritte: aVisitor	aVisitor visitToManyRelationFileDescription: self! !!CCMagritteToManyRelationFileDescription methodsFor: 'file system' stamp: 'CyrilFerlicot 6/18/2015 16:42'!defaultDirectory	^ self propertyAt: #defaultDirectory ifAbsent: [ MAFileSystem imageDirectory ].! !!CCMagritteToManyRelationFileDescription methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/18/2015 16:42'!defaultDirectory: fileReference	"fileReference - a FileSystem FileReference, or an MAFileReference if FileSystem is not installed"	self propertyAt: #defaultDirectory put: fileReference! !!CCMagritteToManyRelationFileMatchingDescription methodsFor: 'visiting' stamp: 'CyrilFerlicot 8/11/2015 14:57'!acceptMagritte: aVisitor	aVisitor visitToManyRelationFileMatchingDescription: self! !!CCConfiguration class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 8/18/2015 16:05'!newFromDictionary: aSTONDictionary	^ self reader writeDictionary: aSTONDictionary toConfiguration: self new! !!CCConfiguration class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 8/18/2015 16:05'!newFromDictionary: aSTONDictionary extendedWith: anOtherDictionary	^ self reader writeDictionary: aSTONDictionary , anOtherDictionary toConfiguration: self new! !!CCConfiguration class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 6/29/2015 15:01'!newFromFile: aFile	^ aFile readStreamDo: [ :input | self newFromStream: input ]! !!CCConfiguration class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 7/30/2015 14:44'!newFromFile: aFile extendedWith: anOtherDictionary	^ aFile readStreamDo: [ :input | self newFromStream: input extendedWith: anOtherDictionary ]! !!CCConfiguration class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 7/29/2015 14:51'!newFromStream: aStream	^ [ self newFromDictionary: (STON fromStream: aStream) ]		on: STONReaderError		do: [ :error | CCConfigurationError signal: error messageText ]! !!CCConfiguration class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 7/30/2015 14:44'!newFromStream: aStream extendedWith: anOtherDictionary	^ [ self newFromDictionary: (STON fromStream: aStream) extendedWith: anOtherDictionary ]		on: STONReaderError		do: [ :error | CCConfigurationError signal: error messageText ]! !!CCConfiguration class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 7/29/2015 14:44'!newFromString: aString	^ self newFromStream: aString readStream! !!CCConfiguration class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 7/30/2015 14:45'!newFromString: aString extendedWith: anOtherDictionary	^ self newFromStream: aString readStream extendedWith: anOtherDictionary! !!CCConfiguration class methodsFor: 'accessors' stamp: 'CyrilFerlicot 8/18/2015 16:04'!reader	^ CCMagritteDictionaryReader! !!CCConfiguration methodsFor: 'comparing' stamp: 'CyrilFerlicot 9/11/2015 13:37'!= anObject	^ self species = anObject species and: [ self properties = anObject properties and: [ self parent = anObject parent and: [ self configurationName = anObject configurationName ] ] ]! !!CCConfiguration methodsFor: 'accessing - properties' stamp: 'GuillermoPolito 6/8/2015 15:55'!allProperties	"Answer all properties of the receiver and its parents."	| parentProperties |	parentProperties := self hasParent		ifTrue: [ self parent allProperties ]		ifFalse: [ Dictionary new ].	parentProperties addAll: self properties.	^ parentProperties! !!CCConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 7/30/2015 11:45'!baseDirectory	^ self propertyAt: 'baseDirectory' default: [ self defaultBaseDirectory ]! !!CCConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 7/30/2015 11:41'!baseDirectory: aDirectory	"Set the directory where to look for the file with non-absolute path or a Directory as FileReference."	self propertyAt: 'baseDirectory' put: (self toDirectory: aDirectory)! !!CCConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 9/11/2015 13:37'!configurationName	^ configurationName ifNil: [ self defaultConfigurationName ]! !!CCConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 9/11/2015 13:37'!configurationName: anObject	configurationName := anObject! !!CCConfiguration methodsFor: 'accessing' stamp: 'DamienCassou 8/28/2015 11:16'!configurations	^ self propertyAt: 'configurations' ifAbsent: [ self defaultValueOf: #configurations ]! !!CCConfiguration methodsFor: 'accessing defaults' stamp: 'CyrilFerlicot 6/29/2015 15:15'!defaultBaseDirectory	"The current working directory"	^ FileSystem workingDirectory! !!CCConfiguration methodsFor: 'accessing defaults' stamp: 'CyrilFerlicot 7/30/2015 12:04'!defaultConfigurationName	^ 'Default Configuration'! !!CCConfiguration methodsFor: 'accessing defaults' stamp: 'DamienCassou 8/28/2015 11:17'!defaultValueOf: propertySelector	^ self magritteDescription children		detect: [ :e | e accessor readSelector = propertySelector ]		ifFound: [ :description | description default ]		ifNone: [ 			CCConfigurationError				signal:					'No default value for ' , propertySelector , '. Please add a default value on ' , self class asString						, ' or add a value on the configuration.' ]! !!CCConfiguration methodsFor: 'descriptions' stamp: 'DamienCassou 4/8/2016 11:41'!descriptionBaseDirectory	<magritteDescription>	^ MADirectoryDescription new		accessor: #baseDirectory;		priority: 0;		label: 'Cocoon base directory';		cocoonDocumentation: 'Indicate where to look for files.';		cocoonDefaultDocumentation: 'The current working directory';		default: self defaultBaseDirectory;		kind: FileReference;		addCondition: [ :value | value exists and: [ value isDirectory ] ];		yourself! !!CCConfiguration methodsFor: 'descriptions' stamp: 'DamienCassou 8/28/2015 11:16'!descriptionConfigurations	<magritteDescription>	^ CCMagrigtteToManyRelationConfigurationDescription new		accessor: #configurations;		priority: 100;		label: 'Subconfigurations of Cocoon.';		cocoonDocumentation:			'Each configuration can define several sub configurations, each of which inherits the properties of its parent.';		classes: {self class};		cocoonDefaultDocumentation: 'A dictionary of default configurations from the exporters.';		default: Dictionary new;		yourself! !!CCConfiguration methodsFor: 'reflective operations' stamp: 'DamienCassou 8/28/2015 11:17'!doesNotUnderstand: aMessage	"I allow to get or set property of the configuration."	^ aMessage arguments size = 1		ifTrue: [ 			self magritteDescription children				detect: [ :each | each accessor writeSelector = aMessage selector ]				ifFound: [ :description | description validate: aMessage argument ].			self properties at: aMessage selector allButLast put: aMessage argument ]		ifFalse: [ 			[ self propertyAt: aMessage selector ]				on: PropertyError				do: [ self defaultValueOf: aMessage selector ] ]! !!CCConfiguration methodsFor: 'private' stamp: 'StephaneDucasse 3/31/2015 10:03'!error: aString	^ CCConfigurationError signal: aString! !!CCConfiguration methodsFor: 'private' stamp: 'CyrilFerlicot 3/31/2015 15:15'!errorPropertyNotFound: aSelector	"Error on a property"		PropertyError signal: 'Property ' , aSelector , ' not found.'! !!CCConfiguration methodsFor: 'testing' stamp: 'StephaneDucasse 3/29/2015 20:52'!hasParent	^ parent notNil! !!CCConfiguration methodsFor: 'testing' stamp: 'StephaneDucasse 3/31/2015 10:16'!hasProperty: aKey	"Test if the property ==aKey== is defined within the receiver."	^ self properties includesKey: aKey! !!CCConfiguration methodsFor: 'comparing' stamp: 'CyrilFerlicot 9/11/2015 16:56'!hash	^ self species hash bitXor: (self properties hash bitXor: (self parent hash bitXor: self configurationName hash))! !!CCConfiguration methodsFor: 'accessing - properties' stamp: 'DamienCassou 8/28/2015 11:48'!inheritsPropertyAt: aKey	"Answer true iff I (or one of my ancestors) contain a property named ==aKey==."	^ self		propertyAt: aKey		ifPresent: [:value | true ]		ifAbsent:			[ 			self hasParent				ifTrue: [ self parent inheritsPropertyAt: aKey ]				ifFalse: [ false ] ]! !!CCConfiguration methodsFor: 'private' stamp: 'StephaneDucasse 3/29/2015 20:52'!log: aString	self verbose		ifTrue: [ 			FileStream stderr				<< aString;				cr ]! !!CCConfiguration methodsFor: 'accessing' stamp: 'DamienCassou 9/7/2015 15:52'!magritteDescription	"If the magritte description is nil I create it and I store it."	^ magritteDescription ifNil: [ magritteDescription := self basicMagritteDescription ]! !!CCConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 7/10/2015 17:24'!magritteDescription: anObject	magritteDescription := anObject.	^ magritteDescription! !!CCConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 3/31/2015 15:16'!parent	"A parent is a Configuration I extends"		^ parent! !!CCConfiguration methodsFor: 'accessing' stamp: 'StephaneDucasse 3/29/2015 20:52'!parent: aConfiguration	parent := aConfiguration! !!CCConfiguration methodsFor: 'copying' stamp: 'CyrilFerlicot 3/31/2015 15:18'!postCopy	"I'm a hook method in the sense of Design Patterns TemplateHook/Methods. I'm called by copy. self is a shallow copy, subclasses should copy fields as necessary to complete the full copy"	super postCopy.	properties := properties copy! !!CCConfiguration methodsFor: 'printing' stamp: 'CyrilFerlicot 9/11/2015 17:15'!printOn: aStream	<ignoreForCoverage>	super printOn: aStream.	aStream		nextPut: $[;		nextPutAll: self configurationName;		nextPut: $-;		print: self identityHash;		nextPut: $]! !!CCConfiguration methodsFor: 'accessing - properties' stamp: 'StephaneDucasse 3/31/2015 10:15'!properties	"Answer the property dictionary of the receiver."	^ properties ifNil: [ properties := Dictionary new ]! !!CCConfiguration methodsFor: 'accessing - properties' stamp: 'GuillermoPolito 6/8/2015 14:16'!propertyAt: aKey	"Answer the value of the property ==aKey==, raises an error if the property doesn't exist."	^ self propertyAt: aKey ifAbsent: [ 		self hasParent			ifTrue: [ self parent propertyAt: aKey ]			ifFalse: [self errorPropertyNotFound: aKey ]]! !!CCConfiguration methodsFor: 'accessing - properties' stamp: 'CyrilFerlicot 3/31/2015 15:23'!propertyAt: aKey default: aBlock	"Answer the value of ==aKey==. If the key have no entry I look on the parent or execute a block if i'm an orphan."	^ self		propertyAt: aKey		ifAbsent: [ 			self hasParent				ifTrue: [ self parent propertyAt: aKey default: aBlock ]				ifFalse: aBlock ]! !!CCConfiguration methodsFor: 'accessing - properties' stamp: 'CyrilFerlicot 3/31/2015 13:46'!propertyAt: aKey ifAbsent: aBlock	"Answer the value of the property ==aKey==, or the result of ==aBlock== if the property doesn't exist."	^ self properties at: aKey ifAbsent: aBlock! !!CCConfiguration methodsFor: 'accessing - properties' stamp: 'StephaneDucasse 3/31/2015 10:15'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the value of the property ==aKey==, or if the property doesn't exist adds and answers the result of evaluating ==aBlock==."	^ self properties at: aKey ifAbsentPut: aBlock! !!CCConfiguration methodsFor: 'accessing - properties' stamp: 'DamienCassou 8/28/2015 11:39'!propertyAt: aKey ifPresent: presentBlock ifAbsent: absentBlock	"Answer the result of ==presentBlock== if I have the property ==aKey== or the result of ==absentBlock==."	^ self properties at: aKey ifPresent: presentBlock ifAbsent: absentBlock! !!CCConfiguration methodsFor: 'accessing - properties' stamp: 'StephaneDucasse 3/31/2015 10:15'!propertyAt: aKey put: aValue	"Adds or replaces the property ==aKey== with ==aValue==."	^ self properties at: aKey put: aValue! !!CCConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 1/24/2016 19:01'!subConfigurationNamed: aString	"I return a configuration of the name 'aString'. If this configuration doesn't exist i raise an error."	^ self configurations		detect: [ :each | each configurationName = aString ]		ifNone:			[ self configurations				do: [ :conf | (conf subConfigurationNamed: aString) ifNotNil: [ :subsub | ^ subsub ] ].			nil ]! !!CCConfiguration methodsFor: 'private' stamp: 'CyrilFerlicot 7/30/2015 11:41'!toDirectory: aDirectory	"I return a FileReference that corresponds to aDirectory."	| directory |	directory := self baseDirectory resolve: aDirectory.	^ (directory exists and: [ directory isDirectory ])		ifTrue: [ directory ]		ifFalse: [ self error: aDirectory asString , ' is not a valid directory.' ]! !"Cocoon-Core"!!CCMockConfiguration commentStamp: 'CyrilFerlicot 6/19/2015 17:23' prior: 0!Hi !! I'm a Mock for the Cocoon tests !!!!CCMockConfiguration methodsFor: 'descriptions' stamp: 'CyrilFerlicot 6/22/2015 13:08'!descriptionMockProperty	<magritteDescription>	^ MAStringDescription new		accessor: #mockProperty;		priority: 100;		label: 'mock property';		default: 'defaultMockValue';		addCondition: [ :value | value notEmpty ];		yourself! !!CCMockConfiguration methodsFor: 'descriptions' stamp: 'CyrilFerlicot 6/22/2015 13:08'!descriptionMockPropertyBis	<magritteDescription>	^ MANumberDescription new		accessor: #mockPropertyBis;		priority: 100;		label: 'mock property bis';		beInteger;		default: 0;		min: -10 max: 10;		yourself! !!CCMockConfiguration methodsFor: 'descriptions' stamp: 'CyrilFerlicot 6/22/2015 13:09'!descriptionMockPropertyFile	<magritteDescription>	^ MAFileDescription new		defaultDirectory: self baseDirectory;		priority: 100;		accessor: #mockPropertyFile;		label: 'mock property file';		default: nil;		kind: FileReference;		addCondition: [ :value | value exists ];		yourself! !!CCMockConfiguration methodsFor: 'descriptions' stamp: 'CyrilFerlicot 6/22/2015 13:09'!descriptionMockPropertyFileList	<magritteDescription>	^ CCMagritteToManyRelationFileDescription new		defaultDirectory: self baseDirectory;		priority: 100;		accessor: #mockPropertyFileList;		label: 'mock property file list';		classes: {FileReference};		default: Array new;		yourself! !!CCMockConfiguration methodsFor: 'descriptions' stamp: 'CyrilFerlicot 6/22/2015 13:09'!descriptionSubConfiguration	<magritteDescription>	^ CCMagritteConfigurationDescription new		priority: 100;		accessor: #subConfiguration;		label: 'mock subconfiguration';		yourself! !!CCMockConfiguration methodsFor: 'descriptions' stamp: 'CyrilFerlicot 6/22/2015 13:09'!descriptionSubConfigurations	<magritteDescription>	^ CCMagrigtteToManyRelationConfigurationDescription new		priority: 100;		accessor: #subConfigurations;		label: 'mock subconfigurations';		classes: {CCMockConfiguration};		default:				(Dictionary new						at: 'default'							put:								(CCMockConfiguration new properties										at: 'subConfigurations' put: Dictionary new;										yourself);						yourself);		yourself! !!CCConfigurationInterpreterTest methodsFor: 'helper' stamp: 'CyrilFerlicot 6/29/2015 15:08'!fromString: aString	^ CCMockConfiguration newFromString: aString! !!CCConfigurationInterpreterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/22/2015 14:04'!testEmptyConfiguration	| ston configuration |	ston := '{  }'.	configuration := self fromString: ston.	self assert: configuration mockProperty equals: 'defaultMockValue'	"the default"! !!CCConfigurationInterpreterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 4/1/2015 11:04'!testMockProperty	| ston configuration |	ston := '{ #mockProperty : ''test'' }'.	configuration := self fromString: ston.	self assert: configuration mockProperty equals: 'test'.		ston := '{ #mockProperty : ''mock'' }'.	configuration := self fromString: ston.	self assert: configuration mockProperty equals: 'mock'.	configuration mockProperty: 'another'.	self assert: configuration mockProperty equals: 'another'! !!CCConfigurationInterpreterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/22/2015 14:15'!testPropagateToSubConfiguration	| ston configuration subConfiguration |	ston := '{ #mockProperty : "something", #configurations : { "Foo" : { #mockPropertyBis : 2 } } }'.	configuration := self fromString: ston.	self assert: configuration mockProperty equals: 'something'.	self assert: configuration configurations size equals: 1.	subConfiguration := configuration configurations anyOne.	self assert: subConfiguration mockProperty equals: 'something'.	self assert: subConfiguration mockPropertyBis equals: 2! !!CCConfigurationInterpreterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 4/1/2015 11:10'!testSubConfigurationNamed	| ston configuration subConfiguration |	ston := '{ #configurations : { "Foo" : { #mockProperty: ''something'' } } }'.	configuration :=self fromString: ston.	subConfiguration := configuration subConfigurationNamed: 'Foo'.	self assert: subConfiguration mockProperty equals: 'something'! !!CCConfigurationInterpreterTest methodsFor: 'tests' stamp: 'DamienCassou 8/28/2015 07:03'!testWithRecursiveSubConfiguration	| ston configuration topConfiguration subConfiguration |	ston := '	{ #configurations :	  { "Top" :	    { #configurations :	      { "Sub" :	        { #mockProperty: #bar }}}}}'.	configuration := self fromString: ston.	self assert: configuration configurations size equals: 1.	topConfiguration := configuration configurations anyOne.	self assert: topConfiguration configurations size equals: 1.	subConfiguration := topConfiguration configurations anyOne.	self assert: subConfiguration mockProperty equals: 'bar'! !!CCConfigurationInterpreterTest methodsFor: 'tests' stamp: 'DamienCassou 8/28/2015 09:36'!testWithRecursiveSubConfiguration2ndPosition	| ston configuration subConfiguration |	ston := '	{ #configurations :	  { "First" : { },	    "Top" :       { #configurations :	      { "Sub" :	        { #mockProperty: #bar }}}}}'.	configuration := self fromString: ston.	self assert: configuration configurations size equals: 2.	subConfiguration := configuration subConfigurationNamed: 'Sub'.	self assert: subConfiguration mockProperty equals: 'bar'! !!CCConfigurationInterpreterTest methodsFor: 'tests' stamp: 'DamienCassou 8/28/2015 07:09'!testWithRecursiveSubConfigurationAccessedByName	| ston configuration subConfiguration |	ston := '	{ #configurations :	  { "Top" :	    { #configurations : { "Sub" : {  }},	      #mockProperty: #bar }}}'.	configuration := self fromString: ston.	subConfiguration := configuration subConfigurationNamed: 'Sub'.	self assert: subConfiguration mockProperty equals: 'bar'! !!CCConfigurationInterpreterTest methodsFor: 'tests' stamp: 'DamienCassou 8/28/2015 09:36'!testWithRecursiveSubConfigurationAndInheritance	| ston configuration topConfiguration subConfiguration |	ston := '	{ #configurations :	  { "Top" :	    { #configurations : { "Sub" : {  }},	      #mockProperty: #bar }}}'.	configuration := self fromString: ston.	self assert: configuration configurations size equals: 1.	topConfiguration := configuration configurations anyOne.	self assert: topConfiguration configurations size equals: 1.	subConfiguration := topConfiguration configurations anyOne.	self assert: subConfiguration mockProperty equals: 'bar'! !!CCConfigurationInterpreterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 4/10/2015 11:31'!testWithSubConfiguration	| ston configuration subConfiguration |	ston := '{ #configurations : { "Foo" : { #mockProperty : #bar } } }'.	configuration :=self fromString: ston.	self assert: configuration configurations size equals: 1.	subConfiguration := configuration configurations anyOne.	self assert: subConfiguration mockProperty equals: 'bar'! !!CCConfigurationTest methodsFor: 'tests-properties' stamp: 'DamienCassou 4/24/2015 17:07'!testBaseDirectoryWithFile		| config dir |	config := CCConfiguration new.	dir := FileSystem memory root / 'somethingThatNobodyWillTry'.	dir ensureCreateDirectory.	config baseDirectory: dir.	self assert: config baseDirectory exists.		dir delete! !!CCConfigurationTest methodsFor: 'tests-properties' stamp: 'CyrilFerlicot 6/22/2015 13:28'!testBaseDirectoryWithNonExistingAbsolutePath	| config root |	config := CCConfiguration new.	root := FileSystem memory root.	self should: [ config baseDirectory: root / 'somethingThatNobodyWillTry' ] raise: Error! !!CCConfigurationTest methodsFor: 'tests-properties' stamp: 'CyrilFerlicot 6/22/2015 13:28'!testBaseDirectoryWithNonExistingRelativePath	| config |	config := CCConfiguration new.	self should: [ config baseDirectory: 'somethingThatNobodyWillTry' ] raise: Error! !!CCConfigurationTest methodsFor: 'tests-copying' stamp: 'CyrilFerlicot 9/11/2015 17:01'!testCopyProperties	"I'm here to test if postCopy is right."	| config |	config := CCMockConfiguration new		mockPropertyBis: 7;		mockProperty: 'mock';		yourself.	self deny: config properties == config copy properties! !!CCConfigurationTest methodsFor: 'tests-testing' stamp: 'DamienCassou 4/24/2015 17:25'!testHasParent	| config configChild |	config := CCConfiguration new.	configChild := CCConfiguration new.	configChild parent: config.	self deny: config hasParent.	self assert: configChild hasParent! !!CCConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 9/11/2015 17:00'!testHash	| configuration |	configuration := CCMockConfiguration new		mockPropertyBis: 7;		mockProperty: 'mock';		yourself.	self assert: configuration hash = configuration copy hash! !!CCConfigurationTest methodsFor: 'tests-properties' stamp: 'DamienCassou 4/24/2015 17:26'!testProperties	| config |	config := CCConfiguration new.	self assert: config properties notNil.	config instVarNamed: 'properties' put: nil.	config propertyAt: #foo put: #bar.	config instVarNamed: 'properties' put: nil.	config propertyAt: #foo ifAbsent: [ nil ].	config instVarNamed: 'properties' put: nil.	config propertyAt: #foo ifAbsentPut: [ #bar ].	config instVarNamed: 'properties' put: nil.	config hasProperty: #foo.	config instVarNamed: 'properties' put: nil! !!CCConfigurationTest methodsFor: 'tests-properties' stamp: 'DamienCassou 4/24/2015 17:26'!testPropertiesAt	| config |	config := CCConfiguration new.	self assert: (config propertyAt: #foo put: 'bar') = 'bar'.	self assert: (config propertyAt: #foo) = 'bar'.	self should: [ config propertyAt: #bar ] raise: PropertyError! !!CCConfigurationTest methodsFor: 'tests-properties' stamp: 'DamienCassou 4/24/2015 17:26'!testPropertiesAtIfAbsent	| config |	config := CCConfiguration new.	self assert: (config propertyAt: #foo put: 'bar') = 'bar'.	self assert: (config propertyAt: #foo ifAbsent: [ 'baz' ]) = 'bar'.	self assert: (config propertyAt: #bar ifAbsent: [ 'baz' ]) = 'baz'! !!CCConfigurationTest methodsFor: 'tests-properties' stamp: 'DamienCassou 4/24/2015 17:26'!testPropertiesAtIfAbsentPut	| config |	config := CCConfiguration new.	self assert: (config propertyAt: #foo put: 'bar') = 'bar'.	self assert: (config propertyAt: #foo ifAbsentPut: [ 'baz' ]) = 'bar'.	self assert: (config propertyAt: #foo) = 'bar'.	self assert: (config propertyAt: #bar ifAbsentPut: [ 'baz' ]) = 'baz'.	self assert: (config propertyAt: #bar) = 'baz'! !!CCConfigurationTest methodsFor: 'tests-properties' stamp: 'DamienCassou 8/28/2015 13:00'!testPropertiesAtIfPresentIfAbsent	| config |	config := CCConfiguration new.	self assert: (config propertyAt: #foo put: 'bar') equals: 'bar'.	self assert: (config propertyAt: #foo ifPresent: [ :smth | true ] ifAbsent: [ false ]).	self deny: (config propertyAt: #foo2 ifPresent: [ :smth | true ] ifAbsent: [ false ])! !!CCConfigurationTest methodsFor: 'tests-properties' stamp: 'DamienCassou 4/24/2015 17:26'!testPropertiesAtPut	| config |	config := CCConfiguration new.	config propertyAt: #foo put: 'bar'.	self assert: (config propertyAt: #foo) = 'bar'.	config propertyAt: #foo put: 'baz'.	self assert: (config propertyAt: #foo) = 'baz'! !!CCConfigurationTest methodsFor: 'tests-properties' stamp: 'DamienCassou 4/24/2015 17:26'!testPropertiesHas	| config |	config := CCConfiguration new.	self deny: (config hasProperty: #foo).	config propertyAt: #foo put: 'bar'.	self assert: (config hasProperty: #foo).	self deny: (config hasProperty: #bar)! !!CCConfigurationToDictionaryTest methodsFor: 'tests-configuration' stamp: 'CyrilFerlicot 6/29/2015 15:07'!testMagritteConfigurationReadingAndInterpretingDictionary	| configuration mag |	configuration := CCMockConfiguration new		baseDirectory: FileSystem memory root;		yourself.	configuration baseDirectory / 'test.txt' writeStreamDo: [ :st | st nextPutAll: 'foo' ].	configuration baseDirectory / 'test2.txt' writeStreamDo: [ :st | st nextPutAll: 'bar' ].	configuration		mockPropertyFileList:				(Array with: configuration baseDirectory / 'test.txt' with: configuration baseDirectory / 'test2.txt');		yourself.	mag := CCMagritteConfigurationReader writeConfiguration: configuration toDictionary: Dictionary new.	self assert: mag class equals: Dictionary.	self assert: (mag at: 'mockPropertyFileList') equals: (Array with: 'test.txt' with: 'test2.txt')! !!CCConfigurationToDictionaryTest methodsFor: 'tests-configuration' stamp: 'CyrilFerlicot 6/29/2015 15:07'!testMagritteConfigurationReadingAndInterpretingFile	| configuration mag |	configuration := CCMockConfiguration new		baseDirectory: FileSystem memory root;		yourself.	configuration baseDirectory / 'test.txt' writeStreamDo: [ :st | st nextPutAll: 'test' ].	configuration		mockPropertyFile: configuration baseDirectory / 'test.txt';		yourself.	mag := CCMagritteConfigurationReader writeConfiguration: configuration toDictionary: Dictionary new.	self assert: mag class equals: Dictionary.	self assert: (mag at: 'mockPropertyFile') equals: 'test.txt'! !!CCConfigurationToDictionaryTest methodsFor: 'tests-configuration' stamp: 'CyrilFerlicot 6/29/2015 15:07'!testMagritteConfigurationReadingDefaultIsNotExported	| configuration mag |	configuration := CCMockConfiguration new.	mag := CCMagritteConfigurationReader writeConfiguration: configuration toDictionary: Dictionary new.	self should: [ mag at: 'mockProperty' ] raise: Error! !!CCConfigurationToDictionaryTest methodsFor: 'tests-configuration' stamp: 'CyrilFerlicot 6/29/2015 15:07'!testMagritteConfigurationReadingNumber	| configuration mag |	configuration := CCMockConfiguration new mockPropertyBis: 7; yourself.	mag := CCMagritteConfigurationReader writeConfiguration: configuration toDictionary: Dictionary new.	self assert: mag class equals: Dictionary.	self assert: (mag at: 'mockPropertyBis') equals: 7! !!CCConfigurationToDictionaryTest methodsFor: 'tests-configuration' stamp: 'CyrilFerlicot 6/29/2015 15:07'!testMagritteConfigurationReadingNumberAndString	| configuration mag |	configuration := CCMockConfiguration new		mockPropertyBis: 7;		mockProperty: 'mock';		yourself.	mag := CCMagritteConfigurationReader writeConfiguration: configuration toDictionary: Dictionary new.	self assert: mag class equals: Dictionary.	self assert: (mag at: 'mockPropertyBis') equals: 7.	self assert: (mag at: 'mockProperty') equals: 'mock'! !!CCConfigurationToDictionaryTest methodsFor: 'tests-configuration' stamp: 'CyrilFerlicot 6/29/2015 15:07'!testMagritteConfigurationReadingString	| configuration mag |	configuration := CCMockConfiguration new		mockProperty: 'mock';		yourself.	mag := CCMagritteConfigurationReader writeConfiguration: configuration toDictionary: Dictionary new.	self assert: mag class equals: Dictionary.	self assert: (mag at: 'mockProperty') equals: 'mock'! !!CCConfigurationToDictionaryTest methodsFor: 'tests-configuration' stamp: 'CyrilFerlicot 6/29/2015 15:07'!testMagritteConfigurationReadingSubconfiguration	| configuration mag |	configuration := CCMockConfiguration new yourself.	configuration		subConfiguration:			(CCMockConfiguration new				parent: configuration;				mockPropertyBis: 4;				yourself) yourself.	mag := CCMagritteConfigurationReader writeConfiguration: configuration toDictionary: Dictionary new. 	self assert: mag class equals: Dictionary.	self		assert: ((mag at: 'subConfiguration') isDictionary and: [ ((mag at: 'subConfiguration') at: 'mockPropertyBis') = 4 ])! !!CCConfigurationToDictionaryTest methodsFor: 'tests-configuration' stamp: 'CyrilFerlicot 9/11/2015 13:50'!testMagritteConfigurationReadingSubconfigurations	| configuration mag |	configuration := CCMockConfiguration new yourself.	configuration		subConfigurations:			(OrderedCollection				with:							(CCMockConfiguration new								configurationName: 'Foo';								parent: configuration;								mockPropertyBis: 7;								yourself) yourself) yourself.	mag := CCMagritteConfigurationReader writeConfiguration: configuration toDictionary: Dictionary new.	self assert: mag class equals: Dictionary.	self		assert:			((mag at: 'subConfigurations') isDictionary				and: [ (((mag at: 'subConfigurations') at: 'Foo') at: 'mockPropertyBis') = 7 ])! !!CCConfigurationToDictionaryTest methodsFor: 'tests-configuration' stamp: 'CyrilFerlicot 6/29/2015 15:07'!testMagritteConfigurationReadingWrongDictionary	self		should: [ 			CCMockConfiguration new				mockPropertyBis: 15;				yourself ]		raise: MAValidationError! !!CCConfigurationToDictionaryTest methodsFor: 'tests-configuration' stamp: 'CyrilFerlicot 6/29/2015 15:07'!testReadconfigurationWithInputWithoutDescription	| configuration mag |	configuration := CCMockConfiguration new		foo: 'bar';		yourself.	mag := CCMagritteConfigurationReader writeConfiguration: configuration toDictionary: Dictionary new.	self assert: (mag at: 'foo') equals: 'bar'! !!CCDictionaryToConfigurationTest methodsFor: 'tests-dictionary' stamp: 'CyrilFerlicot 6/29/2015 15:06'!testMagritteDictionaryReadingAndInterpretingDictionary	| mock dictionary mag |	mock := CCMockConfiguration new baseDirectory: FileSystem memory root; yourself.	mock baseDirectory / 'test.txt' writeStreamDo: [ :st | st nextPutAll: 'bar' ].	mock baseDirectory / 'test2.txt' writeStreamDo: [ :st | st nextPutAll: 'foo' ].	dictionary := Dictionary with: 'mockPropertyFileList' -> (Array with: 'test.txt' with: 'test2.txt').	mag := CCMagritteDictionaryReader writeDictionary: dictionary toConfiguration: mock.	self assert: mag mockPropertyFileList first contents equals: 'bar'.	self assert: mag mockPropertyFileList second contents equals: 'foo'! !!CCDictionaryToConfigurationTest methodsFor: 'tests-dictionary' stamp: 'CyrilFerlicot 6/29/2015 15:06'!testMagritteDictionaryReadingAndInterpretingFile	| mock dictionary mag |	mock := CCMockConfiguration new baseDirectory: FileSystem memory root; yourself.	mock baseDirectory / 'test.txt' writeStreamDo: [ :st | st nextPutAll: 'test' ].	dictionary := Dictionary with: 'mockPropertyFile' -> 'test.txt'.	mag := CCMagritteDictionaryReader writeDictionary: dictionary toConfiguration: mock.	self assert: mag mockPropertyFile contents equals: 'test'! !!CCDictionaryToConfigurationTest methodsFor: 'tests-dictionary' stamp: 'CyrilFerlicot 6/29/2015 15:06'!testMagritteDictionaryReadingDefault	| dictionary mag |	dictionary := Dictionary new.	mag := CCMagritteDictionaryReader writeDictionary: dictionary toConfiguration: CCMockConfiguration new.	self assert: mag class equals: CCMockConfiguration.	self assert: mag mockProperty equals: 'defaultMockValue'! !!CCDictionaryToConfigurationTest methodsFor: 'tests-dictionary' stamp: 'CyrilFerlicot 6/29/2015 15:06'!testMagritteDictionaryReadingNumber	| dictionary mag |	dictionary := Dictionary with: 'mockPropertyBis' -> 7.	mag := CCMagritteDictionaryReader writeDictionary: dictionary toConfiguration: CCMockConfiguration new.	self assert: mag class equals: CCMockConfiguration.	self assert: mag mockPropertyBis equals: 7! !!CCDictionaryToConfigurationTest methodsFor: 'tests-dictionary' stamp: 'CyrilFerlicot 6/29/2015 15:06'!testMagritteDictionaryReadingNumberAndString	| dictionary mag |	dictionary := Dictionary with: 'mockPropertyBis' -> 7 with: 'mockProperty' -> 'mock'.	mag := CCMagritteDictionaryReader writeDictionary: dictionary toConfiguration: CCMockConfiguration new.	self assert: mag class equals: CCMockConfiguration.	self assert: mag mockPropertyBis equals: 7.	self assert: mag mockProperty equals: 'mock'! !!CCDictionaryToConfigurationTest methodsFor: 'tests-dictionary' stamp: 'CyrilFerlicot 6/29/2015 15:06'!testMagritteDictionaryReadingString	| dictionary mag |	dictionary := Dictionary with: 'mockProperty' -> 'mock'.	mag := CCMagritteDictionaryReader		writeDictionary: dictionary		toConfiguration:			(CCMockConfiguration new				baseDirectory: FileSystem workingDirectory;				yourself).	self assert: mag class equals: CCMockConfiguration.	self assert: mag mockProperty equals: 'mock'! !!CCDictionaryToConfigurationTest methodsFor: 'tests-dictionary' stamp: 'CyrilFerlicot 6/29/2015 15:06'!testMagritteDictionaryReadingSubconfiguration	| dictionary mag |	dictionary := Dictionary with: 'subConfiguration' -> (Dictionary with: 'mockPropertyBis' -> 5).	mag := CCMagritteDictionaryReader writeDictionary: dictionary toConfiguration: CCMockConfiguration new.	self assert: mag class equals: CCMockConfiguration.	self		assert: mag subConfiguration		equals:			(CCMockConfiguration new				parent: mag;				mockPropertyBis: 5;				yourself)! !!CCDictionaryToConfigurationTest methodsFor: 'tests-dictionary' stamp: 'CyrilFerlicot 9/11/2015 13:55'!testMagritteDictionaryReadingSubconfigurations	| dictionary mag |	dictionary := Dictionary		with:			'subConfigurations' -> (Dictionary with: 'Foo' -> (Dictionary with: 'mockPropertyBis' -> 5)).	mag := CCMagritteDictionaryReader		writeDictionary: dictionary		toConfiguration: CCMockConfiguration new.	self assert: mag class equals: CCMockConfiguration.	self		assert: mag subConfigurations		equals:			(OrderedCollection				with:					(CCMockConfiguration new						configurationName: 'Foo';						parent: mag;						mockPropertyBis: 5;						yourself))! !!CCDictionaryToConfigurationTest methodsFor: 'tests-dictionary' stamp: 'CyrilFerlicot 9/11/2015 13:54'!testMagritteDictionaryReadingSubconfigurationsPropagate	| dictionary mag |	dictionary := Dictionary		with: 'mockPropertyBis' -> 5		with: 'configurations' -> (Dictionary with: 'Foo' -> Dictionary new).	mag := CCMagritteDictionaryReader writeDictionary: dictionary toConfiguration: CCMockConfiguration new.	self assert: mag class equals: CCMockConfiguration.	self assert: (mag subConfigurationNamed: 'Foo') mockPropertyBis equals: 5! !!CCDictionaryToConfigurationTest methodsFor: 'tests-dictionary' stamp: 'CyrilFerlicot 6/29/2015 15:06'!testMagritteDictionaryReadingWrongDictionary	| dictionary |	dictionary := Dictionary with: 'mockProperty' -> ''.	self should: [ CCMagritteDictionaryReader writeDictionary: dictionary toConfiguration: CCMockConfiguration new ] raise: MAValidationError! !!CCDictionaryToConfigurationTest methodsFor: 'tests-dictionary' stamp: 'CyrilFerlicot 6/29/2015 15:06'!testReadWithInputWithoutDescription	| dictionary mag |	dictionary := Dictionary with: 'foo' -> 'bar'.	mag := CCMagritteDictionaryReader writeDictionary: dictionary toConfiguration: CCMockConfiguration new.	self assert: mag foo equals: 'bar'! !"Cocoon-Tests-Core"!!Json commentStamp: '<historical>' prior: 0!This class reads and writes JSON format data - strings, numbers, boolean, nil, arrays and dictionaries. See http://www.crockford.com/JSON/index.html. It has been extended with syntax for invoking a prearranged list of constructors on read objects.!!JsonSyntaxError commentStamp: '<historical>' prior: 0!Class Json signals instances of me when an input stream contains invalid JSON input.!!JsonTests commentStamp: '<historical>' prior: 0!I provide a number of test cases for class Json.!!Json class methodsFor: 'as yet unclassified' stamp: 'ul 11/9/2010 04:07'!escapeForCharacter: c		| asciiValue |	(asciiValue := c asciiValue) < 128		ifTrue: [ ^escapeArray at: asciiValue + 1 ].	^nil! !!Json class methodsFor: 'as yet unclassified' stamp: 'TommasoDalSasso 3/17/2015 09:31'!initialize	"Json initialize."		escapeArray := Array new: 128.	(0 to: 31), #(127) do: [ :each |		escapeArray at: each + 1 put: '\u', (each printStringHex padLeftTo: 4 with: $0) ].	{		$" -> '\"'.		$\ -> '\\'.		Character backspace -> '\b'.		Character lf -> '\n'.		Character newPage -> '\f'.		Character cr -> '\r'.		Character tab -> '\t'.	} do: [ :each |		escapeArray at: each key asciiValue + 1 put: each value ].! !!Json class methodsFor: 'as yet unclassified' stamp: 'tonyg 8/24/2005 14:48'!mimeType	^ 'application/x-json'! !!Json class methodsFor: 'as yet unclassified' stamp: 'dkb 12/25/2009 02:51'!newWithConstructors: aCollection	| m |	m := Dictionary new.	aCollection do: [:each |		(each isKindOf: Association)			ifTrue: [m add: each]			ifFalse: [m at: each name asString put: each]].	^ self new ctorMap: m; yourself.! !!Json class methodsFor: 'as yet unclassified' stamp: 'tonyg 8/17/2005 09:09'!numbersMayContain: aChar	^ aChar isDigit or: [#($- $+ $. $e $E) includes: aChar]! !!Json class methodsFor: 'as yet unclassified' stamp: 'tonyg 11/29/2005 17:45'!readFrom: aStream	^ self new readFrom: aStream.! !!Json class methodsFor: 'as yet unclassified' stamp: 'tonyg 8/17/2005 07:45'!render: anObject	| s |	s := WriteStream on: String new.	anObject jsonWriteOn: s.	^ s contents.! !!Json class methodsFor: 'as yet unclassified' stamp: 'tonyg 11/30/2005 16:32'!render: anObject withConstructor: aConstructorName on: aStream	aStream nextPutAll: '@', aConstructorName.	anObject jsonWriteOn: aStream.! !!Json class methodsFor: 'as yet unclassified' stamp: 'dkb 12/25/2009 02:52'!renderInstanceVariables: aCollection of: anObject on: aStream	| map |	map := Dictionary new.	aCollection do: [:ivarName | map at: ivarName put: (anObject instVarNamed: ivarName)].	self render: map withConstructor: anObject class name asString on: aStream! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:19'!consume: aString returning: anObject	aString do: [:c | stream next == c ifFalse: [JsonSyntaxError signal: 'Expected ''', aString, ''''] ].	^ anObject! !!Json methodsFor: 'accessing' stamp: 'tonyg 11/29/2005 11:40'!ctorMap	^ ctorMap! !!Json methodsFor: 'accessing' stamp: 'dkb 12/25/2009 02:52'!ctorMap: m	ctorMap := m! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:19'!interpretStringEscape	| c |	c := stream next.	c == $b ifTrue: [^ Character backspace].	c == $n ifTrue: [^ Character lf].	c == $f ifTrue: [^ Character newPage].	c == $r ifTrue: [^ Character cr].	c == $t ifTrue: [^ Character tab].	c == $u ifTrue: [^ self unescapeUnicode].	^ c.! !!Json methodsFor: 'parsing' stamp: 'Igor.Stasenko 4/7/2010 01:45'!readAny	"This is the main entry point for the JSON parser. See also readFrom: on the class side."	| c |	self skipWhitespace.	c := stream peek asLowercase.	c == ${ ifTrue: [stream next. ^ self readDictionary].	c == $[ ifTrue: [stream next. ^ self readArray].	c == $" ifTrue: [stream next. ^ self readString].	c == $t ifTrue: [^ self consume: 'true' returning: true].	c == $f ifTrue: [^ self consume: 'false' returning: false].	c == $n ifTrue: [^ self consume: 'null' returning: nil].	c == $@ ifTrue: [stream next. ^ self readConstructor].	(Json numbersMayContain: c) ifTrue: [^ self readNumber].	JsonSyntaxError signal: 'Unknown Json input'! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:39'!readArray	| a |	a := OrderedCollection new.	self skipWhitespace.	(stream peekFor: $]) ifTrue: [ ^ #() ].		[		a add: self readAny.		self skipWhitespace.		(stream peekFor: $]) ifTrue: [ ^ a asArray].		(stream peekFor: $, ) ifFalse: [JsonSyntaxError signal: 'Missing comma'].	] repeat.! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:20'!readConstructor	| s c v ctor |	s := WriteStream on: ''.	[		c := stream peek.		c ifNil: [JsonSyntaxError signal: 'Premature EOF reading constructor name'].		((c == $.) or: [c isLetter])			ifTrue: [s nextPut: c. stream next]			ifFalse: [				v := self readAny.				s := s contents.				ctor := ctorMap ifNotNil: [ctor := ctorMap at: s ifAbsent: [nil]].				ctor ifNil: [JsonSyntaxError signal: 'Unknown ctor ', s].				^ ctor constructFromJson: v]	] repeat.! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:43'!readDictionary	| m k v needComma |	m := JsonObject new.	needComma := false.	[		self skipWhitespace.		(stream peekFor: $}) ifTrue: [ ^ m].		needComma			ifTrue: [ (stream peekFor: $,) ifFalse: [JsonSyntaxError signal: 'Missing comma'].					self skipWhitespace]			ifFalse: [needComma := true]."		k := self readAny. "		(stream peekFor: $") ifFalse: [JsonSyntaxError signal: 'Key in dictionary must be string'].		k := self readString.		self skipWhitespace.		(stream peekFor: $:) ifFalse: [JsonSyntaxError signal: 'Missing colon'].		v := self readAny.		m at: k put: v.	] repeat.! !!Json methodsFor: 'parsing' stamp: 'tonyg 11/29/2005 17:44'!readFrom: aStream	self stream: aStream.	^ self readAny! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:21'!readNumber	| acc c |	acc := WriteStream on: ''.	[		c := stream peek.		(c isNil not and: [Json numbersMayContain: c]) ifFalse: [			[^ acc contents asNumber] on: Error do: [JsonSyntaxError signal: 'Invalid number']].		acc nextPut: c.		stream next.	] repeat.! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:22'!readString	| s c |	s := WriteStream on: ''.	[		c := stream next.		c == $\			ifTrue: [s nextPut: self interpretStringEscape.]			ifFalse: [c == $" ifTrue: [^ s contents.].					s nextPut: c]	] repeat.! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:22'!skipComment	stream peek == $/ ifTrue: [		stream next.		stream peek == $/			ifTrue: [self skipToEndOfLine]			ifFalse: [stream peek == $*						ifTrue: [stream next. self skipCommentBody]						ifFalse: [JsonSyntaxError signal: 'Invalid comment syntax']]]! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:22'!skipCommentBody	[		[stream next == $*] whileFalse.		stream peek == $/	] whileFalse.	stream next. "skip that last slash"	self skipWhitespace.! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:24'!skipToEndOfLine	| cr lf |	cr := Character cr. lf := Character lf.	[ | c | (c := stream peek) == cr or: [ c == lf]] whileFalse: [stream next].	self skipWhitespace! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:24'!skipWhitespace	[stream peek isSeparator] whileTrue: [stream next].	self skipComment.! !!Json methodsFor: 'accessing' stamp: 'tonyg 8/16/2005 20:20'!stream	"Answer the value of stream"	^ stream! !!Json methodsFor: 'accessing' stamp: 'djr 10/2/2007 22:44'!stream: anObject	"Set the value of stream"	stream := anObject.	(stream respondsTo: #reset) ifTrue: [		stream reset.	].! !!Json methodsFor: 'private' stamp: 'Igor.Stasenko 4/7/2010 01:28'!unescapeUnicode	|string|	string := (String with: stream next with: stream next with: stream next with: stream next) asUppercase.	^ Unicode value: (Integer readFrom: string readStream base: 16)! !!JsonDummyTestObject class methodsFor: 'as yet unclassified' stamp: 'tonyg 11/29/2005 17:49'!constructFromJson: j	^ self new a: (j at: 'a'); b: (j at: 'b'); c: (j at: 'c'); yourself! !!JsonDummyTestObject methodsFor: 'as yet unclassified' stamp: 'tonyg 11/29/2005 17:56'!= other	^ other class == self class and: [		a = other a and: [		b = other b and: [		c = other c]]]! !!JsonDummyTestObject methodsFor: 'accessing' stamp: 'tonyg 11/29/2005 17:48'!a	"Answer the value of a"	^ a! !!JsonDummyTestObject methodsFor: 'accessing' stamp: 'dkb 12/25/2009 02:56'!a: anObject	"Set the value of a"	a := anObject! !!JsonDummyTestObject methodsFor: 'accessing' stamp: 'tonyg 11/29/2005 17:48'!b	"Answer the value of b"	^ b! !!JsonDummyTestObject methodsFor: 'accessing' stamp: 'dkb 12/25/2009 02:56'!b: anObject	"Set the value of b"	b := anObject! !!JsonDummyTestObject methodsFor: 'accessing' stamp: 'tonyg 11/29/2005 17:48'!c	"Answer the value of c"	^ c! !!JsonDummyTestObject methodsFor: 'accessing' stamp: 'dkb 12/25/2009 02:56'!c: anObject	"Set the value of c"	c := anObject! !!JsonDummyTestObject methodsFor: 'as yet unclassified' stamp: 'tonyg 11/30/2005 16:42'!jsonWriteOn: s	Json renderInstanceVariables: {#a. #b. #c} of: self on: s! !!Object methodsFor: '*JSON' stamp: 'Igor.Stasenko 1/9/2010 16:18'!asJsonString	^ String streamContents: [:str |		self jsonWriteOn: str ]! !!Number methodsFor: '*JSON-writing' stamp: 'ul 11/4/2008 04:46'!jsonWriteOn: aWriteStream 	self printOn: aWriteStream base: 10! !!Dictionary methodsFor: '*JSON-writing' stamp: 'Igor.Stasenko 12/27/2009 08:10'!jsonWriteOn: aStream	| needComma |	needComma := false.	aStream nextPut: ${.	self associationsDo: [ :assoc |		needComma			ifTrue: [ aStream nextPut: $, ]			ifFalse: [ needComma := true ].		assoc key jsonWriteOn: aStream.		aStream nextPut: $:.		assoc value jsonWriteOn: aStream ].	aStream nextPut: $}.! !!JsonObject class methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 1/9/2010 16:51'!fromAssociations: collectionOfAssociations	| result |	result := self new.		collectionOfAssociations do: [:each |		result at: each key put: each value ].	^ result! !!JsonObject methodsFor: 'comparing' stamp: 'PaulDeBruicker 12/30/2015 16:21'!addJsonDifferencesWith: aJsonObject to: anOrderedCollection	aJsonObject species = self species		ifTrue: [ 			self keys sort = aJsonObject keys sort				ifTrue: [ self addValueDifferencesWith: aJsonObject to: anOrderedCollection ]				ifFalse: [ 					anOrderedCollection						add:							'Keys are different: ' , (self keys difference: aJsonObject keys) asCommaString , ' actual:'								, self keys sort greaseString , ' expected: ' , aJsonObject keys sort greaseString ] ]		ifFalse: [ 			aJsonObject isArray				ifTrue: [ anOrderedCollection add: 'Expected JSONObject but got Array ', aJsonObject greaseString ]				ifFalse: [ anOrderedCollection add: 'Expected JSONObject but got String ' , aJsonObject ] ]! !!JsonObject methodsFor: 'comparing' stamp: 'PaulDeBruicker 7/17/2014 13:11'!addValueDifferencesWith: aJsonObject to: anOrderedCollection	self		keysAndValuesDo: [ :key :val | 			| otherVal |			otherVal := aJsonObject at: key.			val = otherVal				ifFalse: [ val addJsonDifferencesWith: otherVal to: anOrderedCollection ] ]! !!JsonObject methodsFor: 'accessing' stamp: 'rh 2/19/2010 21:34'!at: aKey	"make it work more like javascript objects"	^ self at: aKey ifAbsent: [nil]! !!JsonObject methodsFor: 'as yet unclassified' stamp: 'rh 2/19/2010 21:33'!doesNotUnderstand: aMessage	| key |	key := aMessage selector.	key isUnary ifTrue: [^ self at: key ifAbsent: [nil]].	^ (key isKeyword and: [(key occurrencesOf: $:) = 1])		ifTrue: [key := key allButLast asSymbol.				self at: key put: aMessage arguments first]		ifFalse: [super doesNotUnderstand: aMessage]					! !!JsonObject methodsFor: 'comparing' stamp: 'PaulDeBruicker 7/17/2014 13:11'!jsonDifferencesWith: aJsonObject	| diffs |	diffs := OrderedCollection new.	self addJsonDifferencesWith: aJsonObject to: diffs.	^ diffs! !!JsonObject methodsFor: 'accessing' stamp: 'rh 2/27/2010 00:03'!name"override 'cause Object defines this"	^self at: 'name'! !!JsonObject methodsFor: 'accessing' stamp: 'rh 2/27/2010 00:04'!value"override 'cause Object defines this"	^self at: 'value'! !!UndefinedObject methodsFor: '*JSON-writing' stamp: 'tonyg 8/17/2005 00:45'!jsonWriteOn: aWriteStream 	aWriteStream nextPutAll: 'null'! !!String methodsFor: '*JSON' stamp: 'PaulDeBruicker 12/30/2015 15:47'!addJsonDifferencesWith: anObject to: anOrderedCollection	self = anObject		ifFalse: [ 			anObject isString				ifTrue: [ 					| locations |					locations := OrderedCollection new.					self						doWithIndex: [ :each :index | 							anObject size >= index								ifTrue: [ 									(anObject at: index) = each										ifFalse: [ locations add: index ] ] ].					anOrderedCollection						add: 'string difference GOT ' , self , ' BUT EXPECTED ' , anObject , ' DIFFERENT STARTING AT POSITIONS ' , locations asCommaString, '    END.    ' ]				ifFalse: [ anOrderedCollection add: 'expected a String but got a ' , anObject className ] ]! !!String methodsFor: '*JSON-writing' stamp: 'ul 11/9/2010 04:07'!jsonWriteOn: aStream	aStream nextPut: $".	self do: [ :ch |		(Json escapeForCharacter: ch)			ifNil: [ aStream nextPut: ch ]			ifNotNil: [ :replacement |				aStream nextPutAll: replacement ] ].	aStream nextPut: $".! !!True methodsFor: '*JSON-writing' stamp: 'tonyg 8/17/2005 00:44'!jsonWriteOn: aStream	aStream nextPutAll: 'true'! !!False methodsFor: '*JSON-writing' stamp: 'tonyg 8/17/2005 00:43'!jsonWriteOn: aStream	aStream nextPutAll: 'false'! !!Association methodsFor: '*JSON-writing' stamp: 'matthias.berth 11/19/2009 10:21'!jsonWriteOn: aStream	self key asString jsonWriteOn: aStream.	aStream nextPut: $:; space.	self value jsonWriteOn: aStream.! !!Integer methodsFor: '*JSON-writing' stamp: 'Igor.Stasenko 12/27/2009 08:05'!jsonWriteOn: aWriteStream	^ self printOn: aWriteStream base: 10! !!Text methodsFor: '*json-printing' stamp: 'cwp 10/26/2006 22:25'!jsonWriteOn: aStream	self string jsonWriteOn: aStream! !!WriteStream methodsFor: '*json-printing' stamp: 'cwp 10/25/2006 12:27'!jsonPrint: anObject	anObject jsonWriteOn: self! !!Array methodsFor: '*json' stamp: 'PaulDeBruicker 12/29/2015 17:20'!addJsonDifferencesWith: anArray to: anOrderedCollection	self = anArray		ifFalse: [ 			self size = anArray size				ifTrue: [ 					self						do: [ :each | 							(anArray includes: each)								ifFalse: [ anArray do: [ :eachItem | each addJsonDifferencesWith: eachItem to: anOrderedCollection ] ] ] ]				ifFalse: [ 					anOrderedCollection						add:							'these json arrays are of different size. ' , self size greaseString , ' & ' , anArray size greaseString , '  '								, ' DIFF ' , (self difference: anArray) asCommaString , ' CONTENT ' ,self asCommaString , ' & '								, anArray asCommaString ] ]! !!Collection methodsFor: '*json' stamp: 'Igor.Stasenko 12/27/2009 08:03'!jsonWriteOn: aStream	"By default, use array braces "	aStream nextPut: $[.		self do: [:each |		each jsonWriteOn: aStream		  ] separatedBy: [ aStream nextPut: $, ].	aStream nextPut: $]! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 11/29/2005 18:03'!json: aString equals: aValue	| readValue |	readValue := self readFrom: aString.	self assert: readValue = aValue.! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 11/29/2005 18:03'!readFrom: aString	^ (Json newWithConstructors: {JsonDummyTestObject.}) readFrom: aString readStream! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 8/17/2005 16:24'!render: anObject equals: aString	self assert: (Json render: anObject) = aString! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 11/29/2005 17:51'!simpleDummyObject	^ JsonDummyTestObject new a: 1; b: 2; c: 3; yourself! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 8/16/2005 23:51'!testArray	self json: '[]' equals: #().	self json: '[[]]' equals: #(#()).	self json: '[[], []]' equals: #(#() #()).	self json: '["hi", "there"]' equals: #('hi' 'there').	self json: '[["a", "b", null]]' equals: #(('a' 'b' nil)).! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 8/16/2005 23:42'!testAtomFalse	self json: 'false' equals: false.	self json: '  false' equals: false.	self json: 'false  ' equals: false.	self json: '  false  ' equals: false.! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 8/16/2005 23:43'!testAtomNull	self json: 'null' equals: nil.	self json: '  null' equals: nil.	self json: 'null  ' equals: nil.	self json: '  null  ' equals: nil.! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 8/17/2005 09:10'!testAtomNumber	self json: '1' equals: 1.	self json: '0123' equals: 123.	self json: '1.23e2' equals: 123.	self json: '-1' equals: -1.	self json: '-0' equals: 0.	self json: '[-1.2]' equals: #(-1.2).! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 8/21/2009 22:57'!testAtomString	self json: '"hi"' equals: 'hi'.	self json: '"\""' equals: '"'.	self json: '"\\"' equals: '\'.	self json: '""' equals: ''.	self json: '"a\u0004b"' equals: ({$a. Character value: 4. $b} as: String).	self json: '"a\nb"' equals: ({$a. Character lf. $b} as: String).! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 8/16/2005 23:36'!testAtomTrue	self json: 'true' equals: true.	self json: '  true' equals: true.	self json: 'true  ' equals: true.	self json: '  true  ' equals: true.! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 11/29/2005 17:58'!testCtor	self json: '@JsonDummyTestObject {"a": 1, "b": 2, "c": 3}' equals: self simpleDummyObject.	self json: (Json render: self simpleDummyObject) equals: self simpleDummyObject.! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'Igor.Stasenko 12/27/2009 08:19'!testDictionary	self json: '{}' equals: (JsonObject new).	self json: '{"a": "a"}' equals: (JsonObject new at: 'a' put: 'a'; yourself).	self json: '{"a": [[]]}' equals: (JsonObject new at: 'a' put: #(#()); yourself).	self json: '{"a":"b", "b":"a"}' equals: (JsonObject new add: 'a'->'b'; add: 'b'->'a';yourself).! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'cwp 10/19/2006 19:06'!testMissingCtor	self 		should: [self readFrom: '@Missing[]']		raise: JsonSyntaxError! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'cwp 10/19/2006 19:06'!testMissingCtorNoMap	self 		should: [Json new readFrom: '@Missing[]' readStream]		raise: JsonSyntaxError! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'ul 11/9/2010 04:16'!testStringWithUnicode	| unicodeString |	unicodeString := (Unicode value: 16r263A) asString.	self json: '"\u263A"' equals:unicodeString.	self json: '"', unicodeString, '"' equals: unicodeString.	self render: unicodeString equals: '"', unicodeString, '"'.! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'matthias.berth 11/19/2009 10:21'!testWriteAssociation	self render: 'key' -> 'value' equals: '"key": "value"'.	self render: 'key' -> 2 equals: '"key": 2'.	"keys should be strings"	self render: 42 -> 2 equals: '"42": 2'.	"try to do _something_ for more complex keys"	self render: #(42 43 44) -> 2 equals:  '"#(42 43 44)": 2'.			! !!JsonTests methodsFor: 'as yet unclassified' stamp: 'tonyg 8/21/2009 22:55'!testWriteString	self render: '"' equals: '"\""'.	self render: '\' equals: '"\\"'.	self render: 'hi' equals: '"hi"'.	self render: ({$a. Character lf. $b} as: String) equals: '"a\nb"'.	self render: ({$a. Character value: 4. $b} as: String) equals: '"a\u0004b"'.! !"JSON"!!LPPhaser commentStamp: 'YannDubois 7/4/2016 16:30' prior: 0!I manage LPPhases,  I am responsible for creating a pipeline of phases.I am responsible for ordering them.!!LPPhase commentStamp: 'YannDubois 7/4/2016 14:53' prior: 0!I ma a phase, I have a block executed when an input is given to me.!!LPPipeline commentStamp: 'YannDubois 7/4/2016 14:50' prior: 0!I am a pipeline of Phases, phases are ordered in dependancy order.i.e. if a phase had dependencies, those dependencies will be before it in the pipeline.I can be executed with #executeOn:  which takes an object as input and pass it through all phases in the pipeline.!!LPPhaser methodsFor: 'adding' stamp: 'YannDubois 7/6/2016 15:57'!addPipe: aPipe	pipes add: aPipe! !!LPPhaser methodsFor: 'building' stamp: 'YannDubois 7/7/2016 11:27'!buildPipeline	| allPhases |	allPhases := self collectPipe asOrderedCollection.	^ (LPPipeline pipes: allPhases) sort! !!LPPhaser methodsFor: 'enumerating' stamp: 'YannDubois 7/6/2016 15:59'!collectPipe	| pipeCollection |	pipeCollection := pipes copy.	pipes do: [ :each | pipeCollection addAll: each allDependencies ].	^ pipeCollection! !!LPPhaser methodsFor: 'initialization' stamp: 'YannDubois 7/6/2016 15:58'!initialize	pipes := IdentitySet new.	^ super initialize ! !!LPPhase class methodsFor: 'initialization' stamp: 'YannDubois 7/4/2016 15:09'!block: aBlockClosure	^ self new block: aBlockClosure! !!LPPhase methodsFor: 'comparing' stamp: 'YannDubois 7/11/2016 15:23'!= aPhase	^ self dependencies includesAll: aPhase dependencies! !!LPPhase methodsFor: 'accessing' stamp: 'YannDubois 7/1/2016 15:49'!block: aBlock	block := aBlock! !!LPPhase methodsFor: 'executing' stamp: 'YannDubois 7/1/2016 15:50'!executeOn: input	^ block value: input! !!LPPipe class methodsFor: 'testing' stamp: 'YannDubois 7/6/2016 15:33'!isAbstract	^ self = LPPipe! !!LPPipe methodsFor: 'comparing' stamp: 'YannDubois 7/11/2016 15:15'!<= anObject	"a LPPipe is <= than another if the second one depends on it. It means that the second is dependent on the first one."	^ self allDependencies size <= anObject allDependencies size! !!LPPipe methodsFor: 'adding' stamp: 'YannDubois 7/6/2016 16:19'!addAllDependencies: aPhaseCollection	dependencies addAll: aPhaseCollection! !!LPPipe methodsFor: 'adding' stamp: 'YannDubois 7/6/2016 16:18'!addDependency: aPhase	dependencies add: aPhase! !!LPPipe methodsFor: 'public' stamp: 'YannDubois 7/6/2016 16:18'!allDependencies	| allDependencies |	allDependencies := self dependencies copy.	self dependencies do: [ :each | allDependencies addAll: each allDependencies ].	^ allDependencies! !!LPPipe methodsFor: 'accessing' stamp: 'YannDubois 7/6/2016 16:17'!dependencies	^ dependencies! !!LPPipe methodsFor: 'executing' stamp: 'YannDubois 7/6/2016 15:34'!executeOn: anInput	self subclassResponsibility! !!LPPipe methodsFor: 'initialization' stamp: 'YannDubois 7/6/2016 16:20'!initialize	super initialize.	dependencies := IdentitySet new! !!LPPipe methodsFor: 'testing' stamp: 'YannDubois 7/7/2016 11:18'!isPipeline	^ false! !!LPPipeline class methodsFor: 'initialization' stamp: 'YannDubois 7/6/2016 15:56'!pipes: aPipeCollection	^ self new pipes: aPipeCollection! !!LPPipeline methodsFor: 'comparing' stamp: 'YannDubois 7/6/2016 15:51'!= aPipeline	^ self pipes = aPipeline pipes! !!LPPipeline methodsFor: 'executing' stamp: 'YannDubois 7/6/2016 15:56'!executeOn: anInput	^ pipes inject: anInput into: [ :subResult :next | next executeOn: subResult ]! !!LPPipeline methodsFor: 'testing' stamp: 'YannDubois 7/7/2016 11:19'!isPipeline	^ true! !!LPPipeline methodsFor: 'accessing' stamp: 'YannDubois 7/6/2016 15:52'!pipes	^ pipes! !!LPPipeline methodsFor: 'accessing' stamp: 'YannDubois 7/6/2016 15:52'!pipes: aPipeCollection	pipes := aPipeCollection! !!LPPipeline methodsFor: 'sorting' stamp: 'YannDubois 7/7/2016 11:34'!sort	pipes := self pipes asSortedCollection asOrderedCollection		do: [ :each | 			each isPipeline				ifTrue: [ each sort ] ]! !"LightPhaser-Model"!!LPPhaseTest methodsFor: 'running' stamp: 'YannDubois 7/5/2016 09:30'!setUp	phaseType := LPPhase block: [ 1 ].	phaseType2 := (LPPhase block: [ 2 ]) addDependency: phaseType; yourself.	phaseType3 := (LPPhase block: [ 5 ]) addDependency: phaseType2; yourself.! !!LPPhaseTest methodsFor: 'tests' stamp: 'YannDubois 7/5/2016 09:32'!testAllDependencies	| results |	results := phaseType3 allDependencies.	self assert: (results includes: phaseType2).	self assert: (results includes: phaseType)! !!LPPhaseTest methodsFor: 'tests' stamp: 'YannDubois 7/4/2016 15:09'!testExecuteOn	| phase |	phase := LPPhase block: [ :arg | arg + 1 ].	self assert: (phase executeOn: 1) equals: 2! !!LPPhaserTest methodsFor: 'accessing' stamp: 'YannDubois 7/4/2016 10:10'!actualClass	^ LPPhaser! !!LPPhaserTest methodsFor: 'accessing' stamp: 'YannDubois 7/4/2016 10:10'!actualInstance	^ self actualClass new! !!LPPhaserTest methodsFor: 'running' stamp: 'YannDubois 7/6/2016 12:09'!setUp	phaseType := LPPhase block: [ 1 ].	phaseType2 := (LPPhase block: [ 2 ]) addDependency: phaseType; yourself.	phaseType3 := (LPPhase block: [ 5 ]) addDependency: phaseType2; yourself.! !!LPPhaserTest methodsFor: 'tests' stamp: 'YannDubois 7/12/2016 14:33'!test2PhasesDependOnTheSamePhase	| phase1 phase2 phase3 pipeline |	phase1 := LPPhase block: [ 1 ].	phase2 := (LPPhase block: [ 2 ]) addDependency: phase1.	phase3 := (LPPhase block: [ 3 ]) addDependency: phase1.	pipeline := LPPhaser new addPipe: phase2; addPipe: phase3; buildPipeline.	self assert: pipeline pipes size equals: 3! !!LPPhaserTest methodsFor: 'tests' stamp: 'YannDubois 7/6/2016 16:53'!testBuildPipeline	| pipeline expected phase1 phase2 pipeline2 |	pipeline := self actualInstance		addPipe: phaseType3;		buildPipeline.	expected := LPPipeline		pipes: (OrderedCollection with: phaseType with: phaseType2 with: phaseType3).	self assert: pipeline equals: expected.	phase1 := LPPhase block: [ 11 ].	phase2 := (LPPhase block: [ 12 ])		addDependency: pipeline;		yourself.	pipeline addDependency: phase1.	pipeline2 := self actualInstance		addPipe: phase2;		buildPipeline.	self assert: pipeline2 equals: (LPPipeline pipes: (OrderedCollection with: phase1 with: pipeline with: phase2))! !!LPPhaserTest methodsFor: 'tests' stamp: 'YannDubois 7/6/2016 15:54'!testBuildPipelineEnsurePhaseTypeAreNotModified	| pipeline |	pipeline := self actualInstance		addPipe: phaseType3;		buildPipeline.	self assert: phaseType3 dependencies size equals: 1! !!LPPhaserTest methodsFor: 'tests' stamp: 'YannDubois 7/6/2016 15:59'!testCollectPhaseTypesWith1Dependency	| result |	result := self actualInstance addPipe: phaseType2; collectPipe.	self assert: (result includes: phaseType2).	self assert: (result includes: phaseType)! !!LPPhaserTest methodsFor: 'tests' stamp: 'YannDubois 7/6/2016 15:59'!testCollectPhaseTypesWith2levelOfDependencies	| result |	result := self actualInstance addPipe: phaseType3; collectPipe.	self assert: (result includes: phaseType3).	self assert: (result includes: phaseType2).	self assert: (result includes: phaseType)! !!LPPipelineTest methodsFor: 'running' stamp: 'YannDubois 7/5/2016 09:18'!setUp	|phaseType phaseType2 phaseType3|	phaseType := LPPhase block: [ :each | each + 1 ].	phaseType2 := (LPPhase block: [ :each | each + 2 ]) addDependency: phaseType; yourself.	phaseType3 := (LPPhase block: [ :each | each + 5 ]) addDependency: phaseType2; yourself.		phaseCollection := OrderedCollection with: phaseType with: phaseType2 with: phaseType3.! !!LPPipelineTest methodsFor: 'tests' stamp: 'YannDubois 7/6/2016 16:00'!testExecuteOn	| pipeline |	pipeline := LPPipeline pipes: phaseCollection.	self assert: (pipeline executeOn: 1) equals: 9! !"LightPhaser-Tests-Model"!!PPContext commentStamp: 'JanKurs 8/26/2014 16:11' prior: 0!A PPContext is provides contextual information to the parsing function.Instance Variables	globals:		<Dictionary>	properties:		<Dictionar>	root:		<PPParser>	stream:		<PPStream>globals	- properties that are not restored after backtrackingproperties	- properties that are restored after backtrackingroot	- the root parserstream	- input stream!!PPFailure commentStamp: 'BernardoContreras 3/16/2015 21:39' prior: 0!The failure object in PetitParser. It is the only class that responds to #isPetitFailure with true. It contains an error message and a position of the occurrence of the failure.Instance Variables:	message	<String>	The error message of this failure.	position	<Integer>	The position of this failure in the input stream.!!PPMemento commentStamp: 'BernardoContreras 3/16/2015 21:40' prior: 0!PPMemento is an internal class used by PPMemoizedParser to cache results and detect left-recursive calls.Instance Variables:	result	<Object>	The cached result.	count	<Integer>	The number of recursive cycles followed.	!!PPParser commentStamp: 'BernardoContreras 3/16/2015 21:32' prior: 0!An abstract parser for all parsers in PetitParser. Subclasses implement #parseOn: to perform the actual recursive-descent parsing. All parsers support a variety of methods to perform an actual parse, see the methods in the #parsing protocol. Parsers are combined with a series of operators that can be found in the #operations protocol.Instance Variables:	properties	<Dictionary>	Stores additional state in the parser object.!!PPDelegateParser commentStamp: 'BernardoContreras 3/16/2015 21:31' prior: 0!A parser that delegates to another parser.Instance Variables:	parser	<PPParser>	The parser to delegate to.!!PPActionParser commentStamp: 'BernardoContreras 3/16/2015 21:31' prior: 0!A parser that performs an action block with the successful parse result of the delegate.Instance Variables:	block	<BlockClosure>	The action block to be executed.!!PPWrappingParser commentStamp: '<historical>' prior: 0!A parser that performs an action block upon activation with the stream and a continuation block.!!PPAndParser commentStamp: 'TudorGirba 2/27/2011 22:22' prior: 0!The and-predicate, a parser that succeeds whenever its delegate does, but does not consume the input stream [Parr 1994, 1995].!!PPCompositeParser commentStamp: 'BernardoContreras 3/16/2015 21:36' prior: 0!A PPCompositeParser is composed parser built from various primitive parsers. Every production in the receiver is specified as a method that returns its parser. Note that every production requires an instance variable of the same name, otherwise the production is not cached and cannot be used in recursive grammars. Productions should refer to each other by reading the respective inst-var. Note: these inst-vars are typically not written, as the assignment happens in the initialize method using reflection.The start production is defined in the method start. It is aliased to the inst-var parser defined in the superclass of PPCompositeParser.!!PPConditionalParser commentStamp: 'JanKurs 2/4/2015 18:03' prior: 0!A PPConditionalParser is a delegate parser that evaluates a block and if that returns true, the delegate parser is invoked and its result returned. If the block evaluates to false, the PPFailure is returned.The block accepts one argument, context.E.g.    ('a' asParser if: [ :ctx | (ctx propertyAt: #myProperty) isNotNil ]) parse: 'a'!!PPEndOfInputParser commentStamp: 'lr 4/18/2008 13:46' prior: 0!A parser that succeeds only at the end of the input stream.!!PPExpressionParser commentStamp: '<historical>' prior: 0!A PPExpressionParser is a parser to conveniently define an expression grammar with prefix, postfix, and left- and right-associative infix operators.The following code initializes a parser for arithmetic expressions. First we instantiate an expression parser, a simple parser for expressions in parenthesis and a simple parser for integer numbers.	expression := PPExpressionParser new.	parens := $( asParser token trim , expression , $) asParser token trim 		==> [ :nodes | nodes second ].	integer := #digit asParser plus token trim		==> [ :token | token value asInteger ].	Then we define on what term the expression grammar is built on:	expression term: parens / integer.	Finally we define the operator-groups in descending precedence. Note, that the action blocks receive both, the terms and the parsed operator in the order they appear in the parsed input. 		expression		group: [ :g |			g prefix: $- asParser token trim do: [ :op :a | a negated ] ];		group: [ :g |			g postfix: '++' asParser token trim do: [ :a :op | a + 1 ].			g postfix: '--' asParser token trim do: [ :a :op | a - 1 ] ];		group: [ :g |			g right: $^ asParser token trim do: [ :a :op :b | a raisedTo: b ] ];		group: [ :g |			g left: $* asParser token trim do: [ :a :op :b | a * b ].			g left: $/ asParser token trim do: [ :a :op :b | a / b ] ];		group: [ :g |			g left: $+ asParser token trim do: [ :a :op :b | a + b ].			g left: $- asParser token trim do: [ :a :op :b | a - b ] ].		After evaluating the above code the 'expression' is an efficient parser that evaluates examples like:	expression parse: '-8++'.	expression parse: '1+2*3'.	expression parse: '1*2+3'.	expression parse: '(1+2)*3'.	expression parse: '8/4/2'.	expression parse: '8/(4/2)'.	expression parse: '2^2^3'.	expression parse: '(2^2)^3'.	Instance Variables:	operators	<Dictionary>	The operators defined in the current group.!!PPFlattenParser commentStamp: 'lr 11/22/2009 13:09' prior: 0!A parser that answers a flat copy of the range my delegate parses.!!PPTokenParser commentStamp: 'lr 2/25/2013 23:31' prior: 0!A parser that answers a token with the value of my delegate parses.Instance Variables:	tokenClass	<PPToken class>	The token sub-class to be used.!!PPMemoizedParser commentStamp: '<historical>' prior: 0!A memoized parser, for refraining redundant computations.Instance Variables:	stream	<PositionableStream>	The stream of the associated memento objects.	buffer	<Array of: PPMemento>	The buffer of memento objects.!!PPNotParser commentStamp: '<historical>' prior: 0!The not-predicate, a parser that succeeds whenever its delegate does not, but consumes no input [Parr 1994, 1995].!!PPOptionalParser commentStamp: 'lr 4/3/2011 14:46' prior: 0!A parser that optionally parsers its delegate, or answers nil.!!PPRepeatingParser commentStamp: 'lr 4/3/2011 14:45' prior: 0!An abstract parser that repeatedly parses between 'min' and 'max' instances of its delegate. The default configuration parses an infinite number of elements, as 'min' is set to 0 and 'max' to infinity (SmallInteger maxVal).Instance Variables:	min	<Integer>	The minimum number of repetitions.	max	<Integer>	The maximum number of repetitions.!!PPLimitedRepeatingParser commentStamp: 'BernardoContreras 3/16/2015 21:30' prior: 0!An abstract parser that repeatedly parses between 'min' and 'max' instances of my delegate and that requires the input to be completed with a specified parser 'limit'. Subclasses provide repeating behavior as typically seen in regular expression implementations (non-blind).Instance Variables:	limit	<PPParser>	The parser to complete the input with.!!PPGreedyRepeatingParser commentStamp: 'lr 4/3/2011 15:08' prior: 0!A greedy repeating parser, commonly seen in regular expression implementations. It aggressively consumes as much input as possible and then backtracks to meet the 'limit' condition.This class essentially implements the iterative version of the following recursive parser composition:	| parser |	parser := PPChoiceParser new.	parser setParsers: (Array		with: (self , parser map: [ :each :rest | rest addFirst: each; yourself ])		with: (limit and ==> [ :each | OrderedCollection new ])).	^ parser ==> [ :rest | rest asArray ]!!PPLazyRepeatingParser commentStamp: 'lr 4/3/2011 15:08' prior: 0!A lazy repeating parser, commonly seen in regular expression implementations. It limits its consumption to meet the 'limit' condition as early as possible.This class essentially implements the iterative version of the following recursive parser composition:	| parser |	parser := PPChoiceParser new.	parser setParsers: (Array		with: (limit and ==> [ :each | OrderedCollection new ])		with: (self , parser map: [ :each :rest | rest addFirst: each; yourself ])).	^ parser ==> [ :rest | rest asArray ]!!PPPossessiveRepeatingParser commentStamp: 'lr 4/3/2011 14:35' prior: 0!The default repeating parser with standard PEG semantics (i.e. possessive, blind, eager).!!PPTrimmingParser commentStamp: 'BernardoContreras 3/16/2015 21:29' prior: 0!A parser that silently consumes spaces before and after the delegate parser.!!PPEndOfFileParser commentStamp: 'JanKurs 2/4/2015 17:52' prior: 0!A PPEndOfFileParser is parser that will will return true if the stream position is at the end, returns failure otherwise.The diffirenece between PPEndOfFIleParser and PPEndOfInputParser is: - PPEndOfFileParser can be created using #eof asParser - PPEndOfInputParser can be created by using parser end - PPEndOfFileParser does not delegate to any other parser - PPEndOfInputParser parsers its delegate and then decides if the input is at the end.The PPEndOfFileParser can be used to accept some input only if it is at the end of the input, e.g:   ('a' asParser, #eof asParser) parse: 'a'   ('a' asParser, #eof asParser) parse: 'aa'!!PPEndOfLineParser commentStamp: 'JanKurs 10/29/2014 15:49' prior: 0!A PPEndOfLineParser is a parser that does not fail, if the stream position is at the end of a line. It does not consume anything.!!PPEpsilonParser commentStamp: 'lr 5/15/2008 15:09' prior: 0!A parser that consumes nothing and always succeeds.!!PPFailingParser commentStamp: 'BernardoContreras 3/16/2015 21:29' prior: 0!A parser that consumes nothing and always fails.Instance Variables:	message <String>	The failure message.!!PPListParser commentStamp: 'BernardoContreras 3/16/2015 21:28' prior: 0!Abstract parser that parses a list of things in some way (to be specified by the subclasses).Instance Variables:	parsers	<SequenceableCollection of: PPParser>	A sequence of other parsers to delegate to.!!PPChoiceParser commentStamp: 'lr 4/18/2008 15:35' prior: 0!A parser that uses the first parser that succeeds.!!PPLimitedChoiceParser commentStamp: 'JanKurs 11/12/2014 11:53' prior: 0!A PPLimitedChoiceParser is similar to the choice parser except for the fact, that limit must pass if one of the choices passes. This is similar strategy as with the PPLimitedRepeatingParsers.This way, one can implement choices that successfully parse this (if limit is filled with 'a'):('aa' // 'a') 'a' parse: 'aa'The limit can be automatically filled using elements from either follow or next set (see methods  PPParser>>followSets or PPParser>>nextSets).Limit is by default epsilon and therefore it behaves as an ordinary ordered choice.Instance Variables	limit:		<Object>limit	- xxxxx!!PPSequenceParser commentStamp: 'lr 4/18/2008 15:34' prior: 0!A parser that parses a sequence of parsers.!!PPLiteralParser commentStamp: 'BernardoContreras 3/16/2015 21:20' prior: 0!Abstract literal parser that parses some kind of literal type (to be specified by subclasses).Instance Variables:	literal	<Object>	The literal object to be parsed.	message	<String>	The error message to be generated.!!PPLiteralObjectParser commentStamp: '<historical>' prior: 0!A parser that accepts a single literal object, such as a character. This is the same as the predicate parser 'PPPredicateParser expect: literal' but slightly more efficient.!!PPLiteralSequenceParser commentStamp: 'lr 12/4/2009 18:39' prior: 0!A parser accepts a sequence of literal objects, such as a String. This is an optimization to avoid having to compose longer sequences from PPSequenceParser.!!PPPluggableParser commentStamp: 'BernardoContreras 3/16/2015 21:19' prior: 0!A pluggable parser that passes the parser stream into a block. This enables users to perform manual parsing or to embed other parser frameworks into PetitParser.Instance Variables:	block	<BlockClosure>	The pluggable one-argument block.!!PPPredicateParser commentStamp: '<historical>' prior: 0!An abstract parser that accepts if a given predicate holds.Instance Variables:	predicate	<BlockClosure>	The block testing for the predicate.	predicateMessage	<String>	The error message of the predicate.	negated	<BlockClosure>	The block testing for the negation of the predicate.	negatedMessage	<String>	The error message of the negated predicate.!!PPPredicateObjectParser commentStamp: 'BernardoContreras 3/16/2015 21:18' prior: 0!A parser that accepts if a given predicate on one element of the input sequence holds.!!PPPredicateSequenceParser commentStamp: 'BernardoContreras 3/16/2015 21:18' prior: 0!A parser that accepts if a given predicate on an arbitrary number of elements of the input sequence holds.Instance Variables:	size	<Integer>	The number of elements to consume.!!PPStartOfLineParser commentStamp: 'JanKurs 10/29/2014 15:48' prior: 0!A PPStartOfLineParser is that does not fail, if the stream position is at the beginning of a line. It does not consume anything.!!PPStartOfLogicalLineParser commentStamp: 'JanKurs 1/8/2015 15:56' prior: 0!A PPStartOfLogicalLineParser is that does not fail, if the stream position is at the first non-blank character of a line. It does not consume anything.!!PPStartOfWordParser commentStamp: 'JanKurs 12/12/2014 16:50' prior: 0!A PPStartOfWordParser is that matches a word boundary.I return success if no word character preceeds my position and if word chracter succeeds my position.Word characters are any alphanumeric characters.!!PPUnresolvedParser commentStamp: 'lr 11/28/2009 18:50' prior: 0!This is a temporary placeholder or forward reference to a parser that has not been defined yet. If everything goes well it will eventually be replaced with the real parser instance.!!PPToken commentStamp: 'BernardoContreras 3/16/2015 21:41' prior: 0!PPToken represents a parsed part of the input stream. Contrary to a simple String it remembers where it came from, the original collection and its start and stop position.Instance Variables:	collection	<SequenceableCollection>	The collection this token comes from.	start	<Integer>	The start position in the collection.	stop	<Integer>	The stop position in the collection.!!PPStream commentStamp: '<historical>' prior: 0!A positional stream implementation used for parsing. It overrides some methods for optimization reasons.!!PPScriptingTest commentStamp: '<historical>' prior: 0!These are some simple demo-scripts of parser combinators for the compiler construction course.http://www.iam.unibe.ch/~scg/Teaching/CC/index.html!!Stream methodsFor: '*petitparser-core-converting' stamp: 'lr 4/8/2010 14:46'!asPetitStream	^ self contents asPetitStream! !!Object methodsFor: '*petitparser-core-converting' stamp: 'lr 12/18/2011 15:58'!asParser	"Answer a parser accepting the receiving object."	^ PPPredicateObjectParser expect: self! !!Object methodsFor: '*petitparser-core-testing' stamp: 'lr 2/7/2010 20:54'!isPetitFailure	^ false! !!Object methodsFor: '*petitparser-core-testing' stamp: 'lr 8/6/2010 16:44'!isPetitParser	^ false! !!PPCharSetPredicate class methodsFor: 'instance creation' stamp: 'lr 8/25/2010 11:05'!on: aBlock	^ self basicNew initializeOn: aBlock! !!PPCharSetPredicate methodsFor: 'initialization' stamp: 'JanKurs 2/20/2015 08:42'!initializeOn: aBlock	block := aBlock.	classification := Array new: 255.	1 to: classification size do: [ :index |		classification at: index put: (block			value: (Character codePoint: index)) ]! !!PPCharSetPredicate methodsFor: 'evaluating' stamp: 'lr 8/30/2010 12:19'!value: aCharacter	| index |	index := aCharacter asInteger.	index == 0		ifTrue: [ ^ block value: aCharacter ].	index > 255		ifTrue: [ ^ block value: aCharacter ].	^ classification at: index! !!PPContext class methodsFor: 'as yet unclassified' stamp: 'JanKurs 1/16/2014 14:38'!on: aPPParser stream: aStream	^ self basicNew 		initialize;		root: aPPParser;		stream: aStream asPetitStream;		yourself! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 1/16/2014 12:13'!atEnd	^ stream atEnd! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 9/5/2014 13:50'!back	^ stream back! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 8/19/2014 14:08'!collection	^ stream collection  ! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 9/30/2014 15:32'!contents 	^ stream contents! !!PPContext methodsFor: 'failures' stamp: 'JanKurs 2/20/2015 08:56'!furthestFailure	" the furthest failure encountered while parsing the input stream "		"^ self globalAt: #furthestFailure ifAbsent: [ nil ]"	"performance optimization:"	^ furthestFailure! !!PPContext methodsFor: 'accessing-globals' stamp: 'JanKurs 8/26/2014 16:25'!globalAt: aKey	"Answer the global property value associated with aKey."		^ self globalAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPContext methodsFor: 'accessing-globals' stamp: 'JanKurs 8/26/2014 16:09'!globalAt: aKey ifAbsent: aBlock	"Answer the global property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ globals isNil		ifTrue: [ aBlock value ]		ifFalse: [ globals at: aKey ifAbsent: aBlock ]! !!PPContext methodsFor: 'accessing-globals' stamp: 'JanKurs 8/26/2014 16:10'!globalAt: aKey ifAbsentPut: aBlock	"Answer the global property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self globalAt: aKey ifAbsent: [ self globalAt: aKey put: aBlock value ]! !!PPContext methodsFor: 'accessing-globals' stamp: 'JanKurs 8/26/2014 16:25'!globalAt: aKey put: anObject	"Set the global property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (globals ifNil: [ globals := Dictionary new: 1 ])		at: aKey put: anObject! !!PPContext methodsFor: 'accessing-globals' stamp: 'JanKurs 8/26/2014 16:10'!hasGlobal: aKey	"Test if the global property aKey is present."		^ globals notNil and: [ globals includesKey: aKey ]! !!PPContext methodsFor: 'accessing-properties' stamp: 'JanKurs 1/16/2014 11:25'!hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ]! !!PPContext methodsFor: 'initialization' stamp: 'JanKurs 8/25/2014 17:08'!initialize	stream := nil.! !!PPContext methodsFor: 'initialization' stamp: 'JanKurs 4/30/2015 10:52'!initializeFor: parser	parser == root ifTrue: [ ^ self ].		root := parser.! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 10/29/2014 15:50'!isEndOfLine	^ stream isEndOfLine! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 8/28/2014 10:20'!isStartOfLine	^ stream isStartOfLine! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 1/15/2014 16:02'!next	^ stream next! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 8/26/2014 12:07'!next: anInteger	^ stream next: anInteger! !!PPContext methodsFor: 'failures' stamp: 'JanKurs 2/20/2015 08:57'!noteFailure: aPPFailure	"record the furthest failure encountered while parsing the input stream "	( furthestFailure isNil or: [ aPPFailure position > furthestFailure position ]) 		ifTrue: [ furthestFailure := aPPFailure ].! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 4/29/2014 16:24'!peek	^ stream peek! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 4/29/2014 16:25'!peekTwice	^ stream peekTwice! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 9/30/2014 15:31'!position	^ stream position! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 9/30/2014 15:31'!position: anInteger	^ stream position: anInteger! !!PPContext methodsFor: 'printing' stamp: 'JanKurs 12/5/2014 22:40'!printOn: aStream	super printOn: aStream.	aStream nextPut: $:.	aStream nextPut: $ .	stream printOn: aStream! !!PPContext methodsFor: 'accessing-properties' stamp: 'JanKurs 1/16/2014 11:25'!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPContext methodsFor: 'accessing-properties' stamp: 'JanKurs 1/16/2014 11:25'!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ properties at: aKey ifAbsent: aBlock ]! !!PPContext methodsFor: 'accessing-properties' stamp: 'JanKurs 1/16/2014 11:25'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!PPContext methodsFor: 'accessing-properties' stamp: 'JanKurs 1/16/2014 11:25'!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (properties ifNil: [ properties := Dictionary new: 1 ])		at: aKey put: anObject! !!PPContext methodsFor: 'memoization' stamp: 'JanKurs 8/26/2014 16:58'!remember	| memento |	memento := PPContextMemento new		stream: stream;		position: stream position;		yourself.			self rememberProperties: memento.	^ memento! !!PPContext methodsFor: 'memoization' stamp: 'JanKurs 8/26/2014 16:52'!rememberProperties: aPPContextMemento	properties ifNil: [ ^ self ].		properties keysAndValuesDo: [ :key :value |		aPPContextMemento propertyAt: key put: value	].! !!PPContext methodsFor: 'accessing-globals' stamp: 'JanKurs 8/26/2014 16:09'!removeGlobal: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeGlobal: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPContext methodsFor: 'accessing-globals' stamp: 'JanKurs 8/26/2014 16:09'!removeGlobal: aKey ifAbsent: aBlock	"Remove the global property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	globals isNil ifTrue: [ ^ aBlock value ].	answer := globals removeKey: aKey ifAbsent: aBlock.	globals isEmpty ifTrue: [ globals := nil ].	^ answer! !!PPContext methodsFor: 'accessing-properties' stamp: 'JanKurs 1/16/2014 11:25'!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPContext methodsFor: 'accessing-properties' stamp: 'JanKurs 1/16/2014 11:25'!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer! !!PPContext methodsFor: 'memoization' stamp: 'JanKurs 8/26/2014 16:58'!restore: aPPContextMemento	aPPContextMemento stream == stream ifFalse: [ self error: 'Oops!!' ].	stream position: aPPContextMemento position.	self restoreProperties: aPPContextMemento.! !!PPContext methodsFor: 'memoization' stamp: 'JanKurs 11/4/2014 17:18'!restoreProperties: aPPContextMemento	aPPContextMemento stream == stream ifFalse: [ self error: 'Oops!!' ].		properties ifNil: [ ^ self ].		properties keysDo: [ :key |		(aPPContextMemento hasProperty: key)			ifTrue: [ properties at: key put: (aPPContextMemento propertyAt: key) ]			ifFalse: [ properties removeKey: key  ]. 	].	aPPContextMemento keysAndValuesDo: [ :key :value |		properties at: key put: value	]! !!PPContext methodsFor: 'acessing' stamp: 'JanKurs 10/29/2013 10:13'!root	^ root ! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 8/19/2014 14:08'!skip: anInteger 	^ stream skip: anInteger ! !!PPContext methodsFor: 'stream mimicry' stamp: 'StephanEggermont 11/10/2014 11:57'!skipTo: anObject 	^ stream skipTo: anObject ! !!PPContext methodsFor: 'stream mimicry' stamp: 'StephanEggermont 11/10/2014 12:00'!skipToAll: aString	"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."	| pattern startMatch |	pattern := aString readStream.	startMatch := nil.	[ pattern atEnd ] whileFalse: 		[ stream atEnd ifTrue: [ ^ false ].		stream next = pattern next 			ifTrue: [ pattern position = 1 ifTrue: [ startMatch := stream position ] ]			ifFalse: 				[ pattern position: 0.				startMatch ifNotNil: 					[ stream position: startMatch.					startMatch := nil ] ] ].	^ true! !!PPContext methodsFor: 'stream mimicry' stamp: 'StephanEggermont 11/10/2014 12:01'!skipToAnyOf: aCharacterSet 	"Set the access position of the receiver to be past the next occurrence of	a character in the character set. Answer whether a fitting character is found."	[stream atEnd]		whileFalse: [ (aCharacterSet includes: stream next) ifTrue: [^true]].	^false! !!PPContext methodsFor: 'acessing' stamp: 'JanKurs 1/16/2014 15:12'!stream	^ stream! !!PPContext methodsFor: 'acessing' stamp: 'JanKurs 1/15/2014 15:36'!stream: aStream	stream := aStream.! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 8/19/2014 14:08'!uncheckedPeek	^ stream uncheckedPeek! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 1/15/2014 16:11'!upTo: anObject	^ stream upTo: anObject! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 4/29/2014 16:29'!upToAll: whatever	^ stream upToAll: whatever! !!PPContext methodsFor: 'stream mimicry' stamp: 'JanKurs 4/29/2014 16:31'!upToAnyOf: whatever	^ stream upToAnyOf: whatever! !!PPContextMemento methodsFor: 'comparing' stamp: 'JanKurs 8/26/2014 15:41'!= anObject		(self == anObject) ifTrue: [ ^ true ].	(anObject class = PPContextMemento) ifFalse: [ ^ false ].		(anObject stream == stream) ifFalse: [ ^ false ].	(anObject position = position) ifFalse: [ ^ false ].	(self propertiesSize = anObject propertiesSize) ifFalse: [ ^ false ].	self keysAndValuesDo: [ :key :value |		(anObject hasProperty: key) ifFalse: [ ^ false ].		((anObject propertyAt: key) = value) ifFalse: [ ^ false ].  	].		^ true.! !!PPContextMemento methodsFor: 'accessing - properties' stamp: 'JanKurs 3/19/2014 12:14'!hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ]! !!PPContextMemento methodsFor: 'comparing' stamp: 'JanKurs 3/19/2014 13:04'!hash	^ (position hash bitXor: stream hash) bitXor: properties hash.! !!PPContextMemento methodsFor: 'accessing - properties' stamp: 'JanKurs 8/26/2014 14:59'!keysAndValuesDo: aBlock	properties ifNil: [ ^ self ].	properties keysAndValuesDo: [ :key :value | aBlock value: key value: value copy ] ! !!PPContextMemento methodsFor: 'accessing' stamp: 'JanKurs 10/28/2013 16:51'!position	^ position! !!PPContextMemento methodsFor: 'accessing' stamp: 'JanKurs 10/28/2013 16:52'!position: anInteger	position := anInteger ! !!PPContextMemento methodsFor: 'accessing - properties' stamp: 'JanKurs 8/26/2014 15:32'!propertiesSize	properties ifNil: [ ^ 0 ].	^ properties size.! !!PPContextMemento methodsFor: 'accessing - properties' stamp: 'JanKurs 3/19/2014 12:14'!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPContextMemento methodsFor: 'accessing - properties' stamp: 'JanKurs 11/17/2014 11:37'!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		properties isNil		ifTrue: [ ^ aBlock value ]		ifFalse: [ 			(properties includesKey: aKey) ifTrue: [ 				^ (properties at: aKey) copy			].			^ aBlock value		]! !!PPContextMemento methodsFor: 'accessing - properties' stamp: 'JanKurs 3/19/2014 12:15'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!PPContextMemento methodsFor: 'accessing - properties' stamp: 'JanKurs 8/26/2014 13:42'!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (properties ifNil: [ properties := Dictionary new: 1 ])		at: aKey put: (anObject copy)! !!PPContextMemento methodsFor: 'accessing - properties' stamp: 'JanKurs 3/19/2014 12:15'!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPContextMemento methodsFor: 'accessing - properties' stamp: 'JanKurs 3/19/2014 12:15'!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer! !!PPContextMemento methodsFor: 'accessing' stamp: 'JanKurs 10/28/2013 16:51'!stream	^ stream! !!PPContextMemento methodsFor: 'accessing' stamp: 'JanKurs 10/28/2013 16:52'!stream: aStream	stream := aStream! !!PPFailure class methodsFor: 'instance creation' stamp: 'JanKurs 9/17/2014 20:27'!message: aString	^ self basicNew initializeMessage: aString ! !!PPFailure class methodsFor: 'instance creation' stamp: 'JanKurs 9/30/2014 16:21'!message: aString at: anInteger	"One should not use this method if the furthest failure is supposed to be reported correctly"	^ self basicNew initializeMessage: aString at: anInteger! !!PPFailure class methodsFor: 'instance creation' stamp: 'JanKurs 8/19/2014 16:32'!message: aString context: aPPContext	^ self basicNew initializeMessage: aString context: aPPContext! !!PPFailure class methodsFor: 'instance creation' stamp: 'JanKurs 8/19/2014 16:57'!message: aString context: aPPContext at: position	^ self basicNew initializeMessage: aString context: aPPContext position: position! !!PPFailure methodsFor: 'initialization' stamp: 'JanKurs 9/17/2014 20:28'!initializeMessage: aString		message := aString.! !!PPFailure methodsFor: 'initialization' stamp: 'JanKurs 9/30/2014 16:21'!initializeMessage: aString at: anInteger	"One should not use this method if the furthest failure is supposed to be reported correctly"	message := aString.	position := anInteger.! !!PPFailure methodsFor: 'initialization' stamp: 'JanKurs 8/19/2014 16:57'!initializeMessage: aString context: aPPContext	self initializeMessage: aString context:  aPPContext position: aPPContext position! !!PPFailure methodsFor: 'initialization' stamp: 'JanKurs 8/25/2014 15:02'!initializeMessage: aString context: aPPContext position: anInteger	message := aString.	context := aPPContext.	position := anInteger.		"record the furthest failure encountered while parsing the input stream "	aPPContext noteFailure: self.	! !!PPFailure methodsFor: 'testing' stamp: 'lr 2/7/2010 20:54'!isPetitFailure	"I am the only class that should implement this method to return true."	^ true! !!PPFailure methodsFor: 'accessing' stamp: 'lr 5/5/2010 13:56'!message	"Answer a human readable error message of this parse failure."		^ message! !!PPFailure methodsFor: 'accessing' stamp: 'lr 5/5/2010 13:55'!position	"Answer the position in the source string that caused this parse failure."	^ position! !!PPFailure methodsFor: 'printing' stamp: 'JanKurs 8/19/2014 16:30'!printOn: aStream	aStream nextPutAll: self message; nextPutAll: ' at '; print: self position! !!PPMemento class methodsFor: 'instance creation' stamp: 'lr 4/22/2008 18:21'!new	^ self basicNew initialize! !!PPMemento methodsFor: 'accessing' stamp: 'JanKurs 1/15/2014 16:09'!contextMemento	^ context! !!PPMemento methodsFor: 'accessing' stamp: 'JanKurs 1/15/2014 16:09'!contextMemento: aPPContextMemento	context  := aPPContextMemento ! !!PPMemento methodsFor: 'accessing-readonly' stamp: 'lr 4/22/2008 18:23'!count	^ count! !!PPMemento methodsFor: 'actions' stamp: 'lr 4/22/2008 18:20'!increment	count := count + 1! !!PPMemento methodsFor: 'initialization' stamp: 'lr 4/22/2008 18:21'!initialize	count := 0	! !!PPMemento methodsFor: 'accessing' stamp: 'lr 4/24/2008 10:15'!result	^ result! !!PPMemento methodsFor: 'accessing' stamp: 'lr 4/22/2008 18:23'!result: anObject	result := anObject! !!PPActionParser class methodsFor: 'instance creation' stamp: 'lr 5/2/2010 16:58'!on: aParser block: aBlock	^ (self on: aParser) setBlock: aBlock! !!PPActionParser methodsFor: 'accessing' stamp: 'lr 4/30/2010 11:10'!block	"Answer the action block of the receiver."	^ block! !!PPActionParser methodsFor: 'parsing' stamp: 'JanKurs 11/11/2013 09:31'!parseOn: aPPContext	| element |	^ (element := parser parseOn: aPPContext) isPetitFailure		ifFalse: [ block value: element ]		ifTrue: [ element ]! !!PPActionParser methodsFor: 'initialization' stamp: 'lr 5/2/2010 16:58'!setBlock: aBlock	block := aBlock! !!PPWrappingParser methodsFor: 'parsing' stamp: 'JanKurs 11/11/2013 09:31'!parseOn: aPPContext	^ block value: aPPContext value: [ parser parseOn: aPPContext ]! !!PPAndParser methodsFor: 'operators' stamp: 'lr 5/1/2010 16:16'!and	^ self! !!PPAndParser methodsFor: 'parsing' stamp: 'JanKurs 8/24/2014 14:45'!parseOn: aPPContext	| element memento |	memento := aPPContext remember.	element := parser parseOn: aPPContext.	aPPContext restore: memento.	^ element! !!PPArithmeticParser methodsFor: 'grammar' stamp: 'lr 2/25/2013 23:46'!addition	^ (factors separatedBy: ($+ asParser / $- asParser) trim) 		foldLeft: [ :a :op :b | a perform: op asSymbol with: b ]! !!PPArithmeticParser methodsFor: 'grammar' stamp: 'lr 9/15/2008 09:28'!factors	^ multiplication / power! !!PPArithmeticParser methodsFor: 'grammar' stamp: 'lr 2/25/2013 23:47'!multiplication	^ (power separatedBy: ($* asParser / $/ asParser) trim)		foldLeft: [ :a :op :b | a perform: op asSymbol with: b ]! !!PPArithmeticParser methodsFor: 'grammar' stamp: 'lr 2/25/2013 23:47'!number	^ ($- asParser optional , #digit asParser plus , ($. asParser , #digit asParser plus) optional) flatten trim 		==> [ :value | value asNumber ]! !!PPArithmeticParser methodsFor: 'grammar' stamp: 'JamesFoster 2/20/2015 11:59'!parentheses	^ $( asParser trim , terms , $) asParser trim		==> [ :nodes | nodes at: 2 ]! !!PPArithmeticParser methodsFor: 'grammar' stamp: 'lr 2/25/2013 23:49'!power	^ (primary separatedBy: $^ asParser trim)		foldRight: [ :a :op :b | a raisedTo: b ]! !!PPArithmeticParser methodsFor: 'grammar' stamp: 'lr 9/15/2008 09:28'!primary	^ number / parentheses! !!PPArithmeticParser methodsFor: 'accessing' stamp: 'lr 7/3/2008 17:06'!start	^ terms end! !!PPArithmeticParser methodsFor: 'grammar' stamp: 'lr 9/15/2008 09:29'!terms	^ addition / factors! !!PPCompositeParser class methodsFor: 'accessing' stamp: 'lr 3/16/2013 21:42'!dependencies	"Answer a collection of PPCompositeParser classes that this parser directly dependends on. Override this method in subclasses to declare dependent parsers. The default implementation does not depend on other PPCompositeParser."	^ #()! !!PPCompositeParser class methodsFor: 'accessing' stamp: 'lr 1/29/2010 11:35'!ignoredNames	"Answer a collection of instance-variables that should not be automatically initialized with productions, but that are used internal to the composite parser."	^ PPCompositeParser allInstVarNames! !!PPCompositeParser class methodsFor: 'instance creation' stamp: 'lr 12/7/2009 08:24'!new	"Answer a new parser starting at the default start symbol."	^ self newStartingAt: self startSymbol! !!PPCompositeParser class methodsFor: 'instance creation' stamp: 'lr 3/16/2013 21:21'!newStartingAt: aSymbol	"Answer a new parser starting at aSymbol. The code makes sure to resolve all dependent parsers correctly."	| parsers remaining |	parsers := IdentityDictionary new.	remaining := OrderedCollection with: self.	[ remaining isEmpty ] whileFalse: [		| dependency |		dependency := remaining removeLast.		(parsers includesKey: dependency) ifFalse: [			parsers at: dependency put: dependency basicNew.			remaining addAll: dependency dependencies ] ].	parsers keysAndValuesDo: [ :class :parser |		| dependencies |		dependencies := IdentityDictionary new.		class dependencies 			do: [ :dependency | dependencies at: dependency put: (parsers at: dependency) ].		parser 			initializeStartingAt: (class == self				ifTrue: [ aSymbol ]				ifFalse: [ class startSymbol ]) 			dependencies: dependencies ].	parsers keysAndValuesDo: [ :class :parser |		parser setParser: (parser perform: parser children first name).		parser productionNames keysAndValuesDo: [ :key :value |			(parser instVarAt: key) setParser: (parser perform: value) ] ].	^ parsers at: self! !!PPCompositeParser class methodsFor: 'parsing' stamp: 'lr 2/7/2010 20:57'!parse: anObject	^ self parse: anObject startingAt: self startSymbol! !!PPCompositeParser class methodsFor: 'parsing' stamp: 'lr 2/7/2010 21:02'!parse: anObject onError: aBlock	^ self parse: anObject startingAt: self startSymbol onError: aBlock! !!PPCompositeParser class methodsFor: 'parsing' stamp: 'lr 2/7/2010 20:57'!parse: anObject startingAt: aSymbol	^ (self newStartingAt: aSymbol) parse: anObject! !!PPCompositeParser class methodsFor: 'parsing' stamp: 'lr 2/7/2010 21:02'!parse: anObject startingAt: aSymbol onError: aBlock	^ (self newStartingAt: aSymbol) parse: anObject onError: aBlock! !!PPCompositeParser class methodsFor: 'accessing' stamp: 'lr 12/7/2009 08:20'!startSymbol	"Answer the method that represents the default start symbol."	^ #start! !!PPCompositeParser methodsFor: 'querying' stamp: 'lr 3/16/2013 21:41'!dependencyAt: aClass	"Answer the dependent parser aClass. Throws an error if this parser class is not declared in the method #dependencies on the class-side of the receiver."		^ dependencies at: aClass ifAbsent: [ self error: 'Undeclared dependency in ' , self class name , ' to ' , aClass name ]! !!PPCompositeParser methodsFor: 'initialization' stamp: 'lr 3/16/2013 17:15'!initializeStartingAt: aSymbol dependencies: aDictionary	self initialize.	parser := PPDelegateParser named: aSymbol.	self productionNames keysAndValuesDo: [ :key :value |		self instVarAt: key put: (PPDelegateParser named: value) ].	dependencies := aDictionary! !!PPCompositeParser methodsFor: 'querying' stamp: 'lr 12/4/2009 18:39'!productionAt: aSymbol	"Answer the production named aSymbol."		^ self productionAt: aSymbol ifAbsent: [ nil ]! !!PPCompositeParser methodsFor: 'querying' stamp: 'lr 6/4/2010 13:37'!productionAt: aSymbol ifAbsent: aBlock	"Answer the production named aSymbol, if there is no such production answer the result of evaluating aBlock."		(self class ignoredNames includes: aSymbol asString)		ifTrue: [ ^ aBlock value ].	(self class startSymbol = aSymbol)		ifTrue: [ ^ parser ].	^ self instVarAt: (self class allInstVarNames		indexOf: aSymbol asString		ifAbsent: [ ^ aBlock value ])! !!PPCompositeParser methodsFor: 'querying' stamp: 'lr 5/8/2011 15:45'!productionNames	"Answer a dictionary of slot indexes and production names."		| productionNames ignoredNames |	productionNames := Dictionary new.	ignoredNames := self class ignoredNames		collect: [ :each | each asSymbol ].	self class allInstVarNames keysAndValuesDo: [ :key :value |		(ignoredNames includes: value asSymbol)			ifFalse: [ productionNames at: key put: value asSymbol ] ].	^ productionNames! !!PPCompositeParser methodsFor: 'accessing' stamp: 'lr 5/16/2008 17:32'!start	"Answer the production to start this parser with."		self subclassResponsibility! !!PPLambdaParser class methodsFor: 'curch-booleans' stamp: 'lr 4/3/2009 08:28'!and	^ self parse: '\p.\q.((p q) p)'! !!PPLambdaParser class methodsFor: 'curch-booleans' stamp: 'lr 4/3/2009 08:28'!false	^ self parse: '\x.\y.y'! !!PPLambdaParser class methodsFor: 'curch-booleans' stamp: 'lr 4/3/2009 08:28'!ifthenelse	^ self parse: '\p.p'! !!PPLambdaParser class methodsFor: 'curch-booleans' stamp: 'lr 4/3/2009 08:28'!not	^ self parse: '\p.\a.\b.((p b) a)'! !!PPLambdaParser class methodsFor: 'curch-booleans' stamp: 'lr 4/3/2009 08:28'!or	^ self parse: '\p.\q.((p p) q)'! !!PPLambdaParser class methodsFor: 'curch-booleans' stamp: 'lr 4/3/2009 08:28'!true	^ self parse: '\x.\y.x'! !!PPLambdaParser methodsFor: 'productions' stamp: 'JamesFoster 2/20/2015 12:10'!abstraction	^ $\ asParser trim , variable , $. asParser trim , expression 		==> [ :node | Array with: (node at: 2) with: (node at: 4) ]! !!PPLambdaParser methodsFor: 'productions' stamp: 'JamesFoster 2/20/2015 12:11'!application	^ $( asParser trim , expression , expression , $) asParser trim 			==> [ :node | Array with: (node at: 2) with: (node at: 3) ]! !!PPLambdaParser methodsFor: 'productions' stamp: 'lr 9/15/2008 09:29'!expression	^ variable / abstraction / application! !!PPLambdaParser methodsFor: 'accessing' stamp: 'lr 5/19/2008 11:35'!start	^ expression end! !!PPLambdaParser methodsFor: 'productions' stamp: 'lr 2/25/2013 23:44'!variable	^ (#letter asParser , #word asParser star) flatten trim! !!PPConditionalParser class methodsFor: 'as yet unclassified' stamp: 'JanKurs 1/25/2015 16:27'!on: aPPParser block: block	^ (PPConditionalParser on: aPPParser)		block: block;		yourself! !!PPConditionalParser methodsFor: 'accessing' stamp: 'JanKurs 1/25/2015 16:28'!block: aBlock	block := aBlock! !!PPConditionalParser methodsFor: 'parsing' stamp: 'JanKurs 1/25/2015 16:27'!parseOn: aPPContext	^ (block value: aPPContext) 		ifTrue: [ parser parseOn: aPPContext ]		ifFalse: [ PPFailure message: block asString, ' was not evaluated to true.' context: aPPContext ]! !!PPDelegateParser class methodsFor: 'instance creation' stamp: 'lr 4/20/2008 16:22'!on: aParser	^ self new setParser: aParser! !!PPDelegateParser methodsFor: 'accessing' stamp: 'lr 10/21/2009 16:37'!children	^ Array with: parser! !!PPDelegateParser methodsFor: 'parsing' stamp: 'JanKurs 11/11/2013 09:31'!parseOn: aPPContext	^ parser parseOn: aPPContext! !!PPDelegateParser methodsFor: 'initialization' stamp: 'lr 4/20/2008 16:23'!setParser: aParser	parser := aParser! !!PPEndOfInputParser methodsFor: 'operators' stamp: 'lr 12/7/2009 08:53'!end	^ self! !!PPEndOfInputParser methodsFor: 'parsing' stamp: 'JanKurs 8/24/2014 14:45'!parseOn: aPPContext	| memento result |	memento := aPPContext remember.	result := parser parseOn: aPPContext.	(result isPetitFailure or: [ aPPContext stream atEnd ])		ifTrue: [ ^ result ].	result := PPFailure		message: 'end of input expected'		context: aPPContext.	aPPContext restore: memento.	^ result! !!PPExpressionParser methodsFor: 'private' stamp: 'FirstnameLastname 11/26/2009 20:48'!build: aParser left: aChoiceParser	^ (aParser separatedBy: aChoiceParser) foldLeft: [ :a :op :b | op first value: a value: op second value: b ]! !!PPExpressionParser methodsFor: 'private' stamp: 'lr 12/4/2009 17:38'!build: aParser postfix: aChoiceParser	^ aParser , aChoiceParser star map: [ :term :ops | ops inject: term into: [ :result :operator | operator first value: result value: operator second ] ]! !!PPExpressionParser methodsFor: 'private' stamp: 'JanKurs 2/20/2015 08:46'!build: aParser prefix: aChoiceParser	^ aChoiceParser star , aParser map: [ :ops :term | ops reverse inject: term into: [ :result :operator | operator first value: operator second value: result ] ]! !!PPExpressionParser methodsFor: 'private' stamp: 'FirstnameLastname 11/26/2009 20:48'!build: aParser right: aChoiceParser	^ (aParser separatedBy: aChoiceParser) foldRight: [ :a :op :b | op first value: a value: op second value: b ]! !!PPExpressionParser methodsFor: 'private' stamp: 'FirstnameLastname 11/26/2009 21:15'!buildOn: aParser	^ self buildSelectors inject: aParser into: [ :term :selector |		| list |		list := operators at: selector ifAbsent: [ #() ].		list isEmpty			ifTrue: [ term ]			ifFalse: [				self					perform: selector with: term 					with: (list size = 1						ifTrue: [ list first first ==> [ :operator | Array with: list first second with: operator ] ]						ifFalse: [ 							list								inject: PPChoiceParser new								into: [ :choice :each | choice / (each first ==> [ :operator | Array with: each second with: operator ]) ] ]) ] ]! !!PPExpressionParser methodsFor: 'private' stamp: 'FirstnameLastname 11/26/2009 20:48'!buildSelectors	^ #(build:prefix: build:postfix: build:right: build:left:)! !!PPExpressionParser methodsFor: 'specifying' stamp: 'lr 2/7/2010 23:20'!group: aOneArgumentBlock	"Defines a priority group by evaluating aOneArgumentBlock."		operators := Dictionary new.	parser := [ 		aOneArgumentBlock value: self.	 	self buildOn: parser ]			ensure: [ operators := nil ]! !!PPExpressionParser methodsFor: 'specifying' stamp: 'FirstnameLastname 11/26/2009 20:49'!left: aParser do: aThreeArgumentBlock	"Define an operator aParser that is left-associative. Evaluate aThreeArgumentBlock with the first term, the operator, and the second term."		self operator: #build:left: parser: aParser do: aThreeArgumentBlock! !!PPExpressionParser methodsFor: 'private' stamp: 'lr 2/7/2010 23:23'!operator: aSymbol parser: aParser do: aBlock	parser isNil		ifTrue: [ ^ self error: 'You did not specify a term when creating the receiver.' ].	operators isNil		ifTrue: [ ^ self error: 'Use #group: to define precedence groups in descending order.' ].	(operators at: aSymbol ifAbsentPut: [ OrderedCollection new ])		addLast: (Array with: aParser asParser with: aBlock)! !!PPExpressionParser methodsFor: 'specifying' stamp: 'FirstnameLastname 11/26/2009 20:49'!postfix: aParser do: aTwoArgumentBlock	"Define a postfix operator aParser. Evaluate aTwoArgumentBlock with the term and the operator."	self operator: #build:postfix: parser: aParser do: aTwoArgumentBlock! !!PPExpressionParser methodsFor: 'specifying' stamp: 'FirstnameLastname 11/26/2009 20:49'!prefix: aParser do: aTwoArgumentBlock	"Define a prefix operator aParser. Evaluate aTwoArgumentBlock with the operator and the term."	self operator: #build:prefix: parser: aParser do: aTwoArgumentBlock! !!PPExpressionParser methodsFor: 'specifying' stamp: 'FirstnameLastname 11/26/2009 20:49'!right: aParser do: aThreeArgumentBlock	"Define an operator aParser that is right-associative. Evaluate aThreeArgumentBlock with the first term, the operator, and the second term."		self operator: #build:right: parser: aParser do: aThreeArgumentBlock! !!PPExpressionParser methodsFor: 'specifying' stamp: 'FirstnameLastname 11/26/2009 21:26'!term: aParser	"Defines the initial term aParser of the receiver."		parser isNil		ifTrue: [ parser := aParser ]		ifFalse: [ self error: 'Unable to redefine the term.' ]! !!PPFlattenParser methodsFor: 'private' stamp: 'lr 2/25/2013 23:31'!on: aCollection start: aStartInteger stop: aStopInteger value: anObject	^ aCollection copyFrom: aStartInteger to: aStopInteger! !!PPFlattenParser methodsFor: 'parsing' stamp: 'JanKurs 8/24/2014 14:46'!parseOn: aPPContext	| start element |	start := aPPContext position.	element := parser parseOn: aPPContext.	element isPetitFailure ifTrue: [ ^ element ].	^ self on: aPPContext stream collection start: start + 1 stop: aPPContext position value: element! !!PPTokenParser methodsFor: 'private' stamp: 'lr 4/6/2010 19:18'!defaultTokenClass	^ PPToken! !!PPTokenParser methodsFor: 'initialization' stamp: 'lr 4/6/2010 19:19'!initialize	tokenClass := self defaultTokenClass	! !!PPTokenParser methodsFor: 'private' stamp: 'lr 2/25/2013 23:32'!on: aCollection start: aStartInteger stop: aStopInteger value: anObject	^ self tokenClass on: aCollection start: aStartInteger stop: aStopInteger value: anObject! !!PPTokenParser methodsFor: 'accessing' stamp: 'lr 4/6/2010 19:23'!tokenClass	^ tokenClass! !!PPTokenParser methodsFor: 'accessing' stamp: 'lr 4/6/2010 19:24'!tokenClass: aTokenClass	tokenClass := aTokenClass! !!PPMemoizedParser methodsFor: 'operators' stamp: 'lr 4/2/2009 19:48'!memoized	"Ther is no point in memoizing more than once."	^ self! !!PPMemoizedParser methodsFor: 'parsing' stamp: 'JanKurs 9/9/2014 11:40'!parseOn: aPPContext	| memento contextMemento  aStream |	"TODO: JK memoizing needs review!!"		contextMemento := aPPContext remember.	(hash == aPPContext hash)		ifFalse: [ self reset: aPPContext ].	memento := (buffer at: contextMemento ifAbsentPut: [ PPMemento new ]).		memento contextMemento isNil		ifTrue: [			aStream := aPPContext stream.			memento result: (aStream size - aStream position + 2 < memento count				ifTrue: [ PPFailure message: 'overflow' context: aPPContext ]				ifFalse: [ memento increment. parser parseOn: aPPContext ]).			memento contextMemento: aPPContext remember ]		ifFalse: [ context restore: memento contextMemento ].	^ memento result.! !!PPMemoizedParser methodsFor: 'parsing' stamp: 'JanKurs 9/9/2014 11:39'!reset: aPPContext	hash := aPPContext hash.	context := aPPContext.	buffer := Dictionary new.! !!PPNotParser methodsFor: 'parsing' stamp: 'JanKurs 8/24/2014 14:47'!parseOn: aPPContext	| element memento |	memento := aPPContext remember.	element := parser parseOn: aPPContext.	aPPContext restore: memento.	^ element isPetitFailure		ifFalse: [ PPFailure message: '' context: aPPContext ]! !!PPOptionalParser methodsFor: 'parsing' stamp: 'JanKurs 3/19/2014 15:12'!parseOn: aPPContext	| element |	element := parser parseOn: aPPContext.	^ element isPetitFailure ifFalse: [ element ]! !!PPGreedyRepeatingParser methodsFor: 'parsing' stamp: 'JanKurs 11/10/2014 17:58'!parseOn: aPPContext	| memento element elements positions |	memento := aPPContext remember.	elements := OrderedCollection new.	[ elements size < min ] whileTrue: [ 		(element := parser parseOn: aPPContext) isPetitFailure ifTrue: [ 			aPPContext restore: memento.			^ element ].		elements addLast: element ].	positions := OrderedCollection with: aPPContext remember.	[ elements size < max and: [ (element := parser parseOn: aPPContext) isPetitFailure not ] ] whileTrue: [		elements addLast: element.		positions addLast: aPPContext remember ].	[ positions isEmpty ] whileFalse: [		aPPContext restore: positions last.		element := limit parseOn: aPPContext.		element isPetitFailure ifFalse: [			aPPContext restore: positions last.			^ elements asArray ].		elements isEmpty ifTrue: [			aPPContext restore: memento.			^ element ].		elements removeLast.		positions removeLast ].	aPPContext restore: memento.	^ PPFailure message: 'overflow' context: aPPContext at: memento position! !!PPLazyRepeatingParser methodsFor: 'parsing' stamp: 'JanKurs 8/24/2014 14:47'!parseOn: aPPContext	| memento element elements |	memento := aPPContext remember.	elements := OrderedCollection new.	[ elements size < min ] whileTrue: [		(element := parser parseOn: aPPContext) isPetitFailure ifTrue: [			aPPContext restore: memento.			^ element ].		elements addLast: element ].	[ self matchesLimitOn: aPPContext ] whileFalse: [		elements size < max ifFalse: [			aPPContext restore: memento.			^ PPFailure message: 'overflow' context: aPPContext at: memento position ].		element := parser parseOn: aPPContext.		element isPetitFailure ifTrue: [			aPPContext restore: memento.			^ element ].		elements addLast: element ].	^ elements asArray! !!PPLimitedRepeatingParser class methodsFor: 'instance creation' stamp: 'lr 4/3/2011 14:58'!on: aParser limit: aLimitParser	^ (self on: aParser) setLimit: aLimitParser! !!PPLimitedRepeatingParser methodsFor: 'accessing' stamp: 'lr 4/4/2011 18:46'!children	^ Array with: parser with: limit! !!PPLimitedRepeatingParser methodsFor: 'accessing' stamp: 'lr 4/2/2011 10:00'!limit	"Answer the parser that limits (or ends) this repetition."		^ limit! !!PPLimitedRepeatingParser methodsFor: 'parsing' stamp: 'JanKurs 1/15/2014 16:04'!matchesLimitOn: aPPContext	| element position |	position := aPPContext remember.	element := limit parseOn: aPPContext.	aPPContext restore: position.	^ element isPetitFailure not! !!PPLimitedRepeatingParser methodsFor: 'initialization' stamp: 'lr 4/2/2011 10:00'!setLimit: aParser	limit := aParser! !!PPPossessiveRepeatingParser methodsFor: 'parsing' stamp: 'JanKurs 8/24/2014 14:48'!parseOn: aPPContext	| memento element elements |	memento := aPPContext remember.	elements := OrderedCollection new.	[ elements size < min ] whileTrue: [		(element := parser parseOn: aPPContext) isPetitFailure ifTrue: [			aPPContext restore: memento.			^ element ].		elements addLast: element ].	[ elements size < max ] whileTrue: [	 	(element := parser parseOn: aPPContext) isPetitFailure			ifTrue: [ ^ elements asArray ].		elements addLast: element ].	^ elements asArray! !!PPRepeatingParser methodsFor: 'initialization' stamp: 'lr 4/1/2011 21:06'!initialize	super initialize.	self setMin: 0; setMax: SmallInteger maxVal! !!PPRepeatingParser methodsFor: 'accessing' stamp: 'lr 4/30/2010 11:08'!max	"Answer the maximum number of repetitions."	^ max! !!PPRepeatingParser methodsFor: 'accessing' stamp: 'lr 4/30/2010 11:08'!min	"Answer the minimum number of repetitions."		^ min! !!PPRepeatingParser methodsFor: 'printing' stamp: 'lr 6/3/2010 14:00'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' ['; print: min; nextPutAll: ', '; nextPutAll: (max = SmallInteger maxVal		ifTrue: [ '*' ] ifFalse: [ max printString ]); nextPut: $]! !!PPRepeatingParser methodsFor: 'initialization' stamp: 'lr 4/1/2011 21:00'!setMax: anInteger	max := anInteger! !!PPRepeatingParser methodsFor: 'initialization' stamp: 'lr 4/1/2011 21:01'!setMin: anInteger	min := anInteger! !!PPTrimmingParser class methodsFor: 'instance creation' stamp: 'lr 7/31/2010 12:01'!on: aParser trimmer: aTrimParser	^ self new		setParser: aParser;		setTrimmer: aTrimParser;		yourself! !!PPTrimmingParser methodsFor: 'parsing' stamp: 'JanKurs 8/24/2014 14:48'!parseOn: aPPContext	| memento element |	memento := aPPContext remember.	[ (trimmer parseOn: aPPContext) isPetitFailure ]		whileFalse.	element := parser parseOn: aPPContext.	element isPetitFailure ifTrue: [		aPPContext restore: memento.		^ element ].	[ (trimmer parseOn: aPPContext) isPetitFailure ]		whileFalse.	^ element! !!PPTrimmingParser methodsFor: 'initialization' stamp: 'lr 7/31/2010 12:00'!setTrimmer: aParser	trimmer := aParser! !!PPEndOfFileParser methodsFor: 'as yet unclassified' stamp: 'JanKurs 9/13/2014 19:04'!acceptsEpsilon	^ true! !!PPEndOfFileParser methodsFor: 'as yet unclassified' stamp: 'JanKurs 1/27/2015 13:37'!exampleOn: aStream 	aStream nextPutAll: #'end-of-input'! !!PPEndOfFileParser methodsFor: 'as yet unclassified' stamp: 'JanKurs 4/22/2013 18:25'!isNullable 	^ true! !!PPEndOfFileParser methodsFor: 'as yet unclassified' stamp: 'JanKurs 1/7/2015 12:41'!nonEmpty	"I know I am empty, but it does not count in my case, I represent virtual non-existent character"	^ self! !!PPEndOfFileParser methodsFor: 'as yet unclassified' stamp: 'JanKurs 1/27/2015 14:27'!parseOn: aPPContext	(aPPContext atEnd) ifFalse:	[		^ PPFailure message: 'end of input expected' context: aPPContext.	].	^ #'end-of-input'! !!PPEndOfLineParser methodsFor: 'parsing' stamp: 'JanKurs 10/29/2014 15:50'!parseOn: aPPContext	(aPPContext isEndOfLine) ifTrue: [ 		^ #endOfLine	].	^ PPFailure message: 'End of line expected' context: aPPContext at: aPPContext position! !!PPEpsilonParser methodsFor: 'parsing' stamp: 'lr 2/7/2010 20:49'!parseOn: aStream	^ nil! !!PPFailingParser class methodsFor: 'instance creation' stamp: 'lr 5/2/2010 19:16'!message: aString	^ self new setMessage: aString! !!PPFailingParser methodsFor: 'accessing' stamp: 'lr 4/30/2010 11:10'!message	"Answer the error message of the receiving parser."	^ message! !!PPFailingParser methodsFor: 'pp-context' stamp: 'JanKurs 8/19/2014 16:59'!parseOn: aPPContext	^ PPFailure message: message context: aPPContext! !!PPFailingParser methodsFor: 'printing' stamp: 'lr 4/16/2010 21:27'!printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: message! !!PPFailingParser methodsFor: 'initialization' stamp: 'lr 5/2/2010 19:16'!setMessage: aString	message := aString! !!PPChoiceParser methodsFor: 'operators' stamp: 'lr 9/17/2008 00:16'!/ aRule 	^ self copyWith: aRule! !!PPChoiceParser methodsFor: 'parsing' stamp: 'JanKurs 11/11/2013 09:31'!parseOn: aPPContext	"This is optimized code that avoids unnecessary block activations, do not change. When all choices fail, the last failure is answered."	| element |	1 to: parsers size do: [ :index |		element := (parsers at: index)			parseOn: aPPContext.		element isPetitFailure			ifFalse: [ ^ element ] ].	^ element! !!PPLimitedChoiceParser methodsFor: 'as yet unclassified' stamp: 'JanKurs 11/11/2014 17:55'!// aRule 	^ self copyWith: aRule! !!PPLimitedChoiceParser methodsFor: 'as yet unclassified' stamp: 'JanKurs 11/12/2014 11:49'!initialize	limit := nil asParser! !!PPLimitedChoiceParser methodsFor: 'accessing' stamp: 'JanKurs 11/12/2014 11:50'!limit		^ limit! !!PPLimitedChoiceParser methodsFor: 'accessing' stamp: 'JanKurs 11/12/2014 11:52'!limit: anObject		limit := anObject! !!PPLimitedChoiceParser methodsFor: 'as yet unclassified' stamp: 'JanKurs 11/12/2014 11:52'!parseOn: aPPContext	"This is optimized code that avoids unnecessary block activations, do not change. When all choices fail, the last failure is answered."	| element limitResult memento |	"self halt."	1 to: parsers size do: [ :index |		memento := aPPContext remember.				element := (parsers at: index)			parseOn: aPPContext.				(element isPetitFailure not) ifTrue: [ 			"check limit"			limitResult := limit parseOn: aPPContext.			limitResult isPetitFailure ifTrue: [ 				element := PPFailure message: 'limit failed' at: aPPContext position .				aPPContext restore: memento.			] ifFalse: [ ^ element ].		].	].		^ element! !!PPListParser class methodsFor: 'instance creation' stamp: 'lr 5/3/2010 20:26'!with: aParser	^ self withAll: (Array with: aParser)! !!PPListParser class methodsFor: 'instance creation' stamp: 'lr 9/23/2008 18:32'!with: aFirstParser with: aSecondParser	^ self withAll: (Array with: aFirstParser with: aSecondParser)! !!PPListParser class methodsFor: 'instance creation' stamp: 'JanKurs 11/11/2014 17:48'!withAll: aCollection	^ self basicNew initialize;		setParsers: aCollection! !!PPListParser methodsFor: 'accessing' stamp: 'lr 10/21/2009 16:37'!children	^ parsers! !!PPListParser methodsFor: 'copying' stamp: 'lr 9/17/2008 22:36'!copyWith: aParser	^ self species withAll: (parsers copyWith: aParser)! !!PPListParser methodsFor: 'initialization' stamp: 'lr 4/29/2010 10:12'!initialize	super initialize.	self setParsers: #()! !!PPListParser methodsFor: 'copying' stamp: 'lr 5/22/2010 10:26'!postCopy	super postCopy.	parsers := parsers copy! !!PPListParser methodsFor: 'initialization' stamp: 'lr 4/29/2010 10:12'!setParsers: aCollection	parsers := aCollection asArray! !!PPSequenceParser methodsFor: 'operators' stamp: 'lr 9/17/2008 00:17'!, aRule	^ self copyWith: aRule! !!PPSequenceParser methodsFor: 'operators-mapping' stamp: 'lr 5/6/2011 20:27'!map: aBlock	^ aBlock numArgs = self children size		ifTrue: [ self ==> [ :nodes | aBlock valueWithArguments: nodes ] ]		ifFalse: [ self error: aBlock numArgs asString , ' arguments expected.' ]! !!PPSequenceParser methodsFor: 'parsing' stamp: 'JanKurs 8/24/2014 14:49'!parseOn: aPPContext	"This is optimized code that avoids unnecessary block activations, do not change."		| memento elements element |	memento := aPPContext remember.	elements := Array new: parsers size.	1 to: parsers size do: [ :index |		element := (parsers at: index) 			parseOn: aPPContext.		element isPetitFailure ifTrue: [			aPPContext restore: memento.			^ element ].		elements at: index put: element ].	^ elements! !!PPSequenceParser methodsFor: 'operators-mapping' stamp: 'lr 1/8/2010 12:01'!permutation: anArrayOfIntegers	"Answer a permutation of the receivers sequence."		anArrayOfIntegers do: [ :index |		(index isInteger and: [ index between: 1 and: parsers size ])			ifFalse: [ self error: 'Invalid permutation index: ' , index printString ] ].	^ self ==> [ :nodes | anArrayOfIntegers collect: [ :index | nodes at: index ] ]! !!PPLiteralObjectParser methodsFor: 'operators' stamp: 'lr 8/18/2010 20:16'!caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PPPredicateObjectParser on: [ :value | literal sameAs: value ] message: message! !!PPLiteralObjectParser methodsFor: 'operators' stamp: 'lr 4/28/2011 20:02'!negate	^ (PPPredicateObjectParser expect: literal message: message) negate! !!PPLiteralObjectParser methodsFor: 'parsing' stamp: 'JanKurs 8/19/2014 17:00'!parseOn: aPPContext	^ (aPPContext stream atEnd not and: [ literal = aPPContext stream uncheckedPeek ])		ifFalse: [ PPFailure message: message context: aPPContext ]		ifTrue: [ aPPContext stream next ]! !!PPLiteralParser class methodsFor: 'instance creation' stamp: 'lr 1/7/2010 15:30'!on: anObject	^ self on: anObject message: anObject printString , ' expected'! !!PPLiteralParser class methodsFor: 'instance creation' stamp: 'lr 1/7/2010 15:29'!on: anObject message: aString	^ self new initializeOn: anObject message: aString! !!PPLiteralParser methodsFor: 'operators' stamp: 'lr 6/1/2010 22:24'!caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		self subclassResponsibility! !!PPLiteralParser methodsFor: 'initialization' stamp: 'lr 5/2/2010 13:25'!initializeOn: anObject message: aString	literal := anObject.	message := aString! !!PPLiteralParser methodsFor: 'accessing' stamp: 'lr 5/2/2010 13:26'!literal	"Answer the parsed literal."	^ literal! !!PPLiteralParser methodsFor: 'accessing' stamp: 'lr 5/2/2010 13:26'!message	"Answer the failure message."		^ message! !!PPLiteralParser methodsFor: 'printing' stamp: 'lr 4/16/2010 16:38'!printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: literal! !!PPLiteralSequenceParser methodsFor: 'operators' stamp: 'lr 8/18/2010 20:16'!caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PPPredicateSequenceParser on: [ :value | literal sameAs: value ] message: message size: size! !!PPLiteralSequenceParser methodsFor: 'initialization' stamp: 'lr 6/1/2010 22:21'!initializeOn: anObject message: aString	super initializeOn: anObject message: aString.	size := literal size! !!PPLiteralSequenceParser methodsFor: 'parsing' stamp: 'JanKurs 8/26/2014 17:03'!parseOn: aPPContext	| memento result |	memento := aPPContext remember.	result := aPPContext next: size.	literal = result ifTrue: [ ^ result ].	aPPContext restore: memento.	^ PPFailure message: message context: aPPContext! !!PPLiteralSequenceParser methodsFor: 'accessing' stamp: 'lr 9/15/2010 11:16'!size	"Answer the sequence size of the receiver."	^ size! !!PPParser class methodsFor: 'instance creation' stamp: 'lr 10/27/2008 11:17'!named: aString	^ self new name: aString! !!PPParser class methodsFor: 'instance creation' stamp: 'lr 4/18/2008 14:00'!new	^ self basicNew initialize! !!PPParser methodsFor: 'operators' stamp: 'lr 9/23/2008 18:32'!, aParser 	"Answer a new parser that parses the receiver followed by aParser."	^ PPSequenceParser with: self with: aParser! !!PPParser methodsFor: 'operators' stamp: 'lr 4/14/2010 11:46'!/ aParser 	"Answer a new parser that parses the receiver, if the receiver fails try with aParser (ordered-choice)."		^ PPChoiceParser with: self with: aParser! !!PPParser methodsFor: 'operators' stamp: 'JanKurs 11/12/2014 11:54'!// aParser 	"		Answer a new parser that parses the receiver, if the receiver fails try with aParser (ordered-choice).		If the receiver passes, limit must pass as well.	"		^ PPLimitedChoiceParser with: self with: aParser! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 5/12/2010 20:32'!==> aBlock	"Answer a new parser that performs aBlock as action handler on success."	^ PPActionParser on: self block: aBlock! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 6/12/2010 10:20'!>=> aBlock	"Answer a new parser that wraps the receiving parser with a two argument block. The first argument is the parsed stream, the second argument a continuation block on the delegate parser."	^ PPWrappingParser on: self block: aBlock! !!PPParser methodsFor: 'enumerating' stamp: 'lr 4/13/2010 08:36'!allParsers	"Answer all the parse nodes of the receiver."	| result |	result := OrderedCollection new.	self allParsersDo: [ :parser | result addLast: parser ].	^ result! !!PPParser methodsFor: 'enumerating' stamp: 'lr 4/13/2010 08:36'!allParsersDo: aBlock	"Iterate over all the parse nodes of the receiver."	self allParsersDo: aBlock seen: IdentitySet new! !!PPParser methodsFor: 'enumerating' stamp: 'lr 4/13/2010 08:35'!allParsersDo: aBlock seen: aSet	"Iterate over all the parse nodes of the receiver, do not visit and follow the ones contained in aSet."	(aSet includes: self)		ifTrue: [ ^ self ].	aSet add: self.	aBlock value: self.	self children		do: [ :each | each allParsersDo: aBlock seen: aSet ]! !!PPParser methodsFor: 'operators' stamp: 'lr 5/31/2010 15:12'!and	"Answer a new parser (logical and-predicate) that succeeds whenever the receiver does, but never consumes input."	^ PPAndParser on: self! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 2/19/2010 07:42'!answer: anObject	"Answer a new parser that always returns anObject from a successful parse."	^ self ==> [ :nodes | anObject ]! !!PPParser methodsFor: 'converting' stamp: 'lr 11/29/2011 20:48'!asParser	"Answer the receiving parser."		^ self! !!PPParser methodsFor: 'accessing' stamp: 'lr 10/21/2009 16:38'!children	"Answer a set of child parsers that could follow the receiver."	^ #()! !!PPParser methodsFor: 'operators' stamp: 'lr 12/3/2010 11:34'!def: aParser	"Redefine the receiver as the argument aParser. This method is useful when defining recursive parsers: instantiate a PPUnresolvedParser and later redefine it with another one."	^ self becomeForward: (aParser name: self name)! !!PPParser methodsFor: 'operators-convenience' stamp: 'lr 2/19/2010 07:42'!delimitedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated and possibly ended by aParser."		^ (self separatedBy: aParser) , (aParser optional) ==> [ :node |		node second isNil			ifTrue: [ node first ]			ifFalse: [ node first copyWith: node second ] ]! !!PPParser methodsFor: 'operators' stamp: 'lr 4/30/2010 12:13'!end	"Answer a new parser that succeeds at the end of the input and return the result of the receiver."	^ PPEndOfInputParser on: self! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 5/15/2008 16:08'!flatten	"Answer a new parser that flattens the underlying collection."		^ PPFlattenParser on: self! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 4/3/2011 15:00'!foldLeft: aBlock	"Answer a new parser that that folds the result of the receiver from left-to-right into aBlock. The argument aBlock must take two or more arguments."		| size args |	size := aBlock numArgs.	args := Array new: size.	^ self ==> [ :nodes |		args at: 1 put: nodes first.		2 to: nodes size by: size - 1 do: [ :index |			args				replaceFrom: 2 to: size with: nodes startingAt: index;				at: 1 put: (aBlock valueWithArguments: args) ].		args first ]! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 4/3/2011 14:59'!foldRight: aBlock	"Answer a new parser that that folds the result of the receiver from right-to-left into aBlock. The argument aBlock must take two or more arguments."	| size args |	size := aBlock numArgs.	args := Array new: size.	^ self ==> [ :nodes |		args at: size put: nodes last.		nodes size - size + 1 to: 1 by: 1 - size do: [ :index |			args				replaceFrom: 1 to: size - 1 with: nodes startingAt: index;				at: size put: (aBlock valueWithArguments: args) ].		args at: size ]! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:32'!hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ]! !!PPParser methodsFor: 'operators' stamp: 'JanKurs 1/25/2015 16:23'!if: aBlock	^ PPConditionalParser on: self block: aBlock! !!PPParser methodsFor: 'initialization' stamp: 'lr 4/24/2008 10:33'!initialize! !!PPParser methodsFor: 'testing' stamp: 'lr 8/6/2010 16:44'!isPetitParser	^ true! !!PPParser methodsFor: 'testing' stamp: 'lr 10/27/2008 11:28'!isUnresolved	^ false! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 5/6/2011 20:28'!map: aBlock	"Answer a new parser that works on the receiving sequence an passes in each element as a block argument."		^ aBlock numArgs = 1		ifTrue: [ self ==> aBlock ]		ifFalse: [ self error: aBlock numArgs asString , ' arguments expected.' ]! !!PPParser methodsFor: 'parsing' stamp: 'lr 2/8/2010 00:30'!matches: anObject	"Answer if anObject can be parsed by the receiver."		^ (self parse: anObject) isPetitFailure not! !!PPParser methodsFor: 'parsing' stamp: 'lr 6/4/2011 18:12'!matchesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answered an OrderedCollection of the matched parse-trees."	| result |	result := OrderedCollection new.	self 		matchesIn: anObject		do: [ :each | result addLast: each ].	^ result! !!PPParser methodsFor: 'parsing' stamp: 'lr 3/1/2010 21:51'!matchesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock for each match with the matched parse-tree as the argument. Make sure to always consume exactly one character with each step, to not miss any match."	((self and ==> aBlock , #any asParser) / #any asParser) star parse: anObject! !!PPParser methodsFor: 'parsing' stamp: 'lr 8/16/2011 07:26'!matchesSkipIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answer an OrderedCollection of the matched parse-trees. Skip over matches."	| result |	result := OrderedCollection new.	self 		matchesSkipIn: anObject		do: [ :each | result addLast: each ].	^ result! !!PPParser methodsFor: 'parsing' stamp: 'lr 8/16/2011 07:26'!matchesSkipIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock for each match with the matched parse-tree as the argument. Skip over matches."	(self ==> aBlock / #any asParser) star parse: anObject! !!PPParser methodsFor: 'parsing' stamp: 'lr 6/4/2011 18:12'!matchingRangesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answer an OrderedCollection of ranges of each match (index of first character to: index of last character)."		| result |	result := OrderedCollection new.	self		matchingRangesIn: anObject		do: [ :value | result addLast: value ].	^ result! !!PPParser methodsFor: 'parsing' stamp: 'lr 2/25/2013 23:41'!matchingRangesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock with the range of each match (index of first character to: index of last character)."	self token		matchesIn: anObject		do: [ :token | aBlock value: (token start to: token stop) ]! !!PPParser methodsFor: 'parsing' stamp: 'DamienCassou 10/29/2011 19:18'!matchingSkipRangesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Skip over matches. Answer an OrderedCollection of ranges of each match (index of first character to: index of last character)."		| result |	result := OrderedCollection new.	self		matchingSkipRangesIn: anObject		do: [ :value | result addLast: value ].	^ result! !!PPParser methodsFor: 'parsing' stamp: 'lr 2/25/2013 23:42'!matchingSkipRangesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Skip over matches. Evaluate aBlock with the range of each match (index of first character to: index of last character)."		self token		matchesSkipIn: anObject		do: [ :token | aBlock value: (token start to: token stop) ]! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:03'!max: anInteger	"Answer a new parser that parses the receiver at most anInteger times."		^ self star setMax: anInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:56'!max: anInteger greedy: aParser	"Answer a new parser that parses the receiver at most anInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMax: anInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:57'!max: anInteger lazy: aParser	"Answer a new parser that parses the receiver at most anInteger times until it reaches aParser. This is a lazy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMax: anInteger! !!PPParser methodsFor: 'operators' stamp: 'lr 5/31/2010 16:34'!memoized	"Answer a new memoized parser, for refraining redundant computations. This ensures polynomial time O(n^4) for left-recursive grammars and O(n^3) for non left-recursive grammars in the worst case. Not necessary for most grammars that are carefully written and in O(n) anyway."		^ PPMemoizedParser on: self! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:02'!min: anInteger	"Answer a new parser that parses the receiver at least anInteger times."		^ self star setMin: anInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:56'!min: anInteger greedy: aParser	"Answer a new parser that parses the receiver at least anInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMin: anInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:57'!min: anInteger lazy: aParser	"Answer a new parser that parses the receiver at least anInteger times until it reaches aParser. This is a lazy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMin: anInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:03'!min: aMinInteger max: aMaxInteger	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times."		^ self star setMin: aMinInteger; setMax: aMaxInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:56'!min: aMinInteger max: aMaxInteger greedy: aParser	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMin: aMinInteger; setMax: aMaxInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:57'!min: aMinInteger max: aMaxInteger lazy: aParser	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMin: aMinInteger; setMax: aMaxInteger! !!PPParser methodsFor: 'accessing' stamp: 'lr 4/19/2010 10:35'!name	"Answer the production name of the receiver."		^ self propertyAt: #name ifAbsent: [ nil ]! !!PPParser methodsFor: 'accessing' stamp: 'lr 4/19/2010 10:38'!name: aString	self propertyAt: #name put: aString! !!PPParser methodsFor: 'operators' stamp: 'lr 2/19/2010 07:36'!negate	"Answer a new parser consumes any input token but the receiver."		^ self not , #any asParser ==> #second! !!PPParser methodsFor: 'operators' stamp: 'lr 5/31/2010 15:12'!not	"Answer a new parser (logical not-predicate) that succeeds whenever the receiver fails, but never consumes input."	^ PPNotParser on: self! !!PPParser methodsFor: 'operators' stamp: 'lr 9/1/2010 22:03'!optional	"Answer a new parser that parses the receiver, if possible."	^ PPOptionalParser on: self! !!PPParser methodsFor: 'parsing' stamp: 'JanKurs 9/9/2014 15:04'!parse: anObject	"Parse anObject with the receiving parser and answer the parse-result or an instance of PPFailure."	^ self parse: anObject withContext: PPContext new! !!PPParser methodsFor: 'parsing' stamp: 'lr 10/29/2010 17:05'!parse: anObject onError: aBlock	"Parse anObject with the receiving parser and answer the parse-result or answer the result of evaluating aBlock. Depending on the number of arguments of the block it is simply evaluated, evaluated with the failure object, or evaluated with the error message and position."		| result |	result := self parse: anObject.	result isPetitFailure		ifFalse: [ ^ result ].	aBlock numArgs = 0		ifTrue: [ ^ aBlock value ].	aBlock numArgs = 1		ifTrue: [ ^ aBlock value: result ].	^ aBlock value: result message value: result position! !!PPParser methodsFor: 'context' stamp: 'JanKurs 8/19/2014 13:26'!parse: anObject withContext: aPPContext	"Parse anObject with the receiving parser and answer the parse-result or an instance of PPFailure."	aPPContext stream: anObject asPetitStream.	^ self parseWithContext: aPPContext.! !!PPParser methodsFor: 'parsing' stamp: 'JanKurs 11/11/2013 09:30'!parseOn: aPPContext	"Parse aStream with the receiving parser and answer the parse-result or an instance of PPFailure. Override this method in subclasses to specify custom parse behavior. Do not call this method from outside, instead use #parse:."		self subclassResponsibility! !!PPParser methodsFor: 'context' stamp: 'JanKurs 2/20/2015 08:47'!parseWithContext: context	| result |	context initializeFor: self.	result := self parseOn: context.		"Return the furthest failure, it gives better results than the last failure"	(result isPetitFailure and: [ context furthestFailure notNil]) 		ifTrue: [ ^ context furthestFailure ].	^ result	! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:03'!plus	"Answer a new parser that parses the receiver one or more times."	^ self star setMin: 1! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:04'!plusGreedy: aParser	"Answer a new parser that parses the receiver one or more times until it reaches aParser. This is a greedy non-blind implementation of the star operator. aParser is not consumed."		^ (self starGreedy: aParser) setMin: 1! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:04'!plusLazy: aParser	"Answer a new parser that parses the receiver one or more times until it reaches aParser. This is a lazy non-blind implementation of the star operator. aParser is not consumed."		^ (self starLazy: aParser) setMin: 1! !!PPParser methodsFor: 'copying' stamp: 'lr 4/19/2010 10:33'!postCopy	super postCopy.	properties := properties copy! !!PPParser methodsFor: 'printing' stamp: 'lr 4/16/2010 16:36'!printNameOn: aStream	self name isNil		ifTrue: [ aStream print: self hash ]		ifFalse: [ aStream nextPutAll: self name ]! !!PPParser methodsFor: 'printing' stamp: 'lr 4/16/2010 16:36'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printNameOn: aStream.	aStream nextPut: $)! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:32'!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:32'!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ properties at: aKey ifAbsent: aBlock ]! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:32'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:33'!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (properties ifNil: [ properties := Dictionary new: 1 ])		at: aKey put: anObject! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:33'!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:33'!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer! !!PPParser methodsFor: 'operators-convenience' stamp: 'lr 2/19/2010 07:56'!separatedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated by aParser."		^ (PPSequenceParser with: self with: (PPSequenceParser with: aParser with: self) star) ==> [ :nodes |		| result |		result := Array new: 2 * nodes second size + 1.		result at: 1 put: nodes first.		nodes second 			keysAndValuesDo: [ :index :pair | result replaceFrom: 2 * index to: 2 * index + 1 with: pair startingAt: 1 ].		result ]! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/2/2011 10:02'!star	"Answer a new parser that parses the receiver zero or more times. This is a greedy and blind implementation that tries to consume as much input as possible and it does not consider what comes afterwards."	^ PPPossessiveRepeatingParser on: self! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/2/2011 10:01'!starGreedy: aParser	"Answer a new parser that parses the receiver zero or more times until it reaches aParser. This is a greedy non-blind implementation of the star operator. aParser is not consumed."		^ PPGreedyRepeatingParser on: self limit: aParser! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/2/2011 10:01'!starLazy: aParser	"Answer a new parser that parses the receiver zero or more times until it reaches aParser. This is a lazy non-blind implementation of the star operator. aParser is not consumed."		^ PPLazyRepeatingParser on: self limit: aParser! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 9/15/2010 09:34'!times: anInteger	"Answer a new parser that parses the receiver exactly anInteger times."		^ self min: anInteger max: anInteger! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 6/29/2010 14:25'!token	"Answer a new parser that transforms the input to a token."		^ PPTokenParser on: self! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 4/6/2010 19:26'!token: aTokenClass	"Answer a new parser that transforms the input to a token of class aTokenClass."		^ self token tokenClass: aTokenClass! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 7/31/2010 12:06'!trim	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trimSpaces! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 7/11/2011 11:03'!trim: aParser	"Answer a new parser that consumes and ignores aParser repeatedly before and after the receiving parser."		^ PPTrimmingParser on: self trimmer: aParser! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 7/11/2011 11:03'!trimBlanks	"Answer a new parser that consumes blanks before and after the receiving parser."		^ self trim: #blank asParser! !!PPParser methodsFor: 'operators-mapping' stamp: 'JanKurs 3/31/2015 17:50'!trimLeft	"Answer a new parser that consumes spaces before the receiving parser."		^ self trimSpacesLeft! !!PPParser methodsFor: 'operators-mapping' stamp: 'JanKurs 3/31/2015 17:31'!trimRight	"Answer a new parser that consumes spaces after the receiving parser."		^ self trimSpacesRight! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 7/11/2011 11:03'!trimSpaces	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trim: #space asParser! !!PPParser methodsFor: 'operators-mapping' stamp: 'JanKurs 3/31/2015 17:50'!trimSpacesLeft	"Answer a new parser that consumes spaces before the receiving parser."		^ (#space asParser star, self) ==> #second! !!PPParser methodsFor: 'operators-mapping' stamp: 'JanKurs 3/31/2015 17:31'!trimSpacesRight	"Answer a new parser that consumes spaces after the receiving parser."		^ (self, #space asParser star) ==> #first! !!PPParser methodsFor: 'operators-convenience' stamp: 'lr 2/25/2012 16:54'!withoutSeparators	"Filters out the separators from a parse result produced by one of the productions #delimitedBy: or #separatedBy:."		^ self ==> [ :items |		| result |		result := Array new: items size + 1 // 2.		1 to: result size do: [ :index | result at: index put: (items at: 2 * index - 1) ].		result ]! !!PPParser methodsFor: 'operators' stamp: 'lr 10/23/2008 14:05'!wrapped	"Answer a new parser that is simply wrapped."		^ PPDelegateParser on: self! !!PPParser methodsFor: 'operators' stamp: 'lr 4/14/2010 11:53'!| aParser	"Answer a new parser that either parses the receiver or aParser. Fail if both pass or fail (exclusive choice, unordered choice)."	^ (self not , aParser) / (aParser not , self) ==> #second! !!PPPluggableParser class methodsFor: 'instance creation' stamp: 'lr 5/2/2010 16:52'!on: aBlock	^ self new initializeOn: aBlock! !!PPPluggableParser methodsFor: 'parsing' stamp: 'JanKurs 11/12/2014 11:48'!acceptsEpsilon	^ false! !!PPPluggableParser methodsFor: 'accessing' stamp: 'lr 4/30/2010 11:10'!block	"Answer the pluggable block."	^ block! !!PPPluggableParser methodsFor: 'initialization' stamp: 'lr 5/2/2010 16:52'!initializeOn: aBlock	block := aBlock! !!PPPluggableParser methodsFor: 'parsing' stamp: 'JanKurs 8/24/2014 14:48'!parseOn: aPPContext	| memento result |	memento := aPPContext remember.	result := block value: aPPContext.	result isPetitFailure		ifTrue: [ aPPContext restore: memento ].	^ result! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'JamesFoster 3/17/2015 15:50'!any	^self		cacheAt: #'any'		ifAbsentPut: [ self			on: [ :each | true ] message: 'input expected'			negated: [ :each | false ] message: 'no input expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 4/1/2011 20:05'!anyExceptAnyOf: aCollection	^ self		on: [ :each | (aCollection includes: each) not ] message: 'any except ' , aCollection printString , ' expected'		negated: [ :each | aCollection includes: each ] message: aCollection printString ,  ' not expected'! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 4/1/2011 20:05'!anyOf: aCollection	^ self		on: [ :each | aCollection includes: each ] message: 'any of ' , aCollection printString , ' expected'		negated: [ :each | (aCollection includes: each) not ] message: 'none of ' , aCollection printString ,  'expected'! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 6/12/2010 09:10'!between: min and: max	^ self		on: [ :each | each >= min and: [ each <= max ] ] message: min printString , '..' , max printString , ' expected'		negated: [ :each | each < min or: [ each > max ] ] message: min printString , '..' , max printString , ' not expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'JamesFoster 3/17/2015 15:51'!blank	^self		cacheAt: #'blank'		ifAbsentPut: [ self			chars: (String with: Character space with: Character tab) message: 'blank expected' ]! !!PPPredicateObjectParser class methodsFor: 'cache' stamp: 'JamesFoster 3/17/2015 16:15'!cacheAt: aSymbol ifAbsentPut: aBlock	cache ifNil: [ ^aBlock value ].	^(cache		at: aSymbol		ifAbsentPut: aBlock) copy! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:02'!char: aCharacter	^ self expect: aCharacter message: (String with: $" with: aCharacter with: $") , ' expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 10:57'!char: aCharacter message: aString	^ self expect: aCharacter message: aString! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:06'!chars: aCollection message: aString	^ self on: (PPCharSetPredicate on: [ :char | aCollection includes: char ]) message: aString! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'JamesFoster 3/17/2015 15:51'!cr	^self		cacheAt: #'cr'		ifAbsentPut: [ self char: (Character codePoint: 13) message: 'carriage return expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'JamesFoster 3/17/2015 15:52'!digit	^self		cacheAt: #'digit'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isDigit ]) message: 'digit expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'JanKurs 10/29/2014 15:52'!endOfLine		^ PPEndOfLineParser new.! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'JanKurs 2/4/2015 17:53'!eof		^ PPEndOfFileParser new! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 8/25/2010 10:57'!expect: anObject	^ self expect: anObject message: anObject printString , ' expected'! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 8/25/2010 10:57'!expect: anObject message: aString	^ self 		on: [ :each | each = anObject ] message: aString		negated: [ :each | each ~= anObject ] message: 'no ' , aString! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'JamesFoster 3/17/2015 15:52'!hex	^self		cacheAt: #'hex'		ifAbsentPut: [ self		on: (PPCharSetPredicate on: [ :char | 			(char between: $0 and: $9) 				or: [ (char between: $a and: $f) 				or: [ (char between: $A and: $F) ] ] ])		message: 'hex digit expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'JamesFoster 3/17/2015 15:52'!letter	^self		cacheAt: #'letter'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isLetter ]) message: 'letter expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'JamesFoster 3/17/2015 15:52'!lf	^self		cacheAt: #'lf'		ifAbsentPut: [ self char: (Character codePoint: 10) ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'JamesFoster 3/17/2015 15:52'!lowercase	^self		cacheAt: #'lowercase'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isLowercase ]) message: 'lowercase letter expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'JamesFoster 3/17/2015 15:53'!newline	^self		cacheAt: #'newline'		ifAbsentPut: [ self chars: (String with: (Character codePoint: 13) with: (Character codePoint: 10)) message: 'newline expected' ]! !!PPPredicateObjectParser class methodsFor: 'instance creation' stamp: 'lr 6/12/2010 09:10'!on: aBlock message: aString	^ self on: aBlock message: aString negated: [ :each | (aBlock value: each) not ] message: 'no ' , aString! !!PPPredicateObjectParser class methodsFor: 'instance creation' stamp: 'lr 6/12/2010 09:10'!on: aBlock message: aString negated: aNegatedBlock message: aNegatedString	^ self new initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'JamesFoster 3/17/2015 15:53'!punctuation	^self		cacheAt: #'punctuation'		ifAbsentPut: [ self chars: '.,"''?!!;:#$%&()*+-/<>=@[]\^_{}|~' message: 'punctuation expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'JamesFoster 3/17/2015 15:53'!space	^self		cacheAt: #'space'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isSeparator ]) message: 'separator expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'JanKurs 10/29/2014 15:48'!startOfLine		^ PPStartOfLineParser new.! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'JanKurs 1/2/2015 18:35'!startOfLogicalLine		^ PPStartOfLogicalLineParser new.! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'JanKurs 12/12/2014 16:42'!startOfWord		^ PPStartOfWordParser new.! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'JamesFoster 3/17/2015 15:53'!tab	^self		cacheAt: #'tab'		ifAbsentPut: [ self char: Character tab message: 'tab expected' ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'JamesFoster 3/17/2015 15:54'!uppercase	^self		cacheAt: #'uppercase'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isUppercase ]) message: 'uppercase letter expected' ]! !!PPPredicateObjectParser class methodsFor: 'cache' stamp: 'JamesFoster 3/17/2015 16:15'!useCache: aBoolean"	PPPredicateObjectParser useCache: true.	PPPredicateObjectParser useCache: false."	cache := aBoolean 		ifTrue: [ Dictionary new ]		ifFalse: [ nil ]! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'JamesFoster 3/17/2015 15:54'!word	^self		cacheAt: #'word'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isAlphaNumeric ]) message: 'letter or digit expected' ]! !!PPPredicateObjectParser methodsFor: 'initialization' stamp: 'lr 6/12/2010 09:12'!initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString	predicate := aBlock.	predicateMessage := aString.	negated := aNegatedBlock.	negatedMessage := aNegatedString! !!PPPredicateObjectParser methodsFor: 'operators' stamp: 'lr 6/12/2010 09:12'!negate	"Answer a parser that is the negation of the receiving predicate parser."		^ self class 		on: negated message: negatedMessage 		negated: predicate message: predicateMessage! !!PPPredicateObjectParser methodsFor: 'parsing' stamp: 'JanKurs 8/24/2014 14:48'!parseOn: aPPContext	^ (aPPContext atEnd not and: [ predicate value: aPPContext uncheckedPeek ])		ifFalse: [ PPFailure message: predicateMessage context: aPPContext ]		ifTrue: [ aPPContext next ]! !!PPPredicateParser methodsFor: 'accessing' stamp: 'lr 5/2/2010 13:36'!block	"Answer the predicate block of the receiver."		^ predicate! !!PPPredicateParser methodsFor: 'accessing' stamp: 'lr 5/2/2010 13:36'!message	"Answer the failure message."		^ predicateMessage! !!PPPredicateParser methodsFor: 'printing' stamp: 'lr 5/2/2010 13:37'!printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: predicateMessage! !!PPPredicateSequenceParser class methodsFor: 'instance creation' stamp: 'lr 6/12/2010 09:14'!on: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger 	^ self new initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger! !!PPPredicateSequenceParser class methodsFor: 'instance creation' stamp: 'lr 6/12/2010 09:14'!on: aBlock message: aString size: anInteger	^ self on: aBlock message: aString negated: [ :each | (aBlock value: each) not ] message: 'no ' , aString size: anInteger ! !!PPPredicateSequenceParser methodsFor: 'initialization' stamp: 'lr 6/12/2010 09:13'!initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger	predicate := aBlock.	predicateMessage := aString.	negated := aNegatedBlock.	negatedMessage := aNegatedString.	size := anInteger ! !!PPPredicateSequenceParser methodsFor: 'operators' stamp: 'lr 6/12/2010 09:14'!negate	"Answer a parser that is the negation of the receiving predicate parser."		^ self class 		on: negated message: negatedMessage		negated: predicate message: predicateMessage		size: size! !!PPPredicateSequenceParser methodsFor: 'parsing' stamp: 'JanKurs 8/24/2014 14:49'!parseOn: aPPContext	| memento result |	memento := aPPContext remember.	result := aPPContext stream next: size.	(result size = size and: [ predicate value: result ])		ifTrue: [ ^ result ].	aPPContext restore: memento.	^ PPFailure message: predicateMessage context: aPPContext! !!PPPredicateSequenceParser methodsFor: 'accessing' stamp: 'lr 6/12/2010 08:58'!size	"Answer the sequence size of the receiver."	^ size! !!PPStartOfLineParser methodsFor: 'parsing' stamp: 'JanKurs 8/28/2014 10:19'!parseOn: aPPContext	(aPPContext isStartOfLine) ifTrue: [ 		^ #startOfLine	].	^ PPFailure message: 'Start of line expected' context: aPPContext at: aPPContext position! !!PPStartOfLogicalLineParser methodsFor: 'as yet unclassified' stamp: 'JanKurs 1/2/2015 18:32'!isBlank: character	^ (character == Character space or: [character == Character tab])! !!PPStartOfLogicalLineParser methodsFor: 'as yet unclassified' stamp: 'JanKurs 1/2/2015 18:32'!parseOn: aPPContext	aPPContext peek isAlphaNumeric ifFalse: [ 		^ PPFailure message: 'Start of logical line expected' context: aPPContext 	].	aPPContext isStartOfLine ifTrue: [ ^ #startOfLogicalLine ].			[ aPPContext position ~= 0 ] whileTrue: [  		aPPContext back.		(self isBlank: aPPContext peek) ifFalse: [ 			^ PPFailure message: 'Start of logical line expected' context: aPPContext		].		aPPContext isStartOfLine ifTrue: [ ^ #startOfLogicalLine ].	]! !!PPStartOfWordParser methodsFor: 'as yet unclassified' stamp: 'JanKurs 12/12/2014 16:36'!acceptsEpsilon	^ true! !!PPStartOfWordParser methodsFor: 'as yet unclassified' stamp: 'JanKurs 1/2/2015 16:31'!parseOn: aPPContext	aPPContext atEnd ifTrue: [  		^ PPFailure message: 'Start of word expected' context: aPPContext at: aPPContext position 	].	(aPPContext position == 0) ifTrue: [ 		(aPPContext peek isAlphaNumeric) ifTrue: [ 			^ #startOfWord		] ifFalse: [ 			^ PPFailure message: 'Start of word expected' context: aPPContext at: aPPContext position 	 	]	].	aPPContext back.	aPPContext peek isAlphaNumeric ifTrue: [		^ PPFailure message: 'Start of word expected' context: aPPContext at: aPPContext position 	].	aPPContext next.		^ aPPContext peek isAlphaNumeric ifTrue: [ #startOfWord ] ifFalse: [ 		PPFailure message: 'Start of word expected' context: aPPContext at: aPPContext position 	]	! !!PPUnresolvedParser methodsFor: 'testing' stamp: 'lr 10/27/2008 11:29'!isUnresolved	^ true! !!PPUnresolvedParser methodsFor: 'parsing' stamp: 'lr 2/7/2010 20:51'!parseOn: aStream	self error: self printString , ' need to be resolved before execution.'! !!PPToken class methodsFor: 'initialization' stamp: 'JanKurs 10/15/2014 15:54'!initialize	"Platform independent newline sequence. LF: Unix, CR+LF: Windows, and CR: Apple."	| cr lf |	cr := Character codePoint: 13.	lf := Character codePoint: 10.	NewLineParser := lf asParser / (cr asParser , lf asParser optional)! !!PPToken class methodsFor: 'instance creation' stamp: 'lr 4/6/2010 20:58'!new	self error: 'Token can only be created using a dedicated constructor.'! !!PPToken class methodsFor: 'instance creation' stamp: 'lr 2/25/2013 23:36'!on: aSequenceableCollection	^ self on: aSequenceableCollection start: 1 stop: aSequenceableCollection size value: nil! !!PPToken class methodsFor: 'instance creation' stamp: 'lr 2/25/2013 23:39'!on: aSequenceableCollection start: aStartInteger stop: aStopInteger value: anObject	^ self basicNew 		initializeOn: aSequenceableCollection		start: aStartInteger stop: aStopInteger		value: anObject! !!PPToken methodsFor: 'comparing' stamp: 'JanKurs 5/1/2015 17:35'!= anObject	^ self class = anObject class and: [ self inputValue = anObject inputValue ]! !!PPToken methodsFor: 'accessing' stamp: 'lr 6/15/2010 23:34'!collection	"Answer the underlying collection of this token."	^ collection! !!PPToken methodsFor: 'querying' stamp: 'lr 9/7/2011 20:40'!column	"Answer the column number of this token in the underlying collection."		| position |	position := 0.	(NewLineParser , [ :stream |		start <= stream position			ifTrue: [ ^ start - position ].		position := stream position ] asParser		/ #any asParser) star			parse: collection.	 ^ start - position! !!PPToken methodsFor: 'copying' stamp: 'lr 2/26/2013 00:34'!copyFrom: aStartInteger to: aStopInteger	^ self class on: collection start: start + aStartInteger - 1 stop: stop + aStopInteger - 3 value: value! !!PPToken methodsFor: 'comparing' stamp: 'JanKurs 5/1/2015 17:36'!hash	^ self inputValue hash! !!PPToken methodsFor: 'initialization' stamp: 'lr 2/25/2013 23:36'!initializeOn: aSequenceableCollection start: aStartInteger stop: aStopInteger value: anObject	collection := aSequenceableCollection.	start := aStartInteger.	stop := aStopInteger.	value := anObject! !!PPToken methodsFor: 'accessing-values' stamp: 'lr 2/26/2013 00:32'!inputValue	"Answer the consumed input of this token."	^ collection copyFrom: start to: stop! !!PPToken methodsFor: 'querying' stamp: 'lr 9/7/2011 20:41'!line	"Answer the line number of this token in the underlying collection."		| line |	line := 1.	(NewLineParser , [ :stream |		start <= stream position			ifTrue: [ ^ line ].		line := line + 1 ] asParser		/ #any asParser) star			parse: collection.	^ line! !!PPToken methodsFor: 'accessing-values' stamp: 'lr 2/26/2013 00:32'!parsedValue	"Answer the parsed value of this token."	^ value! !!PPToken methodsFor: 'printing' stamp: 'JanKurs 5/1/2015 17:35'!printOn: aStream	super printOn: aStream.	aStream nextPut: $[; print: self start; nextPut: $,; print: self stop; nextPut: $].	aStream nextPut: $(; print: self inputValue; nextPut: $)! !!PPToken methodsFor: 'accessing' stamp: 'lr 2/25/2013 23:56'!size	"Answer the size of this token in the underlying collection."	^ stop - start + 1! !!PPToken methodsFor: 'accessing' stamp: 'lr 6/15/2010 23:33'!start	"Answer the start position of this token in the underlying collection."	^ start! !!PPToken methodsFor: 'accessing' stamp: 'lr 6/15/2010 23:33'!stop	"Answer the stop position of this token in the underlying collection."		^ stop! !!PPToken methodsFor: 'accessing-values' stamp: 'JanKurs 5/1/2015 17:37'!value	self notify: 'Token>>#value is no longer supported. Instead use Token>>#inputValue'.	^ self inputValue! !!Symbol methodsFor: '*petitparser-core-converting' stamp: 'lr 12/18/2011 15:58'!asParser	"Answer a predicate parser named after the receiving symbol. Possible symbols are the method selectors on the class-side of PPPredicateObjectParser."	^ PPPredicateObjectParser perform: self! !!UndefinedObject methodsFor: '*petitparser-converting' stamp: 'lr 11/29/2011 20:49'!asParser	"Answer a parser that succeeds and does not consume anything."		^ PPEpsilonParser new! !!PPParserResource methodsFor: 'accessing' stamp: 'lr 9/15/2010 12:12'!parserAt: aParserClass	"Answer a cached instance of aParserClass."		^ parsers at: aParserClass name ifAbsentPut: [ aParserClass new ]! !!PPParserResource methodsFor: 'running' stamp: 'lr 3/29/2010 15:20'!setUp	super setUp.	parsers := Dictionary new! !!String methodsFor: '*petitparser-core-converting' stamp: 'lr 11/29/2011 20:48'!asParser	"Answer a parser that accepts the receiving string."	^ PPLiteralSequenceParser on: self! !!SequenceableCollection methodsFor: '*petitparser-core-converting' stamp: 'lr 2/7/2010 20:53'!asPetitStream	^ PPStream on: self! !!PPStream methodsFor: 'converting' stamp: 'lr 2/7/2010 20:53'!asPetitStream	^ self! !!PPStream methodsFor: 'accessing' stamp: 'lr 2/13/2012 20:25'!collection	"Answer the underlying collection."		^ collection! !!PPStream methodsFor: 'positioning' stamp: 'JanKurs 11/12/2014 15:48'!column	^ self column: position.! !!PPStream methodsFor: 'positioning' stamp: 'JanKurs 1/9/2015 11:17'!column: pos	| nl |	(pos = -1) ifTrue: [  ^ 0 ].	(pos > readLimit) ifTrue: [ ^ self error: 'Out of limit' ].		nl := self newlines.	nl keysAndValuesDo: [ :index :value |		(value > pos) ifTrue: [ ^ pos - (nl at: (index - 1)) + 1]	].		^ pos - (nl at: (nl size )) + 1! !!PPStream methodsFor: 'positioning' stamp: 'JanKurs 1/9/2015 09:55'!fillNewlines	| tmp line |	newlines := OrderedCollection new.			tmp := position.	line := 0.		(0 to: readLimit) do: [:index |		position := index.		self isStartOfLine ifTrue: [ newlines add: position ]	].	position := tmp.	newlines := newlines asArray.	^ newlines! !!PPStream methodsFor: 'queries' stamp: 'JanKurs 10/15/2014 15:26'!insideCRLF	(position < 1) ifTrue: [ ^ false ].		^ (self peek = (Character codePoint: 10)) and: [ self peekBack = (Character codePoint: 13) ]! !!PPStream methodsFor: 'queries' stamp: 'JanKurs 10/29/2014 15:50'!isEndOfLine	self atEnd ifTrue: [ ^ true ].	self insideCRLF ifTrue: [ ^ false ].	^ (self peek = (Character codePoint: 13) or: [ self peek = (Character codePoint: 10)]).! !!PPStream methodsFor: 'queries' stamp: 'JanKurs 10/15/2014 15:27'!isStartOfLine	(position = 0) ifTrue: [ ^ true ].	self insideCRLF ifTrue: [ ^ false ].		^ (self peekBack = (Character codePoint: 13)) or: [ self peekBack = (Character codePoint: 10)].! !!PPStream methodsFor: 'positioning' stamp: 'JanKurs 11/12/2014 15:48'!line	^ self line: position! !!PPStream methodsFor: 'positioning' stamp: 'JanKurs 1/9/2015 10:00'!line: pos	| nl |	(pos = -1) ifTrue: [  ^ 0 ].	(pos > readLimit) ifTrue: [ ^ self error: 'Out of limit' ].		nl := self newlines.	nl keysAndValuesDo: [ :index :value |		(value > pos) ifTrue: [ ^ (index - 1)]	].		^ nl size! !!PPStream methodsFor: 'positioning' stamp: 'JanKurs 1/9/2015 09:47'!newlines	^ newlines ifNil: [ 		newlines := self fillNewlines.	]! !!PPStream methodsFor: 'accessing' stamp: 'JanKurs 10/15/2014 15:27'!next: anInteger 	"Answer up to anInteger elements of my collection. Overridden for efficiency."	| answer endPosition |	endPosition := position + anInteger min: readLimit.	answer := collection copyFrom: position + 1 to: endPosition.	position := endPosition.	^ answer! !!PPStream methodsFor: 'accessing' stamp: 'lr 4/29/2008 21:48'!peek	"An improved version of peek, that is slightly faster than the built in version."	^ self atEnd ifFalse: [ collection at: position + 1 ]! !!PPStream methodsFor: 'accessing' stamp: 'lr 8/25/2010 11:36'!position: anInteger	"The receiver does not check for invalid arguments passed to this method, as it is solely used with valid indexes for backtracking."	position := anInteger! !!PPStream methodsFor: 'printing' stamp: 'lr 11/4/2010 19:23'!printOn: aStream	collection isString		ifFalse: [ ^ super printOn: aStream ].	aStream		nextPutAll: (collection copyFrom: 1 to: position);		nextPutAll: '';		nextPutAll: (collection copyFrom: position + 1 to: readLimit)! !!PPStream methodsFor: 'accessing' stamp: 'JanKurs 10/15/2014 15:29'!size	"		The same implementation as a ReadStream. Implemented here for compatibility with Smalltalk/X		that has different implementation in a ReadStream	"	^readLimit! !!PPStream methodsFor: 'accessing' stamp: 'lr 10/5/2010 16:29'!uncheckedPeek	"An unchecked version of peek that throws an error if we try to peek over the end of the stream, even faster than #peek."	^ collection at: position + 1! !!Character methodsFor: '*petitparser-core-converting' stamp: 'lr 12/18/2011 15:58'!asParser	"Answer a parser that accepts the receiving character."		^ PPLiteralObjectParser on: self! !!Interval methodsFor: '*petitparser-core-converting' stamp: 'JanKurs 11/17/2014 11:36'!asParser    	"Create a range of characters between start and stop."    self assert:start isCharacter.    self assert:stop isCharacter.    self assert:step == 1.    ^ PPPredicateObjectParser between: start and: stop    "		($a to: $f) asParser parse: 'a'		($a to: $f) asParser parse: 'g'    "! !!PositionableStream methodsFor: '*petitparser-core-converting' stamp: 'JanKurs 11/4/2014 09:38'!asPetitStream	"Some of my subclasses do not use the instance-variables collection, position and readLimit but instead have a completely different internal representation. In these cases just use the super implementation that is inefficient but should work in all cases.""	Disabled until we agree on some way how to optimize this	^ (collection isNil or: [ position isNil or: [ readLimit isNil ] ])		ifFalse: [ PPStream on: collection from: ( position + 1 ) to: readLimit ]      ifTrue: [ super asPetitStream ]"	^ super asPetitStream! !!PositionableStream methodsFor: '*petitparser-core' stamp: 'sback 9/3/2010 10:00'!peekTwice	"Answer what would be returned if the message next were sent to the 	receiver. If the receiver is at the end, answer nil."	| array |	self atEnd 		ifTrue: [^Array with: nil with: nil].	array := Array with: (self next) with: (self peek).	position := position - 1.	^array! !!Text methodsFor: '*petitparser-core-converting' stamp: 'lr 2/7/2010 20:53'!asPetitStream	^ string asPetitStream! !!PPAbstractParserTest class methodsFor: 'testing' stamp: 'lr 1/12/2011 21:23'!isAbstract	^ self name = #PPAbstractParserTest! !!PPAbstractParserTest class methodsFor: 'accessing' stamp: 'lr 6/12/2010 08:22'!packageNamesUnderTest	^ #('PetitParser' 'PetitTests')! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'DamienPollet 8/11/2011 01:50'!assert: aParser fail: aCollection	^ self assert: aParser fail: aCollection end: 0! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'JanKurs 9/23/2014 18:08'!assert: aParser fail: aCollection end: anInteger	| stream result context |	self 		assert: aParser isPetitParser		description: 'Parser invalid'.	stream := aCollection asPetitStream.	context := self context.			result := aParser parse: stream withContext: context.	self 		assert: result isPetitFailure		description: 'Parser did not fail'.	self		assert: context position = anInteger		description: 'Parser failed at wrong position'.	^ result! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'JamesFoster 2/20/2015 11:37'!assert: string1 includesSubstring: string2	"Support portability by using ANSI search method"	self assert: (string1 notEmpty and: [string2 notEmpty and: [0 < (string1 indexOfSubCollection: string2 startingAt: 1)]])! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'DamienPollet 8/11/2011 01:49'!assert: aParser parse: aCollection	^ self assert: aParser parse: aCollection to: nil end: aCollection size ! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'DamienPollet 8/11/2011 01:49'!assert: aParser parse: aCollection end: anInteger	^ self assert: aParser parse: aCollection to: nil end: anInteger! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'DamienPollet 8/11/2011 01:49'!assert: aParser parse: aCollection to: anObject	^ self assert: aParser parse: aCollection to: anObject end: aCollection size ! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'JanKurs 9/17/2014 20:03'!assert: aParser parse: aCollection to: aTargetObject end: anInteger	| stream result context |	self assert: aParser isPetitParser description: 'Parser invalid'.	stream := aCollection asPetitStream.	context := self context.		result := aParser parse: stream withContext: context.	aTargetObject isNil		ifTrue: [ self deny: result isPetitFailure ]		ifFalse: [ self assert: result equals: aTargetObject ].	self assert: context position = anInteger description: 'Parser accepted at wrong position'.	^ result! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'lr 2/26/2013 00:43'!assert: aParser parse: aCollection toToken: aStartInteger stop: aStopInteger	^ self assert: aParser parse: aCollection toToken: aStartInteger stop: aStopInteger end: aCollection size! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'Nicolasanquetil 5/3/2013 15:13'!assert: aParser parse: aParserObject toToken: aStartInteger stop: aStopInteger end: anEndInteger	| token |	token := self		assert: aParser		parse: aParserObject		to: nil		end: anEndInteger.	self assert: (token isKindOf: PPToken).	self assert: token start equals: aStartInteger.	self assert: token stop equals: aStopInteger.	^ token! !!PPAbstractParserTest methodsFor: 'context' stamp: 'JanKurs 9/17/2014 20:03'!context	^ PPContext new! !!PPComposedTest methodsFor: 'accessing' stamp: 'lr 2/8/2010 16:44'!comment	^ ($" asParser , $" asParser negate star , $" asParser) flatten! !!PPComposedTest methodsFor: 'accessing' stamp: 'lr 2/8/2010 16:44'!identifier	^ (#letter asParser , #word asParser star) flatten! !!PPComposedTest methodsFor: 'accessing' stamp: 'lr 2/8/2010 16:44'!number	^ ($- asParser optional , #digit asParser plus , ($. asParser , #digit asParser plus) optional) flatten! !!PPComposedTest methodsFor: 'testing-examples' stamp: 'lr 2/8/2010 16:44'!testComment	self assert: self comment parse: '""' to: '""'.	self assert: self comment parse: '"a"' to: '"a"'.	self assert: self comment parse: '"ab"' to: '"ab"'.	self assert: self comment parse: '"abc"' to: '"abc"'.	self assert: self comment parse: '""a' to: '""' end: 2.	self assert: self comment parse: '"a"a' to: '"a"' end: 3.	self assert: self comment parse: '"ab"a' to: '"ab"' end: 4.	self assert: self comment parse: '"abc"a' to: '"abc"' end: 5.	self assert: self comment fail: '"'.	self assert: self comment fail: '"a'.	self assert: self comment fail: '"aa'.	self assert: self comment fail: 'a"'.	self assert: self comment fail: 'aa"'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 7/6/2009 08:34'!testDoubledString	| parser |	parser := ($' asParser , (($' asParser , $' asParser) / $' asParser negate) star flatten , $' asParser) 		==> [ :nodes | nodes second copyReplaceAll: '''''' with: '''' ].	self assert: parser parse: '''''' to: ''.	self assert: parser parse: '''a''' to: 'a'.	self assert: parser parse: '''ab''' to: 'ab'.	self assert: parser parse: '''a''''b''' to: 'a''b'.	self assert: parser parse: '''a''''''''b''' to: 'a''''b'! !!PPComposedTest methodsFor: 'testing' stamp: 'JanKurs 8/19/2014 17:21'!testEvenNumber	"Create a grammar that parses an even number of a's and b's."		| a as b bs s |	a := $a asParser ==> [ :char | as := as + 1 ].	b := $b asParser ==> [ :char | bs := bs + 1 ].	s := (a / b) star >=> [ :stream :cc |		as := bs := 0.		cc value.		(as even and: [ bs even ])			ifFalse: [ PPFailure message: 'Even number of a and b expected' context: stream at: 0 ] ].	self assert: s fail: 'a' end: 1.	self assert: s fail: 'b' end: 1.	self assert: s fail: 'ab' end: 2.	self assert: s fail: 'ba' end: 2.	self assert: s fail: 'aaa' end: 3.	self assert: s fail: 'bbb' end: 3.	self assert: s fail: 'aab' end: 3.	self assert: s fail: 'abb' end: 3.		self assert: s parse: ''.	self assert: s parse: 'aa'.	self assert: s parse: 'bb'.	self assert: s parse: 'aaaa'.	self assert: s parse: 'aabb'.	self assert: s parse: 'abab'.	self assert: s parse: 'baba'.	self assert: s parse: 'bbaa'.	self assert: s parse: 'bbbb'! !!PPComposedTest methodsFor: 'testing-examples' stamp: 'lr 2/8/2010 16:44'!testIdentifier	self assert: self identifier parse: 'a' to: 'a'.	self assert: self identifier parse: 'a1' to: 'a1'.	self assert: self identifier parse: 'a12' to: 'a12'.	self assert: self identifier parse: 'ab' to: 'ab'.	self assert: self identifier parse: 'a1b' to: 'a1b'.	self assert: self identifier parse: 'a_' to: 'a' end: 1.	self assert: self identifier parse: 'a1-' to: 'a1' end: 2.	self assert: self identifier parse: 'a12+' to: 'a12' end: 3.	self assert: self identifier parse: 'ab^' to: 'ab' end: 2.	self assert: self identifier parse: 'a1b*' to: 'a1b' end: 3.	self assert: self identifier fail: ''.	self assert: self identifier fail: '1'.	self assert: self identifier fail: '1a'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 6/24/2011 06:11'!testIfThenElse	"S ::= if C then S else S | if C then S | X"	| start if then else cond expr parser |	start := PPDelegateParser new.	if := 'if' asParser token trim.	then := 'then' asParser token trim.	else := 'else' asParser token trim.	cond := 'C' asParser token trim.	expr := 'X' asParser token trim.	start setParser: (if , cond , then , start , else , start) / (if , cond , then , start) / expr.	parser := start end.	self assert: parser parse: 'X'.	self assert: parser parse: 'if C then X'.	self assert: parser parse: 'if C then X else X'.	self assert: parser parse: 'if C then if C then X'.	self assert: parser parse: 'if C then if C then X else if C then X'.	self assert: parser parse: 'if C then if C then X else X else if C then X'.	self assert: parser parse: 'if C then if C then X else X else if C then X else X'.	self assert: parser fail: 'if C'.	self assert: parser fail: 'if C else X'.	self assert: parser fail: 'if C then if C'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 6/24/2011 06:09'!testLeftRecursion	"S ::= S 'x' S / '1'"		| parser |	parser := PPDelegateParser new.	parser setParser: ((parser , $x asParser , parser) / $1 asParser) memoized flatten.	self assert: parser parse: '1' to: '1'.	self assert: parser parse: '1x1' to: '1x1'.	self assert: parser parse: '1x1x1' to: '1x1x1'.	self assert: parser parse: '1x1x1x1' to: '1x1x1x1'.	self assert: parser parse: '1x1x1x1x1' to: '1x1x1x1x1'.	self assert: parser parse: '1x1x1x1x1x1' to: '1x1x1x1x1x1'! !!PPComposedTest methodsFor: 'testing' stamp: 'JamesFoster 2/20/2015 12:01'!testListOfIntegers	"S ::= S , number | number"		| number list parser |	number := #digit asParser plus flatten trim		==> [ :node | node asInteger ].	list := (number separatedBy: $, asParser token trim)		==> [ :node | node select: [ :each | each isKindOf: Integer ] ].	parser := list end.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1,2' to: (1 to: 2) asArray.	self assert: parser parse: '1,2,3' to: (1 to: 3) asArray.	self assert: parser parse: '1,2,3,4' to: (1 to: 4) asArray.	self assert: parser parse: '1,2,3,4,5' to: (1 to: 5) asArray.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1, 2' to: (1 to: 2) asArray.	self assert: parser parse: '1, 2, 3' to: (1 to: 3) asArray.	self assert: parser parse: '1, 2, 3, 4' to: (1 to: 4) asArray.	self assert: parser parse: '1, 2, 3, 4, 5' to: (1 to: 5) asArray.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1 ,2' to: (1 to: 2) asArray.	self assert: parser parse: '1 ,2 ,3' to: (1 to: 3) asArray.	self assert: parser parse: '1 ,2 ,3 ,4' to: (1 to: 4) asArray.	self assert: parser parse: '1 ,2 ,3 ,4 ,5' to: (1 to: 5) asArray.		self assert: parser fail: ''.	self assert: parser fail: ','.	self assert: parser fail: '1,'.	self assert: parser fail: '1,,2'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 6/24/2011 06:09'!testNestedComments	"C ::= B I* E"	"I ::= !!E (C | T)"	"B ::= /*"	"E ::= */"	"T ::= ."		| begin end any inside parser |	begin := '/*' asParser.	end := '*/' asParser.	any := #any asParser.		parser := PPDelegateParser new.	inside := end not , (parser / any).	parser setParser: begin , inside star , end.		self assert: parser parse: '/*ab*/cd' end: 6.	self assert: parser parse: '/*a/*b*/c*/'.	self assert: parser fail: '/*a/*b*/c'! !!PPComposedTest methodsFor: 'testing-examples' stamp: 'lr 2/8/2010 16:44'!testNumber	self assert: self number parse: '1' to: '1'.	self assert: self number parse: '12' to: '12'.	self assert: self number parse: '12.3' to: '12.3'.	self assert: self number parse: '12.34' to: '12.34'.	self assert: self number parse: '1..' to: '1' end: 1.	self assert: self number parse: '12-' to: '12' end: 2.	self assert: self number parse: '12.3.' to: '12.3' end: 4.	self assert: self number parse: '12.34.' to: '12.34' end: 5.		self assert: self number parse: '-1' to: '-1'.	self assert: self number parse: '-12' to: '-12'.	self assert: self number parse: '-12.3' to: '-12.3'.	self assert: self number parse: '-12.34' to: '-12.34'.		self assert: self number fail: ''.	self assert: self number fail: '-'.	self assert: self number fail: '.'.	self assert: self number fail: '.1'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 6/24/2011 06:10'!testPalindrome	"S0 ::= a S1 a | b S1 b | ...	 S1 ::= S0 | epsilon"		| s0 s1 parser |	s0 := PPDelegateParser new.	s1 := PPDelegateParser new.	s0 setParser: ($a asParser , s1 , $a asParser)		/ ($b asParser , s1 , $b asParser)		/ ($c asParser , s1 , $c asParser).		s1 setParser: s0 / nil asParser.	parser := s0 flatten end.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 'bb' to: 'bb'.	self assert: parser parse: 'cc' to: 'cc'.		self assert: parser parse: 'abba' to: 'abba'.	self assert: parser parse: 'baab' to: 'baab'.	self assert: parser parse: 'abccba' to: 'abccba'.	self assert: parser parse: 'abaaba' to: 'abaaba'.	self assert: parser parse: 'cbaabc' to: 'cbaabc'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser fail: 'aab'.	self assert: parser fail: 'abccbb'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 6/24/2011 06:10'!testParseAaaBbb	"S0 ::= a S1 b	 S1 ::= S0 | epsilon"		| s0 s1 parser |	s0 := PPDelegateParser new.	s1 := PPDelegateParser new.	s0 setParser: $a asParser , s1 , $b asParser.	s1 setParser: s0 / nil asParser.	parser := s0 flatten.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'aabb' to: 'aabb'.	self assert: parser parse: 'aaabbb' to: 'aaabbb'.	self assert: parser parse: 'aaaabbbb' to: 'aaaabbbb'.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser parse: 'aabbb' to: 'aabb' end: 4.	self assert: parser parse: 'aaabbbb' to: 'aaabbb' end: 6.	self assert: parser parse: 'aaaabbbbb' to: 'aaaabbbb' end: 8.	self assert: parser fail: 'a'.	self assert: parser fail: 'b'.	self assert: parser fail: 'aab'.	self assert: parser fail: 'aaabb'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 6/24/2011 06:10'!testParseAaaaaa	"S ::= a a S | epsilon"		| s0 s1 parser |	s0 := PPDelegateParser new.	s1 := $a asParser , $a asParser , s0.	s0 setParser: s1 / nil asParser.	parser := s0 flatten.	self assert: parser parse: '' to: ''.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 'aaaa' to: 'aaaa'.	self assert: parser parse: 'aaaaaa' to: 'aaaaaa'.	self assert: parser parse: 'a' to: '' end: 0.	self assert: parser parse: 'aaa' to: 'aa' end: 2.	self assert: parser parse: 'aaaaa' to: 'aaaa' end: 4.	self assert: parser parse: 'aaaaaaa' to: 'aaaaaa' end: 6! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 9/18/2008 09:26'!testParseAbAbAb	"S ::= (A B)+"		| parser |	parser := ($a asParser , $b asParser) plus flatten.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'abab' to: 'abab'.	self assert: parser parse: 'ababab' to: 'ababab'.	self assert: parser parse: 'abababab' to: 'abababab'.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser parse: 'ababa' to: 'abab' end: 4.	self assert: parser parse: 'abababb' to: 'ababab' end: 6.	self assert: parser parse: 'ababababa' to: 'abababab' end: 8.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'bab'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 9/18/2008 09:26'!testParseAbabbb	"S ::= (A | B)+"	| parser |	parser := ($a asParser / $b asParser) plus flatten.	self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: 'b' to: 'b'.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'ba' to: 'ba'.	self assert: parser parse: 'aaa' to: 'aaa'.	self assert: parser parse: 'aab' to: 'aab'.	self assert: parser parse: 'aba' to: 'aba'.	self assert: parser parse: 'baa' to: 'baa'.	self assert: parser parse: 'abb' to: 'abb'.	self assert: parser parse: 'bab' to: 'bab'.	self assert: parser parse: 'bba' to: 'bba'.	self assert: parser parse: 'bbb' to: 'bbb'.	self assert: parser parse: 'ac' to: 'a' end: 1.	self assert: parser parse: 'bc' to: 'b' end: 1.	self assert: parser parse: 'abc' to: 'ab' end: 2.	self assert: parser parse: 'bac' to: 'ba' end: 2.		self assert: parser fail: ''.	self assert: parser fail: 'c'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 6/24/2011 06:11'!testParseAnBnCn	"PEGs for a non context- free language: 				a^n , b^n , c^n			S <- &P1 P2 	P1 <- AB 'c' 	AB <- 'a' AB 'b' / epsilon	P2 <- 'a'* BC end	BC <- 'b' BC 'c' / epsilon"		| s p1 ab p2 bc |	s := PPDelegateParser new.	p1 := PPDelegateParser new.	ab := PPDelegateParser new.	p2 := PPDelegateParser new.	bc := PPDelegateParser new.		s setParser: (p1 and , p2 end) flatten.	p1 setParser: ab , $c asParser.	ab setParser: ($a asParser , ab , $b asParser) optional.	p2 setParser: $a asParser star , bc.	bc setParser: ($b asParser , bc , $c asParser) optional.		self assert: s parse: 'abc' to: 'abc'.	self assert: s parse: 'aabbcc' to: 'aabbcc'.	self assert: s parse: 'aaabbbccc' to: 'aaabbbccc'.	self assert: s fail: 'bc'.	self assert: s fail: 'ac'.	self assert: s fail: 'ab'.	self assert: s fail: 'abbcc'.	self assert: s fail: 'aabcc'.	self assert: s fail: 'aabbc'! !!PPComposedTest methodsFor: 'testing-examples' stamp: 'lr 2/25/2013 23:51'!testReturn	| number spaces return |	number := #digit asParser plus flatten.	spaces := #space asParser star.	return := (spaces , $^ asParser token , spaces , number)		==> [ :nodes | Array with: #return with: (nodes at: 4) ].	self assert: return parse: '^1' to: #(return '1').	self assert: return parse: '^12' to: #(return '12').	self assert: return parse: '^ 123' to: #(return '123').	self assert: return parse: '^  1234' to: #(return '1234').		self assert: return fail: '1'.	self assert: return fail: '^'! !!PPArithmeticParserTest methodsFor: 'accessing' stamp: 'FirstnameLastname 11/26/2009 21:53'!parserClass	^ PPArithmeticParser! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 4/30/2008 17:21'!testAdd	self assert: '1 + 2' is: 3.	self assert: '2 + 1' is: 3.	self assert: '1 + 2.3' is: 3.3.	self assert: '2.3 + 1' is: 3.3.	self assert: '1 + -2' is: -1.	self assert: '-2 + 1' is: -1! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 4/21/2008 10:23'!testAddMany	self assert: '1' is: 1.	self assert: '1 + 2' is: 3.	self assert: '1 + 2 + 3' is: 6.	self assert: '1 + 2 + 3 + 4' is: 10.	self assert: '1 + 2 + 3 + 4 + 5' is: 15! !!PPArithmeticParserTest methodsFor: 'testing-expression' stamp: 'lr 4/21/2008 10:03'!testBrackets	self assert: '(1)' is: 1.	self assert: '(1 + 2)' is: 3.		self assert: '((1))' is: 1.	self assert: '((1 + 2))' is: 3.	self assert: '2 * (3 + 4)' is: 14.	self assert: '(2 + 3) * 4' is: 20.	self assert: '6 / (2 + 4)' is: 1.	self assert: '(2 + 6) / 2' is: 4! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 4/21/2008 09:32'!testDiv	self assert: '12 / 3' is: 4.	self assert: '-16 / -4' is: 4! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 7/3/2008 15:46'!testDivMany	self assert: '100 / 2' is: 50.	self assert: '100 / 2 / 2' is: 25.	self assert: '100 / 2 / 2 / 5' is: 5.	self assert: '100 / 2 / 2 / 5 / 5' is: 1	! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 4/21/2008 09:31'!testMul	self assert: '2 * 3' is: 6.	self assert: '2 * -4' is: -8! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 4/21/2008 10:16'!testMulMany	self assert: '1 * 2' is: 2.	self assert: '1 * 2 * 3' is: 6.	self assert: '1 * 2 * 3 * 4' is: 24.	self assert: '1 * 2 * 3 * 4 * 5' is: 120! !!PPArithmeticParserTest methodsFor: 'testing' stamp: 'lr 4/21/2008 09:32'!testNum	self assert: '0' is: 0.	self assert: '0.0' is: 0.0.	self assert: '1' is: 1.	self assert: '1.2' is: 1.2.	self assert: '34' is: 34.	self assert: '56.78' is: 56.78.	self assert: '-9' is: -9.	self assert: '-9.9' is: -9.9! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 7/3/2008 15:28'!testPow	self assert: '2 ^ 3' is: 8.	self assert: '-2 ^ 3' is: -8.	self assert: '-2 ^ -3' is: -0.125! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 7/3/2008 15:45'!testPowMany	self assert: '4 ^ 3' is: 64.	self assert: '4 ^ 3 ^ 2' is: 262144.	self assert: '4 ^ 3 ^ 2 ^ 1' is: 262144.	self assert: '4 ^ 3 ^ 2 ^ 1 ^ 0' is: 262144! !!PPArithmeticParserTest methodsFor: 'testing-expression' stamp: 'lr 4/21/2008 10:00'!testPriority	self assert: '2 * 3 + 4' is: 10.	self assert: '2 + 3 * 4' is: 14.	self assert: '6 / 3 + 4' is: 6.	self assert: '2 + 6 / 2' is: 5! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 8/14/2010 13:38'!testSub	self assert: '1 - 2' is: -1.	self assert: '1.2 - 1.2' is: 0.	self assert: '1 - -2' is: 3.	self assert: '-1 - -2' is: 1! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 4/28/2008 11:56'!testSubMany	self assert: '1' is: 1.	self assert: '1 - 2' is: -1.	self assert: '1 - 2 - 3' is: -4.	self assert: '1 - 2 - 3 - 4' is: -8.	self assert: '1 - 2 - 3 - 4 - 5' is: -13! !!PPExpressionParserTest class methodsFor: 'testing' stamp: 'lr 4/6/2010 19:40'!shouldInheritSelectors	^ true! !!PPExpressionParserTest methodsFor: 'accessing' stamp: 'lr 2/25/2013 23:50'!parserInstance	| expression parens number |	expression := PPExpressionParser new.	parens := $( asParser trim , expression , $) asParser trim		==> [ :value | value second ].	number := (#digit asParser plus , ($. asParser , #digit asParser plus) optional) flatten trim		==> [ :value | value asNumber ].	expression term: parens / number.	expression		group: [ :g |			g prefix: $- asParser trim do: [ :op :a | a negated ] ];		group: [ :g |			g postfix: '++' asParser trim do: [ :a :op | a + 1 ].			g postfix: '--' asParser trim do: [ :a :op | a - 1 ] ];		group: [ :g |			g right: $^ asParser trim do: [ :a :op :b | a raisedTo: b ] ];		group: [ :g |			g left: $* asParser trim do: [ :a :op :b | a * b ].			g left: $/ asParser trim do: [ :a :op :b | a / b ] ];		group: [ :g |			g left: $+ asParser trim do: [ :a :op :b | a + b ].			g left: $- asParser trim do: [ :a :op :b | a - b ] ].	^ expression end! !!PPExpressionParserTest methodsFor: 'testing' stamp: 'FirstnameLastname 11/26/2009 22:13'!testPostfixAdd	self assert: '0++' is: 1.	self assert: '0++++' is: 2.	self assert: '0++++++' is: 3.	self assert: '0+++1' is: 2.	self assert: '0+++++1' is: 3.	self assert: '0+++++++1' is: 4! !!PPExpressionParserTest methodsFor: 'testing' stamp: 'FirstnameLastname 11/26/2009 22:11'!testPostfixSub	self assert: '1--' is: 0.	self assert: '2----' is: 0.	self assert: '3------' is: 0.	self assert: '2---1' is: 0.	self assert: '3-----1' is: 0.	self assert: '4-------1' is: 0.! !!PPExpressionParserTest methodsFor: 'testing' stamp: 'FirstnameLastname 11/26/2009 22:13'!testPrefixNegate	self assert: '1' is: 1.	self assert: '-1' is: -1.	self assert: '--1' is: 1.	self assert: '---1' is: -1! !!PPCompositeParserTest class methodsFor: 'testing' stamp: 'lr 10/4/2009 17:09'!isAbstract	^ self name = #PPCompositeParserTest! !!PPCompositeParserTest class methodsFor: 'accessing' stamp: 'lr 3/29/2010 15:21'!resources	^ Array with: PPParserResource! !!PPCompositeParserTest methodsFor: 'utilities' stamp: 'lr 11/29/2010 11:20'!assert: aCollection is: anObject	self parse: aCollection.	self		assert: result = anObject		description: 'Got: ' , result printString , '; Expected: ' , anObject printString		resumable: true! !!PPCompositeParserTest methodsFor: 'parsing' stamp: 'JanKurs 9/17/2014 20:35'!fail: aString rule: aSymbol 	| production context |	production := self parserInstanceFor: aSymbol.	context := self context.		result := production end parse: aString withContext: context.		self		assert: result isPetitFailure		description: 'Able to parse ' , aString printString.	^ result! !!PPCompositeParserTest methodsFor: 'parsing' stamp: 'lr 11/29/2010 11:26'!parse: aString 	^ self parse: aString rule: #start! !!PPCompositeParserTest methodsFor: 'parsing' stamp: 'JanKurs 9/26/2014 16:54'!parse: aString rule: aSymbol	| production context |	production := self parserInstanceFor: aSymbol.	context := self context.		result := production end parse: aString withContext: context.	self		deny: result isPetitFailure		description: 'Unable to parse ' , aString printString.	^ result! !!PPCompositeParserTest methodsFor: 'accessing' stamp: 'FirstnameLastname 11/26/2009 21:52'!parserClass	self subclassResponsibility! !!PPCompositeParserTest methodsFor: 'accessing' stamp: 'lr 3/29/2010 15:21'!parserInstance	^ PPParserResource current parserAt: self parserClass! !!PPCompositeParserTest methodsFor: 'accessing' stamp: 'lr 11/18/2011 19:44'!parserInstanceFor: aSymbol	^ aSymbol = #start		ifTrue: [ self parserInstance ]		ifFalse: [			self parserInstance				productionAt: aSymbol 				ifAbsent: [ self error: 'Production ' , self parserClass name , '>>' , aSymbol printString , ' not found.' ] ]! !!PPCompositeParserTest methodsFor: 'running' stamp: 'FirstnameLastname 11/26/2009 21:48'!setUp	super setUp.	parser := self parserInstance! !!PPCompositeParserTest methodsFor: 'running' stamp: 'lr 11/29/2010 11:19'!tearDown	super tearDown.	parser := result := nil! !!PPLambdaParserTest methodsFor: 'accessing' stamp: 'FirstnameLastname 11/26/2009 21:53'!parserClass	^ PPLambdaParser! !!PPLambdaParserTest methodsFor: 'testing' stamp: 'lr 4/30/2008 09:38'!testAbstraction	self assert: '\x.y' is: #('x' 'y').	self assert: '\x.\y.z' is: #('x' ('y' 'z'))! !!PPLambdaParserTest methodsFor: 'testing-curch' stamp: 'Nicolasanquetil 5/3/2013 15:17'!testAnd	self assert: self parserClass and equals: #('p' #('q' #(#('p' 'q') 'p')))! !!PPLambdaParserTest methodsFor: 'testing' stamp: 'lr 4/30/2008 09:38'!testApplication	self assert: '(x x)' is: #('x' 'x').	self assert: '(x y)' is: #('x' 'y').	self assert: '((x y) z)' is: #(('x' 'y') 'z').	self assert: '(x (y z))' is: #('x' ('y' 'z'))! !!PPLambdaParserTest methodsFor: 'testing-curch' stamp: 'Nicolasanquetil 5/3/2013 15:02'!testFalse	self assert: self parserClass false equals: #('x' #('y' 'y'))! !!PPLambdaParserTest methodsFor: 'testing-curch' stamp: 'Nicolasanquetil 5/3/2013 15:11'!testIfThenElse	self assert: self parserClass ifthenelse equals: #('p' 'p')! !!PPLambdaParserTest methodsFor: 'testing-curch' stamp: 'Nicolasanquetil 5/3/2013 15:18'!testNot	self assert: self parserClass not equals: #('p' #('a' #('b' #(#('p' 'b') 'a'))))! !!PPLambdaParserTest methodsFor: 'testing-curch' stamp: 'Nicolasanquetil 5/3/2013 15:03'!testOr	self assert: self parserClass or equals: #('p' #('q' #(#('p' 'p') 'q')))! !!PPLambdaParserTest methodsFor: 'testing-utilities' stamp: 'JamesFoster 2/20/2015 11:28'!testParseOnError	| beenHere |	result := self parserClass parse: '\x.y' onError: [ self fail ].	self assert: result equals: #('x' 'y').	beenHere := false.	result := self parserClass parse: '\x.' onError: [ beenHere := true ].	self assert: beenHere.	beenHere := false.	result := self parserClass		parse: '\x.'		onError: [ :fail | 			beenHere := true.			fail ].	self assert: beenHere.	self assert: result message includesSubstring: 'separator'.	self assert: result message includesSubstring: 'expected'.	self assert: result position equals: 3.	beenHere := false.	result := self parserClass		parse: '\x.'		onError: [ :msg :pos | 			self assert: msg includesSubstring: 'separator'.			self assert: msg includesSubstring: 'expected'.			self assert: pos equals: 3.			beenHere := true ].	self assert: result.	self assert: beenHere! !!PPLambdaParserTest methodsFor: 'testing-utilities' stamp: 'JanKurs 8/25/2014 15:23'!testParseStartingAtOnError	| beenHere |	result := self parserClass parse: 'x' startingAt: #variable onError: [ self fail ].	self assert: result equals: 'x'.	beenHere := false.	result := self parserClass parse: '\' startingAt: #variable onError: [ beenHere := true ].	self assert: beenHere.	beenHere := false.	result := self parserClass		parse: '\'		startingAt: #variable		onError: [ :fail | 			beenHere := true.			fail ].	self assert: beenHere.	self assert: result message equals: 'separator expected'.	self assert: result position equals: 0.	beenHere := false.	result := self parserClass		parse: '\'		startingAt: #variable		onError: [ :msg :pos | 			self assert: msg equals: 'separator expected'.			self assert: pos equals: 0.			beenHere := true ].	self assert: beenHere! !!PPLambdaParserTest methodsFor: 'testing-utilities' stamp: 'FirstnameLastname 11/26/2009 21:56'!testProductionAt	self assert: (parser productionAt: #foo) isNil.	self assert: (parser productionAt: #foo ifAbsent: [ true ]).		self assert: (parser productionAt: #start) notNil.	self assert: (parser productionAt: #start ifAbsent: [ true ]) notNil.		self assert: (parser productionAt: #variable) notNil.	self assert: (parser productionAt: #variable ifAbsent: [ true ]) notNil! !!PPLambdaParserTest methodsFor: 'testing-curch' stamp: 'Nicolasanquetil 5/3/2013 15:04'!testTrue	self assert: self parserClass true equals: #('x' #('y' 'x'))! !!PPLambdaParserTest methodsFor: 'testing' stamp: 'lr 4/30/2008 09:33'!testVariable	self assert: 'x' is: 'x'.	self assert: 'xy' is: 'xy'.	self assert: 'x12' is: 'x12'! !!PPConditionalParserTest methodsFor: 'as yet unclassified' stamp: 'JanKurs 2/4/2015 18:08'!context	^ context! !!PPConditionalParserTest methodsFor: 'as yet unclassified' stamp: 'JamesFoster 2/20/2015 12:02'!setUp	super setUp.	context := PPContext new! !!PPConditionalParserTest methodsFor: 'as yet unclassified' stamp: 'JanKurs 2/4/2015 18:09'!testConditionCtxAccess	| parser |	parser := ('a' asParser if: [ :ctx | (ctx propertyAt: #foo) = #bar ]).		context propertyAt: #foo put: #bar.	self assert: parser parse: 'a' .	context propertyAt: #foo put: #zorg.	self assert: parser fail: 'a' .! !!PPConditionalParserTest methodsFor: 'as yet unclassified' stamp: 'JanKurs 2/4/2015 18:06'!testConditionFalse	| parser |	parser := ('a' asParser if: [ :ctx | false ]).		self assert: parser fail: 'a'.	self assert: parser fail: 'b'.! !!PPConditionalParserTest methodsFor: 'as yet unclassified' stamp: 'JanKurs 2/4/2015 18:06'!testConditionTrue	| parser |	parser := ('a' asParser if: [ :ctx | true ]).		self assert: parser parse: 'a'.	self assert: parser fail: 'b'.! !!PPConditionalParserTests methodsFor: 'as yet unclassified' stamp: 'JanKurs 2/4/2015 18:08'!context	^ context! !!PPConditionalParserTests methodsFor: 'as yet unclassified' stamp: 'JanKurs 2/21/2015 13:09'!setUp	super setUp.	context := PPContext new! !!PPConditionalParserTests methodsFor: 'as yet unclassified' stamp: 'JanKurs 2/4/2015 18:09'!testConditionCtxAccess	| parser |	parser := ('a' asParser if: [ :ctx | (ctx propertyAt: #foo) = #bar ]).		context propertyAt: #foo put: #bar.	self assert: parser parse: 'a' .	context propertyAt: #foo put: #zorg.	self assert: parser fail: 'a' .! !!PPConditionalParserTests methodsFor: 'as yet unclassified' stamp: 'JanKurs 2/4/2015 18:06'!testConditionFalse	| parser |	parser := ('a' asParser if: [ :ctx | false ]).		self assert: parser fail: 'a'.	self assert: parser fail: 'b'.! !!PPConditionalParserTests methodsFor: 'as yet unclassified' stamp: 'JanKurs 2/4/2015 18:06'!testConditionTrue	| parser |	parser := ('a' asParser if: [ :ctx | true ]).		self assert: parser parse: 'a'.	self assert: parser fail: 'b'.! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'lr 5/2/2010 18:18'!testCharacter	| parser |	parser := $a asParser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'lr 11/29/2011 20:38'!testChoice	| parser |	parser := #(1 2) asChoiceParser.	self assert: parser parse: #(1) to: 1.	self assert: parser parse: #(2) to: 2.	self assert: parser parse: #(1 2) to: 1 end: 1.	self assert: parser parse: #(2 1) to: 2 end: 1.	self assert: parser fail: #().	self assert: parser fail: #(3)! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'JanKurs 8/19/2014 16:59'!testClosure	| parser |	parser := [ :stream | stream upTo: $s ] asParser.	self assert: parser parse: '' to: ''.	self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 's' to: ''.	self assert: parser parse: 'as' to: 'a'.	self assert: parser parse: 'aas' to: 'aa'.	self assert: parser parse: 'sa' to: '' end: 1.	self assert: parser parse: 'saa' to: '' end: 1.		parser := [ :stream | stream upTo: $s. PPFailure message: 'stream' context: stream ] asParser.	self assert: parser fail: ''.	self assert: parser fail: 's'.	self assert: parser fail: 'as'	! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'Nicolasanquetil 5/3/2013 14:59'!testEpsilon	| parser |	parser := nil asParser.	self assert: parser asParser equals: parser! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'Nicolasanquetil 5/3/2013 15:08'!testParser	| parser |	parser := $a asParser.	self assert: parser asParser equals: parser! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'JanKrus 10/15/2014 13:05'!testRange	| parser |	parser := ($a to: $c) asParser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'c' to: $c.	self assert: parser fail: 'd'! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'lr 11/29/2011 20:40'!testSequence	| parser |	parser := #(1 2) asSequenceParser.	self assert: parser parse: #(1 2) to: #(1 2).	self assert: parser parse: #(1 2 3) to: #(1 2) end: 2.	self assert: parser fail: #().	self assert: parser fail: #(1).	self assert: parser fail: #(1 1).	self assert: parser fail: #(1 1 2)! !!PPExtensionTest methodsFor: 'testing-stream' stamp: 'JamesFoster 2/20/2015 12:07'!testStream	| dot stream |	dot := (Character codePoint: 183) asString.	stream := 'abc' readStream asPetitStream.	self assert: stream class equals: PPStream.	self assert: stream printString equals: dot , 'abc'.	self assert: stream peek equals: $a.	self assert: stream uncheckedPeek equals: $a.	self assert: stream next equals: $a.	self assert: stream printString equals: 'a' , dot , 'bc'.	self assert: stream asPetitStream equals: stream! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'lr 5/2/2010 18:18'!testString	| parser |	parser := 'ab' asParser.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'aba' to: 'ab' end: 2.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser fail: 'a'.	self assert: parser fail: 'ac'! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'lr 9/17/2008 22:03'!testSymbol	| parser |	parser := #any asParser.	self assert: parser parse: 'a'.	self assert: parser fail: ''! !!PPExtensionTest methodsFor: 'testing-stream' stamp: 'Nicolasanquetil 5/3/2013 15:00'!testText	| stream |	stream := 'abc' asText asPetitStream.	self assert: stream class equals: PPStream! !!PPMappingTest methodsFor: 'as yet unclassified' stamp: 'JanKurs 10/30/2014 12:42'!testFoldLeft2	| parser |	parser := #any asParser star 		foldLeft: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #((a b) c).	self assert: parser parse: #(a b c d) to: #(((a b) c) d).	self assert: parser parse: #(a b c d e) to: #((((a b) c) d) e)! !!PPMappingTest methodsFor: 'as yet unclassified' stamp: 'JanKurs 10/30/2014 12:42'!testFoldLeft3	| parser |	parser := #any asParser star 		foldLeft: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #((a b c) d e)! !!PPMappingTest methodsFor: 'as yet unclassified' stamp: 'JanKurs 10/30/2014 12:43'!testFoldRight2	| parser |	parser := #any asParser star 		foldRight: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #(a (b c)).	self assert: parser parse: #(a b c d) to: #(a (b (c d))).	self assert: parser parse: #(a b c d e) to: #(a (b (c (d e))))! !!PPMappingTest methodsFor: 'as yet unclassified' stamp: 'JanKurs 10/30/2014 12:43'!testFoldRight3	| parser |	parser := #any asParser star 		foldRight: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #(a b (c d e))! !!PPMappingTest methodsFor: 'as yet unclassified' stamp: 'JanKurs 10/30/2014 12:43'!testMap1	| parser |	parser := #any asParser 		map: [ :a | Array with: a ].	self assert: parser parse: #(a) to: #(a)! !!PPMappingTest methodsFor: 'as yet unclassified' stamp: 'JanKurs 10/30/2014 12:43'!testMap2	| parser |	parser := (#any asParser , #any asParser) 		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: #(a b) to: #(b a)! !!PPMappingTest methodsFor: 'as yet unclassified' stamp: 'JanKurs 10/30/2014 12:43'!testMap3	| parser |	parser := (#any asParser , #any asParser , #any asParser)		map: [ :a :b :c | Array with: c with: b with: a ].	self assert: parser parse: #(a b c) to: #(c b a)! !!PPObjectTest methodsFor: 'parsers' stamp: 'JamesFoster 2/20/2015 12:13'!integer	^ PPPredicateObjectParser		on: [ :each | each isKindOf: Integer ]		message: 'integer expected'! !!PPObjectTest methodsFor: 'parsers' stamp: 'JamesFoster 2/20/2015 12:15'!string	^ PPPredicateObjectParser		on: [ :each | each isKindOf: String ]		message: 'string expected'! !!PPObjectTest methodsFor: 'testing-operators' stamp: 'lr 12/9/2010 10:25'!testChoice	| parser |	parser := self integer / self string.	self assert: parser parse: #(123) to: 123.	self assert: parser parse: #('abc') to: 'abc'! !!PPObjectTest methodsFor: 'testing-fancy' stamp: 'JanKurs 8/19/2014 17:01'!testFibonacci	"This parser accepts fibonacci sequences with arbitrary start pairs."		| parser |	parser := ((self integer , self integer) end ==> [ :pair | pair first + pair last ])		/ (self integer , (self integer , self integer) and >=> [ :stream :continuation |			| result |			result := continuation value.			(result isPetitFailure or: [ result first + result last first ~= result last last ])				ifFalse: [ parser parseOn: stream ]				ifTrue: [ PPFailure message: 'invalid fibonacci sequence' context: stream ] ]).	self assert: parser parse: #(1 1) to: 2.	self assert: parser parse: #(1 1 2) to: 3.	self assert: parser parse: #(1 1 2 3) to: 5.	self assert: parser parse: #(1 1 2 3 5) to: 8.	self assert: parser parse: #(1 1 2 3 5 8) to: 13.	self assert: parser parse: #(1 1 2 3 5 8 13) to: 21.	self assert: parser fail: #().	self assert: parser fail: #(1).	self assert: parser fail: #(1 2 3 4) end: 2	! !!PPObjectTest methodsFor: 'testing' stamp: 'lr 12/9/2010 10:25'!testInteger	self assert: self integer parse: #(123) to: 123.	self assert: self integer fail: #('abc')! !!PPObjectTest methodsFor: 'testing-operators' stamp: 'lr 12/9/2010 10:25'!testSequence	| parser |	parser := self integer , self string.	self assert: parser parse: #(123 'abc') to: #(123 'abc').	self assert: parser fail: #(123 456).	self assert: parser fail: #('abc' 'def').	self assert: parser fail: #('abc' 123)	! !!PPObjectTest methodsFor: 'testing' stamp: 'lr 10/30/2010 12:47'!testString	self assert: self string parse: #('abc') to: 'abc'.	self assert: self string fail: #(123)! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'Nicolasanquetil 5/3/2013 15:14'!testAction	| block parser |	block := [ :char | char asUppercase ].	parser := #any asParser ==> block.	self assert: parser block equals: block.	self assert: parser parse: 'a' to: $A.	self assert: parser parse: 'b' to: $B! !!PPParserTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 15:20'!testAnd	| parser |	parser := 'foo' asParser flatten , 'bar' asParser flatten and.	self		assert: parser		parse: 'foobar'		to: #('foo' 'bar')		end: 3.	self assert: parser fail: 'foobaz'.	parser := 'foo' asParser and.	self assert: parser and equals: parser! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testAnswer	| parser |	parser := $a asParser answer: $b.		self assert: parser parse: 'a' to: $b.		self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/2/2009 19:56'!testBlock	| parser |	parser := [ :s | s next ] asParser.		self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: '' to: nil! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'Nicolasanquetil 5/3/2013 15:07'!testChildren	| p1 p2 p3 |	p1 := #lowercase asParser.	p2 := p1 ==> #asUppercase.	p3 := PPUnresolvedParser new.	p3 def: p2 / p3.	self assert: p1 children isEmpty.	self assert: p2 children size equals: 1.	self assert: p3 children size equals: 2! !!PPParserTest methodsFor: 'testing' stamp: 'lr 9/15/2008 09:24'!testChoice	| parser |	parser := $a asParser / $b asParser.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'ba' to: $b end: 1.	self assert: parser fail: ''.	self assert: parser fail: 'c'.	self assert: parser fail: 'ca'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 5/7/2008 08:58'!testDelimitedBy	| parser |	parser := $a asParser delimitedBy: $b asParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).	self assert: parser parse: 'ab' to: #($a $b).	self assert: parser parse: 'abab' to: #($a $b $a $b).	self assert: parser parse: 'ababab' to: #($a $b $a $b $a $b).		self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abc' to: #($a $b) end: 2.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.	self assert: parser parse: 'ababc' to: #($a $b $a $b) end: 4.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'c'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 2/25/2012 16:56'!testDelimitedByWithoutSeparators	| parser |	parser := ($a asParser delimitedBy: $b asParser)		withoutSeparators.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $a).	self assert: parser parse: 'ababa' to: #($a $a $a).	self assert: parser parse: 'ab' to: #($a).	self assert: parser parse: 'abab' to: #($a $a).	self assert: parser parse: 'ababab' to: #($a $a $a).		self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abc' to: #($a) end: 2.	self assert: parser parse: 'abac' to: #($a $a) end: 3.	self assert: parser parse: 'ababc' to: #($a $a) end: 4.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'c'! !!PPParserTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 15:14'!testEndOfInput	| parser |	parser := PPEndOfInputParser on: $a asParser.	self assert: parser end equals: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''.	self assert: parser fail: 'aa'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 9/17/2008 22:47'!testEndOfInputAfterMatch	| parser |	parser := 'stuff' asParser end.	self assert: parser parse: 'stuff' to: 'stuff'.	self assert: parser fail: 'stufff'.	self assert: parser fail: 'fluff'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 11/20/2009 15:31'!testEpsilon	| parser |	parser := nil asParser.		self assert: parser parse: '' to: nil.		self assert: parser parse: 'a' to: nil end: 0.	self assert: parser parse: 'ab' to: nil end: 0! !!PPParserTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 14:58'!testFailing	| parser result |	parser := PPFailingParser message: 'Plonk'.	self assert: parser message equals: 'Plonk'.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'aa'.	result := parser parse: 'a'.	self assert: result message equals: 'Plonk'.	self assert: result printString equals: 'Plonk at 0'! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'JanKurs 8/25/2014 15:21'!testFailure	| failure |	failure := PPFailure message: 'Error' context: PPContext new at: 3.	self assert: failure message equals: 'Error'.	self assert: failure position equals: 3.	self assert: failure isPetitFailure.	self deny: 4 isPetitFailure.	self deny: 'foo' isPetitFailure! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 5/2/2010 12:18'!testFlatten	| parser |	parser := $a asParser flatten.		self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: #($a) to: #($a).		self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testFoldLeft2	| parser |	parser := #any asParser star 		foldLeft: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #((a b) c).	self assert: parser parse: #(a b c d) to: #(((a b) c) d).	self assert: parser parse: #(a b c d e) to: #((((a b) c) d) e)! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testFoldLeft3	| parser |	parser := #any asParser star 		foldLeft: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #((a b c) d e)! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testFoldRight2	| parser |	parser := #any asParser star 		foldRight: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #(a (b c)).	self assert: parser parse: #(a b c d) to: #(a (b (c d))).	self assert: parser parse: #(a b c d e) to: #(a (b (c (d e))))! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testFoldRight3	| parser |	parser := #any asParser star 		foldRight: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #(a b (c d e))! !!PPParserTest methodsFor: 'testing-properties' stamp: 'lr 4/19/2010 10:38'!testHasProperty	| parser |	parser := PPParser new.	self deny: (parser hasProperty: #foo).	parser propertyAt: #foo put: 123.	self assert: (parser hasProperty: #foo)! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'Nicolasanquetil 5/3/2013 15:15'!testListConstructor	| p1 p2 p3 |	p1 := PPChoiceParser with: $a asParser.	p2 := PPChoiceParser with: $a asParser with: $b asParser.	p3 := PPChoiceParser withAll: (Array with: $a asParser with: $b asParser with: $c asParser).	self assert: p1 children size equals: 1.	self assert: p2 children size equals: 2.	self assert: p3 children size equals: 3! !!PPParserTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 14:59'!testLiteralObject	| parser |	parser := PPLiteralObjectParser on: $a message: 'letter "a" expected'.	self assert: parser literal equals: $a.	self assert: parser message equals: 'letter "a" expected'.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 6/1/2010 22:30'!testLiteralObjectCaseInsensitive	| parser |	parser := $a asParser caseInsensitive.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'B'	! !!PPParserTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 15:08'!testLiteralSequence	| parser |	parser := PPLiteralSequenceParser on: 'abc' message: 'sequence "abc" expected'.	self assert: parser size equals: 3.	self assert: parser literal equals: 'abc'.	self assert: parser message equals: 'sequence "abc" expected'.	self assert: parser parse: 'abc' to: 'abc'.	self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 6/1/2010 22:31'!testLiteralSequenceCaseInsensitive	| parser |	parser := 'abc' asParser caseInsensitive.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser parse: 'ABC' to: 'ABC'.	self assert: parser parse: 'abC' to: 'abC'.	self assert: parser parse: 'AbC' to: 'AbC'.		self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testMap1	| parser |	parser := #any asParser 		map: [ :a | Array with: a ].	self assert: parser parse: #(a) to: #(a)! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testMap2	| parser |	parser := (#any asParser , #any asParser) 		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: #(a b) to: #(b a)! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testMap3	| parser |	parser := (#any asParser , #any asParser , #any asParser)		map: [ :a :b :c | Array with: c with: b with: a ].	self assert: parser parse: #(a b c) to: #(c b a)! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testMapFail1	self		should: [ #any asParser map: [  ] ]		raise: Error.	self		should: [ #any asParser map: [ :a :b | ] ]		raise: Error! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testMapFail2	self		should: [ (#any asParser , #any asParser) map: [ :a | ] ]		raise: Error.	self		should: [ (#any asParser , #any asParser) map: [ :a :b :c | ] ]		raise: Error! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 2/8/2010 00:32'!testMatches	| parser |	parser := $a asParser.		self assert: (parser matches: 'a').	self deny: (parser matches: 'b').		self assert: (parser matches: 'a' readStream).	self deny: (parser matches: 'b' readStream)! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'Nicolasanquetil 5/3/2013 15:15'!testMatchesIn	| parser result |	parser := $a asParser.	result := parser matchesIn: 'abba'.	self assert: result size equals: 2.	self assert: result first equals: $a.	self assert: result last equals: $a.	result := parser matchesIn: 'baaah'.	self assert: result size equals: 3.	self assert: result first equals: $a.	self assert: result last equals: $a! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'Nicolasanquetil 5/3/2013 15:00'!testMatchesInEmpty	"Empty matches should properly advance and match at each position and at the end."	| parser result |	parser := [ :stream | stream position ] asParser.	result := parser matchesIn: '123'.	self assert: result asArray equals: #(0 1 2 3)! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'Nicolasanquetil 5/3/2013 15:09'!testMatchesInOverlapping	"Matches that overlap should be properly reported."	| parser result |	parser := #digit asParser , #digit asParser.	result := parser matchesIn: 'a123b'.	self assert: result size equals: 2.	self assert: result first equals: #($1 $2).	self assert: result last equals: #($2 $3)! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'Nicolasanquetil 5/3/2013 15:16'!testMatchesSkipIn	| parser result |	parser := $a asParser.	result := parser matchesSkipIn: 'abba'.	self assert: result size equals: 2.	self assert: result first equals: $a.	self assert: result last equals: $a.	result := parser matchesSkipIn: 'baaah'.	self assert: result size equals: 3.	self assert: result first equals: $a.	self assert: result last equals: $a! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'Nicolasanquetil 5/3/2013 15:00'!testMatchesSkipInOverlapping	"Matches that overlap should be properly reported."	| parser result |	parser := #digit asParser , #digit asParser.	result := parser matchesSkipIn: 'a123b'.	self assert: result size equals: 1.	self assert: result first equals: #($1 $2)! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'Nicolasanquetil 5/3/2013 15:09'!testMatchingRangesIn	| input parser result |	input := 'a12b3'.	parser := #digit asParser plus.	result := parser matchingRangesIn: input.	result := result collect: [ :each | input copyFrom: each first to: each last ].	self assert: result size equals: 3.	self assert: result first equals: '12'.	self assert: result second equals: '2'.	self assert: result last equals: '3'! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'Nicolasanquetil 5/3/2013 15:17'!testMatchingSkipRangesIn	| input parser result |	input := 'a12b3'.	parser := #digit asParser plus.	result := parser matchingSkipRangesIn: input.	result := result collect: [ :each | input copyFrom: each first to: each last ].	self assert: result size equals: 2.	self assert: result first equals: '12'.	self assert: result last equals: '3'! !!PPParserTest methodsFor: 'testing' stamp: 'JamesFoster 2/20/2015 12:17'!testMax	| parser printString suffix |	parser := $a asParser max: 2.	self assert: parser min equals: 0.	self assert: parser max equals: 2.	self assert: parser parse: '' to: #().	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self		assert: parser		parse: 'aaa'		to: #($a $a)		end: 2.	self		assert: parser		parse: 'aaaa'		to: #($a $a)		end: 2.	printString := parser printString.	suffix := printString copyFrom: printString size - 5 to: printString size.	self assert: suffix = '[0, 2]'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/3/2011 21:02'!testMaxGreedy	| parser |	parser := #word asParser max: 2 greedy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abc'.		self assert: parser parse: '1' to: #() end: 0.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser fail: 'abc1'.		self assert: parser parse: '12' to: #($1) end: 1.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser fail: 'abc12'.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1) end: 2.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser fail: 'abc123'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/3/2011 21:03'!testMaxLazy	| parser |	parser := #word asParser max: 2 lazy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abc'.		self assert: parser parse: '1' to: #() end: 0.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser fail: 'abc1'.		self assert: parser parse: '12' to: #() end: 0.	self assert: parser parse: 'a12' to: #($a) end: 1.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser fail: 'abc12'.		self assert: parser parse: '123' to: #() end: 0.	self assert: parser parse: 'a123' to: #($a) end: 1.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser fail: 'abc123'! !!PPParserTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 15:10'!testMemoized	| count parser twice |	count := 0.	parser := [ :s | 	count := count + 1.	s next ] asParser memoized.	twice := parser and , parser.	count := 0.	self assert: parser parse: 'a' to: $a.	self assert: count equals: 1.	count := 0.	self assert: twice parse: 'a' to: #($a $a).	self assert: count equals: 1.	self assert: parser memoized equals: parser! !!PPParserTest methodsFor: 'testing' stamp: 'JamesFoster 2/20/2015 12:17'!testMin	| parser printString suffix |	parser := $a asParser min: 2.	self assert: parser min equals: 2.	self assert: parser max > parser min.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self assert: parser parse: 'aaaa' to: #($a $a $a $a).	printString := parser printString.	suffix := printString copyFrom: printString size - 5 to: printString size.	self assert: suffix = '[2, *]'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/3/2011 21:12'!testMinGreedy	| parser |	parser := #word asParser min: 2 greedy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde1' to: #($a $b $c $d $e) end: 5.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b $1) end: 3.	self assert: parser parse: 'abc12' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd12' to: #($a $b $c $d $1) end: 5.	self assert: parser parse: 'abcde12' to: #($a $b $c $d $e $1) end: 6.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1 $2) end: 3.	self assert: parser parse: 'ab123' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc123' to: #($a $b $c $1 $2) end: 5.	self assert: parser parse: 'abcd123' to: #($a $b $c $d $1 $2) end: 6.	self assert: parser parse: 'abcde123' to: #($a $b $c $d $e $1 $2) end: 7.		self assert: parser parse: '1234' to: #($1 $2 $3) end: 3.	self assert: parser parse: 'a1234' to: #($a $1 $2 $3) end: 4.	self assert: parser parse: 'ab1234' to: #($a $b $1 $2 $3) end: 5.	self assert: parser parse: 'abc1234' to: #($a $b $c $1 $2 $3) end: 6.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d $1 $2 $3) end: 7.	self assert: parser parse: 'abcde1234' to: #($a $b $c $d $e $1 $2 $3) end: 8! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/3/2011 21:15'!testMinLazy	| parser |	parser := #word asParser min: 2 lazy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde1' to: #($a $b $c $d $e) end: 5.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser parse: 'abc12' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd12' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde12' to: #($a $b $c $d $e) end: 5.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1) end: 2.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser parse: 'abc123' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd123' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde123' to: #($a $b $c $d $e) end: 5.		self assert: parser parse: '1234' to: #($1 $2) end: 2.	self assert: parser parse: 'a1234' to: #($a $1) end: 2.	self assert: parser parse: 'ab1234' to: #($a $b) end: 2.	self assert: parser parse: 'abc1234' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde1234' to: #($a $b $c $d $e) end: 5! !!PPParserTest methodsFor: 'testing' stamp: 'JamesFoster 2/20/2015 12:17'!testMinMax	| parser printString suffix |	parser := $a asParser min: 2 max: 4.	self assert: parser min equals: 2.	self assert: parser max equals: 4.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self assert: parser parse: 'aaaa' to: #($a $a $a $a).	self		assert: parser		parse: 'aaaaa'		to: #($a $a $a $a)		end: 4.	self		assert: parser		parse: 'aaaaaa'		to: #($a $a $a $a)		end: 4.	printString := parser printString.	suffix := printString copyFrom: printString size - 5 to: printString size.	self assert: suffix = '[2, 4]'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/3/2011 20:54'!testMinMaxGreedy	| parser |	parser := #word asParser min: 2 max: 4 greedy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1'.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b $1) end: 3.	self assert: parser parse: 'abc12' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd12' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde12'.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1 $2) end: 3.	self assert: parser parse: 'ab123' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc123' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd123' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde123'.		self assert: parser parse: '1234' to: #($1 $2 $3) end: 3.	self assert: parser parse: 'a1234' to: #($a $1 $2 $3) end: 4.	self assert: parser parse: 'ab1234' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc1234' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1234'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/3/2011 20:57'!testMinMaxLazy	| parser |	parser := #word asParser min: 2 max: 4 lazy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1'.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser parse: 'abc12' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd12' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde12'.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1) end: 2.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser parse: 'abc123' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd123' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde123'.		self assert: parser parse: '1234' to: #($1 $2) end: 2.	self assert: parser parse: 'a1234' to: #($a $1) end: 2.	self assert: parser parse: 'ab1234' to: #($a $b) end: 2.	self assert: parser parse: 'abc1234' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1234'! !!PPParserTest methodsFor: 'testing-accessing' stamp: 'Nicolasanquetil 5/3/2013 15:11'!testNamed	| parser |	parser := PPSequenceParser new.	self assert: parser name isNil.	parser := PPChoiceParser named: 'choice'.	self assert: parser name equals: 'choice'.	parser := $* asParser name: 'star'.	self assert: parser name equals: 'star'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 2/7/2010 20:10'!testNegate	| parser |	parser := 'foo' asParser negate.		self assert: parser parse: 'f' to: $f end: 1.	self assert: parser parse: 'fo' to: $f end: 1.	self assert: parser parse: 'fob' to: $f end: 1.	self assert: parser parse: 'ffoo' to: $f end: 1.		self assert: parser fail: ''.	self assert: parser fail: 'foo'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 8/26/2010 09:54'!testNot	| parser |	parser := 'foo' asParser flatten , 'bar' asParser flatten not.		self assert: parser parse: 'foobaz' to: #('foo' nil) end: 3.	self assert: parser fail: 'foobar'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/29/2008 11:32'!testOptional	| parser |	parser := $a asParser optional.		self assert: parser parse: '' to: nil.	self assert: parser parse: 'a' to: $a.		self assert: parser parse: 'aa' to: $a end: 1.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: nil end: 0.	self assert: parser parse: 'bb' to: nil end: 0.	self assert: parser parse: 'ba' to: nil end: 0! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'JamesFoster 2/20/2015 11:34'!testParse	| parser result |	parser := $a asParser.	self assert: (parser parse: 'a') equals: $a.	self assert: (result := parser parse: 'b') isPetitFailure.	self assert: result message includesSubstring: $a printString.	self assert: result message includesSubstring: 'expected'.	self assert: result position equals: 0.	self assert: (parser parse: 'a' readStream) equals: $a.	self assert: (result := parser parse: 'b' readStream) isPetitFailure.	self assert: result message includesSubstring: $a printString.	self assert: result message includesSubstring: 'expected'.	self assert: result position equals: 0! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'Nicolasanquetil 5/3/2013 15:03'!testParseOnError0	| parser result seen |	parser := $a asParser.	result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result equals: $a.	result := parser parse: 'b' onError: [ seen := true ].	self assert: result.	self assert: seen! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'JamesFoster 2/20/2015 11:34'!testParseOnError1	| parser result seen |	parser := $a asParser.	result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result equals: $a.	result := parser		parse: 'b'		onError: [ :failure | 			self assert: failure position equals: 0.			self assert: failure message includesSubstring: $a printString.			self assert: failure message includesSubstring: 'expected'.			seen := true ].	self assert: result.	self assert: seen! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'JamesFoster 2/20/2015 11:34'!testParseOnError2	| parser result seen |	parser := $a asParser.	result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result equals: $a.	result := parser		parse: 'b'		onError: [ :msg :pos | 			self assert: msg includesSubstring: $a printString.			self assert: msg includesSubstring: 'expected'.			self assert: pos equals: 0.			seen := true ].	self assert: result.	self assert: seen! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 8/6/2010 19:06'!testParser	| parser |	parser := PPParser new.		self assert: parser isPetitParser.	self deny: 4 isPetitParser.	self deny: 'foo' isPetitParser! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 1/8/2010 12:09'!testPermutation	| parser |	parser := #any asParser , #any asParser , #any asParser.	self assert: (parser permutation: #()) parse: '123' to: #().	self assert: (parser permutation: #(1)) parse: '123' to: #($1).	self assert: (parser permutation: #(1 3)) parse: '123' to: #($1 $3).	self assert: (parser permutation: #(3 1)) parse: '123' to: #($3 $1).	self assert: (parser permutation: #(2 2)) parse: '123' to: #($2 $2).	self assert: (parser permutation: #(3 2 1)) parse: '123' to: #($3 $2 $1).		self should: [ parser permutation: #(0) ] raise: Error.	self should: [ parser permutation: #(4) ] raise: Error.	self should: [ parser permutation: #($2) ] raise: Error! !!PPParserTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 15:04'!testPluggable	| block parser |	block := [ :stream | stream position ].	parser := block asParser.	self assert: parser block equals: block! !!PPParserTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 15:12'!testPlus	| parser |	parser := $a asParser plus.	self assert: parser min equals: 1.	self assert: parser max > parser min.	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self		assert: parser		parse: 'ab'		to: #($a)		end: 1.	self		assert: parser		parse: 'aab'		to: #($a $a)		end: 2.	self		assert: parser		parse: 'aaab'		to: #($a $a $a)		end: 3.	self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'ba'! !!PPParserTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 15:19'!testPlusGreedy	| limit parser |	limit := #digit asParser.	parser := #word asParser plusGreedy: limit.	self assert: parser min equals: 1.	self assert: parser max > parser min.	self assert: parser limit equals: limit.	self assert: parser children size equals: 2.	self assert: parser children last equals: limit.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self		assert: parser		parse: 'a1'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab1'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc1'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: 'a12'		to: #($a $1)		end: 2.	self		assert: parser		parse: 'ab12'		to: #($a $b $1)		end: 3.	self		assert: parser		parse: 'abc12'		to: #($a $b $c $1)		end: 4.	self		assert: parser		parse: 'a123'		to: #($a $1 $2)		end: 3.	self		assert: parser		parse: 'ab123'		to: #($a $b $1 $2)		end: 4.	self		assert: parser		parse: 'abc123'		to: #($a $b $c $1 $2)		end: 5! !!PPParserTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 15:04'!testPlusLazy	| limit parser |	limit := #digit asParser.	parser := #word asParser plusLazy: limit.	self assert: parser min equals: 1.	self assert: parser max > parser min.	self assert: parser limit equals: limit.	self assert: parser children size equals: 2.	self assert: parser children last equals: limit.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self		assert: parser		parse: 'a1'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab1'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc1'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: 'a12'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab12'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc12'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: 'a123'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab123'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc123'		to: #($a $b $c)		end: 3! !!PPParserTest methodsFor: 'testing-properties' stamp: 'lr 4/19/2010 10:41'!testPostCopy	| parser copy |	parser := PPParser new.	parser propertyAt: #foo put: true.	copy := parser copy.	copy propertyAt: #foo put: false.	self assert: (parser propertyAt: #foo).	self deny: (copy propertyAt: #foo)! !!PPParserTest methodsFor: 'testing-accessing' stamp: 'JamesFoster 2/20/2015 11:35'!testPrint	| parser |	parser := PPParser new.	self assert: parser printString includesSubstring: 'PPParser'.		parser := PPParser named: 'choice'.	self assert: parser printString includesSubstring: 'PPParser(choice'.		parser := PPLiteralObjectParser on: $a.	self assert: parser printString includesSubstring: $a printString.		parser := PPFailingParser message: 'error'.	self assert: parser printString includesSubstring: 'error'.		parser := PPPredicateObjectParser on: [ :c | true ] message: 'error'.	self assert: parser printString includesSubstring: 'error'! !!PPParserTest methodsFor: 'testing-properties' stamp: 'lr 4/19/2010 10:36'!testPropertyAt	| parser |	parser := PPParser new.	self should: [ parser propertyAt: #foo ] raise: Error.	parser propertyAt: #foo put: true.	self assert: (parser propertyAt: #foo)! !!PPParserTest methodsFor: 'testing-properties' stamp: 'lr 4/19/2010 10:37'!testPropertyAtIfAbsent	| parser |	parser := PPParser new.	self assert: (parser propertyAt: #foo ifAbsent: [ true ]).	parser propertyAt: #foo put: true.	self assert: (parser propertyAt: #foo ifAbsent: [ false ])! !!PPParserTest methodsFor: 'testing-properties' stamp: 'lr 4/19/2010 10:37'!testPropertyAtIfAbsentPut	| parser |	parser := PPParser new.	self assert: (parser propertyAt: #foo ifAbsentPut: [ true ]).	self assert: (parser propertyAt: #foo ifAbsentPut: [ false ])! !!PPParserTest methodsFor: 'testing-properties' stamp: 'lr 4/19/2010 10:37'!testRemoveProperty	| parser |	parser := PPParser new.	self should: [ parser removeProperty: #foo ] raise: Error.	parser propertyAt: #foo put: true.	self assert: (parser removeProperty: #foo)! !!PPParserTest methodsFor: 'testing-properties' stamp: 'lr 4/19/2010 10:37'!testRemovePropertyIfAbsent	| parser |	parser := PPParser new.	self assert: (parser removeProperty: #foo ifAbsent: [ true ]).	parser propertyAt: #foo put: true.	self assert: (parser removeProperty: #foo ifAbsent: [ false ])! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/29/2008 11:42'!testSeparatedBy	| parser |	parser := $a asParser separatedBy: $b asParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'abab' to: #($a $b $a) end: 3.	self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'c'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 2/25/2012 16:55'!testSeparatedByWithoutSeparators	| parser |	parser := ($a asParser separatedBy: $b asParser)		withoutSeparators.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $a).	self assert: parser parse: 'ababa' to: #($a $a $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'abab' to: #($a $a) end: 3.	self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abac' to: #($a $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'c'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/29/2008 11:33'!testSequence	| parser |	parser := $a asParser , $b asParser.		self assert: parser parse: 'ab' to: #($a $b).		self assert: parser parse: 'aba' to: #($a $b) end: 2.	self assert: parser parse: 'abb' to: #($a $b) end: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'aa'.	self assert: parser fail: 'ba'.	self assert: parser fail: 'bab'! !!PPParserTest methodsFor: 'testing-fixtures' stamp: 'lr 2/7/2010 22:00'!testSideEffectChoice	"Adding another element to a choice should create a copy, otherwise we get unwanted side-effects."	| p1 p2 p3 |	p1 := $a asParser.	p2 := p1 / $b asParser.	p3 := p1 / $c asParser.		self assert: p1 parse: 'a'.	self assert: p1 fail: 'b'.	self assert: p1 fail: 'c'.		self assert: p2 parse: 'a'.	self assert: p2 parse: 'b'.	self assert: p2 fail: 'c'.		self assert: p3 parse: 'a'.	self assert: p3 fail: 'b'.	self assert: p3 parse: 'c'! !!PPParserTest methodsFor: 'testing-fixtures' stamp: 'lr 5/31/2010 19:25'!testSideEffectListCopy	| old new |	old := $a asParser , $b asParser.	new := old copy.		self deny: old == new.	self deny: old children == new children.	self assert: old children first == new children first.	self assert: old children last == new children last! !!PPParserTest methodsFor: 'testing-fixtures' stamp: 'lr 4/14/2010 11:38'!testSideEffectSequence	"Adding another element to a sequence should create a copy, otherwise we get unwanted side-effects."	| p1 p2 p3 |	p1 := $a asParser.	p2 := p1 , $b asParser.	p3 := p1 , $c asParser.		self assert: p1 parse: 'a'.		self assert: p1 parse: 'ab' end: 1.	self assert: p1 parse: 'ac' end: 1.		self assert: p2 fail: 'a'.		self assert: p2 parse: 'ab'.	self assert: p2 fail: 'ac'.	self assert: p3 fail: 'a'.		self assert: p3 fail: 'ab'.	self assert: p3 parse: 'ac'! !!PPParserTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 15:13'!testStar	| parser |	parser := $a asParser star.	self assert: parser min equals: 0.	self assert: parser max > parser min.	self assert: parser parse: '' to: #().	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self		assert: parser		parse: 'b'		to: #()		end: 0.	self		assert: parser		parse: 'ab'		to: #($a)		end: 1.	self		assert: parser		parse: 'aab'		to: #($a $a)		end: 2.	self		assert: parser		parse: 'aaab'		to: #($a $a $a)		end: 3! !!PPParserTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 15:19'!testStarGreedy	| limit parser |	limit := #digit asParser.	parser := #word asParser starGreedy: limit.	self assert: parser min equals: 0.	self assert: parser max > parser min.	self assert: parser limit equals: limit.	self assert: parser children size equals: 2.	self assert: parser children last equals: limit.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self		assert: parser		parse: '1'		to: #()		end: 0.	self		assert: parser		parse: 'a1'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab1'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc1'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: '12'		to: #($1)		end: 1.	self		assert: parser		parse: 'a12'		to: #($a $1)		end: 2.	self		assert: parser		parse: 'ab12'		to: #($a $b $1)		end: 3.	self		assert: parser		parse: 'abc12'		to: #($a $b $c $1)		end: 4.	self		assert: parser		parse: '123'		to: #($1 $2)		end: 2.	self		assert: parser		parse: 'a123'		to: #($a $1 $2)		end: 3.	self		assert: parser		parse: 'ab123'		to: #($a $b $1 $2)		end: 4.	self		assert: parser		parse: 'abc123'		to: #($a $b $c $1 $2)		end: 5! !!PPParserTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 15:05'!testStarLazy	| limit parser |	limit := #digit asParser.	parser := #word asParser starLazy: limit.	self assert: parser min equals: 0.	self assert: parser max > parser min.	self assert: parser limit equals: limit.	self assert: parser children size equals: 2.	self assert: parser children last equals: limit.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self		assert: parser		parse: '1'		to: #()		end: 0.	self		assert: parser		parse: 'a1'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab1'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc1'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: '12'		to: #()		end: 0.	self		assert: parser		parse: 'a12'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab12'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc12'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: '123'		to: #()		end: 0.	self		assert: parser		parse: 'a123'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab123'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc123'		to: #($a $b $c)		end: 3! !!PPParserTest methodsFor: 'testing' stamp: 'lr 9/15/2010 09:53'!testTimes	| parser |	parser := $a asParser times: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a) end: 2! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'Nicolasanquetil 5/3/2013 15:13'!testToken	| parser |	parser := $a asParser token.	self assert: parser tokenClass equals: PPToken.	self		assert: parser		parse: 'a'		toToken: 1		stop: 1.	self assert: parser fail: 'b'.	self assert: parser fail: ''.	parser := $a asParser token: PPToken.	self assert: parser tokenClass equals: PPToken.	self		assert: parser		parse: 'a'		toToken: 1		stop: 1.	self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 7/11/2011 11:05'!testTrim	| parser |	parser := $a asParser token trim.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.	self assert: parser parse: 'a 	 ' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.	self assert: parser parse: '   a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 7/31/2010 12:07'!testTrimBlanks	| parser |	parser := $a asParser token trimBlanks.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'b'.! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 7/11/2011 11:05'!testTrimCustom	| parser |	parser := $a asParser token trim: $b asParser.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'ab' toToken: 1 stop: 1.	self assert: parser parse: 'abb' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'ba' toToken: 2 stop: 2.	self assert: parser parse: 'bba' toToken: 3 stop: 3.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'ab' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'abba' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 7/31/2010 12:07'!testTrimSpaces	| parser |	parser := $a asParser token trimSpaces.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.	self assert: parser parse: 'a 	 ' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.	self assert: parser parse: '   a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 11/20/2009 15:31'!testUnresolved	| parser |	parser := PPUnresolvedParser new.		self assert: parser isUnresolved.	self should: [ parser parse: '' ] raise: Error.	self should: [ parser parse: 'a' ] raise: Error.	self should: [ parser parse: 'ab' ] raise: Error.		parser := nil asParser.	self deny: parser isUnresolved! !!PPParserTest methodsFor: 'testing' stamp: 'tg 7/29/2010 22:39'!testWrapped	| parser |	parser := $a asParser wrapped.		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.		parser := (($a asParser , $b asParser ) wrapped , $c asParser).	self assert: parser parse: 'abc' to: #(#($a $b) $c)! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'Nicolasanquetil 5/3/2013 15:20'!testWrapping	| parser result |	parser := #digit asParser plus >=> [ :stream :cc | Array with: stream position with: cc value with: stream position ].	self assert: parser parse: '1' to: #(0 #($1) 1).	self assert: parser parse: '12' to: #(0 #($1 $2) 2).	self assert: parser parse: '123' to: #(0 #($1 $2 $3) 3).	result := parser parse: 'a'.	self assert: result first equals: 0.	self assert: result second isPetitFailure.	self assert: result last equals: 0! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/14/2010 16:30'!testXor	| parser |	parser := ($a asParser / $b asParser)			|  ($b asParser / $c asParser).		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'c' to: $c.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'd'.		" truly symmetric "	parser := ($b asParser / $c asParser)			|  ($a asParser / $b asParser).		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'c' to: $c.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'd'! !!PPPredicateTest methodsFor: 'utilities' stamp: 'lr 6/12/2010 08:37'!assertCharacterSets: aParser	"Assert the character set of aParser does not overlap with the character set with the negated parser, and that they both cover the complete character space."	| positives negatives |	positives := self parsedCharacterSet: aParser.	negatives := self parsedCharacterSet: aParser negate.	self charactersDo: [ :char | 		| positive negative |		positive := positives includes: char.		negative := negatives includes: char.		self 			assert: ((positive and: [ negative not ])				or: [ positive not and: [ negative ] ])			description: char printString , ' should be in exactly one set' ]! !!PPPredicateTest methodsFor: 'private' stamp: 'lr 6/12/2010 08:37'!charactersDo: aBlock	1 to: 256 do: [ :index | aBlock value: (Character codePoint: index) ]! !!PPPredicateTest methodsFor: 'utilities' stamp: 'JamesFoster 2/20/2015 12:21'!parsedCharacterSet: aParser	| result |	result := WriteStream on: String new.	self charactersDo: [ :char |		(aParser matches: (char asString))			ifTrue: [ result nextPut: char ] ].	^ result contents! !!PPPredicateTest methodsFor: 'testing-objects' stamp: 'lr 11/29/2009 09:32'!testAny	| parser |	parser := #any asParser.	self assertCharacterSets: parser.	self assert: parser parse: ' ' to: $ .	self assert: parser parse: '1' to: $1.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''! !!PPPredicateTest methodsFor: 'testing-objects' stamp: 'tg 7/12/2010 11:26'!testAnyExceptAnyOf	| parser |	parser := PPPredicateObjectParser anyExceptAnyOf: #($: $,).	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ':'.	self assert: parser fail: ','! !!PPPredicateTest methodsFor: 'testing-objects' stamp: 'lr 6/12/2010 09:16'!testAnyOf	| parser |	parser := PPPredicateObjectParser anyOf: #($a $z).	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: 'x'! !!PPPredicateTest methodsFor: 'testing-objects' stamp: 'lr 6/12/2010 09:16'!testBetweenAnd	| parser |	parser := PPPredicateObjectParser between: $b and: $d.	self assertCharacterSets: parser.	self assert: parser fail: 'a'.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'c' to: $c.	self assert: parser parse: 'd' to: $d.	self assert: parser fail: 'e'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 5/5/2010 14:15'!testBlank	| parser |	parser := #blank asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character space) to: Character space.	self assert: parser parse: (String with: Character tab) to: Character tab.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: (String with: Character cr)! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 5/2/2010 12:51'!testChar	| parser |	parser := $* asParser.	self assertCharacterSets: parser.	self assert: parser parse: '*' to: $*.	self assert: parser parse: '**' to: $* end: 1.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'JanKurs 10/15/2014 13:13'!testCr	| parser |	parser := #cr asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: (Character codePoint: 13)) to: (Character codePoint: 13)! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testDigit	| parser |	parser := #digit asParser.	self assertCharacterSets: parser.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '9' to: $9.	self assert: parser fail: ''.	self assert: parser fail: 'a'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'JamesFoster 2/20/2015 12:22'!testEndOfFile	| parser |	parser := (#letter asParser / #blank asParser) star, #eof asParser.		self assert: parser parse: 'lorem ipsum'.		parser := #any asParser, #eof asParser, #any asParser star.	self assert: parser fail: 'a', Character cr asString, 'b'.	self assert: parser fail: Character cr asString , Character lf asString.	self assert: parser parse: 'a'.! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'JamesFoster 2/20/2015 12:22'!testEndOfLine	| cr crlf lf parser |	cr := Character cr asString.	crlf := Character cr asString , Character lf asString.	lf := Character lf asString.	parser := (#letter asParser / #blank asParser) star, #endOfLine asParser.		self assert: parser parse: 'lorem ipsum'.		parser := #any asParser, #endOfLine asParser, #any asParser star.	self assert: parser parse: 'a', cr, 'b'.	self assert: parser fail: crlf.	self assert: parser fail: 'lorem ipsum'.		parser := #endOfLine asParser, #any asParser, #endOfLine asParser negate star, #endOfLine asParser.	self assert: parser parse: cr, 'lorem ipsum'.	self assert: parser parse: lf, 'lorem ipsum'.		self assert: parser parse: crlf, 'lorem ipsum'.			self assert: parser parse: crlf.	self assert: parser parse: cr.	self assert: parser parse: lf.		parser := #endOfLine asParser negate star, #endOfLine asParser, #any asParser star.	self assert: parser parse: crlf, 'lorem ipsum'.	self assert: parser parse: crlf.! !!PPPredicateTest methodsFor: 'testing-objects' stamp: 'lr 6/12/2010 09:16'!testExpect	| parser |	parser := PPPredicateObjectParser expect: $a.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.	self assert: parser fail: ''! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testHex	| parser |	parser := #hex asParser.	self assertCharacterSets: parser.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '5' to: $5.	self assert: parser parse: '9' to: $9.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: 'D' to: $D.	self assert: parser parse: 'F' to: $F.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'e' to: $e.	self assert: parser parse: 'f' to: $f.	self assert: parser fail: ''.	self assert: parser fail: 'g'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testLetter	| parser |	parser := #letter asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'Z' to: $Z.	self assert: parser fail: ''.	self assert: parser fail: '0'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testLf	| parser |	parser := #lf asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character lf) to: Character lf! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testLowercase	| parser |	parser := #lowercase asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ''.	self assert: parser fail: 'A'.	self assert: parser fail: '0'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:36'!testNewline	| parser |	parser := #newline asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character cr) to: Character cr.	self assert: parser parse: (String with: Character lf) to: Character lf.	self assert: parser fail: ' '! !!PPPredicateTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 15:06'!testOnMessage	| block parser |	block := [ :char | char = $* ].	parser := PPPredicateObjectParser on: block message: 'starlet'.	self assert: parser block equals: block.	self assert: parser message equals: 'starlet'.	self assertCharacterSets: parser.	self assert: parser parse: '*' to: $*.	self		assert: parser		parse: '**'		to: $*		end: 1.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 5/5/2010 14:14'!testPunctuation	| parser |	parser := #punctuation asParser.	self assertCharacterSets: parser.	self assert: parser parse: '.' to: $..	self assert: parser parse: ',' to: $,.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: '1'! !!PPPredicateTest methodsFor: 'testing-sequence' stamp: 'Nicolasanquetil 5/3/2013 15:14'!testSequenceParser	| parser |	parser := PPPredicateSequenceParser		on: [ :value | value first isUppercase ]		message: 'uppercase 3 letter words'		size: 3.	self assert: parser size equals: 3.	self assert: parser parse: 'Abc'.	self assert: parser parse: 'ABc'.	self assert: parser parse: 'ABC'.	self assert: parser fail: 'abc'.	self assert: parser fail: 'aBC'.	self assert: parser fail: 'Ab'.	parser := parser negate.	self assert: parser size equals: 3.	self assert: parser fail: 'Abc'.	self assert: parser fail: 'ABc'.	self assert: parser fail: 'ABC'.	self assert: parser parse: 'abc'.	self assert: parser parse: 'aBC'.	self assert: parser fail: 'Ab'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testSpace	| parser |	parser := #space asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character tab) to: Character tab.	self assert: parser parse: ' ' to: Character space.	self assert: parser fail: ''.	self assert: parser fail: 'a'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'JamesFoster 2/20/2015 12:23'!testStartOfLine	| cr crlf lf parser |	cr := Character cr asString.	crlf := Character cr asString , Character lf asString.	lf := Character lf asString.	parser := #startOfLine asParser, #any asParser star.		self assert: parser parse: 'lorem ipsum'.		parser := #any asParser, #startOfLine asParser, #any asParser star.	self assert: parser fail: 'lorem ipsum'.		parser := #startOfLine asParser, #any asParser, #startOfLine asParser, #any asParser star.	self assert: parser parse: cr, 'lorem ipsum'.	self assert: parser parse: lf, 'lorem ipsum'.		self assert: parser fail: crlf, 'lorem ipsum'.			self assert: parser fail: crlf.	self assert: parser parse: cr.	self assert: parser parse: lf.		parser := #startOfLine asParser, #any asParser, #any asParser, #startOfLine asParser, #any asParser star.	self assert: parser parse: crlf, 'lorem ipsum'.	self assert: parser parse: crlf.! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'JanKurs 1/2/2015 18:34'!testStartOfLogicalLine	| parser |	parser := #startOfLogicalLine asParser, #any asParser star.		self assert: parser parse: 'lorem'.	self assert: parser fail: ' lorem'.		parser := #any asParser, #startOfLogicalLine asParser, #any asParser star.	self assert: parser fail: 'lorem'.	self assert: parser fail: '        lorem'.	self assert: parser parse: ' lorem'.	self assert: parser parse: '	lorem'.! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'JanKurs 1/6/2015 14:00'!testStartOfWord	| parser |	parser := #startOfWord asParser, #word asParser plus.		self assert: parser parse: 'lorem'.		parser := #any asParser, #startOfWord asParser, #word asParser plus.	self assert: parser fail: 'lorem'.	self assert: parser fail: '1234'.		self assert: parser parse: ' lorem'.		self assert: parser parse: ' 123'.	self assert: parser parse: ')lorem'.	self assert: parser parse: ':lorem'.		parser := #startOfWord asParser, #any asParser optional.	self assert: parser fail: ''.	self assert: parser parse: 'a'.	self assert: parser fail: '.'.! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testTab	| parser |	parser := #tab asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character tab) to: Character tab! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testUppercase	| parser |	parser := #uppercase asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: 'Z' to: $Z.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: '0'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testWord	| parser |	parser := #word asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: '0' to: $0.	self assert: parser fail: ''.	self assert: parser fail: '-'! !!PPScriptingTest methodsFor: 'examples' stamp: 'JanKurs 10/15/2014 13:14'!expressionInterpreter	"Same as #expressionInterpreter but with semantic actions."		| mul prim add dec |	add := PPUnresolvedParser new.	mul := PPUnresolvedParser new.	prim := PPUnresolvedParser new.	dec := ($0 to: $9) asParser ==> [ :token | token codePoint - $0 codePoint ].	add def: ((mul , $+ asParser , add) ==> [ :nodes | (nodes at: 1) + (nodes at: 3) ])		/ mul.	mul def: ((prim , $* asParser , mul) ==> [ :nodes | (nodes at: 1) * (nodes at: 3) ])		/ prim.	prim def: (($( asParser , add , $) asParser) ==> [ :nodes | nodes at: 2 ])		/ dec.	^ add end! !!PPScriptingTest methodsFor: 'examples' stamp: 'JanKurs 10/15/2014 15:12'!expressionParser	"Simple demo of scripting an expression parser."		| mul prim add dec |	add := PPUnresolvedParser new.	mul := PPUnresolvedParser new.	prim := PPUnresolvedParser new.	dec := ($0 to: $9) asParser.	add def: (mul , $+ asParser , add)		/ mul.	mul def: (prim , $* asParser , mul)		/ prim.	prim def: ($( asParser , add , $) asParser)		/ dec.	^ add end! !!PPScriptingTest methodsFor: 'examples' stamp: 'JanKurs 10/15/2014 15:13'!straightLineParser	| goal stm stmList id char dec exp expList mulExp primExp nonzero num lower upper |	goal := PPUnresolvedParser new.	stmList := PPUnresolvedParser new.	stm := PPUnresolvedParser new.	exp := PPUnresolvedParser new.	expList := PPUnresolvedParser new.	mulExp := PPUnresolvedParser new.	primExp := PPUnresolvedParser new.		lower := ($a to: $z) asParser.	upper := ($A to: $Z) asParser.	char := lower / upper.	nonzero := ($1 to: $9) asParser.	dec := ($0 to: $9) asParser.	id := char, ( char / dec ) star.	num := $0 asParser / ( nonzero, dec star).	goal def: stmList end.	stmList def: stm , ( $; asParser, stm ) star.	stm def: ( id, ':=' asParser, exp )		/ ( 'print' asParser, $( asParser, expList, $) asParser ). 	exp def: mulExp, ( ( $+ asParser / $- asParser ), mulExp ) star.	expList def: exp, ( $, asParser, exp ) star.	mulExp def: primExp, ( ( $* asParser / $/ asParser ), primExp ) star.	primExp def: id		/ num		/ ( $( asParser, stmList, $, asParser, exp, $) asParser ).	^ goal! !!PPScriptingTest methodsFor: 'tests' stamp: 'lr 6/12/2010 08:31'!testExpressionInterpreter	self 		assert: self expressionInterpreter		parse: '2*(3+4)'		to: 14! !!PPScriptingTest methodsFor: 'tests' stamp: 'lr 6/12/2010 08:31'!testExpressionParser	self		assert: self expressionParser		parse: '2*(3+4)'		to: #($2 $* ($( ($3 $+ $4) $)))! !!PPScriptingTest methodsFor: 'tests' stamp: 'lr 9/17/2008 22:44'!testSLassign		self assert: self straightLineParser		parse: 'abc:=1'		to: #(#($a #($b $c) ':=' #(#(#($1 #()) #()) #())) #())! !!PPScriptingTest methodsFor: 'tests' stamp: 'lr 6/12/2010 08:27'!testSLprint	self 		assert: self straightLineParser		parse: 'print(3,4)'		to: #(('print' $( ((($3 ()) ()) () (($, ((($4 ()) ()) ())))) $)) ())! !!PPTokenTest methodsFor: 'accessing' stamp: 'lr 4/3/2009 08:51'!identifier	^ #word asParser plus token! !!PPTokenTest methodsFor: 'utilities' stamp: 'lr 3/29/2010 15:34'!parse: aString using: aParser	^ aParser parse: aString! !!PPTokenTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 15:15'!testCollection	| input result |	input := 'foo    '.	result := self parse: input using: self identifier.	self assert: result collection equals: input.	self assert: result collection == input! !!PPTokenTest methodsFor: 'testing-querying' stamp: 'JanKurs 10/15/2014 15:16'!testColumn	| input parser result |	input := '1' , (String with: (Character codePoint: 13)) , '12' , (String with: (Character codePoint: 13) with: (Character codePoint: 10)) , '123'		, (String with: (Character codePoint: 10)) , '1234'.	parser := #any asParser token star.	result := parser parse: input.	result with: #(1 2 1 2 3 4 1 2 3 4 1 2 3 4) do: [ :token :line | self assert: token column equals: line ]! !!PPTokenTest methodsFor: 'testing-copying' stamp: 'Nicolasanquetil 5/3/2013 15:08'!testCopyFromTo	| result other |	result := PPToken on: 'abc'.	other := result copyFrom: 2 to: 2.	self assert: other size equals: 1.	self assert: other start equals: 2.	self assert: other stop equals: 2.	self assert: other collection equals: result collection! !!PPTokenTest methodsFor: 'testing-comparing' stamp: 'Nicolasanquetil 5/3/2013 15:16'!testEquality	| token1 token2 |	token1 := self parse: 'foo' using: self identifier.	token2 := self parse: 'foo' using: self identifier.	self deny: token1 == token2.	self assert: token1 equals: token2.	self assert: token1 hash equals: token2 hash! !!PPTokenTest methodsFor: 'testing' stamp: 'lr 2/26/2013 02:50'!testInitialize	PPToken initialize! !!PPTokenTest methodsFor: 'testing-values' stamp: 'Nicolasanquetil 5/3/2013 15:00'!testInputValue	| input result |	input := 'foo'.	result := self parse: input using: self identifier.	self assert: result inputValue equals: input.	self deny: result inputValue == input! !!PPTokenTest methodsFor: 'testing-querying' stamp: 'JanKurs 10/30/2014 12:52'!testLine	| input parser result |	input := '1' , (String with: (Character codePoint: 13)) , '12' , (String with: (Character codePoint: 13) with: (Character codePoint: 10)) , '123'		, (String with: (Character codePoint: 10)) , '1234'.	parser := #any asParser token star.	result := parser parse: input.	result with: #(1 1 2 2 2 2 3 3 3 3 4 4 4 4) do: [ :token :line | self assert: token line equals: line ]! !!PPTokenTest methodsFor: 'testing' stamp: 'lr 4/14/2010 11:44'!testNew	self should: [ PPToken new ] raise: Error.	! !!PPTokenTest methodsFor: 'testing-values' stamp: 'Nicolasanquetil 5/3/2013 15:16'!testParsedValue	| input result |	input := 'foo'.	result := self parse: input using: self identifier.	self assert: result parsedValue equals: #($f $o $o)! !!PPTokenTest methodsFor: 'testing' stamp: 'JamesFoster 2/20/2015 11:35'!testPrinting	| result |	result := PPToken on: 'var'.	self assert: result printString includesSubstring: 'PPToken[1,3]'! !!PPTokenTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 15:01'!testSize	| result |	result := self parse: 'foo' using: self identifier.	self assert: result size equals: 3! !!PPTokenTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 15:10'!testStart	| result |	result := self parse: 'foo' using: self identifier.	self assert: result start equals: 1! !!PPTokenTest methodsFor: 'testing' stamp: 'Nicolasanquetil 5/3/2013 15:17'!testStop	| result |	result := self parse: 'foo' using: self identifier.	self assert: result stop equals: 3! !!PPTokenTest methodsFor: 'testing' stamp: 'lr 2/26/2013 02:49'!testValue	| result |	result := PPToken on: 'var'.	self should: [ result value ] raise: Notification! !!PPContextMementoTest methodsFor: 'accessing' stamp: 'JanKurs 8/26/2014 13:55'!memento	^ PPContextMemento new! !!PPContextMementoTest methodsFor: 'running' stamp: 'JamesFoster 2/20/2015 12:03'!setUp	super setUp.	memento := self memento.! !!PPContextMementoTest methodsFor: 'tests' stamp: 'JanKurs 8/28/2014 10:26'!testEquality	| m1 m2  |	m1 := self memento.	m2 := self memento.		self assert: m1 = m2.		m1 propertyAt: #foo put: #bar.	self assert: (m1 = m2) not.		m2 propertyAt: #foo put: #bar.	self assert: m1 = m2.! !!PPContextMementoTest methodsFor: 'tests' stamp: 'JanKurs 8/28/2014 10:26'!testEquality2	| m1 m2  |	m1 := self memento.	m2 := self memento.		self assert: m1 = m2.		m1 propertyAt: #foo put: #bar.	self assert: (m1 = m2) not.		m2 propertyAt: #bar put: #foo.	self assert: (m1 = m2) not.! !!PPContextMementoTest methodsFor: 'tests' stamp: 'JanKurs 8/28/2014 10:27'!testGetProperty		| c retval retval2 |	c := OrderedCollection new.		memento propertyAt: #foo put: c.		retval := memento propertyAt: #foo.	self assert: retval size = c size.	self assert: (retval == c) not.	self assert: retval = c.		c add: #element.	self assert: (retval = c) not.	retval2 := memento propertyAt: #foo.	self assert: (retval = retval2).	self assert: (retval == retval2) not.		retval add: #element.	self assert: (retval = retval2) not.! !!PPContextMementoTest methodsFor: 'tests' stamp: 'JanKurs 8/26/2014 15:43'!testKeysAndValuesDo	|   |	memento keysAndValuesDo: [ :key :value |		self signalFailure: 'Should not be called'	].! !!PPContextMementoTest methodsFor: 'tests' stamp: 'JanKurs 8/26/2014 15:43'!testKeysAndValuesDo2	| c1 c2   |	c1 := OrderedCollection new.	c2 := OrderedCollection new.	memento propertyAt: #foo put: c1.	memento propertyAt: #bar put: c2.	memento keysAndValuesDo: [ :key :value |		self assert: (value == c1) not.		self assert: (value == c2) not.	].! !!PPContextMementoTest methodsFor: 'tests' stamp: 'JanKurs 9/13/2014 21:49'!testPutProperty	| c retval  |	c := OrderedCollection new.	self assert: (memento hasProperty: #foo) not.	self assert: (memento hasProperty: #bar) not.			self should: [ memento propertyAt: #foo ] raise: Error.	self assert: (memento propertyAt: #foo ifAbsent: [ c ]) == c.		retval := memento propertyAt: #foo ifAbsentPut: [ c ].	self assert: retval size = c size.		self assert: (retval == c) not.	self assert: retval = c.	self assert: (memento hasProperty: #foo).		retval := memento propertyAt: #bar put: c.	self assert: retval size = c size.		self assert: (retval == c) not.	self assert: retval = c.	self assert: (memento hasProperty: #foo).	! !!PPContextTest methodsFor: 'as yet unclassified' stamp: 'JanKurs 8/26/2014 11:58'!context	^ PPContext new! !!PPContextTest methodsFor: 'as yet unclassified' stamp: 'JamesFoster 2/20/2015 13:14'!setUp	super setUp.	context := self context.! !!PPContextTest methodsFor: 'tests' stamp: 'JanKurs 8/26/2014 12:24'!testFurthestFailure	| f1 f2 |		f1 := PPFailure message: #foo context: context at: 1.	self assert: context furthestFailure = f1.		f2 := PPFailure message: #foo context: context at: 1.	self assert: context furthestFailure = f1.		f2 := PPFailure message: #foo context: context at: 3.	self assert: context furthestFailure = f2.! !!PPContextTest methodsFor: 'tests' stamp: 'JanKurs 8/26/2014 17:11'!testMemoization	| stream memento memento2 collection |	stream := 'abc' asPetitStream.	context := context stream: stream.	collection := OrderedCollection new.	context propertyAt: #foo put: collection.		memento := context remember.		self assert: memento isNil not.		context next.	collection add: #element.	self assert: (context propertyAt: #foo) size = 1. 		memento2 := context remember.	context restore: memento.	self assert: (context propertyAt: #foo) size = 0. 	self assert: context position = 0.		context restore: memento2.	self assert: (context propertyAt: #foo) size = 1. 	self assert: context position = 1.! !!PPContextTest methodsFor: 'tests' stamp: 'JanKurs 8/26/2014 14:58'!testMemoization2	| stream memento |	stream := 'abc' asPetitStream.	context := context stream: stream.		memento := context remember.		context next.	self assert: context position = 1.		context restore: memento.	self assert: context position = 0.! !!PPContextTest methodsFor: 'tests' stamp: 'JanKurs 11/4/2014 17:15'!testMemoization3	| stream memento memento2 collection |	stream := 'abc' asPetitStream.	context := context stream: stream.	collection := OrderedCollection new.	memento := context remember.	context propertyAt: #foo put: collection.	memento2 := context remember.		context restore: memento.	self assert: (context hasProperty: #foo) not.		context restore: memento2.	self assert: (context hasProperty: #foo).! !!PPContextTest methodsFor: 'tests' stamp: 'JanKurs 9/13/2014 18:23'!testPutGlobals	self assert: (context hasGlobal: #foo) not.	self assert: (context hasGlobal: #bar) not.			self should: [ context globalAt: #foo ] raise: Error.	self assert: (context globalAt: #foo ifAbsent: [ #bar ]) = #bar.		self assert: (context globalAt: #foo ifAbsentPut: [ #bar ]) = #bar.		self assert: (context hasGlobal: #foo).	self assert: (context hasGlobal: #bar) not.		self assert: (context globalAt: #foo) = #bar.		self assert: (context globalAt: #foo ifAbsentPut: [ #zorg ]) = #bar.		self assert: (context hasGlobal: #foo).	self assert: (context hasGlobal: #bar) not.		self assert: (context globalAt: #foo) = #bar.		self assert: (context globalAt: #foo put: #zorg) = #zorg.		self assert: (context hasGlobal: #foo).	self assert: (context hasGlobal: #bar) not.		self assert: (context globalAt: #foo) = #zorg.		self should: [ context globalAt: #bar ] raise: Error.	self assert: (context globalAt: #bar put: #foo) = #foo.	self assert: (context globalAt: #foo) = #zorg.	self assert: (context globalAt: #bar) = #foo.! !!PPContextTest methodsFor: 'tests' stamp: 'JanKurs 9/13/2014 18:22'!testPutProperties	self assert: (context hasProperty: #foo) not.	self assert: (context hasProperty: #bar) not.			self should: [ context propertyAt: #foo ] raise: Error.	self assert: (context propertyAt: #foo ifAbsent: [ #bar ]) = #bar.		self assert: (context propertyAt: #foo ifAbsentPut: [ #bar ]) = #bar.		self assert: (context hasProperty: #foo).	self assert: (context hasProperty: #bar) not.		self assert: (context propertyAt: #foo) = #bar.		self assert: (context propertyAt: #foo ifAbsentPut: [ #zorg ]) = #bar.		self assert: (context hasProperty: #foo).	self assert: (context hasProperty: #bar) not.		self assert: (context propertyAt: #foo) = #bar.		self assert: (context propertyAt: #foo put: #zorg) = #zorg.		self assert: (context hasProperty: #foo).	self assert: (context hasProperty: #bar) not.		self assert: (context propertyAt: #foo) = #zorg.		self should: [ context propertyAt: #bar ] raise: Error.	self assert: (context propertyAt: #bar put: #foo) = #foo.	self assert: (context propertyAt: #foo) = #zorg.	self assert: (context propertyAt: #bar) = #foo.! !!PPContextTest methodsFor: 'tests' stamp: 'JanKurs 9/13/2014 18:23'!testRemoveGlobals	context globalAt: #foo put: #zorg.	context globalAt: #bar put: #qwark.		self assert: (context removeGlobal: #foo) = #zorg.	self assert: (context removeGlobal: #bar) = #qwark.		self should: [context removeGlobal: #foo] raise: Error.	self assert: (context removeGlobal: #bar ifAbsent: [ #foobar ]) = #foobar.! !!PPContextTest methodsFor: 'tests' stamp: 'JanKurs 9/13/2014 18:23'!testRemoveProperties	context propertyAt: #foo put: #zorg.	context propertyAt: #bar put: #qwark.		self assert: (context removeProperty: #foo) = #zorg.	self assert: (context removeProperty: #bar) = #qwark.		self should: [context removeProperty: #foo] raise: Error.	self assert: (context removeProperty: #bar ifAbsent: [ #foobar ]) = #foobar.! !!PPContextTest methodsFor: 'tests' stamp: 'JanKurs 8/26/2014 12:08'!testStreamProtocol	context stream: 'hi there' asPetitStream.		self assert: context position = 0.	self assert: context peek = $h.	self assert: context uncheckedPeek = $h.	self assert: context next = $h.	self assert: context peek = $i.	self assert: context uncheckedPeek = $i.	self assert: context position = 1.		context skip: 2.	self assert: context position = 3.	self assert: context peek = $t.	self assert: context atEnd not.		self assert: (context next: 5) = 'there'.	self assert: context position = 8.	self assert: context atEnd.! !!BlockClosure methodsFor: '*petitparser-core-converting' stamp: 'lr 11/29/2011 20:48'!asParser	"Answer a parser implemented in the receiving one-argument block."	^ PPPluggableParser on: self! !!Collection methodsFor: '*petitparser-core-converting' stamp: 'lr 11/29/2011 20:38'!asChoiceParser	^ PPChoiceParser withAll: (self collect: [ :each | each asParser ])! !!Collection methodsFor: '*petitparser-converting' stamp: 'JanKurs 10/15/2014 15:50'!asParser    	"Create a range of characters between start and stop."	(self allSatisfy: [ :e | e isCharacter ]) ifTrue: [ 		| charSet |		charSet := PPCharSetPredicate on: [ :char | self includes: char ] .     	^ PPPredicateObjectParser on: charSet message: 'One of these charactes expected: ', self printString.	].	^ super asParser	"		($a to:$f) asParser parse:'a'		($a to:$f) asParser parse:'g'	"! !!Collection methodsFor: '*petitparser-core-converting' stamp: 'lr 11/29/2011 20:38'!asSequenceParser	^ PPSequenceParser withAll: (self collect: [ :each | each asParser ])! !"PetitParser"!"PetitTests"!!PRTParametrizable commentStamp: 'DamienCassou 4/3/2015 14:12' prior: 0!I'm a trait that proposes parameter-related methods.!!PRMagritteDictionaryReader commentStamp: 'CyrilFerlicot 6/30/2015 14:45' prior: 0!I read a dictionary which the values are all strings and I return a new dictionary with the descriptions of an annotation.dictionary is my input dictionary.annotationDictionary is the new dictionary I'm building.class is the class of the annotation.!!PRError commentStamp: 'TorstenBergmann 3/5/2015 22:09' prior: 0!General Pillar error!!PRInputFileError commentStamp: 'CyrilFerlicot 4/9/2015 13:11' prior: 0!An inclusion error during an inclusion of file.!!PRPropertyError commentStamp: 'TorstenBergmann 3/5/2015 22:09' prior: 0!A Pillar property error!!PRSyntaxError commentStamp: 'CyrilFerlicot 4/22/2015 14:23' prior: 0!An error about syntax!!PRWarning commentStamp: 'TorstenBergmann 3/5/2015 22:12' prior: 0!A Pillar warning!!PRLinkWarning commentStamp: 'CyrilFerlicot 5/21/2015 10:01' prior: 0!I am a warning raised when a we have a problem with a link at the export.!!PRReferenceNotFound commentStamp: '<historical>' prior: 0!I am a warning raised when a reference is not found during the resolution phase!!PRMagrittePathDescription commentStamp: 'CyrilFerlicot 6/30/2015 15:10' prior: 0!I am a magritte description of a Path.!!PRBasicObject commentStamp: 'DamienCassou 2/28/2014 09:39' prior: 0!I provide nothing but I'm here to (hopefully) facilitate portability with multiple Smalltalks.!!PRObject commentStamp: 'jf 9/18/2009 15:47' prior: 0!I am a superclass of most objects within Pier. I hold a dictionary of properties, so that users can easily annotate me with new values. I am visitable.!!PRAbstractScriptLanguage commentStamp: 'DamienCassou 2/28/2014 09:41' prior: 0!I represent a programming language that can be referenced from a PRScript to get syntax highlighting.!!PRNoScriptLanguage commentStamp: 'DamienCassou 2/28/2014 09:41' prior: 0!I'm here for authors to specify they don't want syntax highlighting in their scripts.!!PRRealScriptLanguage commentStamp: 'TorstenBergmann 3/5/2015 22:02' prior: 0!Superclass for existing real scripting languages!!PRBashScriptLanguage commentStamp: 'TorstenBergmann 3/5/2015 22:02' prior: 0!Bash scripting language!!PRCSSScriptLanguage commentStamp: 'TorstenBergmann 3/5/2015 22:03' prior: 0!Cascading stylesheet language!!PRHTMLScriptLanguage commentStamp: 'TorstenBergmann 3/5/2015 22:03' prior: 0!Hypertext markup language!!PRHTTPScriptLanguage commentStamp: 'TorstenBergmann 3/5/2015 22:03' prior: 0!General HTTP script language!!PRJSONScriptLanguage commentStamp: 'TorstenBergmann 3/5/2015 22:03' prior: 0!JSON!!PRJavaScriptScriptLanguage commentStamp: 'TorstenBergmann 3/5/2015 22:04' prior: 0!JavaScript language!!PRSQLScriptLanguage commentStamp: 'TorstenBergmann 3/5/2015 22:04' prior: 0!SQL!!PRSTONScriptLanguage commentStamp: 'TorstenBergmann 3/5/2015 22:04' prior: 0!STON (Smalltalk Object Notation)!!PRShellCommandsScriptLanguage commentStamp: '' prior: 0!A PRBashScriptLanguage is xxxxxxxxx.!!PRSmalltalkScriptLanguage commentStamp: 'TorstenBergmann 3/5/2015 22:04' prior: 0!Smalltalk !!PRUnspecifiedScriptLanguage commentStamp: 'TorstenBergmann 3/5/2015 22:05' prior: 0!An unspecified script language!!PRUnsupportedScriptLanguage commentStamp: 'TorstenBergmann 3/5/2015 22:05' prior: 0!An unsupported script language!!PRDocumentItem commentStamp: 'CyrilFerlicot 10/28/2015 22:37' prior: 0!I am an abstract superclass for the document hierarchy. My subclasses include all the basic elements to represent a document.Description----------------------------Most of the time I will be use by a visitor that will visit me. Each of my subclasses can have his own visitor.I usually am contain inside a PRDocumentGroup at the exception of PRDocument.Public API and Key Messages----------------------------- #parser    This class method return the default parser for this document model.Example----------------------------I am an abstract class. I should not be use directly.Internal Representation and Key Implementation Points.----------------------------    Instance Variables	counter:		I am a counter use by some document items. Maybe I can be improve because not all items need a counter.!!PRAbstractAnnotation commentStamp: 'CyrilFerlicot 10/28/2015 22:53' prior: 0!I am an abstract class to represent an open-ended syntax for special text.Description----------------------------I allow to extend easily the syntax of Pillar. I am contained inside a PRDocumentGroup. I am define by a tag and I can have some parameters.Public API and Key Messages----------------------------- #tag    This class method define the tag of an annotation.- #parameters: aCollection    This class method is the constructor of an annotation. This method take a dictionary of parameters.Example ----------------------------I am an abstract class, I should not be use directly.Internal Representation and Key Implementation Points.----------------------------    Instance Variables	hadAllKeys:		I am a boolean. I  know if all the parameters write by the user had a key or if one didn't had a key. To export the document, this is useless except for the Pillar writer.	parameters:		I  keep all the parameters of the annotation with a key and a value.			The name at the begining of each annote is called the tag (e.g., 'index', 'note', 'cite'). The tag is followed by a series of associations (key/value pairs).Todo------------------------- ${todo} to represent a position in the text where things must be changed- ${note:value=some text}$ (equivalent to previous one) (the default value= works the same as for Java annotations);- ${index:AClass}$ to add AClass to the document index;- ${cite:Duca99b}$ to reference a particular item of a bibliography;- ${cite:value=Duca99b|page=90}$ (equivalent to previous one but additionaly specifies a page number;- ${background:file://foobar.png}$ to specify the background of the current section;- ${toc:maxLevel=2}$ to show a table of content with only level 1 and 2 section headings.- ${note:some text with a curly brace \} inside}$ (shows how to escape a curly brace).!!PRCitationAnnotation commentStamp: 'ThibaultArloing 5/3/2016 15:59' prior: 0!I am an annotation that mark a citation.My tag is: 'cite'.I can have in parameter:- a ref with the key "ref=" (required, you can write it without the key, take a reference in the LaTeX bib format)Examples: ${cite:foo}$${cite:ref=foo}$!!PRColumnAnnotation commentStamp: 'CyrilFerlicot 6/30/2015 15:47' prior: 0!I am an annotation that mark the beginning of a new column.My tag is: 'column''.I can have in parameter:- a wodth with the key "width=" (required, you can write it without the key, take an integer between 0 and 100)Examples: ${column:50}$${column:width=50}$!!PRColumnsAnnotation commentStamp: 'CyrilFerlicot 6/30/2015 15:48' prior: 0!I am an annotation that mark the beginning of a columns environement.My tag is: 'columns''.Example: ${columns}$!!PREndColumnsAnnotation commentStamp: 'CyrilFerlicot 6/30/2015 15:48' prior: 0!I am an annotation that mark the end of a columns environement.My tag is: 'endColumns''.Example: ${endColumns}$!!PRFootnoteAnnotation commentStamp: 'YannDubois 5/3/2016 15:59' prior: 0!I am an annotation that mark a footnoteMy tag is 'footnote'My parameters are :- note=aString !!PRIndexAnnotation commentStamp: 'DamienCassou 4/3/2015 17:25' prior: 0!Add a word to the document index.!!PRInputFileAnnotation commentStamp: 'CyrilFerlicot 6/30/2015 14:59' prior: 0!I include a reference to a pillar file. With me we can add a transformation to remplace an annotation to a pillar file by his tree.My tag is: 'inputFile''.I can have in parameter:- a path to a file with the key "value=" (required, you can write it without the key)Examples: ${inputFile:myFile.pillar}$${inputFile:value=directory/myFile.pillar}$!!PRSlideTitleAnnotation commentStamp: 'CyrilFerlicot 6/30/2015 14:36' prior: 0!I'm an annotation use to create a new Slide for a Slider exporter. My tag is: 'slide''.I can have in parameter:- a title with the key "title=" (required, you can write it without the key)- a label if you want to create a reference to this slide (optional)Examples: ${slide:Introduction|label=sld:intro}$${slide:title=Presentation}$${slide:title=Conclusion|label=sld:ccl}$!!PRTocAnnotation commentStamp: 'CyrilFerlicot 6/30/2015 15:51' prior: 0!I'm an annotation use to generate some Table of contents. My tag is: 'toc''.I have this form : ${toc:depthLevel=x|level=y|highlight=true}$The depthLevel is use to know the min level of title i need to use. I'll not print title lower than it.The level is use to know what i need to print. I stay on the section x-1 and I stop at the next y title.Highlight allow to highlight the current section (this might be vanish in the futur).Example:${toc:depthLevel=5|level=3|highlight=true}$!!PRAnchor commentStamp: 'lr 5/29/2006 09:30' prior: 0!I am an anchor within a document. I am used as a reference point within a large document.!!PRCitation commentStamp: 'ThibaultArloing 5/3/2016 15:59' prior: 0!I am a citation.!!PRDocumentGroup commentStamp: 'lr 5/28/2006 20:33' prior: 0!I am an abstract group of document items.!!PRColumn commentStamp: 'CyrilFerlicot 6/18/2015 10:37' prior: 0!I am a column.!!PRColumns commentStamp: 'CyrilFerlicot 6/18/2015 10:38' prior: 0!I am a columns environment.!!PRDocument commentStamp: 'lr 5/28/2006 21:06' prior: 0!I am the root of a document composite.!!PRFormat commentStamp: 'TorstenBergmann 3/5/2015 21:59' prior: 0!A styling format !!PRBoldFormat commentStamp: 'TorstenBergmann 3/5/2015 22:00' prior: 0!Bold styling format!!PRItalicFormat commentStamp: 'TorstenBergmann 3/5/2015 21:59' prior: 0!Italic styling format!!PRMonospaceFormat commentStamp: 'TorstenBergmann 3/5/2015 22:00' prior: 0!Monospace styling!!PRStrikethroughFormat commentStamp: 'TorstenBergmann 3/5/2015 22:00' prior: 0!Strikethrough format!!PRSubscriptFormat commentStamp: 'TorstenBergmann 3/5/2015 22:00' prior: 0!Style as subscript!!PRSuperscriptFormat commentStamp: 'TorstenBergmann 3/5/2015 22:00' prior: 0!Style as superscript!!PRUnderlineFormat commentStamp: 'TorstenBergmann 3/5/2015 22:01' prior: 0!Style as underline formatted!!PRHeader commentStamp: 'lr 5/28/2006 20:34' prior: 0!I represent a header within a document. My level is a natural number.!!PRList commentStamp: 'lr 5/28/2006 20:55' prior: 0!I am an abstract list. My children are instances of *PRListItem*.!!PRDefinitionList commentStamp: 'lr 12/30/2007 19:44' prior: 0!I am an definition list. I am typically used for a keyword and a longer definition string.!!PROrderedList commentStamp: 'lr 5/28/2006 20:53' prior: 0!I am an ordered list. I am typically used for numbered items.!!PRUnorderedList commentStamp: 'lr 5/28/2006 20:53' prior: 0!I am an unordered list. I am typically used for unnumbered lists!!PRListItem commentStamp: 'lr 6/2/2006 11:26' prior: 0!I am a item within a *PRList*.!!PRDataItem commentStamp: 'TorstenBergmann 3/5/2015 22:01' prior: 0!Data in a list!!PRTermItem commentStamp: 'TorstenBergmann 3/5/2015 22:01' prior: 0!A term!!PRParagraph commentStamp: 'lr 5/28/2006 20:54' prior: 0!I am a paragraph of text.!!PRAnnotatedParagraph commentStamp: 'TorstenBergmann 3/5/2015 22:01' prior: 0!An annotated paragraph!!PREmptyParagraph commentStamp: 'TorstenBergmann 3/5/2015 22:01' prior: 0!An empty paragraph!!PRPreformatted commentStamp: 'lr 5/28/2006 20:56' prior: 0!I am preformatted text or source code. My children are instances of *PRText*.!!PRReference commentStamp: 'CyrilFerlicot 4/28/2015 10:49' prior: 0!I'm a reference. I can be a Link or a Figure. Later i could be a video for example.!!PRFigure commentStamp: 'DamienCassou 9/6/2015 10:27' prior: 0!I'm a Figure, i can have a label in parameter. My alias (coming from the superclass) represents the figure caption!!PRLink commentStamp: 'lr 5/28/2006 21:02' prior: 0!I am an abstract link built from an alias and a reference. The alias is the string representation that will be displayed to the user, whereas the reference is a string identifying the target. If there is no alias, the reference itself is displayed. Links can try to embed the referenced target into the containing document.!!Examples=*Reference*=+Alias>Embedded Reference*!!PRExternalLink commentStamp: 'CyrilFerlicot 4/28/2015 15:31' prior: 0!I am an external link with an URL (Uniform Resource Locator) as reference.!!PRMailLink commentStamp: 'lr 6/2/2006 11:29' prior: 0!I am an external link pointing to a mail address. I encode my URL to prevent spam bots collecting the address.!!PRSemanticLink commentStamp: 'LukasKomarek 4/21/2016 15:21' prior: 0!I am an abstract class of some that represents a link to a well known web site such as Wikipedia or Youtube.!!PRWikipediaSemLink commentStamp: 'LukasKomarek 4/21/2016 15:23' prior: 0!I am an external link with a link that is translatable to a url pointing to a Wikipedia page.!!PRYoutubeSemLink commentStamp: 'LukasKomarek 4/21/2016 15:23' prior: 0!I am an external link with a link that is translatable to a url pointing to a Youtube page.!!PRInternalLink commentStamp: 'lr 4/10/2007 21:12' prior: 0!I am an internal link pointing to a structure within the current kernel. I reference my owning structure to be able to lookup the referenced structure. The referenced structure is cached in the instance variable ==target==.!!PRSection commentStamp: 'CyrilFerlicot 6/2/2015 16:59' prior: 0!I'm a section. I'm here to add a structure to the document.!!PRSlide commentStamp: 'CyrilFerlicot 6/5/2015 16:37' prior: 0!I am a slide. I am here to structure a document that will be export as a Slide prensentation. (PRBeamerExporter, PRDeckJSExporter...).title is the title of the slide.the label is a way to create a link to this slinde on the slider.!!PRTable commentStamp: 'lr 5/28/2006 20:56' prior: 0!I am a table. My children are instances of *PRTableRow*.!!PRTableCell commentStamp: 'lr 5/28/2006 20:57' prior: 0!I am a cell of a table.!!PRTableRow commentStamp: 'lr 5/28/2006 20:56' prior: 0!I am a row of a table. My children are instances of *PRTableCell*.!!PRFootnote commentStamp: 'YannDubois 5/3/2016 10:08' prior: 0!I am a footnote, you can create me with :noted: aStringIt create a footnote with note specified in parameter.!!PRHorizontalRule commentStamp: 'lr 5/28/2006 20:57' prior: 0!I am a horizontal rule.!!PRLineBreak commentStamp: 'lr 9/14/2009 08:31' prior: 0!I am a line break. I only show up in the wiki format.!!PRStructure commentStamp: 'ThibaultArloing 5/4/2016 17:05' prior: 0!I am a structure representation.!!PRText commentStamp: 'lr 5/28/2006 20:58' prior: 0!I am a plain text. I am the most important leaf node of the document composite.!!PRCommentedLine commentStamp: 'TorstenBergmann 3/5/2015 22:01' prior: 0!A commented line!!PRRaw commentStamp: '<historical>' prior: 0!I represent a text that is not parsed/analyzed at all. I can have a type to limit the kind of output with which I'm associated. For example, an instance of me with type 'html' will only be written to HTML documents.I'm particularly useful when the rest of Pillar can't represent something you *really* want in your output: for example, an equation. In this case, you can describe your equation in latex using an instance of me of type latex and a picture everywhere else.!!PRScript commentStamp: 'TorstenBergmann 3/5/2015 22:02' prior: 0!An embedded script!!PRStructureRenderer commentStamp: '<historical>' prior: 0!I am a render class for Structures.!!PRDefinitionListRenderer commentStamp: '<historical>' prior: 0!I render structures as a Definition List.!!PRTableRenderer commentStamp: '<historical>' prior: 0!I render Structures as a Table!!PRVisitor commentStamp: 'lr 6/2/2006 11:55' prior: 0!I am an abstract visitor. I provide a default implementation of all visit messages that does not descend automatically into children of the visited graph. Subclasses should override all my messages in appropriate ways to visit the nodes they need.!!PRFileDependencies commentStamp: 'YannDubois 4/25/2016 16:47' prior: 0!I am a vistitor which visit the document and return all file dependencies of this document.!!PRImageDependencies commentStamp: 'YannDubois 4/25/2016 16:47' prior: 0!I am a vistitor which visit the document and return all image dependencies of this document.!!PRCascadingCounter commentStamp: '<historical>' prior: 0!I can keep track of the count of nested structures so each structure as its own number. For exemple, 2 sections in Chapter 1 would have a counter of #(1 1) and #(1 2). The first number indicates the top-most structure (here a chapter), while the following numbers represent the nested structures. I can count up to a max level.!!PRNotFoundCounter commentStamp: 'BenjaminVanRyseghem 1/9/2014 12:16' prior: 0!I am a subclass used when a reference is not found.In this case no number can be returned so a Warning is raised, and a ? is displayed!!PRDocGeneratorAboutScriptLanguage commentStamp: 'CyrilFerlicot 4/23/2015 15:53' prior: 0!I generate a documentation about the different script languages from class which inherit from PRRealScriptLanguage.!!PRScriptEvaluationEnvironment commentStamp: 'TorstenBergmann 3/5/2015 22:02' prior: 0!A script evaluator!!PRTParametrizable methodsFor: 'accessing-parameters' stamp: 'CyrilFerlicot 4/13/2015 23:23'!hasParameter: aKey	self		parameters at: aKey		ifAbsent: [ ^ false ].	^ true! !!PRTParametrizable methodsFor: 'accessing-parameters' stamp: 'DamienCassou 4/3/2015 17:40'!hasParameters	^ self parameters isEmpty not! !!PRTParametrizable methodsFor: 'accessing-parameters' stamp: 'CyrilFerlicot 4/13/2015 22:33'!parameterAt: aKey put: aValue	^ self parameters at: aKey put: aValue! !!PRTParametrizable methodsFor: 'accessing-parameters' stamp: 'DamienCassou 4/3/2015 14:20'!parameters	^ self explicitRequirement! !!UndefinedObject methodsFor: '*Pillar-Model-Core' stamp: 'DamienCassou 2/5/2014 13:04'!accept: aVisitor	<ignoreForCoverage>	"do nothing"! !!MAVisitor methodsFor: '*Pillar-Model-Core' stamp: 'CyrilFerlicot 6/30/2015 15:15'!visitPathDescription: aPathDescription	self visitElementDescription: aPathDescription! !!PRMagritteDictionaryReader class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 6/30/2015 14:50'!writeDictionary: aCollection for: anAnnotationClass	^ self new		class: anAnnotationClass;		write: aCollection! !!PRMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 7/1/2015 10:10'!checkRequired: accessor with: aDescription	^ aDescription required		ifTrue: [ PRPropertyError signal: accessor , ' is a required parameter on a ' , class tag , ' annotation' ]! !!PRMagritteDictionaryReader methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/30/2015 14:46'!class: anObject	class := anObject! !!PRMagritteDictionaryReader methodsFor: 'action' stamp: 'CyrilFerlicot 7/1/2015 09:56'!interpretAsBoolean: value with: aDescription	'true' = value		ifTrue: [ ^ true ].	'false' = value		ifTrue: [ ^ false ].	PRError		signal: aDescription accessor readSelector , ' must be a boolean in ' , class tag , ' annotation. Receive : ' , value! !!PRMagritteDictionaryReader methodsFor: 'action' stamp: 'CyrilFerlicot 6/30/2015 15:37'!interpretAsNumber: value with: aDescription	value		do: [ :each | 			each isDigit				ifFalse: [ 					PRError						signal:							aDescription accessor readSelector , ' must be a number in ' , class tag , ' annotation. Receive : ' , value ] ].	^ value asNumber! !!PRMagritteDictionaryReader methodsFor: 'action' stamp: 'CyrilFerlicot 6/30/2015 14:57'!raiseWarningIfTooManyParameters	dictionary isEmpty		ifFalse: [ 			dictionary keys				do: [ :key | PRWarning signal: key , ' is not a valid parameter for a ' , class tag , ' annotation. This will be ignore.' ] ]! !!PRMagritteDictionaryReader methodsFor: 'action' stamp: 'CyrilFerlicot 7/1/2015 10:59'!sortDescriptions	"I sort the descriptions to keep the order on the parameters for the Pillar exporter. If one day the Pillar export become a normalizer and not an exact expoter, just return ==class new magritteDescription children=="	| sortedDescriptions descriptions |	descriptions := class new magritteDescription children.	sortedDescriptions := OrderedCollection new.	dictionary keys		do: [ :key | 			descriptions copy				do: [ :description | 					description accessor readSelector = key						ifTrue: [ 							sortedDescriptions add: description.							descriptions remove: description ] ] ].	descriptions do: [ :each | sortedDescriptions add: each ].	"I add the rest of the descriptions to check if all required parameters are present."	^ sortedDescriptions! !!PRMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'MartinDias 7/3/2015 12:19'!tryToAddFrom: aDescription withInterpretation: aBlock	"I take a Description, check if an object of the dictionary match with the description, if I find one, I interpret it and add it to the new dictionary."	| accessor value |	accessor := aDescription accessor selector.	((dictionary includesKey: accessor) not and: [ aDescription default isNil ])		ifTrue: [ ^ self checkRequired: accessor with: aDescription].	value := dictionary at: accessor		ifPresent: aBlock		ifAbsent: [ aDescription default ].		aDescription validate: value.	annotationDictionary at: accessor put: value.	dictionary removeKey: accessor ifAbsent: [  ].! !!PRMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 6/30/2015 16:18'!visitBooleanDescription: aDescription	self tryToAddFrom: aDescription withInterpretation: [ :value | self interpretAsBoolean: value with: aDescription ]! !!PRMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 6/30/2015 15:08'!visitElementDescription: aDescription	self tryToAddFrom: aDescription withInterpretation: [ :value | value ]! !!PRMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 6/30/2015 15:37'!visitNumberDescription: aDescription	self tryToAddFrom: aDescription withInterpretation: [ :value | self interpretAsNumber: value with: aDescription ]! !!PRMagritteDictionaryReader methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 6/30/2015 15:17'!visitPathDescription: aDescription	self tryToAddFrom: aDescription withInterpretation: [ :value | Path from: value ]! !!PRMagritteDictionaryReader methodsFor: 'action' stamp: 'CyrilFerlicot 7/1/2015 10:54'!write: aCollection	| descriptions |	dictionary := aCollection.	descriptions := self sortDescriptions.	annotationDictionary := aCollection class new.	self visitAll: descriptions.	self raiseWarningIfTooManyParameters.	^ annotationDictionary! !!PRReferenceNotFound methodsFor: 'accessing' stamp: 'BenjaminVanRyseghem 1/9/2014 17:11'!inputFile: aFile	inputFile := aFile! !!PRReferenceNotFound methodsFor: 'accessing' stamp: 'BenjaminVanRyseghem 1/9/2014 17:11'!messageText	^inputFile ifNil: [ super messageText ] ifNotNil: [ inputFile pathString, ' ', super messageText ]! !!PRMagrittePathDescription class methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/30/2015 15:14'!label	^ 'Path'! !!PRMagrittePathDescription methodsFor: 'visiting' stamp: 'CyrilFerlicot 6/30/2015 15:11'!acceptMagritte: aVisitor	aVisitor visitPathDescription: self! !!Collection methodsFor: '*Pillar-Model-Core' stamp: 'DamienCassou 3/20/2014 18:12'!acceptDecorated: aVisitor	<ignoreForCoverage "This method is ignored for test coverage because it exists only as a hook for other frameworks (i.e., Magritte).">	self accept: aVisitor! !!Object methodsFor: '*Pillar-Model-Core-Core' stamp: 'DamienCassou 2/5/2014 12:42'!accept: aVisitor	<ignoreForCoverage>	self error: self printString , ' is missing #accept:'! !!Object methodsFor: '*Pillar-Model-Core-Core' stamp: 'DamienCassou 10/8/2013 09:25'!acceptDecorated: aVisitor	self accept: aVisitor! !!PRBasicObject class methodsFor: 'error handling' stamp: 'jf 9/18/2009 15:40'!defaultErrorClass	^ PRError! !!PRBasicObject class methodsFor: 'license' stamp: 'DamienCassou 2/5/2014 12:42'!pierLicense	<ignoreForCoverage>	"Return a string with the license of the package. This string shall not be removed or altered in any case."	^ 'The MIT LicenseCopyright (c) 2003-' , Date today year printString , ' Lukas Renggli, renggli at gmail.comCopyright (c) 2003-' , Date today year printString , ' ContributorsPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.'! !!PRAbstractScriptLanguage class methodsFor: 'protected' stamp: 'DamienCassou 1/10/2014 15:47'!acceptLanguage: aLanguageName	^ aLanguageName matchesRegexIgnoringCase: self acceptedLanguagesRegex ! !!PRAbstractScriptLanguage class methodsFor: 'requirement' stamp: 'DamienCassou 1/10/2014 16:27'!acceptedLanguagesRegex 	^ self standardName! !!PRAbstractScriptLanguage class methodsFor: 'private' stamp: 'DamienCassou 1/10/2014 17:50'!concreteClassFor: aLanguageName	aLanguageName isNil ifTrue: [ ^ PRUnspecifiedScriptLanguage ].	^ (self withAllConcreteClasses copyWithout: PRUnsupportedScriptLanguage)		detect: [ :cl | cl acceptLanguage: aLanguageName ]		ifNone: [ PRUnsupportedScriptLanguage ]! !!PRAbstractScriptLanguage class methodsFor: 'instance creation' stamp: 'DamienCassou 1/10/2014 16:25'!default	^ self new		originalName: self standardName;		yourself! !!PRAbstractScriptLanguage class methodsFor: 'instance creation' stamp: 'DamienCassou 1/10/2014 16:21'!for: aLanguageName	^ (self concreteClassFor: aLanguageName) new		originalName: aLanguageName;		yourself! !!PRAbstractScriptLanguage class methodsFor: 'protected' stamp: 'DamienCassou 1/10/2014 16:27'!standardName	^ self subclassResponsibility! !!PRAbstractScriptLanguage methodsFor: 'comparing' stamp: 'CyrilFerlicot 4/8/2015 10:45'!= anObject	^ self originalName = anObject originalName! !!PRAbstractScriptLanguage methodsFor: 'comparing' stamp: 'CyrilFerlicot 4/8/2015 10:46'!hash	^ self originalName hash! !!PRAbstractScriptLanguage methodsFor: 'testing' stamp: 'DamienCassou 1/10/2014 16:02'!isSpecified	^ self subclassResponsibility! !!PRAbstractScriptLanguage methodsFor: 'accessing' stamp: 'DamienCassou 1/10/2014 16:22'!originalName	^ originalName! !!PRAbstractScriptLanguage methodsFor: 'accessing' stamp: 'DamienCassou 1/10/2014 16:22'!originalName: aLanguageName	originalName := aLanguageName! !!PRAbstractScriptLanguage methodsFor: 'printing' stamp: 'DamienCassou 1/10/2014 16:22'!printOn: aStream	aStream nextPutAll: self originalName! !!PRNoScriptLanguage class methodsFor: 'requirement' stamp: 'DamienCassou 1/10/2014 16:27'!acceptedLanguagesRegex	^ '^$|', self standardName! !!PRNoScriptLanguage class methodsFor: 'testing' stamp: 'DamienCassou 1/10/2014 15:39'!isAbstract	^ false! !!PRNoScriptLanguage class methodsFor: 'protected' stamp: 'DamienCassou 1/10/2014 16:28'!standardName	^ 'no language'! !!PRNoScriptLanguage methodsFor: 'testing' stamp: 'DamienCassou 1/10/2014 16:02'!isSpecified	^ true! !!PRBashScriptLanguage class methodsFor: 'testing' stamp: 'DamienCassou 1/14/2014 15:03'!isAbstract	^ false! !!PRBashScriptLanguage class methodsFor: 'requirement' stamp: 'DamienCassou 1/14/2014 15:03'!standardName	^ 'bash'! !!PRCSSScriptLanguage class methodsFor: 'testing' stamp: 'DamienCassou 9/17/2014 15:11'!isAbstract	^ false! !!PRCSSScriptLanguage class methodsFor: 'protected' stamp: 'DamienCassou 9/17/2014 15:11'!standardName	^ 'css'! !!PRHTMLScriptLanguage class methodsFor: 'testing' stamp: 'DamienCassou 1/10/2014 15:39'!isAbstract	^ false! !!PRHTMLScriptLanguage class methodsFor: 'requirement' stamp: 'DamienCassou 1/10/2014 16:28'!standardName	^ 'html'! !!PRHTTPScriptLanguage class methodsFor: 'testing' stamp: 'DamienCassou 1/10/2014 15:39'!isAbstract	^ false! !!PRHTTPScriptLanguage class methodsFor: 'requirement' stamp: 'CyrilFerlicot 7/2/2015 11:49'!standardName	^ 'http'! !!PRJSONScriptLanguage class methodsFor: 'testing' stamp: 'DamienCassou 1/14/2014 15:42'!isAbstract	^ false! !!PRJSONScriptLanguage class methodsFor: 'requirement' stamp: 'DamienCassou 1/14/2014 15:42'!standardName	^ 'json'! !!PRJavaScriptScriptLanguage class methodsFor: 'testing' stamp: 'DamienCassou 9/17/2014 15:07'!isAbstract	^ false! !!PRJavaScriptScriptLanguage class methodsFor: 'protected' stamp: 'DamienCassou 9/17/2014 15:09'!standardName	^ 'javascript'! !!PRPillarLanguage class methodsFor: 'testing' stamp: 'DamienPollet 1/31/2016 06:44'!isAbstract	^ false! !!PRPillarLanguage class methodsFor: 'requirement' stamp: 'DamienPollet 1/31/2016 06:44'!standardName	^ 'pillar'! !!PRRealScriptLanguage methodsFor: 'testing' stamp: 'DamienCassou 1/10/2014 16:08'!isSpecified	^ true! !!PRSQLScriptLanguage class methodsFor: 'testing' stamp: 'DamienCassou 1/10/2014 16:57'!isAbstract	^ false! !!PRSQLScriptLanguage class methodsFor: 'protected' stamp: 'CyrilFerlicot 7/2/2015 11:49'!standardName	^ 'sql'! !!PRSTONScriptLanguage class methodsFor: 'testing' stamp: 'DamienCassou 1/14/2014 15:41'!isAbstract	^ false! !!PRSTONScriptLanguage class methodsFor: 'requirement' stamp: 'DamienCassou 1/14/2014 15:42'!standardName	^ 'ston'! !!PRShellCommandsScriptLanguage class methodsFor: 'testing' stamp: 'DamienPollet 2/20/2014 23:27'!isAbstract	^ false! !!PRShellCommandsScriptLanguage class methodsFor: 'requirement' stamp: 'DamienPollet 2/20/2014 23:27'!standardName	^ 'shellcommands'! !!PRSmalltalkScriptLanguage class methodsFor: 'testing' stamp: 'DamienCassou 1/10/2014 15:39'!isAbstract	^ false! !!PRSmalltalkScriptLanguage class methodsFor: 'requirement' stamp: 'DamienCassou 1/10/2014 16:29'!standardName	^ 'smalltalk'! !!PRUnspecifiedScriptLanguage class methodsFor: 'protected' stamp: 'DamienCassou 1/10/2014 16:31'!acceptLanguage: aLanguageName	^ aLanguageName isNil or: [ super acceptLanguage: aLanguageName ]! !!PRUnspecifiedScriptLanguage class methodsFor: 'testing' stamp: 'DamienCassou 1/10/2014 15:39'!isAbstract	^ false! !!PRUnspecifiedScriptLanguage class methodsFor: 'protected' stamp: 'DamienCassou 1/10/2014 16:29'!standardName	^ 'unspecified language'! !!PRUnspecifiedScriptLanguage methodsFor: 'testing' stamp: 'DamienCassou 1/10/2014 15:59'!isSpecified	^ false! !!PRUnspecifiedScriptLanguage methodsFor: 'accessing' stamp: 'DamienCassou 1/10/2014 16:56'!originalName	^ ''! !!PRUnsupportedScriptLanguage class methodsFor: 'instance creation' stamp: 'DamienCassou 2/5/2014 12:44'!default	<ignoreForCoverage>	^ self shouldNotImplement! !!PRUnsupportedScriptLanguage class methodsFor: 'testing' stamp: 'DamienCassou 1/10/2014 15:39'!isAbstract	^ false! !!PRUnsupportedScriptLanguage methodsFor: 'testing' stamp: 'DamienCassou 1/10/2014 16:55'!isSpecified	^ false! !!PRAbstractAnnotation class methodsFor: 'protected' stamp: 'CyrilFerlicot 4/10/2015 10:53'!acceptName: aTag 	^ aTag asSymbol = self tag! !!PRAbstractAnnotation class methodsFor: 'protected' stamp: 'YannDubois 5/2/2016 14:08'!adaptKeysOn: aCollection	| newDictionary |	newDictionary := SmallDictionary new.	aCollection		keysDo: [ :key | 			(aCollection at: key) isNil				ifTrue: [ newDictionary at: self defaultParameterName put: key ]				ifFalse: [ newDictionary at: key put: (aCollection at: key) ] ].	^ newDictionary! !!PRAbstractAnnotation class methodsFor: 'protected' stamp: 'CyrilFerlicot 7/1/2015 10:20'!checkKeysOf: aCollection	| nilParameters |	nilParameters := 0.	aCollection values		do: [ :each | 			each isNil				ifTrue: [ nilParameters := nilParameters + 1 ] ].	self raiseErrorIfTooManyParameters: nilParameters.	^ nilParameters = 1		ifTrue: [ self adaptKeysOn: aCollection ]		ifFalse: [ aCollection ]! !!PRAbstractAnnotation class methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/30/2015 09:47'!defaultParameterName	"Each annotation can have some parameters. A parameter have a key and a value. We allow for each annotation to have 1 parameters without key inside the pillar document. I return the key of this parameter."	^ 'value'! !!PRAbstractAnnotation class methodsFor: 'protected' stamp: 'CyrilFerlicot 4/22/2015 14:31'!findClassAcceptingTag: aTag	^ self withAllConcreteClasses		detect: [ :class | class acceptName: aTag ]		ifNone: [ PRSyntaxError signal: 'Pillar doesn''t support this tag : ''' , aTag , ''' on his annotations.' ]! !!PRAbstractAnnotation class methodsFor: 'testing' stamp: 'DamienCassou 4/3/2015 17:54'!isAbstract	^ self = PRAbstractAnnotation! !!PRAbstractAnnotation class methodsFor: 'accessing' stamp: 'DamienCassou 4/3/2015 16:55'!markupParameterSeparator	^ $:! !!PRAbstractAnnotation class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 7/1/2015 10:23'!parameters: aCollection	| parameters |	parameters := self checkKeysOf: aCollection.	^ self new		hadAllKeys: aCollection = parameters;		parameters: (PRMagritteDictionaryReader writeDictionary: parameters for: self);		yourself! !!PRAbstractAnnotation class methodsFor: 'protected' stamp: 'CyrilFerlicot 6/30/2015 14:18'!raiseErrorIfTooManyParameters: nilParameters	nilParameters > 1		ifTrue: [ PRError signal: 'More than one parameter have no key in ' , self tag , ' annotation.' ]! !!PRAbstractAnnotation class methodsFor: 'protected' stamp: 'DamienCassou 4/3/2015 16:55'!tag	^ self subclassResponsibility! !!PRAbstractAnnotation methodsFor: 'comparing' stamp: 'CyrilFerlicot 6/30/2015 16:54'!= anObject	^ super = anObject and: [ self parameters = anObject parameters and: [ self hadAllKeys = anObject hadAllKeys ] ]! !!PRAbstractAnnotation methodsFor: 'visiting' stamp: 'DamienCassou 4/3/2015 17:56'!accept: aVisitor	aVisitor visitAnnotation: self! !!PRAbstractAnnotation methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/30/2015 09:58'!hadAllKeys	^ hadAllKeys ifNil: [ true ]! !!PRAbstractAnnotation methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/30/2015 09:58'!hadAllKeys: anObject	hadAllKeys := anObject! !!PRAbstractAnnotation methodsFor: 'comparing' stamp: 'CyrilFerlicot 4/9/2015 12:47'!hash	^ super hash bitXor: self parameters hash! !!PRAbstractAnnotation methodsFor: 'initialization' stamp: 'YannDubois 5/2/2016 14:10'!initialize	super initialize.	parameters := SmallDictionary new! !!PRAbstractAnnotation methodsFor: 'accessing' stamp: 'DamienCassou 4/3/2015 17:27'!parameters	^ parameters! !!PRAbstractAnnotation methodsFor: 'accessing' stamp: 'CyrilFerlicot 7/1/2015 10:45'!parameters: aCollection	parameters := aCollection! !!PRAbstractAnnotation methodsFor: 'copying' stamp: 'CyrilFerlicot 8/7/2015 14:19'!postCopy	super postCopy.	parameters := parameters copy.	hadAllKeys := hadAllKeys copy! !!PRCitationAnnotation class methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 5/3/2016 15:48'!defaultParameterName	^'ref'! !!PRCitationAnnotation class methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 5/3/2016 15:48'!tag	^ #cite! !!PRCitationAnnotation methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 5/3/2016 15:48'!accept: aVisitor	aVisitor visitCitationAnnotation: self! !!PRCitationAnnotation methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 5/3/2016 15:48'!descriptionRef	<magritteDescription>	^ MAStringDescription new		accessor: #ref;		priority: 100;		label: 'Reference of a citation';		required: true;		yourself! !!PRCitationAnnotation methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 5/3/2016 15:48'!isCitation	^true! !!PRColumnAnnotation class methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/30/2015 15:48'!defaultParameterName	^ 'width'! !!PRColumnAnnotation class methodsFor: 'protected' stamp: 'CyrilFerlicot 6/18/2015 10:14'!tag	^ #column! !!PRColumnAnnotation methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/18/2015 14:23'!columnAnnotation	"This is a hack, we will need to clean that."	^ self! !!PRColumnAnnotation methodsFor: 'descriptions' stamp: 'CyrilFerlicot 6/30/2015 15:29'!descriptionWidth	<magritteDescription>	^ MANumberDescription new		accessor: #width;		priority: 100;		label: 'Width of the column';		required: true;		min: 0 max: 100;		yourself! !!PRColumnAnnotation methodsFor: 'testing' stamp: 'CyrilFerlicot 6/18/2015 10:58'!isColumnBeginning	^ true! !!PRColumnsAnnotation class methodsFor: 'protected' stamp: 'CyrilFerlicot 6/18/2015 10:14'!tag	^ #columns! !!PRColumnsAnnotation methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 6/18/2015 10:56'!isColumnsBeginning	^ true! !!PREndColumnsAnnotation class methodsFor: 'protected' stamp: 'CyrilFerlicot 6/18/2015 10:14'!tag 	^ #endColumns! !!PREndColumnsAnnotation methodsFor: 'testing' stamp: 'CyrilFerlicot 6/18/2015 11:11'!isColumnsEnding	^ true! !!PRFootnoteAnnotation class methodsFor: 'accessing' stamp: 'YannDubois 5/3/2016 09:55'!defaultParameterName	^ 'note'! !!PRFootnoteAnnotation class methodsFor: 'protected' stamp: 'YannDubois 5/3/2016 09:54'!tag	^ #footnote! !!PRFootnoteAnnotation methodsFor: 'as yet unclassified' stamp: 'YannDubois 5/3/2016 15:51'!accept: aVisitor	aVisitor visitFootnoteAnnotation: self! !!PRFootnoteAnnotation methodsFor: 'descriptions' stamp: 'YannDubois 5/3/2016 09:57'!descriptionNote	<magritteDescription>	^ MAStringDescription new		accessor: #note;		priority: 100;		label: 'Content of the note';		required: true;		yourself! !!PRIndexAnnotation class methodsFor: 'protected' stamp: 'DamienCassou 4/3/2015 16:55'!tag	^ #index! !!PRInputFileAnnotation class methodsFor: 'protected' stamp: 'CyrilFerlicot 4/8/2015 13:23'!tag	^ #inputFile! !!PRInputFileAnnotation methodsFor: 'visiting' stamp: 'CyrilFerlicot 4/9/2015 12:48'!accept: aVisitor	aVisitor visitInputFileAnnotation: self! !!PRInputFileAnnotation methodsFor: 'acessing-magritte' stamp: 'CyrilFerlicot 6/30/2015 15:26'!descriptionValue	<magritteDescription>	^ PRMagrittePathDescription new		accessor: #value;		priority: 100;		label: 'Path of the inputFile';		yourself! !!PRInputFileAnnotation methodsFor: 'private' stamp: 'CyrilFerlicot 4/9/2015 13:16'!errorFileNotFound: aFile	PRInputFileError signal: 'File at: ' , aFile fullName , ' not found.'! !!PRInputFileAnnotation methodsFor: 'accessing' stamp: 'CyrilFerlicot 4/23/2015 17:27'!fileWithConfiguration: aConfiguration	"I search my file."	^ aConfiguration baseDirectory resolve: (self parameters at: 'value')! !!PRSlideTitleAnnotation class methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/30/2015 14:09'!defaultParameterName	"For a slide annotation the default parameter is the title of the slide."	^ 'title'! !!PRSlideTitleAnnotation class methodsFor: 'protected' stamp: 'CyrilFerlicot 6/1/2015 16:22'!tag	^ #slide! !!PRSlideTitleAnnotation methodsFor: 'visiting' stamp: 'CyrilFerlicot 6/1/2015 16:22'!accept: aVisitor	aVisitor visitSlideTitleAnnotation: self! !!PRSlideTitleAnnotation methodsFor: 'descriptions' stamp: 'CyrilFerlicot 6/30/2015 15:26'!descriptionLabel	<magritteDescription>	^ MAStringDescription new		accessor: #label;		priority: 100;		label: 'Label of a Slide';		yourself! !!PRSlideTitleAnnotation methodsFor: 'descriptions' stamp: 'CyrilFerlicot 6/30/2015 15:26'!descriptionTitle	<magritteDescription>	^ MAStringDescription new		accessor: #title;		priority: 100;		label: 'Title of a Slide';		required: true;		yourself! !!PRSlideTitleAnnotation methodsFor: 'testing' stamp: 'CyrilFerlicot 6/3/2015 14:14'!isSlideBeginning	^ true! !!PRSlideTitleAnnotation methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/5/2015 16:42'!slideAnnotation	"I'm here to take care of the case where a paragraph only contains a SlideTitleAnnotation."	^ self! !!PRTocAnnotation class methodsFor: 'protected' stamp: 'CyrilFerlicot 4/17/2015 11:05'!tag	^ #toc! !!PRTocAnnotation methodsFor: 'visiting' stamp: 'CyrilFerlicot 5/29/2015 10:27'!accept: aVisitor	aVisitor visitTOCAnnotation: self! !!PRTocAnnotation methodsFor: 'descriptions' stamp: 'CyrilFerlicot 6/30/2015 16:16'!descriptionDepthLevel	<magritteDescription>	^ MANumberDescription new		accessor: #depthLevel;		priority: 100;		label: 'Depth Level of the ToC';		required: true;		min: 0 max: 7;		yourself! !!PRTocAnnotation methodsFor: 'descriptions' stamp: 'CyrilFerlicot 6/30/2015 16:22'!descriptionHighlight	<magritteDescription>	^ MABooleanDescription new		accessor: #highlight;		priority: 100;		label: 'Highlight';		yourself! !!PRTocAnnotation methodsFor: 'descriptions' stamp: 'CyrilFerlicot 6/30/2015 16:16'!descriptionLevel	<magritteDescription>	^ MANumberDescription new		accessor: #level;		priority: 100;		label: 'Level of the ToC';		required: true;		min: 0 max: 7;		yourself! !!PRTocAnnotation methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 7/2/2015 10:56'!todo	self flag: #todo "add title to the parameters."! !!PRAnchor class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRAnchor class methodsFor: 'instance creation' stamp: 'lr 4/5/2007 13:08'!named: aString	^ self new name: aString! !!PRAnchor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!= anObject	^ super = anObject		and: [ self name = anObject name ]! !!PRAnchor methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitAnchor: self! !!PRAnchor methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!hash	^ super hash bitXor: self name hash! !!PRAnchor methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!name	^ name! !!PRAnchor methodsFor: 'accessing' stamp: 'CyrilFerlicot 7/2/2015 13:35'!name: aString	name := aString trimBoth	"We do trimBoth to avoid to have unexpected space before or after an anchor."! !!PRCitation class methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 5/3/2016 15:47'!defaultRef	^'No Reference'! !!PRCitation class methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 5/3/2016 15:47'!isAbstract	^false! !!PRCitation class methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 5/3/2016 15:47'!ref: aString	^ self new		ref: aString;		yourself! !!PRCitation methodsFor: 'comparing' stamp: 'ThibaultArloing 5/3/2016 15:45'!= anObject	^ super = anObject and: [ self ref = anObject ref ]! !!PRCitation methodsFor: 'visiting' stamp: 'ThibaultArloing 5/3/2016 15:45'!accept: aVisitor	aVisitor visitCitation: self! !!PRCitation methodsFor: 'initialization' stamp: 'ThibaultArloing 5/3/2016 15:46'!initialize	super initialize.	ref := self class defaultRef! !!PRCitation methodsFor: 'accessing' stamp: 'ThibaultArloing 5/3/2016 15:46'!ref	^ ref! !!PRCitation methodsFor: 'accessing' stamp: 'ThibaultArloing 5/3/2016 15:46'!ref: aString	ref := aString! !!PRColumn class methodsFor: 'testing' stamp: 'CyrilFerlicot 6/18/2015 10:38'!isAbstract	^ false! !!PRColumn class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 6/18/2015 14:13'!width: aNumber	^ self new		width: aNumber;		yourself! !!PRColumn methodsFor: 'visiting' stamp: 'CyrilFerlicot 6/18/2015 10:39'!accept: aVisitor	aVisitor visitColumn: self! !!PRColumn methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/18/2015 14:13'!width	^ width! !!PRColumn methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/18/2015 14:13'!width: anObject	width := anObject! !!PRColumns class methodsFor: 'testing' stamp: 'CyrilFerlicot 6/18/2015 10:39'!isAbstract	^ false! !!PRColumns methodsFor: 'visiting' stamp: 'CyrilFerlicot 6/18/2015 10:40'!accept: aVisitor	aVisitor visitColumns: self! !!PRDocument class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRDocument methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitDocument: self! !!PRDocument methodsFor: 'common-properties' stamp: 'DamienCassou 6/4/2014 15:50'!authors	^ self propertyAt: 'authors' ifAbsent: [ self defaultAuthors ]! !!PRDocument methodsFor: 'common-properties' stamp: 'GuillermoPolito 5/8/2015 15:59'!date	^ (self propertyAt: 'date' ifAbsent: [ self defaultDate ]) asDate! !!PRDocument methodsFor: 'common-defaults' stamp: 'DamienCassou 6/4/2014 15:50'!defaultAuthors	^ ''! !!PRDocument methodsFor: 'common-defaults' stamp: 'DamienCassou 6/4/2014 17:58'!defaultDate	^ Date today! !!PRDocument methodsFor: 'common-defaults' stamp: 'DamienCassou 6/4/2014 17:58'!defaultNext	^ nil! !!PRDocument methodsFor: 'common-properties' stamp: 'DamienCassou 6/4/2014 15:51'!next	^ self propertyAt: 'next' ifAbsent: [ self defaultNext ]! !!PRDocument methodsFor: 'common-properties' stamp: 'DamienCassou 6/4/2014 17:58'!next: aDocument	^ self propertyAt: 'next' put: aDocument! !!PRDocumentGroup class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!with: aDocumentItem	^ self new		add: aDocumentItem;		yourself! !!PRDocumentGroup class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!withAll: aCollection	^ self new		addAll: aCollection;		yourself! !!PRDocumentGroup methodsFor: 'comparing' stamp: 'ThibaultArloing 5/10/2016 15:58'!= anObject	^ super = anObject		and: [ self children = anObject children ]! !!PRDocumentGroup methodsFor: 'visiting' stamp: 'DamienCassou 3/20/2014 18:08'!accept: aVisitor	<ignoreForCoverage "This method is ignored for test coverage because it is overriden in all subclasses and these subclasses don't need to do a super-send.">	aVisitor visitDocumentGroup: self! !!PRDocumentGroup methodsFor: 'adding' stamp: 'lr 3/20/2006 19:06'!add: aDocumentItem	self setChildren: (self children copyWith: aDocumentItem)! !!PRDocumentGroup methodsFor: 'adding' stamp: 'lr 7/31/2007 21:22'!addAll: aCollection	self setChildren: self children , aCollection! !!PRDocumentGroup methodsFor: 'accessing' stamp: 'lr 5/28/2006 20:32'!children	"Answer the children of the receiver."	^ children! !!PRDocumentGroup methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!hasChildren	^ self children notEmpty! !!PRDocumentGroup methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!hash	^ super hash bitXor: self children hash! !!PRDocumentGroup methodsFor: 'initialization' stamp: 'lr 4/4/2007 15:05'!initialize	super initialize.	self setChildren: #()! !!PRDocumentGroup methodsFor: 'testing' stamp: 'BenComan 5/28/2014 22:30'!isGroup	^true! !!PRDocumentGroup methodsFor: 'copying' stamp: 'lr 2/12/2007 19:07'!postCopy	super postCopy.	self setChildren: (self children		collect: [ :each | each copy ])! !!PRDocumentGroup methodsFor: 'initialization' stamp: 'lr 3/20/2006 19:06'!setChildren: aCollection	children := aCollection! !!PRDocumentGroup methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!size	^ self children size! !!PRDocumentGroup methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!text	^ String streamContents: [ :stream |		self children do: [ :each |			stream nextPutAll: each text ] ]! !!PRBoldFormat class methodsFor: 'testing' stamp: 'lr 3/30/2007 19:40'!isAbstract	^ false! !!PRBoldFormat methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitBoldFormat: self! !!PRFormat methodsFor: 'visiting' stamp: 'DamienCassou 3/20/2014 18:08'!accept: aVisitor	<ignoreForCoverage "This method is ignored for test coverage because it is overriden in all subclasses and these subclasses don't need to do a super-send.">	aVisitor visitFormat: self! !!PRItalicFormat class methodsFor: 'testing' stamp: 'lr 3/30/2007 19:40'!isAbstract	^ false! !!PRItalicFormat methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitItalicFormat: self! !!PRMonospaceFormat class methodsFor: 'testing' stamp: 'lr 3/30/2007 19:40'!isAbstract	^ false! !!PRMonospaceFormat methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitMonospaceFormat: self! !!PRStrikethroughFormat class methodsFor: 'testing' stamp: 'lr 3/30/2007 19:40'!isAbstract	^ false! !!PRStrikethroughFormat methodsFor: 'visiting' stamp: 'lr 5/31/2007 07:46'!accept: aVisitor	aVisitor visitStrikethroughFormat: self! !!PRSubscriptFormat class methodsFor: 'testing' stamp: 'lr 3/30/2007 19:40'!isAbstract	^ false! !!PRSubscriptFormat methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitSubscriptFormat: self! !!PRSuperscriptFormat class methodsFor: 'testing' stamp: 'lr 3/30/2007 19:40'!isAbstract	^ false! !!PRSuperscriptFormat methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitSuperscriptFormat: self! !!PRUnderlineFormat class methodsFor: 'testing' stamp: 'lr 3/30/2007 19:43'!isAbstract	^ false! !!PRUnderlineFormat methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitUnderlineFormat: self! !!PRHeader class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRHeader class methodsFor: 'instance creation' stamp: 'lr 3/9/2006 11:30'!withAll: aCollection level: anInteger	^ (self withAll: aCollection)		level: anInteger;		yourself! !!PRHeader methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!= anObject	^ super = anObject		and: [ self level = anObject level ]! !!PRHeader methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitHeader: self! !!PRHeader methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!hash	^ super hash bitXor: self level hash! !!PRHeader methodsFor: 'testing' stamp: 'CyrilFerlicot 5/23/2015 20:08'!isHeader	^ true! !!PRHeader methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!level	^ level! !!PRHeader methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:29'!level: anInteger	level := anInteger! !!PRDefinitionList class methodsFor: 'testing' stamp: 'lr 12/30/2007 17:23'!isAbstract	^ false! !!PRDefinitionList methodsFor: 'visiting' stamp: 'lr 12/30/2007 17:23'!accept: aVisitor	aVisitor visitDefinitionList: self! !!PRList methodsFor: 'visiting' stamp: 'DamienCassou 3/20/2014 18:07'!accept: aVisitor	<ignoreForCoverage "This method is ignored for test coverage because it is overriden in all subclasses and these subclasses don't need to do a super-send.">	aVisitor visitList: self! !!PROrderedList class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PROrderedList methodsFor: 'visiting' stamp: 'lr 12/30/2007 19:31'!accept: aVisitor	aVisitor visitOrderedList: self! !!PRUnorderedList class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRUnorderedList methodsFor: 'visiting' stamp: 'lr 12/30/2007 19:31'!accept: aVisitor	aVisitor visitUnorderedList: self! !!PRDataItem methodsFor: 'visiting' stamp: 'lr 12/30/2007 21:50'!accept: aVisitor	aVisitor visitDataItem: self! !!PRListItem class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRListItem methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitListItem: self! !!PRTermItem methodsFor: 'visiting' stamp: 'lr 12/30/2007 21:51'!accept: aVisitor	aVisitor visitTermItem: self! !!PRAnnotatedParagraph class methodsFor: 'instance creation' stamp: 'lr 5/26/2009 22:04'!withAll: aCollection annotation: aString	^ (self withAll: aCollection)		annotation: aString;		yourself! !!PRAnnotatedParagraph methodsFor: 'comparing' stamp: 'lr 5/26/2009 22:07'!= anObject	^ super = anObject and: [ self annotation = anObject annotation ]! !!PRAnnotatedParagraph methodsFor: 'visiting' stamp: 'lr 5/26/2009 21:59'!accept: aVisitor	aVisitor visitAnnotatedParagraph: self! !!PRAnnotatedParagraph methodsFor: 'accessing' stamp: 'lr 5/26/2009 21:59'!annotation	^ annotation! !!PRAnnotatedParagraph methodsFor: 'accessing' stamp: 'lr 5/26/2009 21:59'!annotation: aString	annotation := aString! !!PRAnnotatedParagraph methodsFor: 'comparing' stamp: 'lr 5/26/2009 22:07'!hash	^ super hash bitXor: self annotation hash! !!PREmptyParagraph methodsFor: 'visiting' stamp: 'lr 12/20/2007 12:12'!accept: aVisitor	aVisitor visitEmptyParagraph: self! !!PRParagraph class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRParagraph methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitParagraph: self! !!PRPreformatted class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRPreformatted methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitPreformatted: self! !!PRFigure class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/28/2015 14:15'!extensionOf: aString isOneOf: extensions	| extension |	extension := (aString splitOn: $.) last asLowercase.	^ extensions includes: extension! !!PRFigure class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/28/2015 13:22'!isAbstract	^ false! !!PRFigure class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/28/2015 14:19'!isValidReference: aString	^ (self extensionOf: aString isOneOf: self pictureExtensions)		and: [ aString includesSubstring: '://' caseSensitive: true ]! !!PRFigure class methodsFor: 'private' stamp: 'CyrilFerlicot 4/28/2015 13:31'!pictureExtensions	^ #('png' 'jpg' 'jpeg' 'pdf')! !!PRFigure methodsFor: 'visiting' stamp: 'CyrilFerlicot 4/28/2015 15:04'!accept: aVisitor	aVisitor visitFigure: self! !!PRFigure methodsFor: 'testing' stamp: 'DamienCassou 9/6/2015 07:32'!hasCaption	^ self hasChildren! !!PRFigure methodsFor: 'testing' stamp: 'CyrilFerlicot 6/8/2015 15:00'!hasLabel	^ self label isNotNil! !!PRFigure methodsFor: 'accessing' stamp: 'CyrilFerlicot 4/28/2015 15:06'!label	^ self parameters at: 'label' ifAbsent: [ nil ]! !!PRFigure methodsFor: 'accessing' stamp: 'CyrilFerlicot 4/28/2015 15:06'!label: aString	self parameters at: 'label' put: aString! !!PRExternalLink class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRExternalLink class methodsFor: 'testing' stamp: 'DamienCassou 10/8/2013 08:40'!isValidReference: aString	^ aString includesSubstring: '://' caseSensitive: true! !!PRExternalLink class methodsFor: 'accessing' stamp: 'CyrilFerlicot 4/28/2015 14:18'!priority	^ 25! !!PRExternalLink methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitExternalLink: self! !!PRExternalLink methodsFor: 'testing' stamp: 'lr 4/1/2009 22:19'!isExternal	^ true! !!PRExternalLink methodsFor: 'accessing' stamp: 'LukasKomarek 4/21/2016 14:58'!localFileOrExternalReference	^ self class localFileOrExternalReference: self url! !!PRExternalLink methodsFor: 'accessing' stamp: 'lr 9/8/2008 21:30'!url	"Answer the URL the receiver is pointing to."	^ self urlPrefix , self urlEntry , self urlPostfix! !!PRExternalLink methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!urlEntry	^ self reference! !!PRExternalLink methodsFor: 'accessing-dynamic' stamp: 'lr 10/20/2006 11:43'!urlPostfix	^ ''! !!PRExternalLink methodsFor: 'accessing-dynamic' stamp: 'lr 10/20/2006 11:43'!urlPrefix	^ ''! !!PRMailLink class methodsFor: 'testing' stamp: 'lr 9/22/2008 08:28'!isValidReference: aString	| index |	index := aString indexOf: $@ ifAbsent: [ ^ false ].	index := aString indexOf: $. startingAt: index ifAbsent: [ ^ false ].	^ aString allSatisfy: [ :each | each isAlphaNumeric or: [ '@-.' includes: each ] ]! !!PRMailLink class methodsFor: 'accessing' stamp: 'lr 1/9/2009 19:20'!priority	^ 50! !!PRMailLink methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitMailLink: self! !!PRMailLink methodsFor: 'accessing-dynamic' stamp: 'DamienCassou 4/26/2014 18:04'!scrambledUrl	^ self url! !!PRMailLink methodsFor: 'accessing-dynamic' stamp: 'DamienCassou 4/26/2014 18:04'!unscrambledUrl	^ self urlPrefix, super urlEntry, self urlPostfix! !!PRMailLink methodsFor: 'accessing-dynamic' stamp: 'CyrilFerlicot 5/1/2015 20:06'!urlEntry	^ String streamContents: [ :stream |		super urlEntry do: [ :each |			(1 to: 2) atRandom = 1				ifTrue: [ stream nextPut: each ]				ifFalse: [ stream nextPut: $%; nextPutAll: ((each codePoint printStringBase: 16)		padLeftTo: 2 with: $0) ] ] ]! !!PRMailLink methodsFor: 'accessing-dynamic' stamp: 'lr 3/9/2006 11:29'!urlPrefix	^ 'mailto:'! !!PRSemanticLink class methodsFor: 'testing' stamp: 'LukasKomarek 4/16/2016 13:25'!isAbstract	^ true! !!PRSemanticLink class methodsFor: 'testing' stamp: 'LukasKomarek 4/26/2016 19:30'!isValidReference: aString	| array |	array := aString splitOn: ':'.	^ array size > 1 & ((array at: 1) = self linkName)! !!PRSemanticLink class methodsFor: 'accessing' stamp: 'LukasKomarek 4/26/2016 19:30'!linkName	self subclassResponsibility ! !!PRSemanticLink class methodsFor: 'accessing' stamp: 'LukasKomarek 4/21/2016 15:37'!priority	^ 10! !!PRWikipediaSemLink class methodsFor: 'testing' stamp: 'LukasKomarek 4/16/2016 13:34'!isAbstract	^ false! !!PRWikipediaSemLink class methodsFor: 'accessing' stamp: 'LukasKomarek 4/26/2016 19:30'!linkName	^ 'wikipedia'! !!PRWikipediaSemLink methodsFor: 'accessing-parameters' stamp: 'LukasKomarek 5/19/2016 18:37'!lang	^ self parameters at: 'lang' ifAbsent: [ ^ 'en' ]! !!PRWikipediaSemLink methodsFor: 'accessing-dynamic' stamp: 'LukasKomarek 5/18/2016 16:26'!urlEntry	| ref |	ref := (self reference splitOn: ':') second.	^ ref = '' ifTrue: [ '' ] ifFalse: [ 'wiki/' , ref ]! !!PRWikipediaSemLink methodsFor: 'accessing-dynamic' stamp: 'LukasKomarek 5/19/2016 18:30'!urlPrefix	^ 'https://' , self lang , '.wikipedia.org/'! !!PRYoutubeSemLink class methodsFor: 'testing' stamp: 'LukasKomarek 4/16/2016 13:35'!isAbstract	^ false! !!PRYoutubeSemLink class methodsFor: 'accessing' stamp: 'LukasKomarek 4/26/2016 19:30'!linkName	^ 'youtube'! !!PRYoutubeSemLink methodsFor: 'accessing-dynamic' stamp: 'LukasKomarek 5/18/2016 16:26'!urlEntry		| ref |	ref := (self reference splitOn: ':') second.	^ ref = '' ifTrue: [ '' ] ifFalse: [ 'watch?v=', ref ]! !!PRYoutubeSemLink methodsFor: 'accessing-dynamic' stamp: 'LukasKomarek 4/21/2016 15:54'!urlPrefix	^ 'https://www.youtube.com/'! !!PRInternalLink class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRInternalLink class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isValidReference: aString	^ true! !!PRInternalLink class methodsFor: 'accessing' stamp: 'lr 1/9/2009 19:20'!priority	^ 100! !!PRInternalLink class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 5/20/2015 16:38'!reference: aString	| index |	^ (index := aString indexOf: $@) isZero		ifTrue: [ super reference: aString ]		ifFalse: [ 			index = 1				ifTrue: [ self new anchor: (aString copyFrom: index + 1 to: aString size) ]				ifFalse: [ 					self new						reference: (aString copyFrom: 1 to: index - 1);						anchor: (aString copyFrom: index + 1 to: aString size);						yourself ] ]! !!PRInternalLink methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!= anObject	^ super = anObject		and: [ self anchor = anObject anchor ]! !!PRInternalLink methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitInternalLink: self! !!PRInternalLink methodsFor: 'accessing' stamp: 'lr 5/28/2006 20:48'!anchor	"Answer an anchor string the receiver is pointing to."	^ anchor! !!PRInternalLink methodsFor: 'accessing' stamp: 'CyrilFerlicot 7/2/2015 13:37'!anchor: aString	anchor := aString trimBoth! !!PRInternalLink methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!hasAnchor	^ self anchor notNil! !!PRInternalLink methodsFor: 'testing' stamp: 'CyrilFerlicot 5/20/2015 18:13'!hasReference	^ self reference notNil! !!PRInternalLink methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!hash	^ super hash bitXor: self anchor hash! !!PRInternalLink methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!isInternal	^ true! !!PRInternalLink methodsFor: 'accessing' stamp: 'CyrilFerlicot 5/21/2015 14:52'!referenceAsHTML	"I return a reference to a pillar file as an html file."	| ref |	ref := self reference.	((ref endsWith: '.pillar') or: [ ref endsWith: '.pier' ])		ifTrue: [ ref := (ref copyUpToLast: $.) , '.html' ]		ifFalse: [ PRLinkWarning signal: 'Reference : ' , ref , ' should end with .pillar or .pier' ].	^ ref! !!PRInternalLink methodsFor: 'accessing' stamp: 'CyrilFerlicot 5/21/2015 14:52'!referenceAsMarkdown	"I return a reference to a pillar file as a markdown file."	| ref |	ref := self reference.	((ref endsWith: '.pillar') or: [ ref endsWith: '.pier' ])		ifTrue: [ ref := (ref copyUpToLast: $.) , '.md' ]		ifFalse: [ PRLinkWarning signal: 'Reference : ' , ref , ' should end with .pillar or .pier' ].	^ ref! !!PRInternalLink methodsFor: 'accessing' stamp: 'CyrilFerlicot 5/20/2015 16:38'!renderAsText	| text |	text := String new writeStream.	self reference isNotNil		ifTrue: [ text nextPutAll: self reference ].	self hasAnchor		ifTrue: [ 			text				nextPutAll: '@';				nextPutAll: self anchor ].	^ text contents! !!PRLink class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 9/9/2015 17:44'!fromReference: aReference	| classes  |	classes := PRLink withAllConcreteClasses select: [ :each | each isValidReference: aReference ].	classes sort: [ :a :b | a priority < b priority ].	^ classes first reference: aReference! !!PRLink class methodsFor: 'accessing' stamp: 'CyrilFerlicot 10/29/2015 21:17'!priority	^ 0! !!PRLink methodsFor: 'visiting' stamp: 'DamienCassou 3/20/2014 18:07'!accept: aVisitor	<ignoreForCoverage "This method is ignored for test coverage because it is overriden in all subclasses and these subclasses don't need to do a super-send.">	aVisitor visitLink: self! !!PRLink methodsFor: 'testing' stamp: 'CyrilFerlicot 4/28/2015 13:12'!isBroken	"Answer ==true== if the receiver is broken."	^ false! !!PRLink methodsFor: 'testing' stamp: 'lr 4/1/2009 22:18'!isExternal	^ false! !!PRLink methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!isInternal	^ false! !!PRLink methodsFor: 'testing' stamp: 'lr 4/16/2007 12:00'!isLink	^ true! !!PRLink methodsFor: 'accessing' stamp: 'CyrilFerlicot 5/20/2015 16:35'!renderAsText	^ self reference! !!PRLink methodsFor: 'accessing' stamp: 'CyrilFerlicot 5/20/2015 16:34'!title	^ self renderAsText isEmpty		ifTrue: [ nil ]		ifFalse: [ self renderAsText ]! !!PRReference class methodsFor: 'testing' stamp: 'CyrilFerlicot 10/29/2015 21:19'!isValidReference: aString	self subclassResponsibility! !!PRReference class methodsFor: 'private' stamp: 'LukasKomarek 4/21/2016 14:58'!localFileOrExternalReference: aString	| localFileIndicator |	localFileIndicator := 'file://'.	^ (aString beginsWith: localFileIndicator)			ifTrue: [ aString allButFirst: localFileIndicator size ]			ifFalse: [ aString ]! !!PRReference class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 4/28/2015 13:00'!reference: aString	^ self new		reference: aString;		yourself! !!PRReference methodsFor: 'comparing' stamp: 'CyrilFerlicot 9/8/2015 18:46'!= anObject	^ super = anObject and: [ self reference = anObject reference and: [ self parameters = anObject parameters ] ]! !!PRReference methodsFor: 'visiting' stamp: 'CyrilFerlicot 4/28/2015 14:27'!accept: aVisitor	<ignoreForCoverage "This method is ignored for test coverage because it is overriden in all subclasses and these subclasses don't need to do a super-send.">	aVisitor visitReference: self! !!PRReference methodsFor: 'accessing-dynamic' stamp: 'CyrilFerlicot 4/28/2015 13:07'!alias	"Answer the alias of the receiver or an empty string if none."	^ self text! !!PRReference methodsFor: 'testing' stamp: 'CyrilFerlicot 4/28/2015 13:07'!hasAlias	^ self hasChildren! !!PRReference methodsFor: 'testing' stamp: 'CyrilFerlicot 4/28/2015 13:06'!hasAnchor	^ false! !!PRReference methodsFor: 'comparing' stamp: 'CyrilFerlicot 9/8/2015 18:46'!hash	^ super hash bitXor: self reference hash! !!PRReference methodsFor: 'initialization' stamp: 'YannDubois 5/2/2016 14:10'!initialize	super initialize.	self parameters: SmallDictionary new! !!PRReference methodsFor: 'accessing' stamp: 'LukasKomarek 4/21/2016 14:58'!localFileOrExternalReference	^ self class localFileOrExternalReference: self reference! !!PRReference methodsFor: 'accessing-parameters' stamp: 'CyrilFerlicot 4/28/2015 11:11'!parameters	"Answer an array of parameters."	^ parameters! !!PRReference methodsFor: 'accessing' stamp: 'CyrilFerlicot 7/1/2015 13:37'!parameters: aCollection	parameters := aCollection! !!PRReference methodsFor: 'copying' stamp: 'CyrilFerlicot 4/28/2015 13:10'!postCopy	super postCopy.	self parameters: (self parameters		collect: [ :each | each copy ])! !!PRReference methodsFor: 'accessing' stamp: 'CyrilFerlicot 4/28/2015 13:11'!reference	"Answer the reference of the receiver."	^ reference! !!PRReference methodsFor: 'accessing' stamp: 'CyrilFerlicot 4/28/2015 13:11'!reference: aString	reference := aString! !!PRReference methodsFor: 'accessing-dynamic' stamp: 'CyrilFerlicot 4/28/2015 13:06'!text	| text |	^ (text := super text) isEmpty 		ifTrue: [ self reference ]		ifFalse: [ text ]! !!PRReference methodsFor: 'accessing' stamp: 'CyrilFerlicot 4/28/2015 13:11'!title	"Answer a title of the reference, this is should never be nil."	^ self reference! !!PRSection class methodsFor: 'testing' stamp: 'CyrilFerlicot 6/2/2015 16:59'!isAbstract	^ false! !!PRSection methodsFor: 'visiting' stamp: 'CyrilFerlicot 6/2/2015 16:59'!accept: aVisitor	aVisitor visitSection: self! !!PRSlide class methodsFor: 'testing' stamp: 'CyrilFerlicot 6/3/2015 13:35'!isAbstract	^ false! !!PRSlide class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 6/3/2015 16:50'!titled: aTitle	^ self new		title: aTitle;		yourself! !!PRSlide methodsFor: 'visiting' stamp: 'CyrilFerlicot 6/3/2015 13:36'!accept: aVisitor	aVisitor visitSlide: self! !!PRSlide methodsFor: 'testing' stamp: 'CyrilFerlicot 6/5/2015 17:30'!hasLabel	^ label isNotNil! !!PRSlide methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/5/2015 16:37'!label	^ label! !!PRSlide methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/5/2015 16:37'!label: anObject	label := anObject! !!PRSlide methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/3/2015 17:27'!title	^ title isNotNil		ifTrue: [ title ]		ifFalse: [ 'New Slide' ]! !!PRSlide methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/3/2015 16:49'!title: anObject	title := anObject! !!PRTable class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRTable methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitTable: self! !!PRTable methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!columnCount	^ self children inject: 0 into: [ :max :row | max max: row columnCount ]! !!PRTable methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!rowCount	^ self children size! !!PRTableCell class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 7/20/2015 13:59'!align: aSymbolePosition heading: aBoolean withAll: aCollection	^ (self withAll: aCollection)		align: aSymbolePosition;		heading: aBoolean;		yourself! !!PRTableCell class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRTableCell methodsFor: 'comparing' stamp: 'lr 8/14/2008 08:52'!= anObject	^ super = anObject		and: [ self align = anObject align		and: [ self heading = anObject heading ] ]! !!PRTableCell methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitTableCell: self! !!PRTableCell methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!align	^ align! !!PRTableCell methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!align: aSymbol	align := aSymbol! !!PRTableCell methodsFor: 'actions' stamp: 'lr 3/9/2006 11:30'!beAlignedCenter	self align: #center! !!PRTableCell methodsFor: 'actions' stamp: 'lr 3/9/2006 11:30'!beAlignedLeft	self align: #left! !!PRTableCell methodsFor: 'actions' stamp: 'lr 3/9/2006 11:30'!beAlignedRight	self align: #right! !!PRTableCell methodsFor: 'actions' stamp: 'lr 8/14/2008 08:52'!beHeading	self heading: true! !!PRTableCell methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:30'!hash	^ super hash bitXor: self align hash! !!PRTableCell methodsFor: 'accessing' stamp: 'lr 8/14/2008 08:52'!heading	^ heading! !!PRTableCell methodsFor: 'accessing' stamp: 'lr 8/14/2008 08:52'!heading: aBoolean	heading := aBoolean! !!PRTableCell methodsFor: 'initialization' stamp: 'lr 8/14/2008 09:01'!initialize	super initialize.	heading := false! !!PRTableCell methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAligned	^ self align notNil! !!PRTableCell methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAlignedCenter	^ self align = #center! !!PRTableCell methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAlignedLeft	^ self align = #left! !!PRTableCell methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAlignedRight	^ self align = #right! !!PRTableCell methodsFor: 'testing' stamp: 'lr 8/14/2008 09:00'!isHeading	^ self heading! !!PRTableRow class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRTableRow methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitTableRow: self! !!PRTableRow methodsFor: 'accessing' stamp: 'lr 3/9/2006 11:30'!columnCount	^ self children size! !!PRTableRow methodsFor: 'testing' stamp: 'DamienCassou 6/3/2014 10:42'!isHeading	"For a row to be considered a heading row, all cells must be either heading or empty. A totally empty row is not considered a heading row."	^ (self children anySatisfy: [ :cell | cell hasChildren ])		and: [ self children allSatisfy: [ :cell | cell isHeading or: [ cell hasChildren not ] ] ]! !!PRDocumentItem methodsFor: 'comparing' stamp: 'ThibaultArloing 5/10/2016 16:04'!= anObject	^ self species = anObject species! !!PRDocumentItem methodsFor: 'visiting' stamp: 'DamienCassou 3/20/2014 18:08'!accept: aVisitor	<ignoreForCoverage "This method is ignored for test coverage because it is overriden in all subclasses and these subclasses don't need to do a super-send.">	aVisitor visitDocumentItem: self! !!PRDocumentItem methodsFor: 'accessing' stamp: 'CyrilFerlicot 5/19/2015 16:16'!counter	^ counter! !!PRDocumentItem methodsFor: 'accessing' stamp: 'CyrilFerlicot 5/19/2015 16:16'!counter: anObject	counter := anObject! !!PRDocumentItem methodsFor: 'testing' stamp: 'lr 3/9/2006 11:29'!hasChildren	^ false! !!PRDocumentItem methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:29'!hash	^ self species hash! !!PRDocumentItem methodsFor: 'initialization' stamp: 'CyrilFerlicot 5/20/2015 15:14'!initialize	counter := PRNotFoundCounter maxLevel: 5! !!PRDocumentItem methodsFor: 'testing' stamp: 'CyrilFerlicot 6/18/2015 10:58'!isColumnBeginning	^ false! !!PRDocumentItem methodsFor: 'testing' stamp: 'CyrilFerlicot 6/18/2015 10:47'!isColumnsBeginning	^ false! !!PRDocumentItem methodsFor: 'testing' stamp: 'CyrilFerlicot 6/18/2015 11:10'!isColumnsEnding	^ false! !!PRDocumentItem methodsFor: 'testing' stamp: 'ThibaultAroing 5/26/2016 14:03'!isDocument	^self class = PRDocument! !!PRDocumentItem methodsFor: 'testing' stamp: 'BenComan 5/28/2014 22:29'!isGroup	^false! !!PRDocumentItem methodsFor: 'testing' stamp: 'CyrilFerlicot 5/23/2015 20:08'!isHeader	^ false! !!PRDocumentItem methodsFor: 'testing' stamp: 'lr 4/16/2007 12:00'!isLink	^ false! !!PRDocumentItem methodsFor: 'testing' stamp: 'CyrilFerlicot 6/3/2015 13:47'!isSlideBeginning	^ false! !!PRDocumentItem methodsFor: 'helpers' stamp: 'DamienCassou 10/15/2015 11:36'!parser  ^ self class parser! !!PRDocumentItem methodsFor: 'accessing-dynamic' stamp: 'lr 5/28/2006 20:31'!text	"Answer a string representation of the receiver."	^ String new! !!PRFootnote class methodsFor: 'testing' stamp: 'YannDubois 5/3/2016 10:06'!isAbstract	^ false! !!PRFootnote class methodsFor: 'instance creation' stamp: 'YannDubois 5/3/2016 10:47'!noted: aString	^ self new note: aString.! !!PRFootnote methodsFor: 'visiting' stamp: 'YannDubois 5/3/2016 10:09'!accept: aVisitor	aVisitor visitFootnote: self.! !!PRFootnote methodsFor: 'accessing' stamp: 'YannDubois 5/3/2016 10:04'!note	^ note! !!PRFootnote methodsFor: 'accessing' stamp: 'YannDubois 5/3/2016 10:05'!note: aString	note := aString! !!PRHorizontalRule class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRHorizontalRule methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitHorizontalRule: self! !!PRLineBreak class methodsFor: 'testing' stamp: 'lr 12/9/2007 09:19'!isAbstract	^ false! !!PRLineBreak methodsFor: 'visiting' stamp: 'lr 12/9/2007 09:05'!accept: aVisitor	aVisitor visitLineBreak: self! !!PRStructure class methodsFor: 'testing' stamp: 'ThibaultArloing 5/25/2016 09:08'!isAbstract	^false! !!PRStructure methodsFor: 'visiting' stamp: 'ThibaultArloing 5/9/2016 14:49'!accept: aVisitor	aVisitor visitStructure: self! !!PRStructure methodsFor: 'accesing' stamp: 'ThibaultArloing 5/24/2016 16:32'!structDict	^ structDict ifNil: [ Dictionary new ]! !!PRStructure methodsFor: 'accesing' stamp: 'ThibaultArloing 5/24/2016 16:32'!structDict: aDictionary	structDict := aDictionary! !!PRStructure methodsFor: 'accesing' stamp: 'ThibaultArloing 5/25/2016 10:00'!tag ^ 	tag ifNil: [ 'default' ]! !!PRStructure methodsFor: 'accesing' stamp: 'ThibaultArloing 5/25/2016 10:03'!tag: aTag	tag := aTag! !!PRCommentedLine methodsFor: 'visiting' stamp: 'DamienCassou 11/18/2013 15:49'!accept: aVisitor	aVisitor visitCommentedLine: self! !!PRRaw class methodsFor: 'instance creation' stamp: 'lr 9/25/2011 13:38'!content: aString type: aTypeString	^ (self content: aString)		type: aTypeString;		yourself! !!PRRaw class methodsFor: 'accessing' stamp: 'lr 9/25/2011 13:48'!verbatimTypeSeparator	^ ':'! !!PRRaw class methodsFor: 'accessing' stamp: 'BenjaminVanRyseghem 11/20/2013 00:24'!verbatimTypes	"The verbatim types to be recognized, for now this is hardcoded."		^ #('text' 'html' 'latex' 'markdown')! !!PRRaw methodsFor: 'comparing' stamp: 'lr 2/2/2010 15:17'!= anObject	^ super = anObject and: [ self type = anObject type ]! !!PRRaw methodsFor: 'visiting' stamp: 'DamienCassou 11/20/2013 17:22'!accept: aVisitor	aVisitor visitRaw: self! !!PRRaw methodsFor: 'comparing' stamp: 'lr 2/2/2010 15:16'!hash	^ super hash bitXor: self type hash! !!PRRaw methodsFor: 'testing' stamp: 'DamienCassou 11/20/2013 17:45'!isForType: aSymbol	^ self type isNil or: [ self type = aSymbol ]! !!PRRaw methodsFor: 'accessing' stamp: 'lr 2/2/2010 15:16'!type	^ type! !!PRRaw methodsFor: 'accessing' stamp: 'lr 2/2/2010 15:16'!type: aString	type := aString! !!PRScript class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 7/1/2015 13:55'!content: aString parameters: parameters	^ (self content: aString)		parameters: parameters;		yourself! !!PRScript methodsFor: 'comparing' stamp: 'CyrilFerlicot 5/1/2015 18:12'!= anObject	"We use the method language to be sure that the language is a PRAbstractScriptLanguage and not a string."		^ super = anObject		and: [ 			self language.			anObject language.			self parameters = anObject parameters ]! !!PRScript methodsFor: 'visiting' stamp: 'DamienCassou 11/18/2013 15:53'!accept: aVisitor	aVisitor visitScript: self! !!PRScript methodsFor: 'accessing-delegated' stamp: 'DamienCassou 2/29/2016 16:37'!caption	^ caption		ifNil: [ 			caption := self				parameters at: 'caption'				ifPresent: [ :string | (PRDocument parser parse: string) children first ]				ifAbsent: [ PRParagraph with: (PRText content: '') ] ]! !!PRScript methodsFor: 'accessing-delegated' stamp: 'CyrilFerlicot 7/1/2015 13:57'!caption: aString	parameters := self parameters copyWith: 'caption' -> aString! !!PRScript methodsFor: 'accessing-delegated' stamp: 'DamienCassou 1/14/2014 13:38'!eval: aString	parameters := parameters copyWith: 'eval' -> aString! !!PRScript methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 8/31/2015 21:21'!evaluate	| content |	content := self evaluationString.	^ [ (PRDocument parser parse: content) children ]		on: Error		do: [ :e | PRBoldFormat with: (PRText content: e messageText) ]! !!PRScript methodsFor: 'comparing' stamp: 'CyrilFerlicot 4/23/2015 12:53'!evaluationString	^ String		streamContents: [ :stream | 			| evaluator |			evaluator := PRScriptEvaluationEnvironment new				setStream: stream;				yourself.			[ Compiler evaluate: self text for: evaluator logged: false ]				on: Error				do: [ :e | 					stream						nextPutAll: '= ';						nextPutAll: e description ] ]! !!PRScript methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 4/30/2015 12:53'!firstLine: aString	parameters := parameters copyWith: 'firstLine' -> aString! !!PRScript methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 4/30/2015 12:53'!fromFile: aString	parameters := parameters copyWith: 'fromFile' -> aString! !!PRScript methodsFor: 'testing' stamp: 'CyrilFerlicot 4/13/2015 23:01'!hasCaption	^ self parameters at: 'caption' ifPresent: [ :param | param isEmptyOrNil not ] ifAbsent: [ false ]! !!PRScript methodsFor: 'testing' stamp: 'CyrilFerlicot 4/13/2015 23:01'!hasLabel	| label |	label := self parameters at: 'label' ifAbsent: [ ^ false ].	^ label isEmptyOrNil not! !!PRScript methodsFor: 'testing' stamp: 'CyrilFerlicot 4/30/2015 15:07'!hasNoCode	^ (self text copyWithout: Character tab) isEmpty! !!PRScript methodsFor: 'testing' stamp: 'DamienCassou 2/29/2016 16:44'!hasShortCaption	^ self parameters at: 'shortCaption'		ifPresent: [ :param | param isEmptyOrNil not ]		ifAbsent: [ false ]! !!PRScript methodsFor: 'comparing' stamp: 'CyrilFerlicot 4/21/2015 11:23'!hash	^ super hash bitXor: self properties hash! !!PRScript methodsFor: 'accessing-delegated' stamp: 'YannDubois 4/5/2016 09:21'!hideable: aString	parameters := parameters copyWith: 'hideable' -> aString! !!PRScript methodsFor: 'initialization' stamp: 'YannDubois 5/2/2016 14:10'!initialize	super initialize.	parameters := SmallDictionary new! !!PRScript methodsFor: 'testing' stamp: 'CyrilFerlicot 4/23/2015 10:43'!isEvaluated	^ self parameters at: 'eval' ifPresent: [ :eva | eva = 'true' or: [ eva = true ] ] ifAbsent: [ false ]! !!PRScript methodsFor: 'testing' stamp: 'YannDubois 4/5/2016 10:44'!isHideable	^ self parameters at: 'hideable' ifPresent: [ :hideable | hideable = 'true' or: [ hideable = true ] ] ifAbsent: [ false ]! !!PRScript methodsFor: 'testing' stamp: 'ThibaultArloing 5/11/2016 16:10'!isStructure	^ self parameters includesKey: 'structure'! !!PRScript methodsFor: 'accessing-delegated' stamp: 'CyrilFerlicot 4/13/2015 23:01'!label	^ self parameters at: 'label' ifAbsent: ['']! !!PRScript methodsFor: 'accessing-delegated' stamp: 'DamienCassou 1/9/2014 15:42'!label: aString	parameters := parameters copyWith: 'label' -> aString! !!PRScript methodsFor: 'accessing-delegated' stamp: 'CyrilFerlicot 4/13/2015 23:01'!language	^ self		parameters at: 'language'		ifPresent: [ :language | 			language isString				ifTrue: [ 					| realObject |					realObject := PRAbstractScriptLanguage for: language.					self language: realObject.					realObject ]				ifFalse: [ language ] ]		ifAbsent: [ PRUnspecifiedScriptLanguage default ]! !!PRScript methodsFor: 'accessing-delegated' stamp: 'CyrilFerlicot 7/1/2015 14:02'!language: aLanguage	self parameters at: 'language' put: aLanguage! !!PRScript methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 4/30/2015 12:53'!lastLine: aString	parameters := parameters copyWith: 'lastLine' -> aString! !!PRScript methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 4/23/2015 11:23'!lineNumber: aString	parameters := parameters copyWith: 'lineNumber' -> aString! !!PRScript methodsFor: 'accessing-parameters' stamp: 'CyrilFerlicot 7/1/2015 14:02'!parameters	^ parameters! !!PRScript methodsFor: 'accessing-parameters' stamp: 'CyrilFerlicot 7/1/2015 13:39'!parameters: aCollection	parameters := aCollection! !!PRScript methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 4/24/2015 17:39'!removePossibleParagraph: content	^ (content first class = PRParagraph ) ifTrue:[ content first children ] ifFalse: [ content ]! !!PRScript methodsFor: 'accessing-delegated' stamp: 'DamienCassou 2/29/2016 16:45'!shortCaption	^ self parameters at: 'shortCaption' ifAbsent: ['']! !!PRScript methodsFor: 'accessing-delegated' stamp: 'DamienCassou 2/29/2016 16:41'!shortCaption: aString 	parameters := parameters copyWith: 'shortCaption' -> aString! !!PRScript methodsFor: 'testing' stamp: 'ThibaultArloing 5/9/2016 10:10'!structureName	^ self parameters at: 'structure'! !!PRScript methodsFor: 'testing' stamp: 'ThibaultArloing 5/9/2016 13:51'!structureName: aName	^ self parameters at: 'structure' put: aName! !!PRScript methodsFor: 'accessing' stamp: 'DamienCassou 1/8/2014 18:06'!text: aString	super text: aString withoutTrailingNewlines! !!PRText class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 7/1/2015 13:55'!content: aString	^ self new text: aString! !!PRText class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ false! !!PRText methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:30'!= anObject	^ super = anObject		and: [ self text = anObject text ]! !!PRText methodsFor: 'visiting' stamp: 'lr 3/30/2007 20:01'!accept: aVisitor	aVisitor visitText: self! !!PRText methodsFor: 'comparing' stamp: 'lr 3/9/2006 11:30'!hash	^ super hash bitXor: self text hash! !!PRText methodsFor: 'testing' stamp: 'BenjaminVanRyseghem 1/15/2014 15:45'!isText	^ self class name = #PRText! !!PRText methodsFor: 'printing' stamp: 'lr 3/9/2006 11:30'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' text: '; print: self text! !!PRText methodsFor: 'accessing' stamp: 'lr 4/5/2007 14:40'!text	"Answer the string the receiver is representing."	^ text! !!PRText methodsFor: 'accessing' stamp: 'lr 4/5/2007 14:40'!text: aString	text := aString! !!PRObject class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:30'!isAbstract	^ true! !!PRObject class methodsFor: 'instance creation' stamp: 'jf 9/18/2009 15:41'!new	"Create a new instance of this class and checks if it isn't abstract."	self isAbstract		ifTrue: [ self error: self name , ' is abstract.' ].	^ super new! !!PRObject class methodsFor: 'reflection' stamp: 'lr 3/9/2006 11:30'!withAllConcreteClasses	^ Array streamContents: [ :stream |		self withAllConcreteClassesDo: [ :each |			stream nextPut: each ] ]! !!PRObject class methodsFor: 'reflection' stamp: 'CyrilFerlicot 4/28/2015 14:04'!withAllConcreteClassesDo: aBlock	self		withAllSubclassesDo: [ :each | 			each isAbstract				ifFalse: [ aBlock value: each ] ]! !!PRObject methodsFor: 'visiting' stamp: 'DamienCassou 2/5/2014 12:45'!accept: aVisitor	<ignoreForCoverage>	"Dispatch to ==aVisitor== depending on the receiver."! !!PRObject methodsFor: 'private' stamp: 'DamienCassou 10/28/2013 16:47'!errorPropertyNotFound: aSelector	PRPropertyError signal: 'Property ' , aSelector , ' not found.'! !!PRObject methodsFor: 'testing' stamp: 'lr 4/10/2007 21:49'!hasProperty: aKey	"Test if the property ==aKey== is defined within the receiver."	^ self properties includesKey: aKey! !!PRObject methodsFor: 'copying' stamp: 'lr 3/9/2006 11:29'!postCopy	super postCopy.	properties := properties copy! !!PRObject methodsFor: 'copying' stamp: 'DamienCassou 2/5/2014 12:45'!postCopyTo: anObject	<ignoreForCoverage>! !!PRObject methodsFor: 'printing' stamp: 'DamienCassou 2/5/2014 12:46'!printOn: aStream	<ignoreForCoverage>	super printOn: aStream.	aStream nextPut: $[; print: self identityHash; nextPut: $]! !!PRObject methodsFor: 'accessing-properties' stamp: 'lr 5/28/2006 17:01'!properties	"Answer the property dictionary of the receiver."	^ properties ifNil: [ properties := Dictionary new ]! !!PRObject methodsFor: 'accessing-properties' stamp: 'lr 4/10/2007 21:49'!propertyAt: aKey	"Answer the value of the property ==aKey==, raises an error if the property doesn't exist."	^ self propertyAt: aKey ifAbsent: [ self errorPropertyNotFound: aKey ]! !!PRObject methodsFor: 'accessing-properties' stamp: 'lr 4/10/2007 21:49'!propertyAt: aKey ifAbsent: aBlock	"Answer the value of the property ==aKey==, or the result of ==aBlock== if the property doesn't exist."	^ self properties at: aKey ifAbsent: aBlock! !!PRObject methodsFor: 'accessing-properties' stamp: 'lr 4/10/2007 21:49'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the value of the property ==aKey==, or if the property doesn't exist adds and answers the result of evaluating ==aBlock==."	^ self properties at: aKey ifAbsentPut: aBlock! !!PRObject methodsFor: 'accessing-properties' stamp: 'lr 4/10/2007 21:50'!propertyAt: aKey put: aValue	"Adds or replaces the property ==aKey== with ==aValue==."	^ self properties at: aKey put: aValue! !!PRDefinitionListRenderer methodsFor: 'rendering' stamp: 'ThibaultArloing 5/24/2016 16:46'!renderFor: aStructure	| list |	list := PRDefinitionList new.	aStructure structDict keys		do: [ :each | 			list				add: (PRTermItem with: (PRText new text: each));				add: (PRDataItem with: (PRText new text: (aStructure structDict at: each))) ].	^ list! !!PRStructureRenderer class methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 5/24/2016 16:44'!isAbstract	^ self = PRStructureRenderer ! !!PRStructureRenderer methodsFor: 'rendering' stamp: 'ThibaultArloing 5/24/2016 16:44'!renderFor: aStructure	^ self subclassResponsibility ! !!PRTableRenderer methodsFor: 'rendering' stamp: 'ThibaultArloing 5/24/2016 16:53'!renderFor: aStructure	| table |	table := PRTable new.	aStructure structDict keys		do: [ :each | 			table				add:					(PRTableRow new						add: (PRTableCell with: (PRText new text: each));						add: (PRTableCell with: (PRText new text: (aStructure structDict at: each)));						yourself) ].	^ table! !!PRDependencies methodsFor: 'accessing' stamp: 'YannDubois 4/25/2016 16:29'!cachedDependencies	^ cachedDependencies ! !!PRDependencies methodsFor: 'visiting' stamp: 'YannDubois 4/25/2016 16:29'!start: aDocument	cachedDependencies := Set new.	super start: aDocument.	^ cachedDependencies.! !!PRFileDependencies class methodsFor: 'testing' stamp: 'YannDubois 4/25/2016 16:46'!isAbstract	^ false! !!PRFileDependencies methodsFor: 'visiting-document' stamp: 'YannDubois 4/26/2016 15:11'!visitInternalLink: anInternalLink	anInternalLink hasReference		ifTrue: [ self cachedDependencies add: (anInternalLink localFileOrExternalReference) ].	super visitInternalLink: anInternalLink ! !!PRImageDependencies class methodsFor: 'as yet unclassified' stamp: 'YannDubois 4/25/2016 13:06'!isAbstract	^ false! !!PRImageDependencies methodsFor: 'visiting-document' stamp: 'YannDubois 4/26/2016 15:09'!visitFigure: anObject	cachedDependencies add: anObject localFileOrExternalReference.	super visitFigure: anObject.! !!PRVisitor class methodsFor: 'testing' stamp: 'DamienCassou 3/20/2014 18:09'!isAbstract	<ignoreForCoverage "This method is ignored for test coverage because it is overriden in all subclasses and these subclasses don't need to do a super-send.">	^ true! !!PRVisitor methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!start: anObject	self visit: anObject! !!PRVisitor methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!visit: anObject	anObject acceptDecorated: self! !!PRVisitor methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!visitAll: aCollection	aCollection do: [ :each | self visit: each ]! !!PRVisitor methodsFor: 'visiting' stamp: 'lr 3/9/2006 11:30'!visitAll: aCollection separatedBy: aBlock	aCollection do: [ :each | self visit: each ] separatedBy: aBlock! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitAnchor: anObject	self visitDocumentItem: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 5/26/2009 22:07'!visitAnnotatedParagraph: aDocument	self visitParagraph: aDocument! !!PRVisitor methodsFor: 'visiting-annotations' stamp: 'CyrilFerlicot 4/10/2015 11:13'!visitAnnotation: anAnnotation	self visitDocumentItem: anAnnotation! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitBoldFormat: anObject	self visitFormat: anObject! !!PRVisitor methodsFor: 'visiting-annotations' stamp: 'ThibaultArloing 5/3/2016 15:50'!visitCitation: aCitation	self visitDocumentItem: aCitation! !!PRVisitor methodsFor: 'visiting-annotations' stamp: 'ThibaultArloing 5/3/2016 15:50'!visitCitationAnnotation: aCitation	self visitAnnotation: aCitation! !!PRVisitor methodsFor: 'visiting-annotations' stamp: 'CyrilFerlicot 6/18/2015 11:23'!visitColumn: aColumn	self visitDocumentGroup: aColumn! !!PRVisitor methodsFor: 'visiting-annotations' stamp: 'CyrilFerlicot 6/18/2015 10:20'!visitColumnAnnotation: aColumnAnnotation	self visitAnnotation: aColumnAnnotation! !!PRVisitor methodsFor: 'visiting-annotations' stamp: 'CyrilFerlicot 6/18/2015 11:23'!visitColumns: aColumns	self visitDocumentGroup: aColumns! !!PRVisitor methodsFor: 'visiting-annotations' stamp: 'CyrilFerlicot 6/18/2015 10:19'!visitColumnsAnnotation: aColumnsAnnotation	self visitAnnotation: aColumnsAnnotation! !!PRVisitor methodsFor: 'visiting-document' stamp: 'DamienCassou 11/18/2013 18:05'!visitCommentedLine: aCommentedLine! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 12/30/2007 21:53'!visitDataItem: anObject	self visitListItem: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 12/30/2007 19:33'!visitDefinitionList: anObject	self visitList: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitDocument: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:05'!visitDocumentGroup: anObject	self visitAll: anObject children! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:04'!visitDocumentItem: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'DamienCassou 3/20/2014 17:49'!visitEmptyParagraph: anObject	<ignoreForCoverage "This method is ignored for coverage because visiting an empty paragraph is typically very much different from visiting a paragraph.">		self visitParagraph: anObject! !!PRVisitor methodsFor: 'visiting-annotations' stamp: 'CyrilFerlicot 6/18/2015 10:20'!visitEndColumnsAnnotation: aEndColumnsAnnotation	self visitAnnotation: aEndColumnsAnnotation! !!PRVisitor methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 4/28/2015 15:14'!visitExternalLink: anObject	self visitLink: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'YannDubois 4/25/2016 11:03'!visitFigure: anObject	self visitReference: anObject! !!PRVisitor methodsFor: 'visiting-annotations' stamp: 'YannDubois 5/3/2016 10:12'!visitFootnote: aFootnote	self visitDocumentItem: aFootnote! !!PRVisitor methodsFor: 'visiting-annotations' stamp: 'YannDubois 5/3/2016 10:12'!visitFootnoteAnnotation: aFootnoteAnnotation	self visitAnnotation: aFootnoteAnnotation! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitFormat: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitHeader: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitHorizontalRule: anObject	self visitDocumentItem: anObject! !!PRVisitor methodsFor: 'visiting-annotations' stamp: 'CyrilFerlicot 4/10/2015 11:14'!visitInputFileAnnotation: anInputFileAnnotation	self visitAnnotation: anInputFileAnnotation! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitInternalLink: anObject	self visitLink: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitItalicFormat: anObject	self visitFormat: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'DamienCassou 3/20/2014 17:51'!visitLineBreak: anObject	<ignoreForCoverage "This method is ignored for coverage because visiting a line break is typically very much different from visiting a standard document item.">	self visitDocumentItem: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 4/28/2015 18:37'!visitLink: anObject	self visitReference: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitList: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitListItem: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitMailLink: anObject	self visitExternalLink: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitMonospaceFormat: anObject	self visitFormat: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitOrderedList: anObject	self visitList: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitParagraph: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitPreformatted: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'DamienCassou 11/20/2013 17:22'!visitRaw: aRaw	self visitText: aRaw! !!PRVisitor methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 4/28/2015 14:27'!visitReference: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'DamienCassou 11/18/2013 17:40'!visitScript: aScript 	self visitText: aScript! !!PRVisitor methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/2/2015 16:59'!visitSection: aSection	self visitDocumentGroup: aSection! !!PRVisitor methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/3/2015 13:36'!visitSlide: aSlide	self visitDocumentGroup: aSlide! !!PRVisitor methodsFor: 'visiting-annotations' stamp: 'CyrilFerlicot 6/1/2015 16:23'!visitSlideTitleAnnotation: aSlideTitleAnnotation	self visitAnnotation: aSlideTitleAnnotation! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 5/31/2007 07:46'!visitStrikethroughFormat: anObject	self visitFormat: anObject! !!PRVisitor methodsFor: 'visiting-annotations' stamp: 'ThibaultArloing 5/9/2016 14:56'!visitStructure: aStructure	self visitDocumentItem: aStructure! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitSubscriptFormat: anObject	self visitFormat: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitSuperscriptFormat: anObject	self visitFormat: anObject! !!PRVisitor methodsFor: 'visiting-annotations' stamp: 'CyrilFerlicot 5/29/2015 10:27'!visitTOCAnnotation: aTOCAnnotation	self visitAnnotation: aTOCAnnotation! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitTable: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitTableCell: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitTableRow: anObject	self visitDocumentGroup: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 12/30/2007 21:53'!visitTermItem: anObject	self visitListItem: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitText: anObject	self visitDocumentItem: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitUnderlineFormat: anObject	self visitFormat: anObject! !!PRVisitor methodsFor: 'visiting-document' stamp: 'lr 3/30/2007 20:01'!visitUnorderedList: anObject	self visitList: anObject! !!PRCascadingCounter class methodsFor: 'instance creation' stamp: 'DamienCassou 3/5/2013 18:09'!maxLevel: anInteger	^ self new 		setMaxLevel: anInteger;		yourself! !!PRCascadingCounter methodsFor: 'accessing' stamp: 'DamienCassou 11/21/2013 10:49'!current	^ self deepCopy! !!PRCascadingCounter methodsFor: 'action' stamp: 'CyrilFerlicot 5/18/2015 15:39'!dontIncrementAt: level 	counters at: level put: -1! !!PRCascadingCounter methodsFor: 'accessing' stamp: 'DamienCassou 11/21/2013 12:54'!elements	^ counters first: self indexOfLastNonZero! !!PRCascadingCounter methodsFor: 'action' stamp: 'DamienCassou 3/5/2013 18:04'!incrementAt: level 	counters at: level put: (counters at: level) + 1.	level + 1 to: counters size		do: [ :i | counters at: i put: 0 ]! !!PRCascadingCounter methodsFor: 'accessing' stamp: 'DamienCassou 11/21/2013 13:00'!indexOfLastNonZero	counters size to: 1 by: -1 do: [ :index | 		(counters at: index) strictlyPositive			ifTrue: [ ^ index ] ].	^ 1! !!PRCascadingCounter methodsFor: 'testing' stamp: 'CyrilFerlicot 5/20/2015 15:06'!isValidCounter	^ true! !!PRCascadingCounter methodsFor: 'printing' stamp: 'DamienCassou 11/21/2013 13:04'!printOn: aStream	self elements do: [ :each | aStream nextPutAll: each printString ] separatedBy: [ aStream nextPut: $. ]! !!PRCascadingCounter methodsFor: 'initialization' stamp: 'DamienCassou 3/5/2013 18:02'!setMaxLevel: anInteger	counters := Array new: anInteger withAll: 0.! !!PRNotFoundCounter methodsFor: 'accessing' stamp: 'BenjaminVanRyseghem 1/9/2014 12:29'!elements	^ { '?' }! !!PRNotFoundCounter methodsFor: 'testing' stamp: 'CyrilFerlicot 5/20/2015 15:06'!isValidCounter	^ false! !!PRDocGeneratorAboutScriptLanguage class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 4/23/2015 15:56'!on: aStream 		"I generate the documentation of the scripts languages on a Stream."		^self new 		stream: aStream;		generateDoc;		stream! !!PRDocGeneratorAboutScriptLanguage methodsFor: 'action' stamp: 'CyrilFerlicot 4/23/2015 15:55'!generateDoc	"I return a Stream with the documentation of the script languages supported by pillar's script."	PRRealScriptLanguage subclasses do: [ :subClass | self writeDocOf: subClass ].	^ self stream! !!PRDocGeneratorAboutScriptLanguage methodsFor: 'initialization' stamp: 'CyrilFerlicot 4/23/2015 15:50'!initialize	super initialize.	self stream: String new writeStream! !!PRDocGeneratorAboutScriptLanguage methodsFor: 'accessing' stamp: 'CyrilFerlicot 4/23/2015 15:59'!stream	^ stream! !!PRDocGeneratorAboutScriptLanguage methodsFor: 'accessing' stamp: 'CyrilFerlicot 4/23/2015 15:58'!stream: anObject	stream := anObject! !!PRDocGeneratorAboutScriptLanguage methodsFor: 'printing' stamp: 'CyrilFerlicot 4/23/2015 16:31'!writeDocOf: aClass	self writeDocOf: aClass on: self stream! !!PRDocGeneratorAboutScriptLanguage methodsFor: 'printing' stamp: 'CyrilFerlicot 4/23/2015 16:31'!writeDocOf: aClass on: aStream	aStream		nextPutAll: '- ';		nextPutAll: aClass name;		nextPutAll: ' which tag is: ';		nextPutAll: aClass standardName; lf! !!PRScriptEvaluationEnvironment methodsFor: 'initialize-release' stamp: 'DamienCassou 4/4/2015 22:16'!setStream: aStream	stream := aStream! !!Trait method!hasParameter: aKey	self		parameters at: aKey		ifAbsent: [ ^ false ].	^ true! !!Trait method!hasParameter: aKey	self		parameters at: aKey		ifAbsent: [ ^ false ].	^ true! !!Trait method!hasParameter: aKey	self		parameters at: aKey		ifAbsent: [ ^ false ].	^ true! !!Trait method!hasParameters	^ self parameters isEmpty not! !!Trait method!hasParameters	^ self parameters isEmpty not! !!Trait method!hasParameters	^ self parameters isEmpty not! !!Trait method!parameterAt: aKey put: aValue	^ self parameters at: aKey put: aValue! !!Trait method!parameterAt: aKey put: aValue	^ self parameters at: aKey put: aValue! !!Trait method!parameterAt: aKey put: aValue	^ self parameters at: aKey put: aValue! !!Trait method!parameters	^ self explicitRequirement! !!Trait method!parameters	^ self explicitRequirement! !!Trait method!parameters	^ self explicitRequirement! !"Pillar-Model"!!PRTPipe commentStamp: 'YannDubois 7/12/2016 13:38' prior: 0!I am a trait used to factorize similar behavior on PRPipeline and PRPhase.!!PRTitleConfiguration commentStamp: 'CyrilFerlicot 6/24/2015 16:46' prior: 0!I contains the configuration of the numbering of a header level.My level is the level of the header I describe.Numbering is a boolean. If numbering is at false the numerator will not take this level of header into account.If size is at 0 i'll take this level of header into account for the numerator but i'll not render the counter. If my size is at 1 i'll only render the numer of my header level. If my size x i'll render the counter of my level and the counter of x-1 of my parents.renderAs allow me to know what kind of representation I want for my counter. It can be "number", "roman", "letter" or "upperLetter".If numbering is at false, the size need to be 0.!!PRLevelLetterConfiguration commentStamp: 'CyrilFerlicot 5/18/2015 14:57' prior: 0!I'm a configuration that render myself as a Letter.!!PRLevelNumberConfiguration commentStamp: 'CyrilFerlicot 5/18/2015 14:57' prior: 0!I'm a configuration that render myself as a Number.!!PRLevelRomanConfiguration commentStamp: 'CyrilFerlicot 5/18/2015 14:58' prior: 0!I'm a configuration that render myself as a Roman number.!!PRLevelUpperLetterConfiguration commentStamp: 'CyrilFerlicot 5/18/2015 14:58' prior: 0!I'm a configuration that render myself as an upper letter.!!PRTransformersDocumentation commentStamp: 'CyrilFerlicot 6/16/2015 18:07' prior: 0!I am a class that will generate the documentation of the transformers in Pillar.I will use the 'pillarTransformer:key:documentation' pragma. I will display the keyword and the documentation of a transformer. The keyword is use to disable a transformer into a configuration.To use me you can execute :| stream |stream := '' writeStream.PRTransformersDocumentation on: stream.stream contents!!PRMagritteHeaderLevelDescription commentStamp: 'CyrilFerlicot 6/22/2015 17:19' prior: 0!I am the Magritte description of a header level.!!PRPillarConfiguration commentStamp: 'StephaneDucasse 3/31/2015 10:24' prior: 0!I manage pillar specific configuration.!!PRMagritteNewLineDescription commentStamp: 'CyrilFerlicot 6/29/2015 09:57' prior: 0!I am a description of a new line in Pillar.!!PRCreateSymLink commentStamp: 'ThibaultArloing 6/21/2016 10:28' prior: 0!I allow to create a symbolic Link!!PRExportBrush commentStamp: '<historical>' prior: 0!I'm the superclass of all brushes. A brush is something you can add on a canvas. For exemple, LaTeX command and environment brushes can be added to a LaTeX canvas; HTML tags can be added to an HTML canvas.!!PRExportCanvas commentStamp: '<historical>' prior: 0!I am the place where the visitors will write stuff. I output everything to a stream. Eventhough I have some streaming capabilities (#nextPutAll:, #raw:, ...), my clients should use brushes as much as possible instead. This is because the brushes will take the responsibility to write correct text for the clients.!!PROutputStream commentStamp: '<historical>' prior: 0!I represent a very simple interface for writing text to a stream.I'm associated with a configuration which knows some details about the output stream (e.g., the line ending convention)!!PRMagrittePathOrStreamDescription commentStamp: '' prior: 0!I am a path or WriteStream description for Pillar.!!PRMagritteScriptLanguageDescription commentStamp: 'CyrilFerlicot 6/22/2015 16:58' prior: 0!I am the Magritte description of a Script Language.!!PRCheckPhase commentStamp: 'YannDubois 5/24/2016 14:44' prior: 0!I am a phase of the export of Pillar filesI take in input, a collection of PRDcument, I check the files, and I return them.!!PRCheckRaw commentStamp: 'YannDubois 5/24/2016 14:47' prior: 0!I am a phase of the export of Pillar filesI take in input a collection of PRDocument, I check if the raws have a good type!!PRDocumentWriter commentStamp: '<historical>' prior: 0!I'm the superclass of all classes supposed to output a pier document to a text file. I have a canvas to which the subclasses can write to using dedicated brushes. I have a configuration which specifies some details about how to write text (e.g., end of line convention).!!PRNodeTransformer commentStamp: 'CyrilFerlicot 6/2/2015 16:54' prior: 0!I'm an abstract class. I allows the transformation of a tree. I'll visit a tree and if a node need to be transform i'll replace the node by his transformation.The replacement is a Stack with all the nodes of the branch of the node I'm visiting.!!PRAnchorOfSection commentStamp: 'CyrilFerlicot 4/20/2015 14:07' prior: 0!After each title I add an anchor with the title of the section.!!PRCitationTransformer commentStamp: 'ThibaultArloing 5/3/2016 15:58' prior: 0!I am a transformer which will replace the citation annotations  by a real citation structure.!!PRCleanAnnotationInParagraphTransfomer commentStamp: 'DamienCassou 7/20/2016 16:21' prior: 0!When a paragraph only contains an annotation, I remove the paragraph so the annotation becomes a top-level child of the document.!!PRFootnoteTransformer commentStamp: 'DamienCassou 7/18/2016 15:54' prior: 0!I replace each ==footnote== annotation with a structure of footnote.!!PRHeaderCapitalizationTransformer commentStamp: 'DamienCassou 7/18/2016 16:19' prior: 0!I capitalize all headers following the ==level*== configuration parameters.!!PRHeadingLevelOffset commentStamp: 'DamienCassou 7/18/2016 16:28' prior: 0!Convert from the level of a Pillar heading to the level of heading in the exported document. For example, a ==headingLevelOffset== of 3 converts a 1st level Pillar heading to an ==<h4>== in HTML.!!PRNumeratingLinksVisitor commentStamp: 'CyrilFerlicot 5/19/2015 18:09' prior: 0!I'm created with an anchorsMapping and i give counters at each internal links of the document I visit.!!PRNumeratingVisitor commentStamp: 'DamienCassou 7/18/2016 15:53' prior: 0!I add numbers to all titles, scripts, figures, and internal links.!!PRRemoveHideableScripts commentStamp: 'DamienCassou 7/18/2016 16:22' prior: 0!I visit a document and I hide scripts with ==hideable== parameter at ==true==.!!PRScriptEvaluator commentStamp: 'DamienCassou 7/18/2016 16:20' prior: 0!I replace each script with ==eval=true== with the result of its evaluation.!!PRScriptFromFile commentStamp: 'DamienCassou 7/18/2016 16:21' prior: 0!I replace each script with a ==fromFile== parameter with the content of the referenced file.!!PRScriptLineNumber commentStamp: 'DamienCassou 7/18/2016 16:23' prior: 0!I add line numbers to each script with ==lineNumber=true==.!!PRScriptStructureTransformer commentStamp: 'DamienCassou 7/18/2016 16:23' prior: 0!I transform a script structure with the associated structure.!!PRStructureTransfomer commentStamp: 'ThibaultArloing 5/12/2016 10:05' prior: 0!I represent the transformation of a structure.I have a different render for each subclasses.I can be referenced by a structure which wants to be transformed following my rule.!!PRTransformerWithoutUselessParagraph commentStamp: 'CyrilFerlicot 4/15/2015 10:29' prior: 0!I'm an abstract transformer. I assure that the transformation I do don't contains useless paragraph node.!!PRFileInclusion commentStamp: 'DamienCassou 7/18/2016 15:51' prior: 0!I replace each ==inputFile== annotation with the content of the referenced file.!!PRUpdateFileInclusionReference commentStamp: 'ThibaultArloing 6/22/2016 11:31' prior: 0!I update all reference of figures and internal links for file inclusion !!PRPhase commentStamp: 'CyrilFerlicot 6/16/2015 16:43' prior: 0!I am an abstract class to describe a Phase of an export. A Phase take an input, transform it and return an output.configuration is the configuration of the export.To create a new phase you have to define his prority as a class method then to define the action of the Phase with a method 'actionOn: anInput'. This method will return an output. You can also add some transformations to the output like: 	transformerInputFileOn: aCollection	<pillarTransformer: 1> "the parameter is the priority of the transformation"	aCollection		do: [ :each | 			PRFileInclusion new				configuration: self configuration;				start: each ]!!PRCreationPhase commentStamp: 'CyrilFerlicot 6/15/2015 13:18' prior: 0!I am a phase of the export of Pillar files. I take nothing, I can use a transformer to add files and I return a collection of pillar files.!!PRDocumentChildrenTransformer commentStamp: 'CyrilFerlicot 6/3/2015 13:00' prior: 0!I'm an abstract class. I allows the transformation of a tree. I'll visit the children of a document a remplace them by a collection of newChildren.newChildren is a Collection where we stock the new children of PRDocument during the transformation.!!PRColumnsTransformer commentStamp: 'DamienCassou 7/18/2016 15:54' prior: 0!I replace each ==columns== annotation with a structure of columns.!!PRSectionTransformer commentStamp: 'DamienCassou 7/18/2016 15:48' prior: 0!For each header, I add a section structure. This is useful in export formats (such as HTML5 and Docbook) where sub-sections are embedded in their parent section.!!PRSlideTransformer commentStamp: 'DamienCassou 7/18/2016 15:50' prior: 0!I replace each slide annotation with a slide structure.!!PRExportPhase commentStamp: 'CyrilFerlicot 6/15/2015 11:48' prior: 0!I am a phase of the export of Pillar files. I take in input a colletion of PRDocument, I transform them and I export them.!!PRParsingPhase commentStamp: 'CyrilFerlicot 6/15/2015 10:13' prior: 0!I am a phase of the export of Pillar files. I take in input a colletion of pillar files, I transform them and I return a collection of PRDocument.!!PRPipeline commentStamp: 'YannDubois 7/12/2016 11:04' prior: 0!I represent the concept of pipeline. I can contain phases and other pipelines that have the method pipelineKey corresponding to my key.My main method is #buildPipe: which builds the pipeline.I can have a pipelineKey which allows me to be included in an other pipeline.!!PRCheckPipeline commentStamp: 'YannDubois 7/12/2016 11:04' prior: 0!I am the check pipeline, I contain all checkers.!!PRCompilationPipeline commentStamp: 'YannDubois 7/12/2016 11:05' prior: 0!I am the compilation pipeline, I contain all compilation phases.!!PRNumeratingPipeline commentStamp: 'YannDubois 7/12/2016 11:06' prior: 0!I am the numerating pipeline, I contain all phases related to numeration. I am included in transform pipeline.!!PRTransformPipeline commentStamp: 'YannDubois 7/12/2016 11:00' prior: 0!I am the transform pipeline, I contain all not disabled transformers.!!ManifestPillarExporterCore commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PRConfigurationError commentStamp: '<historical>' prior: 0!I am the error raised when the configuration provided during the export is invalid.!!PRExportError commentStamp: 'DamienCassou 4/2/2015 14:34' prior: 0!I'm an exception class representing errors that happens while exporting a pillar document.!!PRNoInputFileError commentStamp: '<historical>' prior: 0!I am an error raised when no input file is specified while exporting a pier document!!PRTPipe classTrait methodsFor: 'building' stamp: 'YannDubois 7/18/2016 11:20'!buildPipe: aConfiguration	^ (LPPhase block: [ :input | self executeOn: input ])		addAllDependencies: (self dependencies collect: [ :each | each buildPipe: aConfiguration ])! !!PRTPipe classTrait methodsFor: 'meta-data' stamp: 'YannDubois 7/12/2016 11:36'!dependencies	 ^ {  }! !!PRTPipe classTrait methodsFor: 'instance-creation' stamp: 'YannDubois 7/18/2016 13:49'!executeOn: anInput	^ self explicitRequirement! !!PRTPipe classTrait methodsFor: 'testing' stamp: 'YannDubois 7/12/2016 15:35'!isEnabled: aConfiguration	^ (aConfiguration disabledPhases includes: self key) not! !!PRTPipe classTrait methodsFor: 'accessing' stamp: 'YannDubois 7/12/2016 13:25'!key	"A symbol describing what I do."	^ self explicitRequirement! !!PRTPipe classTrait methodsFor: 'accessing' stamp: 'YannDubois 7/12/2016 13:26'!pipelineKey	"A symbol representing in which pipeline I should be included. There must be a pipeline which answers my pipelineKey when sending it the message #key."	^ self explicitRequirement! !!PRLevelLetterConfiguration methodsFor: 'rendering-element' stamp: 'CyrilFerlicot 5/29/2016 01:14'!renderElement: aNumber	| alphabet position |	aNumber = 0 ifTrue: [ ^ 'NaN' ].		alphabet := Character alphabet.	position := aNumber \\ alphabet size.	position = 0 ifTrue: [ position := alphabet size ].	^ String		streamContents: [ :s | 			s nextPut: (alphabet at: position).			((aNumber - 1) / alphabet size) asFloat floor timesRepeat: [ s nextPut: $' ] ]! !!PRLevelNumberConfiguration methodsFor: 'rendering-element' stamp: 'ThibaultArloing 4/5/2016 10:28'!renderElement: aNumber	^ aNumber asString! !!PRLevelRomanConfiguration methodsFor: 'rendering-element' stamp: 'ThibaultArloing 4/5/2016 10:29'!renderElement: aNumber	^ aNumber printStringRoman! !!PRLevelUpperLetterConfiguration methodsFor: 'rendering-element' stamp: 'CyrilFerlicot 5/29/2016 01:15'!renderElement: aNumber	| alphabet position |	aNumber = 0 ifTrue: [ ^ 'NaN' ].		alphabet := Character alphabet.	position := aNumber \\ alphabet size.	position = 0 ifTrue: [ position := alphabet size ].		^ String		streamContents: [ :s | 			s nextPut: (alphabet at: position) asUppercase.			((aNumber - 1) / alphabet size) asFloat floor				timesRepeat: [ s nextPut: $' ] ]! !!PRTitleConfiguration class methodsFor: 'accessing - defaults' stamp: 'CyrilFerlicot 6/24/2015 17:12'!defaultLevel	^ 1! !!PRTitleConfiguration class methodsFor: 'instance creation' stamp: 'ThibaultArloing 4/11/2016 15:34'!new	^ self with: Dictionary new! !!PRTitleConfiguration class methodsFor: 'instance creation' stamp: 'ThibaultArloing 4/11/2016 15:44'!with: aDictionary	| config |	config := super new		numbering: (aDictionary at: 'numbering' ifAbsent: [ true ]);		autoAnchor: (aDictionary at: 'autoAnchor' ifAbsent: [ false ]);		capitalization: (aDictionary at: 'capitalization' ifAbsent: [ 'raw' ]);		yourself.	config numbering		ifTrue: [ config size: (aDictionary at: 'size' ifAbsent: [ 0 ]) ]		ifFalse: [ config size: 0 ].	^ config! !!PRTitleConfiguration methodsFor: 'comparing' stamp: 'CyrilFerlicot 6/24/2015 17:11'!= anObject	^ self species = anObject species		and: [ self predecessor = anObject predecessor and: [ self numbering = anObject numbering and: [ self size = anObject size ] ] ]! !!PRTitleConfiguration methodsFor: 'accessing' stamp: 'YannDubois 4/6/2016 09:41'!autoAnchor	^ autoAnchor ! !!PRTitleConfiguration methodsFor: 'accessing' stamp: 'YannDubois 4/6/2016 10:18'!autoAnchor: anObject 	^ autoAnchor := anObject ! !!PRTitleConfiguration methodsFor: 'accessing' stamp: 'ThibaultArloing 4/5/2016 14:26'!capitalization	^ capitalization! !!PRTitleConfiguration methodsFor: 'accessing' stamp: 'ThibaultArloing 4/5/2016 14:27'!capitalization: anObject	capitalization := anObject ! !!PRTitleConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/24/2015 16:53'!configuration	^ configuration! !!PRTitleConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/24/2015 16:53'!configuration: anObject	configuration := anObject! !!PRTitleConfiguration methodsFor: 'rendering' stamp: 'CyrilFerlicot 5/17/2015 18:54'!elementSeparator	^ $.! !!PRTitleConfiguration methodsFor: 'comparing' stamp: 'YannDubois 5/24/2016 16:32'!hash	^ self species hash bitXor: (self predecessor hash bitXor: numbering hash)! !!PRTitleConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/24/2015 17:13'!level	^ level ifNil: [ self class defaultLevel ]! !!PRTitleConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/24/2015 16:45'!level: anObject	level := anObject! !!PRTitleConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 5/15/2015 02:38'!numbering	^ numbering! !!PRTitleConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 5/15/2015 02:38'!numbering: anObject	numbering := anObject! !!PRTitleConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/24/2015 17:10'!predecessor	^ self level = 1		ifTrue: [ nil ]		ifFalse: [ self configuration perform: ('level' , (self level - 1) asString) asSymbol ]! !!PRTitleConfiguration methodsFor: 'rendering' stamp: 'CyrilFerlicot 5/19/2015 11:07'!printCounter: aCollection	^ self printCounter: aCollection withMaxSize: self size! !!PRTitleConfiguration methodsFor: 'rendering' stamp: 'CyrilFerlicot 6/24/2015 17:08'!printCounter: aCollection withMaxSize: aSize	| stream |	stream := String new writeStream.	aSize > 0		ifTrue: [ 			(self predecessor isNotNil and: [ aSize - 1 > 0 ])				ifTrue: [ 					stream nextPutAll: (self predecessor printCounter: aCollection allButLast withMaxSize: aSize - 1).					aCollection allButLast last = -1						ifFalse: [ stream nextPut: self elementSeparator ] ].			stream nextPutAll: (self printElement: aCollection last) ].	^ stream contents! !!PRTitleConfiguration methodsFor: 'rendering-element' stamp: 'CyrilFerlicot 5/18/2015 18:06'!printElement: aNumber	^ aNumber = -1		ifTrue: [ '' ]		ifFalse: [ self renderElement: aNumber ]! !!PRTitleConfiguration methodsFor: 'rendering-element' stamp: 'ThibaultArloing 4/4/2016 14:45'!renderElement: aNumber	^ self subclassResponsibility! !!PRTitleConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 5/15/2015 02:38'!size	^ size! !!PRTitleConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 5/15/2015 02:38'!size: anObject	size := anObject! !!PRTransformersDocumentation class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 6/16/2015 17:35'!on: aStream	"I generate the documentation of the Pillar transformers on a Stream."	^ self new		stream: aStream;		generateDoc;		stream! !!PRTransformersDocumentation methodsFor: 'accessing' stamp: 'DamienCassou 7/18/2016 17:23'!allTransformers	| configuration |	configuration := PRPillarConfiguration new		disabledPhases: {};		yourself.	^ PRTransformPipeline allPipeClasses: configuration! !!PRTransformersDocumentation methodsFor: 'action' stamp: 'DamienCassou 7/18/2016 15:23'!generateDoc	| transformers |	transformers := self allTransformers.	stream		lf;		lf;		nextPutAll: 'Transformers and keywords to disable them:';		lf;		lf.	self generateDocumentationOf: transformers! !!PRTransformersDocumentation methodsFor: 'action' stamp: 'DamienCassou 7/18/2016 15:34'!generateDocumentationOf: transformers	transformers		do: [ :transformer | 			stream				nextPutAll: ';==';				nextPutAll: transformer key;				nextPutAll: '==';				nextPutAll: Smalltalk os lineEnding;				nextPutAll: ':';				nextPutAll: transformer comment;				nextPutAll: Smalltalk os lineEnding ]! !!PRTransformersDocumentation methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/16/2015 17:39'!stream	^ stream! !!PRTransformersDocumentation methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/16/2015 17:39'!stream: anObject	stream := anObject! !!PRMagritteHeaderLevelDescription class methodsFor: 'accessing-defaults' stamp: 'CyrilFerlicot 6/23/2015 12:03'!defaultLevel	^ 1! !!PRMagritteHeaderLevelDescription class methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/22/2015 17:20'!label	^ 'Header level description'! !!PRMagritteHeaderLevelDescription methodsFor: 'visiting' stamp: 'CyrilFerlicot 6/22/2015 17:20'!acceptMagritte: aVisitor	aVisitor visitHeaderLevelDescription: self! !!PRMagritteHeaderLevelDescription methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/23/2015 12:03'!level	^ self propertyAt: #level ifAbsent: [ self class defaultLevel ]! !!PRMagritteHeaderLevelDescription methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/23/2015 12:04'!level: anObject	self propertyAt: #level put: anObject! !!PRPillarConfiguration class methodsFor: 'accessing' stamp: 'CyrilFerlicot 5/29/2016 00:55'!defaultHeaderConfigurations	^ Dictionary		with: 'number' -> PRLevelNumberConfiguration		with: 'roman' -> PRLevelRomanConfiguration		with: 'letter' -> PRLevelLetterConfiguration		with: 'upperLetter' -> PRLevelUpperLetterConfiguration yourself! !!PRPillarConfiguration class methodsFor: 'accessing' stamp: 'CyrilFerlicot 5/29/2016 00:56'!headerConfigurations	^ HeaderConfigurations ifNil: [ HeaderConfigurations := self defaultHeaderConfigurations ]! !!PRPillarConfiguration class methodsFor: 'accessing' stamp: 'CyrilFerlicot 5/18/2015 15:23'!headerConfigurations: anObject	HeaderConfigurations := anObject! !!PRPillarConfiguration methodsFor: 'converting' stamp: 'YannDubois 6/1/2016 11:00'!asJson	| result |	result := '' writeStream.	self properties jsonWriteOn: result.	^ result contents! !!PRPillarConfiguration methodsFor: 'helper' stamp: 'ThibaultArloing 4/11/2016 15:25'!configureLevelDescription: levelNumber	^ PRMagritteHeaderLevelDescription new		accessor: ('level' , levelNumber asString) asSymbol;		priority: 100;		label: 'Header level' , levelNumber asString , ' configuration';		cocoonDocumentation: (self levelDescriptionCocoonDocumentation: levelNumber);		cocoonDefaultDocumentation: 'All levels are numbered with digits and all parents are visible.';		default:				(PRLevelNumberConfiguration new						numbering: true;						size: levelNumber;						level: levelNumber;						autoAnchor: false;						configuration: self;						yourself);		classes: PRTitleConfiguration allSubclasses;		level: levelNumber;		yourself! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'DamienCassou 4/8/2016 14:04'!descriptionDefaultExporters	<magritteDescription>	^ MAToManyScalarRelationDescription new		priority: 100;		accessor: #defaultExporters;		label: 'List of the default exporters.';		cocoonDocumentation: 'Collection of exporters to use when none is explicitely specified. You can specify the exporter you want through the ==-\-to\=== command-line argument.';		classes: {ByteString};		default: (Array with: 'text');		cocoonDefaultDocumentation: 'By default only the text exporter is enabled.';		addCondition: [ :value | value isNotEmpty ];		yourself! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'DamienCassou 4/8/2016 13:24'!descriptionDefaultScriptLanguage	<magritteDescription>	^ PRMagritteScriptLanguageDescription new		priority: 100;		accessor: #defaultScriptLanguage;		label: 'Default language for scripts.';		cocoonDocumentation:				'Indicate the language in scripts when none is specified. This language is used for syntax highlighting. The currently supported languages are ', (PRRealScriptLanguage withAllConcreteClasses collect: #standardName) asCommaStringAnd, '.';		default: PRUnspecifiedScriptLanguage default;		cocoonDefaultDocumentation: 'An unspecified language';		yourself! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'DamienCassou 7/18/2016 15:32'!descriptionDisabledPhases	<magritteDescription>	^ MAToManyScalarRelationDescription new		priority: 100;		accessor: #disabledPhases;		label: 'List of disabled phases.';		cocoonDocumentation: 'Collection of phases that Pillar should ignore.' , "(PRTransformersDocumentation on: String new writeStream) contents," 'For exemple, a value of ==["scriptEvaluator", "section", "transform"]== will disable script evaluation (useful when security is important), sectioning (useful when generating HTML 4) and the transform phases (i.e. all the transformers) .';		classes: {ByteString};		default: Array new;		cocoonDefaultDocumentation: 'By default the collection is empty, i.e., all phases are active.';		yourself! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'DamienCassou 4/8/2016 11:50'!descriptionHeadingLevelOffset	<magritteDescription>	^ MANumberDescription new		accessor: #headingLevelOffset;		priority: 100;		label:				'Offset of Header counter.';		cocoonDocumentation: 'Indicate how to convert from the level of a Pillar heading to the level of heading in your exported document.	For example, a ==headingLevelOffset== of 3 converts a 1st level Pillar heading to an ==<h4>== in HTML.';		beInteger;		default: 0;		min: 0 max: 6;		yourself! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'DamienCassou 6/20/2016 14:55'!descriptionInputFile	<magritteDescription>	^ MAFileDescription new		defaultDirectory: self baseDirectory;		priority: 100;		accessor: #inputFile;		label: 'Input file to parse and export.';		cocoonDocumentation: 'The Pillar file that must be exported. You can also specify an input file at the end of the command-line interface.';		default: nil;		kind: AbstractFileReference;		yourself! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'ThibaultArloing 4/11/2016 15:29'!descriptionLevel1	<magritteDescription>	^ self configureLevelDescription: 1! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'ThibaultArloing 4/11/2016 15:29'!descriptionLevel2	<magritteDescription>	^ self configureLevelDescription: 2! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'ThibaultArloing 4/11/2016 15:29'!descriptionLevel3	<magritteDescription>	^ self configureLevelDescription: 3! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'ThibaultArloing 4/11/2016 15:29'!descriptionLevel4	<magritteDescription>	^ self configureLevelDescription: 4! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'ThibaultArloing 4/11/2016 15:29'!descriptionLevel5	<magritteDescription>	^ self configureLevelDescription: 5! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'YannDubois 4/15/2016 16:31'!descriptionMetadata	<magritteDescription>	^  CCMagritteConfigurationDescription new		accessor: #metadata;		priority: 100;		label: 'Metadata for documents';		cocoonDocumentation:			'Each document can have metadata like title or authors';		cocoonDefaultDocumentation: 'A dictionary of default default metadata';		default: PRPillarConfiguration new;		yourself! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'CyrilFerlicot 6/29/2015 14:43'!descriptionNewLine	<magritteDescription>	^ PRMagritteNewLineDescription new		accessor: #newLine;		priority: 100;		label: 'Representation of a new line.';		cocoonDocumentation:				'The string that separates lines in the exported document.	This is often either LF or CR\+LF but any string is possible.';		default: Smalltalk os lineEnding;		cocoonDefaultDocumentation: 'Depend on the operating system.';		yourself! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'ThibaultArloing 4/11/2016 16:07'!descriptionOutputDirectory	<magritteDescription>	^ MADirectoryDescription new		accessor: #outputDirectory;		priority: 100;		label: 'Output Directory where we export.';		cocoonDocumentation: 'Indicate where Pillar will create generated files.';		cocoonDefaultDocumentation: 'The value of ==baseDirectory==';		default: self baseDirectory;		defaultDirectory: self baseDirectory;		kind: AbstractFileReference;		addCondition: [ :fileRef | fileRef isDirectory or: [ fileRef exists not ]];		yourself! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'DamienCassou 4/8/2016 16:31'!descriptionOutputFile	<magritteDescription>	^ PRMagrittePathOrStreamDescription new		priority: 100;		accessor: #outputFile;		label: 'Output File name';		cocoonDocumentation: 'If ==separateOutputFiles== is ==false==, indicate the name of the output file. This can also be a write stream.';		cocoonDefaultDocumentation: 'A file named ''output'' with an extension depending on ==outputType==.';		default: (RelativePath from: 'output');		yourself! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'DamienCassou 4/8/2016 14:00'!descriptionOutputType	<magritteDescription>	^ MAClassDescription new		accessor: #outputType;		priority: 100;		label: 'Output Type.';		cocoonDocumentation: 'Indicate the kind of output desired. Can be any of ',(PRDocumentWriter withAllConcreteClasses collect: #writerName) asCommaStringAnd,'.';		default: nil;		addCondition: [ :value | (PRDocumentWriter allSubclasses reject: [ :klass | klass isAbstract ]) anySatisfy: [ :each | each = value ] ];		yourself! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'DamienCassou 4/8/2016 13:28'!descriptionRenderStructureAsSlide	<magritteDescription>	^ MABooleanDescription new		accessor: #renderStructureAsSlide;		priority: 100;		label: 'Render the Structure as Slide for Sliders.';		cocoonDocumentation:				'When ==true== (the default), Pillar will create a dedicated slide for each Pillar header. This parameter is meaningless when generating a written document.';		default: true;		yourself! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'DamienCassou 4/8/2016 11:48'!descriptionScrambledEmailAddresses	<magritteDescription>	^ MABooleanDescription new		accessor: #scrambledEmailAddresses;		priority: 100;		label: 'Scramble Email Addresses.';		cocoonDocumentation:				'Indicate if email addresses should appear scrambled to defeat the stupidest spammers looking for them (the default). If ==false==, email addresses will appear unscrambled.';		default: true;		yourself! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'DamienCassou 4/8/2016 11:49'!descriptionSeparateOutputFiles	<magritteDescription>	^ MABooleanDescription new		accessor: #separateOutputFiles;		priority: 100;		label: 'Export with separate output files.';		cocoonDocumentation: 'If ==true==, each input file is exported to one output file. If ==false== (the default), all input files are exported to ==outputFile==.';		default: false;		yourself! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'DamienCassou 4/8/2016 16:33'!descriptionSlideInTemplateForDeckJS	<magritteDescription>	^ MANumberDescription new		accessor: #slideInTemplateForDeckJS;		priority: 100;		label: 'Number of slides in Template';		cocoonDocumentation: 'Indicate the number of slides created by the DeckJS template. This is important to create anchors.';		default: 1;		isInteger;		min: -7 max: 7;		yourself! !!PRPillarConfiguration methodsFor: 'descriptions' stamp: 'CyrilFerlicot 6/29/2015 14:45'!descriptionVerbose	<magritteDescription>	^ MABooleanDescription new		accessor: #verbose;		priority: 100;		label: 'Verbose log';		cocoonDocumentation: 'Indicate whether Pillar should write a verbose log when exporting.';		default: false;		yourself! !!PRPillarConfiguration methodsFor: 'actions' stamp: 'ThibaultArloing 7/29/2016 16:11'!export	(PRCompilationPipeline buildPipe: self) sort		executeOn: (PRCompilationContext configuration: self)! !!PRPillarConfiguration methodsFor: 'actions' stamp: 'YannDubois 5/24/2016 16:28'!export: aConfigurationName	self log: 'Exporting ' , aConfigurationName.	(self getConfigurationNamed: aConfigurationName) export.	self log: 'End of exporting ' , aConfigurationName! !!PRPillarConfiguration methodsFor: 'configurations' stamp: 'DamienCassou 9/28/2015 12:46'!findDefaultConfigurationNamed: aString	"Search for a default configuration named ==aString== by asking the document writer classes for their default configurations. Raise an exception if no writer class defines a configuration named ==aString==. If a writer class defines such a configuration, merge its properties."	| writerClass defaultConfiguration newConfiguration |	writerClass := PRDocumentWriter allSubclasses		detect: [ :each | each isAbstract not and: [ each defaultConfigurationName = aString ] ]		ifNone: [ PRConfigurationError signal: 'No default configuration named: ' , aString ].	defaultConfiguration := writerClass defaultConfiguration.	newConfiguration := self class new.	newConfiguration parent: self.	defaultConfiguration properties		keysDo:			[ :propertyName | 			(newConfiguration inheritsPropertyAt: propertyName)				ifFalse:					[ 					newConfiguration						propertyAt: propertyName						put: (defaultConfiguration propertyAt: propertyName) ] ].	^ newConfiguration! !!PRPillarConfiguration methodsFor: 'private' stamp: 'ThibaultArloing 4/14/2016 10:40'!formatValue: aValue	^ aValue isString			ifTrue:[ '"', aValue, '"' ]			ifFalse:[ aValue asString ]! !!PRPillarConfiguration methodsFor: 'configurations' stamp: 'YannDubois 4/28/2016 15:54'!getConfigurationNamed: aConfigurationName	^ (self subConfigurationNamed: aConfigurationName) ifNil: [ self findDefaultConfigurationNamed: aConfigurationName ]! !!PRPillarConfiguration methodsFor: 'accessing' stamp: 'DamienCassou 6/22/2016 10:48'!inputString: aString	"I transform aString as a File and I add it to the properties"		| inputFile |	self baseDirectory: FileSystem memory root.	inputFile := self baseDirectory / 'input.conf'.	inputFile writeStreamDo: [ :stream | 		| znWriteStream |		znWriteStream := ZnCharacterWriteStream on: stream binary.		znWriteStream nextPutAll: aString ].	self inputFile: inputFile.! !!PRPillarConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/25/2015 15:44'!levelConfigurationFor: aHeader	"I return a PRNumberingConfiguration corresponding for a Header."	^ self perform: ('level' , aHeader level asString) asSymbol! !!PRPillarConfiguration methodsFor: 'helper' stamp: 'DamienCassou 4/8/2016 16:27'!levelDescriptionCocoonDocumentation: levelNumber	|  level |	level := levelNumber asString.	^ 'Configure how headers at level ', level, ' will be rendered. Value must be a dictionnary. These keys are recognized:;==numbering==:a boolean indicating if headers at this level must be numbered;==size==:a positive number indicating how many parent levels should be visible in the number: e.g., if ==2==, the parent header''s number and the current header''s number will be shown (must be lower than or equal to ', level,');==renderAs==:a string indicating how the numbering is done (must be one of =="number"==, =="roman"==, =="letter"== or =="upperLetter"==)'! !!PRPillarConfiguration methodsFor: 'converting' stamp: 'ThibaultAroing 5/26/2016 14:51'!outputFileName	^ self outputFile isStream		ifFalse: [ self outputFile basename withoutPeriodSuffix ]		ifTrue: [ 'writeStream' ]! !!PRPillarConfiguration methodsFor: 'accessing' stamp: 'DamienCassou 4/5/2015 18:43'!outputStream: aStream	self outputFile: aStream! !!PRPillarConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 8/18/2015 16:02'!pharoExtensions	^ #('image' 'changes')! !!PRPillarConfiguration methodsFor: 'accessing' stamp: 'CyrilFerlicot 8/18/2015 16:01'!pharoRelativeNames	^ #('pillar' 'pharo' 'stderr' 'stdout' 'stdin' 'package-cache' 'pharo-vm' 'play-cache' 'play-stash')! !!PRAbstractScriptLanguage methodsFor: '*pillar-exportercore' stamp: 'DamienCassou 1/10/2014 17:46'!isSyntaxHighlightingPossible	^ false! !!PRMagritteNewLineDescription class methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/29/2015 09:57'!label	^ 'newLine'! !!PRMagritteNewLineDescription methodsFor: 'visiting' stamp: 'CyrilFerlicot 6/29/2015 09:58'!acceptMagritte: aVisitor	aVisitor visitNewLineDescription: self! !!PRRealScriptLanguage methodsFor: '*pillar-exportercore' stamp: 'DamienCassou 1/10/2014 17:53'!isSyntaxHighlightingPossible	^ true! !!PRCreateSymLink methodsFor: 'system' stamp: 'ThibaultArloing 7/1/2016 15:17'!createSymbolic: name to: target	| command |	command :='ln -sf ' , target , ' ' , name.	name asFileReference exists		ifTrue: [ command := 'unlink ', name , '; ' , command ].	self system: command! !!PRCreateSymLink methodsFor: 'system' stamp: 'ThibaultArloing 6/23/2016 15:41'!system: command	"Perform OS system() call."	^ self ffiCall: #(#int #system #(#char #* #command)) module: LibC! !!PRExportBrush methodsFor: 'initialization' stamp: 'DamienCassou 10/14/2013 16:29'!setStream: aStream	stream := aStream! !!PRExportCanvas class methodsFor: 'instance creation' stamp: 'DamienCassou 10/14/2013 16:20'!on: aStream 	^ self new		setStream: aStream;		yourself! !!PRExportCanvas methodsFor: 'private' stamp: 'DamienCassou 10/14/2013 16:19'!brush: aBrush	self flush.	currentBrush := aBrush.	aBrush setStream: stream.	^ aBrush! !!PRExportCanvas methodsFor: 'accessing' stamp: 'DamienCassou 10/14/2013 16:19'!flush	stream flush! !!PRExportCanvas methodsFor: 'writing text' stamp: 'DamienCassou 11/18/2013 18:13'!line: aString	self		nextPutAll: aString;		newLine! !!PRExportCanvas methodsFor: 'writing text' stamp: 'DamienCassou 11/18/2013 18:13'!lines: aString	"Output aString and take care of line ending within aString."	| str |	str := aString readStream.	[str atEnd] whileFalse: [ | line |		line := str nextLine.		str atEnd			ifTrue: [ self nextPutAll: line ]			ifFalse: [ self line: line ]	 ]! !!PRExportCanvas methodsFor: 'writing text' stamp: 'DamienCassou 10/14/2013 16:19'!newLine	stream newLine! !!PRExportCanvas methodsFor: 'writing text' stamp: 'DamienCassou 11/18/2013 17:22'!nextPut: aCharacter	stream << aCharacter! !!PRExportCanvas methodsFor: 'writing text' stamp: 'DamienCassou 11/18/2013 17:22'!nextPutAll: aString	aString do: [ :char | self nextPut: char ]! !!PRExportCanvas methodsFor: 'writing text' stamp: 'DamienCassou 12/3/2013 17:02'!nextPutAllLines: aString	self withLinesIn: aString do: [ :line | self nextPutAll: line ] separatedBy: [ self newLine ]! !!PRExportCanvas methodsFor: 'writing text' stamp: 'DamienCassou 10/14/2013 16:35'!raw: aString	stream << aString! !!PRExportCanvas methodsFor: 'writing text' stamp: 'DamienCassou 12/3/2013 16:54'!rawLines: aString	"Output aString and take care of line ending within aString."	self withLinesIn: aString do: [ :line | self raw: line ] separatedBy: [ self newLine ]! !!PRExportCanvas methodsFor: 'initialization' stamp: 'DamienCassou 10/14/2013 16:19'!setStream: aStream 	stream := aStream! !!PRExportCanvas methodsFor: 'writing text' stamp: 'DamienCassou 10/14/2013 16:19'!space	stream space! !!PRExportCanvas methodsFor: 'private' stamp: 'CyrilFerlicot 4/24/2015 14:03'!withLinesIn: aString do: aBlock separatedBy: anotherBlock	| str |	str := aString readStream.	[ str atEnd ]		whileFalse: [ 			| line |			line := str nextLine.			aBlock value: line.			str atEnd				ifFalse: anotherBlock ]! !!PROutputStream class methodsFor: 'instance creation' stamp: 'DamienCassou 10/4/2013 10:39'!on: aWriteStream 	^ self new		setStream: aWriteStream;		yourself! !!PROutputStream methodsFor: 'streaming' stamp: 'DamienCassou 10/8/2013 12:51'!<< anObject	anObject isBlock		ifTrue: anObject		ifFalse: [ stream << anObject ]! !!PROutputStream methodsFor: 'accessing' stamp: 'CyrilFerlicot 10/29/2015 22:00'!configuration	^ configuration ifNil: [ configuration := PRPillarConfiguration new ]! !!PROutputStream methodsFor: 'accessing' stamp: 'DamienCassou 12/3/2013 17:02'!configuration: aConfiguration	^ configuration := aConfiguration! !!PROutputStream methodsFor: 'streaming' stamp: 'DamienCassou 2/20/2014 10:54'!contents	^ stream contents! !!PROutputStream methodsFor: 'accessing' stamp: 'DamienCassou 10/7/2013 10:50'!flush	stream flush! !!PROutputStream methodsFor: 'testing' stamp: 'BenjaminVanRyseghem 11/15/2013 02:23'!isEmpty		^ stream isEmpty! !!PROutputStream methodsFor: 'streaming' stamp: 'DamienCassou 10/9/2013 14:26'!newLine	self << self configuration newLine! !!PROutputStream methodsFor: 'initialize-release' stamp: 'DamienCassou 10/4/2013 09:58'!setStream: aWriteStream	stream := aWriteStream! !!PROutputStream methodsFor: 'streaming' stamp: 'DamienCassou 10/8/2013 13:44'!space	stream space! !!PROutputStream methodsFor: 'private' stamp: 'BenjaminVanRyseghem 11/19/2013 09:45'!stream	^ stream! !!PROutputStream methodsFor: 'streaming' stamp: 'DamienCassou 2/27/2014 11:31'!trimLastNewLine	| newLine |	newLine := self configuration newLine.	(newLine isEmpty or: [ stream position < newLine size ])		ifTrue: [ ^ self ].	stream position: stream position - newLine size.! !!PRMagrittePathOrStreamDescription class methodsFor: 'accessing-defaults' stamp: 'CyrilFerlicot 8/5/2015 13:26'!defaultKind	^ Path! !!PRMagrittePathOrStreamDescription methodsFor: 'visiting' stamp: 'CyrilFerlicot 8/5/2015 13:25'!acceptMagritte: aVisitor	aVisitor visitPathOrStreamDescription: self! !!PRMagrittePathOrStreamDescription methodsFor: 'accessing' stamp: 'CyrilFerlicot 8/5/2015 13:25'!secondKind	^ WriteStream! !!PRMagrittePathOrStreamDescription methodsFor: 'validation-private' stamp: 'CyrilFerlicot 8/5/2015 13:25'!validateKind: anObject	"Validate ==anObject== to be of the right kind."	((anObject isKindOf: self kind) or: [anObject isKindOf: self secondKind])		ifFalse: [ MAKindError description: self signal: self kindErrorMessage ]! !!PRMagritteScriptLanguageDescription class methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/22/2015 16:59'!label	^ 'Script Language'! !!PRMagritteScriptLanguageDescription methodsFor: 'visiting' stamp: 'CyrilFerlicot 6/22/2015 16:58'!acceptMagritte: aVisitor	aVisitor visitScriptLanguageDescription: self! !!PRCheckPhase class methodsFor: 'instance-creation' stamp: 'AutoDeprecationRefactoring 7/18/2016 14:18'!executeOn: anInput	self new		configuration: anInput configuration;		start: anInput input.	^ anInput! !!PRCheckPhase class methodsFor: 'testing' stamp: 'YannDubois 5/24/2016 10:15'!isAbstract	^ self = PRCheckPhase ! !!PRCheckPhase class methodsFor: 'accessing' stamp: 'DamienCassou 7/13/2016 14:36'!key	^ nil! !!PRCheckPhase class methodsFor: 'meta-data' stamp: 'YannDubois 7/8/2016 16:45'!pipelineKey	^ #check! !!PRCheckPhase methodsFor: 'accessing' stamp: 'DamienCassou 7/13/2016 14:41'!configuration	^ configuration! !!PRCheckPhase methodsFor: 'accessing' stamp: 'DamienCassou 7/13/2016 14:41'!configuration: anObject	configuration := anObject! !!PRCheckRaw methodsFor: 'visiting-document' stamp: 'YannDubois 5/24/2016 11:35'!visitRaw: aRaw	((PRDocumentWriter withAllConcreteClasses collect: [ :each | each writerName ])		includes: aRaw type)		ifTrue: [ ^ self ].	PRWarning signal: aRaw type , ' is not a valid type for a raw.'.! !!PRDocumentWriter class methodsFor: 'accessing' stamp: 'ThibaultArloing 4/13/2016 14:53'!defaultConfiguration	| defaultConfiguration |	defaultConfiguration := PRPillarConfiguration new.	defaultConfiguration properties at: 'outputType' put: self.	defaultConfiguration properties at: 'configurations' put: Dictionary new.	"we specify an empty collection of sub configurations to avoid infinite recursion : a default configuration would otherwise contain a collection of default configurations, each containing a collection of default configurations..."	^ defaultConfiguration! !!PRDocumentWriter class methodsFor: 'accessing' stamp: 'DamienCassou 12/11/2013 17:20'!defaultConfigurationName	^ self writerName! !!PRDocumentWriter class methodsFor: 'accessing' stamp: 'DamienCassou 12/9/2013 11:03'!fileExtension	^ self subclassResponsibility! !!PRDocumentWriter class methodsFor: 'testing' stamp: 'DamienCassou 2/12/2016 13:01'!isAbstract	^ self = PRDocumentWriter! !!PRDocumentWriter class methodsFor: 'accessing' stamp: 'DamienCassou 12/11/2013 17:20'!markupType	^ self writerName! !!PRDocumentWriter class methodsFor: 'instance creation' stamp: 'DamienCassou 10/4/2013 10:39'!on: aWriteStream 	^ self new		setStream: aWriteStream;		yourself! !!PRDocumentWriter class methodsFor: 'instance creation' stamp: 'DamienCassou 2/20/2014 10:48'!write: aDocumentItem	^ self new write: aDocumentItem! !!PRDocumentWriter class methodsFor: 'instance creation' stamp: 'DamienCassou 2/27/2014 12:41'!write: aDocument to: aStream 	^ self new write: aDocument to: aStream! !!PRDocumentWriter class methodsFor: 'accessing' stamp: 'DamienCassou 12/11/2013 17:20'!writerName	^ self subclassResponsibility! !!PRDocumentWriter methodsFor: 'accessing' stamp: 'DamienCassou 10/14/2013 16:32'!canvasClass	^ self subclassResponsibility! !!PRDocumentWriter methodsFor: 'accessing' stamp: 'CyrilFerlicot 10/29/2015 22:00'!configuration	^ configuration ifNil: [ configuration :=PRPillarConfiguration new ]! !!PRDocumentWriter methodsFor: 'accessing' stamp: 'DamienCassou 12/3/2013 17:01'!configuration: aConfiguration 	configuration := aConfiguration.	stream ifNotNil: [ stream configuration: aConfiguration ]! !!PRDocumentWriter methodsFor: 'streaming' stamp: 'DamienCassou 2/20/2014 10:53'!contents	^ stream contents! !!PRDocumentWriter methodsFor: 'private' stamp: 'DamienCassou 2/20/2014 10:53'!defaultStream	^ WriteStream on: String new! !!PRDocumentWriter methodsFor: 'accessing' stamp: 'ThibaultArloing 4/18/2016 17:11'!fileExtension	^ self class fileExtension , '.json'! !!PRDocumentWriter methodsFor: 'helpers' stamp: 'DamienCassou 2/29/2016 17:31'!getStringFor: anObject	"Visit anObject and exports everything to a new stream. Answer the stream content."	^ self getStringForAll: { anObject }! !!PRDocumentWriter methodsFor: 'helpers' stamp: 'DamienCassou 2/29/2016 17:13'!getStringForAll: aCollection	"Visit each element of aCollection and exports everything to a new stream. Answer the stream content."	^ String streamContents: [ :newStream | | visitor |		visitor := (self class on: newStream)			configuration: self configuration;			yourself.		aCollection do: [ :object | visitor start: object ] ]! !!PRDocumentWriter methodsFor: 'initialization' stamp: 'CyrilFerlicot 3/31/2015 11:25'!initialize	super initialize.	writingRaw := false! !!PRDocumentWriter methodsFor: 'helpers' stamp: 'DamienCassou 1/10/2014 16:00'!languageForScript: aScript	^ aScript language isSpecified		ifTrue: [ aScript language ]		ifFalse: [ self configuration defaultScriptLanguage ]! !!PRDocumentWriter methodsFor: 'accessing' stamp: 'DamienCassou 11/20/2013 17:43'!markupType	^ self class markupType! !!PRDocumentWriter methodsFor: 'helpers' stamp: 'DamienCassou 1/13/2014 15:00'!noNewLineDuring: aBlock	| oldNewLine |	oldNewLine := self configuration newLine.	self configuration newLine: ''.	aBlock ensure: [ self configuration newLine: oldNewLine ]! !!PRDocumentWriter methodsFor: 'initialization' stamp: 'DamienCassou 12/3/2013 17:01'!setStream: aStream	stream := PROutputStream on: aStream.	configuration ifNotNil: [ stream configuration: configuration ]! !!PRDocumentWriter methodsFor: 'visiting' stamp: 'DamienCassou 10/14/2013 16:31'!start: anObject	canvas := self canvasClass on: stream.	super start: anObject.	canvas flush! !!PRDocumentWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 3/20/2014 17:47'!visitEmptyParagraph: anObject	stream newLine! !!PRDocumentWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 3/20/2014 18:31'!visitLineBreak: aLineBreak	canvas newLine! !!PRDocumentWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 12/11/2013 17:21'!visitRaw: aRaw	(aRaw isForType: self writerName)		ifTrue: [ self writeRawDuring: [ super visitRaw: aRaw ] ]! !!PRDocumentWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 12/9/2013 11:19'!visitText: aText	writingRaw		ifTrue: [ canvas rawLines: aText text ]		ifFalse: [ canvas nextPutAllLines: aText text ]! !!PRDocumentWriter methodsFor: 'visiting' stamp: 'YannDubois 8/9/2016 14:17'!write: aDocumentItem	^ self write: aDocumentItem to: self defaultStream! !!PRDocumentWriter methodsFor: 'visiting' stamp: 'DamienCassou 2/20/2014 10:49'!write: aDocumentItem to: aStream	^ self setStream: aStream; start: aDocumentItem; contents! !!PRDocumentWriter methodsFor: 'helpers' stamp: 'CyrilFerlicot 7/29/2015 15:15'!writeCounter: aCounter	"Write on the canvas the string representation of ==aCounter=="	^ aCounter elements do: [ :each | self writeCounterElement: each ] separatedBy: [ self writeCounterElementSeparator ]! !!PRDocumentWriter methodsFor: 'helpers' stamp: 'CyrilFerlicot 7/29/2015 15:15'!writeCounterDefinitionSeparator	canvas nextPutAll: '. '! !!PRDocumentWriter methodsFor: 'helpers' stamp: 'CyrilFerlicot 7/29/2015 15:15'!writeCounterElement: aCounterElement	canvas nextPutAll: aCounterElement asString! !!PRDocumentWriter methodsFor: 'helpers' stamp: 'CyrilFerlicot 7/29/2015 15:15'!writeCounterElementSeparator	canvas nextPut: $.! !!PRDocumentWriter methodsFor: 'helpers' stamp: 'CyrilFerlicot 7/29/2015 15:15'!writeCounterForFigure: aFigure	aFigure counter isValidCounter		ifFalse: [ ^ self ].	self writeCounter: aFigure counter.	self writeCounterDefinitionSeparator! !!PRDocumentWriter methodsFor: 'helpers' stamp: 'CyrilFerlicot 7/29/2015 15:15'!writeCounterForHeader: aHeader	| headerConf |	headerConf := self configuration levelConfigurationFor: aHeader.	(headerConf numbering and: [ aHeader counter isValidCounter and: [ headerConf size > 0 ] ])		ifFalse: [ ^ self ].	canvas nextPutAll: (headerConf printCounter: aHeader counter elements).	self writeCounterDefinitionSeparator! !!PRDocumentWriter methodsFor: 'helpers' stamp: 'CyrilFerlicot 7/29/2015 15:15'!writeCounterForScript: aScript	aScript counter isValidCounter		ifFalse: [ ^ self ].	self writeCounter: aScript counter.	self writeCounterDefinitionSeparator! !!PRDocumentWriter methodsFor: 'helpers' stamp: 'DamienCassou 11/20/2013 17:29'!writeRawDuring: aBlock	[ 	writingRaw := true.	aBlock value ]		ensure: [ writingRaw := false ]! !!PRDocumentWriter methodsFor: 'accessing' stamp: 'DamienCassou 12/11/2013 17:21'!writerName	^ self class writerName! !!PRAnchorOfSection class methodsFor: 'accessing' stamp: 'YannDubois 4/8/2016 10:28'!charForAnchorOccurence	^ '@'! !!PRAnchorOfSection class methodsFor: 'accessing' stamp: 'YannDubois 5/20/2016 10:36'!key	^ #sectionAutoAnchors! !!PRAnchorOfSection methodsFor: 'adding' stamp: 'YannDubois 4/12/2016 11:04'!addAnchorOf: aPRHeader	| anchorText headerText |	headerText := aPRHeader children first text.		occurenceOfHeader at: headerText ifAbsentPut: 0.	occurenceOfHeader at: headerText put: ((occurenceOfHeader at: headerText) + 1).		anchorText := headerText , self class charForAnchorOccurence , (occurenceOfHeader at: headerText) asString .	^ Array with: aPRHeader with: (PRAnchor named: anchorText)! !!PRAnchorOfSection methodsFor: 'private' stamp: 'YannDubois 4/8/2016 16:11'!initOccurenceOfAnchor: aGroup	occurenceOfHeader := Dictionary new.	(aGroup children)		do: [ :child | 			child class = PRAnchor				ifTrue: [ self verifyAnchorName: (child name) ] ].! !!PRAnchorOfSection methodsFor: 'private' stamp: 'YannDubois 4/12/2016 11:21'!verifyAnchorName: aString	"Verify an anchor name, if it has the form 'anchorName@aNumber', the occurence number on 	 the dictionary is change by aNumber if it is greater than the occurence and if anchorName 	 is a key on the dictionary"	| anchorParts anchorLastPart realAnchorName |		anchorParts := (aString substrings: '@') asOrderedCollection .	(anchorParts size > 1)  ifFalse: [ ^ self ].	anchorLastPart := (anchorParts at: (anchorParts size)).		anchorLastPart asNumber isNumber 		ifTrue: [ anchorParts removeAt: (anchorParts size) ].		realAnchorName := anchorParts inject: '' into: [ :substring :next | substring , next ].		((occurenceOfHeader at: realAnchorName ifAbsent: [ true ]) or: [ (occurenceOfHeader at: realAnchorName) > (anchorLastPart asNumber) ])		ifTrue: [ occurenceOfHeader at: realAnchorName put: (anchorLastPart asNumber) ].! !!PRAnchorOfSection methodsFor: 'visiting-document' stamp: 'YannDubois 5/23/2016 09:25'!visitDocumentGroup: aGroup	occurenceOfHeader ifNil: [ self initOccurenceOfAnchor: aGroup ].	aGroup		setChildren:			(aGroup children				flatCollect: [ :child | 					"if child is a PRHeader and the configuration's parameter autoAnchor is true"					((child class = PRHeader) and: [ ((self configuration levelConfigurationFor: child ) autoAnchor ) ])						ifTrue: [ self addAnchorOf: child ]						ifFalse: [ 							replacement push: {child}.							self visit: child.							replacement pop ] ])! !!PRCitationTransformer class methodsFor: 'accessing' stamp: 'YannDubois 5/20/2016 11:27'!key	^ #citations! !!PRCitationTransformer methodsFor: 'helper' stamp: 'ThibaultArloing 5/3/2016 15:49'!createNewCitationWith: documentItem	tmpCitation := PRCitation ref: (documentItem parameters at: 'ref' ifAbsent:[ PRCitation defaultRef ])! !!PRCitationTransformer methodsFor: 'visiting-annotations' stamp: 'YannDubois 8/9/2016 09:59'!visitCitationAnnotation: aCitationAnnotation	self createNewCitationWith: aCitationAnnotation.	self replace: (OrderedCollection with: tmpCitation) .	super visitCitationAnnotation: aCitationAnnotation ! !!PRCleanAnnotationInParagraphTransfomer class methodsFor: 'accessing' stamp: 'DamienCassou 7/21/2016 11:21'!key	^ #cleanAnnotationInParagraph! !!PRCleanAnnotationInParagraphTransfomer methodsFor: 'testing' stamp: 'DamienCassou 7/20/2016 16:54'!paragraphIsSingleton: aParagraph	^ aParagraph children size = 1		or: [ self paragraphJustContainsALineBreakMore: aParagraph ]! !!PRCleanAnnotationInParagraphTransfomer methodsFor: 'testing' stamp: 'DamienCassou 7/20/2016 16:53'!paragraphJustContainsALineBreakMore: aParagraph	^ aParagraph children size = 2		and: [ aParagraph children second isKindOf: PRLineBreak ]! !!PRCleanAnnotationInParagraphTransfomer methodsFor: 'testing' stamp: 'ThibaultArloing 7/21/2016 17:06'!paragraphOnlyContainsAnnotation: aParagraph	^ ((aParagraph children size between: 1 and: 2) and: [ aParagraph children first isKindOf: PRAbstractAnnotation ])		and: [ self paragraphIsSingleton: aParagraph ]! !!PRCleanAnnotationInParagraphTransfomer methodsFor: 'visiting-document' stamp: 'DamienCassou 7/20/2016 16:54'!visitParagraph: aParagraph	(self paragraphOnlyContainsAnnotation: aParagraph)		ifTrue: [ self replace: {aParagraph children first} ]! !!PRFootnoteTransformer class methodsFor: 'testing' stamp: 'YannDubois 5/3/2016 10:55'!isAbstract	^ false! !!PRFootnoteTransformer class methodsFor: 'accessing' stamp: 'YannDubois 5/19/2016 11:28'!key	^ #footnote! !!PRFootnoteTransformer methodsFor: 'private' stamp: 'YannDubois 5/3/2016 10:58'!createFootnote: aFootnoteAnnotation	^ PRFootnote noted: (aFootnoteAnnotation parameters at: 'note')! !!PRFootnoteTransformer methodsFor: 'visiting-annotations' stamp: 'YannDubois 5/19/2016 11:34'!visitFootnoteAnnotation: aFootnoteAnnotation	self replace: {(self createFootnote: aFootnoteAnnotation)}! !!PRHeaderCapitalizationTransformer class methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 4/8/2016 15:03'!capitalizationConfiguration	^ Dictionary with: 'upper case' -> [ :text | text asUppercase ]					 with: 'lower case' -> [ :text | text asLowercase ]					 with: 'capitalize' -> [ :text | self new capitalizeHeader: text ]					 with: 'capitalize english' -> [ :text | self new capitalizeEnglish: text ]					 with: 'raw' -> [ :text | text ]! !!PRHeaderCapitalizationTransformer class methodsFor: 'accessing' stamp: 'YannDubois 5/19/2016 13:58'!key	^ #capitalization! !!PRHeaderCapitalizationTransformer class methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 4/8/2016 14:35'!nonCapitalizedWordEnglish	| result |	result := Set with: 'to' with: 'and' with: 'or' with: 'an' with: 'a' with: 'of'.			result addAll: (Set with: 'the' with: 'but' with: 'nor' with: 'for' with: 'yet' with: 'so').			result addAll: (Set with: 'on' with: 'at' with: 'in').				^ result! !!PRHeaderCapitalizationTransformer methodsFor: 'visiting-document' stamp: 'ThibaultArloing 4/15/2016 15:54'!capitalizeEnglish: aString	| substrings result |	substrings := (aString substrings) asOrderedCollection.	result := '' writeStream.	result << (substrings removeFirst) capitalized << ' '.	substrings do: [ :each | result << ((self class nonCapitalizedWordEnglish includes: each)																					ifTrue: [ each ]																					ifFalse: [ each capitalized ])														  << ' '].		^ result contents trimBoth! !!PRHeaderCapitalizationTransformer methodsFor: 'visiting-document' stamp: 'ThibaultArloing 4/15/2016 15:52'!capitalizeHeader: aString		| stream |	stream := '' writeStream.	((aString substrings) inject: '' into: [ :subtotal :next | stream << next capitalized << ' ' ]).	^ stream contents trimBoth! !!PRHeaderCapitalizationTransformer methodsFor: 'visiting-document' stamp: 'YannDubois 5/19/2016 13:51'!initialize	super initialize.	headerCapitalization := 'raw'! !!PRHeaderCapitalizationTransformer methodsFor: 'visiting-document' stamp: 'YannDubois 5/19/2016 16:01'!visitHeader: aGroup	headerCapitalization := (self configuration levelConfigurationFor: aGroup) capitalization.	super visitHeader: aGroup.! !!PRHeaderCapitalizationTransformer methodsFor: 'visiting-document' stamp: 'YannDubois 5/23/2016 11:06'!visitText: aText	aText text: ((self class capitalizationConfiguration at: headerCapitalization ifAbsent: [[:text|text]]) value: aText text).	headerCapitalization := 'raw'! !!PRHeadingLevelOffset class methodsFor: 'accessing' stamp: 'DamienCassou 6/21/2016 11:09'!key	^ #headingLevelOffset! !!PRHeadingLevelOffset methodsFor: 'visiting-document' stamp: 'ThibaultArloing 7/21/2016 12:01'!visitHeader: aHeader	aHeader level: aHeader level + self configuration headingLevelOffset! !!PRNodeTransformer class methodsFor: 'instance-creation' stamp: 'ThibaultArloing 7/19/2016 11:37'!executeOn: anInput	self new		configuration: anInput configuration;		start: anInput input.	^ anInput! !!PRNodeTransformer class methodsFor: 'testing' stamp: 'YannDubois 5/17/2016 15:38'!isAbstract	^ self = PRNodeTransformer ! !!PRNodeTransformer class methodsFor: 'accessing' stamp: 'DamienCassou 7/13/2016 14:27'!pipelineKey	^ #transform! !!PRNodeTransformer methodsFor: 'accessing' stamp: 'DamienCassou 7/13/2016 14:46'!configuration	^ configuration! !!PRNodeTransformer methodsFor: 'accessing' stamp: 'DamienCassou 7/13/2016 14:46'!configuration: anObject	configuration := anObject! !!PRNodeTransformer methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/2/2015 16:56'!initialize	super initialize.	replacement := Stack new! !!PRNodeTransformer methodsFor: 'protected' stamp: 'CyrilFerlicot 6/2/2015 16:56'!replace: newNodes	"When we do a transformation I replace the current node by his transformation."	replacement pop.	replacement push: newNodes! !!PRNodeTransformer methodsFor: 'visiting' stamp: 'DamienCassou 7/15/2016 07:07'!start: anObject	super start: anObject.	^ anObject! !!PRNodeTransformer methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/2/2015 16:56'!visitDocumentGroup: aGroup	aGroup		setChildren:			(aGroup children				flatCollect: [ :child | 					replacement push: {child}.					self visit: child.					replacement pop]). ! !!PRNumeratingLinksVisitor class methodsFor: 'meta-data' stamp: 'YannDubois 7/8/2016 16:52'!dependencies	^ {PRNumeratingVisitor}! !!PRNumeratingLinksVisitor class methodsFor: 'accessing' stamp: 'ThibaultArloing 7/19/2016 11:32'!executeOn: anInput	self new		configuration: anInput configuration;		anchorsMapping: (anInput propertyAt: #anchorsMapping);		start: anInput input.	^ anInput! !!PRNumeratingLinksVisitor class methodsFor: 'accessing' stamp: 'YannDubois 5/18/2016 17:00'!key	^ #numerator! !!PRNumeratingLinksVisitor class methodsFor: 'accessing' stamp: 'YannDubois 7/8/2016 16:50'!pipelineKey	^ #numerating! !!PRNumeratingLinksVisitor class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 5/19/2015 18:10'!with: anAnchorsMapping	^ self new		anchorsMapping: anAnchorsMapping;		yourself! !!PRNumeratingLinksVisitor methodsFor: 'accessing' stamp: 'CyrilFerlicot 5/19/2015 18:11'!anchorCounter: aString	^ anchorsMapping at: aString ifAbsent: [ self cantFindCounterNamed: aString for: 'anchor' ]! !!PRNumeratingLinksVisitor methodsFor: 'accessing' stamp: 'CyrilFerlicot 5/19/2015 18:09'!anchorsMapping: anObject	anchorsMapping := anObject! !!PRNumeratingLinksVisitor methodsFor: 'errors' stamp: 'CyrilFerlicot 5/19/2015 18:11'!cantFindCounterNamed: counterName for: kind	PRReferenceNotFound signal: 'Can''t find ', kind, ' named ''', counterName, ''''.	^ PRNotFoundCounter new! !!PRNumeratingLinksVisitor methodsFor: 'testing' stamp: 'CyrilFerlicot 5/19/2015 18:12'!isEmpty	^  anchorsMapping isEmpty ! !!PRNumeratingLinksVisitor methodsFor: 'visiting-document' stamp: 'YannDubois 5/19/2016 10:44'!visitInternalLink: anInternalLink	anInternalLink hasAnchor		ifTrue: [ anInternalLink counter: (self anchorCounter: anInternalLink anchor) ]! !!PRNumeratingVisitor class methodsFor: 'instance creation' stamp: 'ThibaultArloing 7/19/2016 13:26'!executeOn: anInput	self new		configuration: anInput configuration;		start: anInput input;		actionOn: anInput.	^ anInput! !!PRNumeratingVisitor class methodsFor: 'accessing' stamp: 'YannDubois 5/19/2016 09:16'!key	^ #numerator! !!PRNumeratingVisitor class methodsFor: 'accessing' stamp: 'YannDubois 7/8/2016 16:50'!pipelineKey	^ #numerating! !!PRNumeratingVisitor class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 5/20/2015 10:37'!with: aConfiguration	^ self new		configuration: aConfiguration;		initializeTopNumerate;		yourself! !!PRNumeratingVisitor methodsFor: 'actions' stamp: 'ThibaultArloing 7/19/2016 13:27'!actionOn: anInput	^ anInput		propertyAt: #anchorsMapping put: anchorsMapping;		yourself! !!PRNumeratingVisitor methodsFor: 'initialization' stamp: 'CyrilFerlicot 5/19/2015 17:43'!initialize	super initialize.	headerCounter := PRCascadingCounter maxLevel: 5.	figureCounter := PRCascadingCounter maxLevel: 2.	scriptCounter := PRCascadingCounter maxLevel: 2.	anchorsMapping := Dictionary new! !!PRNumeratingVisitor methodsFor: 'initialize-release' stamp: 'CyrilFerlicot 5/20/2015 10:37'!initializeTopNumerate	| cpt |	cpt := 1.	[ (configuration perform: ('level' , cpt asString) asSymbol) numbering or: [ cpt > 5 ] ] whileFalse: [ cpt := cpt + 1 ].	topLevelNumerate := cpt! !!PRNumeratingVisitor methodsFor: 'test' stamp: 'CyrilFerlicot 5/19/2015 16:45'!needNumbering: aHeader	^ (configuration levelConfigurationFor: aHeader) numbering! !!PRNumeratingVisitor methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 5/20/2015 10:21'!visitAnchor: anAnchor	anchorsMapping at: anAnchor name put: headerCounter current! !!PRNumeratingVisitor methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 5/20/2015 10:21'!visitFigure: aFigure	"Figures and scripts are numbered based on the top-level header. This means that figures and scripts always have 2 numbers: one indicating the header they are in, and one indicating the position of the element in the corresponding section"	aFigure label		ifNotNil: [ 			figureCounter incrementAt: 2.			aFigure counter: figureCounter current.			aFigure parameters at: 'label' ifPresent: [ :label | anchorsMapping at: label put: figureCounter current ] ]! !!PRNumeratingVisitor methodsFor: 'visiting-document' stamp: 'YannDubois 5/19/2016 10:45'!visitHeader: aHeader	| aLevel |	aLevel := aHeader level.	(self needNumbering: aHeader)		ifTrue: [ headerCounter incrementAt: aLevel ]		ifFalse: [ headerCounter dontIncrementAt: aLevel ].	aHeader level = topLevelNumerate		ifTrue: [ 			figureCounter incrementAt: 1.			scriptCounter incrementAt: 1 ].	"Figures and scripts are numbered based on the top-level header. This means that figures and scripts always have 2 numbers: one indicating the header they are in, and one indicating the position of the element in the corresponding section"	aHeader counter: headerCounter current! !!PRNumeratingVisitor methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 5/20/2015 10:22'!visitScript: aScript	"Figures and scripts are numbered based on the top-level header. This means that figures and scripts always have 2 numbers: one indicating the header they are in, and one indicating the position of the element in the corresponding section"	aScript isEvaluated		ifTrue: [ ^ self visitAll: aScript evaluate ].	aScript hasLabel		ifTrue: [ 			scriptCounter incrementAt: 2.			aScript counter: scriptCounter current.			aScript parameters at: 'label' ifPresent: [ :label | anchorsMapping at: label put: scriptCounter current ] ]! !!PRNumeratingVisitor methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 7/31/2015 11:02'!visitSlideTitleAnnotation: aSlideTitleAnnotation	aSlideTitleAnnotation parameters		at: 'label'		ifPresent: [ :label | anchorsMapping at: label put: headerCounter current ]! !!PRRemoveHideableScripts class methodsFor: 'accessing' stamp: 'YannDubois 5/19/2016 16:59'!key	^ #scriptHide! !!PRRemoveHideableScripts methodsFor: 'visiting-document' stamp: 'ThibaultArloing 4/5/2016 16:07'!visitScript: aScript	(aScript isHideable)		ifTrue: [ self replace: #() ]! !!PRScriptEvaluator class methodsFor: 'accessing' stamp: 'YannDubois 5/19/2016 16:10'!key	^ #scriptEvaluator! !!PRScriptEvaluator methodsFor: 'visiting-document' stamp: 'YannDubois 5/19/2016 16:16'!visitScript: aScript	aScript isEvaluated		ifTrue: [ self replace: aScript evaluate ]! !!PRScriptFromFile class methodsFor: 'accessing' stamp: 'YannDubois 5/19/2016 16:25'!key	^ #scriptInclusion! !!PRScriptFromFile methodsFor: 'adding' stamp: 'CyrilFerlicot 4/30/2015 15:26'!addScript: aScript	| content cpt |	content := String new writeStream.	aScript hasNoCode		ifFalse: [ 			PRWarning				signal:					'Be careful, you used the fromFile parameter on a script which is not empty. This has been erased : ' , aScript text ].	cpt := 0.	"We first pass the begining of the code."	firstLine - 1 timesRepeat: [ fileStream nextLine ].	lastLine - firstLine + 1		timesRepeat: [ 			content nextPutAll: fileStream nextLine.			content nextPutAll: self configuration newLine ].	^ aScript text: content contents! !!PRScriptFromFile methodsFor: 'accessing' stamp: 'CyrilFerlicot 4/30/2015 14:28'!fileLineNumber	| tmpStream cpt |	tmpStream := fileStream copy.	cpt := 0.	[ tmpStream nextLine isNotNil ] whileTrue: [ cpt := cpt + 1 ].	^ cpt! !!PRScriptFromFile methodsFor: 'testing' stamp: 'CyrilFerlicot 5/14/2015 21:43'!hasFromFile: aScript	"I check if the transformer need to transform the script. If the script has bad parameters i raise a warning."	aScript parameters		at: 'firstLine'		ifPresent: [ :lineNumber | 			firstLine := lineNumber asInteger.			firstLine isNotNil				ifFalse: [ PRPropertyError signal: 'firstLine parameter must contains digits' ].			aScript parameters				at: 'fromFile'				ifAbsent: [ 					PRWarning signal: 'firstLine has to be with a fromFile parameter.'.					^ false ] ].	aScript parameters		at: 'lastLine'		ifPresent: [ :lineNumber | 			lastLine := lineNumber asInteger.			lastLine isNotNil				ifFalse: [ PRPropertyError signal: 'lastLine parameter must contains digits' ].			aScript parameters				at: 'fromFile'				ifAbsent: [ 					PRWarning signal: 'lastLine has to be with a fromFile parameter.'.					^ false ] ].	aScript parameters		at: 'fromFile'		ifPresent: [ :fileName | 			self setFileAndInterval: fileName.			^ true ]		ifAbsent: [ ^ false ]! !!PRScriptFromFile methodsFor: 'accessing' stamp: 'CyrilFerlicot 4/30/2015 13:13'!initialize	super initialize.	firstLine := nil.	lastLine := nil! !!PRScriptFromFile methodsFor: 'action' stamp: 'CyrilFerlicot 5/1/2015 18:42'!setFileAndInterval: aFileName	"I get the File and i set the line numbers."	fileStream := self configuration baseDirectory resolve: aFileName.	fileStream exists		ifTrue: [ 			fileStream := fileStream contents readStream.			self updateInterval ]		ifFalse: [ PRInputFileError signal: aFileName , ' is not a valid file name into ' , self configuration baseDirectory asString , '.' ]! !!PRScriptFromFile methodsFor: 'action' stamp: 'CyrilFerlicot 5/1/2015 18:43'!updateInterval	| fileLineNumber |	fileLineNumber := self fileLineNumber.	firstLine isNil		ifTrue: [ firstLine := 1 ]		ifFalse: [ 			firstLine <= fileLineNumber				ifFalse: [ 					PRPropertyError						signal: 'firstLine parameter is not a valid parameter. Please choose a firstLine lower than the file size.' ] ].	lastLine isNil		ifTrue: [ lastLine := fileLineNumber ]		ifFalse: [ 			(lastLine >= firstLine and: [ lastLine <= fileLineNumber ])				ifFalse: [ 					PRPropertyError						signal:							'lastLine parameter is not a valid parameter. Please choose a lastLine lower than the file size and higher then the firstLine.' ] ]! !!PRScriptFromFile methodsFor: 'visiting-document' stamp: 'YannDubois 5/19/2016 16:47'!visitScript: aScript	(self hasFromFile: aScript)		ifTrue: [ self replace: {(self addScript: aScript)} ]! !!PRScriptLineNumber class methodsFor: 'accessing' stamp: 'YannDubois 5/20/2016 09:25'!key	^ #scriptLineNumber! !!PRScriptLineNumber methodsFor: 'adding' stamp: 'CyrilFerlicot 4/23/2015 14:49'!add: aString untilNewLineAt: firstOccurence withNumber: number	| length |	length := firstOccurence + self configuration newLine size -1 .	self add: (aString first: length) withNumber: number.	^ aString allButFirst: length! !!PRScriptLineNumber methodsFor: 'adding' stamp: 'CyrilFerlicot 4/23/2015 14:30'!add: aString withNumber: number	stream		nextPutAll: number asString;		nextPutAll: String tab;		nextPutAll: aString! !!PRScriptLineNumber methodsFor: 'adding' stamp: 'CyrilFerlicot 4/23/2015 14:50'!addLineNumberTo: aScript	"I add a numerotation at each line of a script."	| text firstOccurence number |	text := aScript text.	number := 1.	stream := String new writeStream.	firstOccurence := text indexOfSubCollection: self configuration newLine.	[ firstOccurence = 0 ]		whileFalse: [ 			text := self add: text untilNewLineAt: firstOccurence withNumber: number.			firstOccurence := text indexOfSubCollection: self configuration newLine.			number := number + 1 ].	self add: text withNumber: number.	^ aScript text: stream contents! !!PRScriptLineNumber methodsFor: 'testing' stamp: 'CyrilFerlicot 4/22/2015 18:05'!hasLineNumber: aScript	^ aScript parameters at: 'lineNumber' ifPresent: [ :lN | lN = 'true' or: [ lN = true ] ] ifAbsent: [ false ]! !!PRScriptLineNumber methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 4/23/2015 14:29'!visitScript: aScript	(self hasLineNumber: aScript)		ifTrue: [ self replace: {self addLineNumberTo: aScript} ]! !!PRScriptStructureTransformer class methodsFor: 'accessing' stamp: 'YannDubois 5/20/2016 10:50'!key	^ #structures! !!PRScriptStructureTransformer methodsFor: 'creating' stamp: 'YannDubois 6/1/2016 11:22'!createStructureFrom: aScript	^ PRStructure new		tag: aScript structureName;		structDict: (Json readFrom: aScript text readStream) asDictionary;		yourself! !!PRScriptStructureTransformer methodsFor: 'visiting-document' stamp: 'ThibaultArloing 5/9/2016 14:04'!visitScript: aScript	aScript isStructure		ifTrue: [ self replace: (OrderedCollection with: (self createStructureFrom: aScript)) ]! !!PRStructureTransfomer class methodsFor: 'accessing' stamp: 'YannDubois 5/20/2016 10:49'!key	^ #structures! !!PRStructureTransfomer methodsFor: 'visiting-annotations' stamp: 'ThibaultArloing 5/25/2016 10:01'!transformClassFor: aStructureTag	^ self transformDictionary at: aStructureTag! !!PRStructureTransfomer methodsFor: 'visiting-annotations' stamp: 'ThibaultArloing 5/25/2016 10:01'!transformDictionary	^ Dictionary		with: 'exercise' -> PRDefinitionListRenderer		with: 'city' -> PRTableRenderer		with: 'country' -> PRTableRenderer		with: 'default' -> PRTableRenderer! !!PRStructureTransfomer methodsFor: 'visiting-annotations' stamp: 'ThibaultArloing 5/25/2016 09:55'!visitStructure: aStructure	| transformClass |	transformClass := (self transformClassFor: aStructure tag) new.	self replace: (OrderedCollection with: (transformClass  renderFor: aStructure))! !!PRFileInclusion class methodsFor: 'accessing' stamp: 'ThibaultArloing 7/21/2016 12:24'!dependencies	^ { PRTransformPipeline }! !!PRFileInclusion class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/9/2015 11:38'!isAbstract	^ false! !!PRFileInclusion class methodsFor: 'accessing' stamp: 'YannDubois 5/18/2016 11:48'!key	^ #fileInclusion! !!PRFileInclusion class methodsFor: 'accessing' stamp: 'ThibaultArloing 7/21/2016 12:24'!pipelineKey	^ #compilation! !!PRFileInclusion methodsFor: 'protected' stamp: 'YannDubois 5/18/2016 11:19'!aboutClass	<key: 'fileInclusion' documentation:		'I replace each ==inputFile== annotation with the content of the referenced file.'>	^ PRInputFileAnnotation ! !!PRFileInclusion methodsFor: 'visiting-document' stamp: 'ThibaultArloing 7/21/2016 14:52'!buildFileInclusionPipeline: aConfiguration	| parse check transform fileInclusion |	parse := PRParsingPhase buildPipe: aConfiguration.	check := PRCheckPipeline buildPipe: aConfiguration.	transform := PRTransformPipeline buildPipe: aConfiguration.	fileInclusion := PRFileInclusion buildPipe: aConfiguration.	^ (LPPipeline		pipes:			{parse.			check.			transform.			fileInclusion}) sort! !!PRFileInclusion methodsFor: 'visiting-document' stamp: 'ThibaultArloing 7/21/2016 11:23'!pathForFile: aFile	^ (aFile copyReplaceAll: self configuration baseDirectory fullName with: FileSystem disk delimiter asString) copyReplaceAll: '//' with: ''  ! !!PRFileInclusion methodsFor: 'visitor' stamp: 'CyrilFerlicot 4/15/2015 10:01'!specificVisitor: anInputFileAnnotation	^ self visitInputFileAnnotation: anInputFileAnnotation! !!PRFileInclusion methodsFor: 'visiting-document' stamp: 'ThibaultArloing 7/21/2016 11:14'!visitInputFileAnnotation: anInputFileAnnotation	"I load the file and if the file exist I replace the node of the annotation by the content of the file."	| file pipeline |	file := anInputFileAnnotation fileWithConfiguration: self configuration.	file exists		ifTrue: [ | parsedFile stream |			stream := FileStream readOnlyFileNamed: file.			pipeline := self buildFileInclusionPipeline: self configuration.			parsedFile := PRUpdateFileInclusionReference				start:					(pipeline						executeOn:							(PRCompilationContext new								input: file;								configuration: self configuration)) input				with: (self pathForFile: file parent fullName).			self replace: parsedFile children ]		ifFalse: [ anInputFileAnnotation errorFileNotFound: file ]! !!PRTransformerWithoutUselessParagraph class methodsFor: 'testing' stamp: 'YannDubois 5/18/2016 17:01'!isAbstract	^ self = PRTransformerWithoutUselessParagraph! !!PRTransformerWithoutUselessParagraph methodsFor: 'protected' stamp: 'CyrilFerlicot 4/23/2015 12:45'!aboutClass	^ self subclassResponsibility! !!PRTransformerWithoutUselessParagraph methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 4/16/2015 17:53'!replaceParagraph	replacement first class = PRParagraph		ifTrue: [ replacement push: replacement pop first children ]! !!PRTransformerWithoutUselessParagraph methodsFor: 'visitor' stamp: 'CyrilFerlicot 4/23/2015 12:46'!specificVisitor: something	^ self subclassResponsibility! !!PRTransformerWithoutUselessParagraph methodsFor: 'as yet unclassified' stamp: 'YannDubois 7/1/2016 09:59'!transformParagraph: paragraph	^ (paragraph children size = 1 or: (paragraph children size = 2 and: paragraph children last class = PRLineBreak))		ifTrue: [ self transformParagraphWith1Child: paragraph ]		ifFalse: [ self transformParagraphWithChildren: paragraph ]! !!PRTransformerWithoutUselessParagraph methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 6/23/2016 09:47'!transformParagraphWith1Child: paragraph	^ paragraph children first class = self aboutClass		ifTrue: [ 			replacement push: {paragraph}.			self specificVisitor: paragraph children first.			replacement pop ]		ifFalse: [ self visitNormalNode: paragraph ]! !!PRTransformerWithoutUselessParagraph methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 4/16/2015 17:48'!transformParagraphWithChildren: paragraph	^ (paragraph children contains: [ :each | each class = self aboutClass ])		ifTrue: [ self visitParagraphWithAnnotation: paragraph ]		ifFalse: [ self visitNormalNode: paragraph ]! !!PRTransformerWithoutUselessParagraph methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 4/16/2015 17:26'!visitDocumentGroup: aGroup	aGroup		setChildren:			(aGroup children				flatCollect: [ :child | 					child class = PRParagraph						ifTrue: [ self transformParagraph: child ]						ifFalse: [ self visitNormalNode: child ] ])! !!PRTransformerWithoutUselessParagraph methodsFor: 'visitor' stamp: 'CyrilFerlicot 4/14/2015 23:47'!visitNormalNode: node	replacement push: {node}.	self visit: node.	^ replacement pop! !!PRTransformerWithoutUselessParagraph methodsFor: 'visitor' stamp: 'CyrilFerlicot 4/20/2015 15:58'!visitParagraphWithAnnotation: paragraph	^ {(paragraph		setChildren:			(paragraph children				flatCollect: [ :child | 					child class = self aboutClass						ifTrue: [ 							replacement push: {child}.							self visit: child.							self replaceParagraph.							replacement pop ]						ifFalse: [ self visitNormalNode: child ] ]))}! !!PRUpdateFileInclusionReference class methodsFor: 'visiting' stamp: 'ThibaultArloing 6/22/2016 14:02'!isAbstract	^ false! !!PRUpdateFileInclusionReference class methodsFor: 'visiting' stamp: 'ThibaultArloing 7/19/2016 13:54'!start: aDocument with: aPath	^ self new		path: aPath;		start: aDocument! !!PRUpdateFileInclusionReference methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 7/21/2016 11:14'!newReferenceFor: aReference	(aReference reference includesSubstring: 'file://')		ifTrue: [ ^ aReference reference copyReplaceAll: 'file://' with: 'file://', self path , '/' ].	^ self path , '/' , aReference reference! !!PRUpdateFileInclusionReference methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 6/22/2016 14:03'!path	^ path! !!PRUpdateFileInclusionReference methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 6/22/2016 14:03'!path: aPath	path := aPath! !!PRUpdateFileInclusionReference methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 6/22/2016 11:22'!start: anObject	super start: anObject.	^ anObject! !!PRUpdateFileInclusionReference methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 6/22/2016 15:25'!visitFigure: aFigure	aFigure reference: (self newReferenceFor: aFigure).	super visitFigure: aFigure! !!PRUpdateFileInclusionReference methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 6/22/2016 15:34'!visitInternalLink: anInternalLink	anInternalLink hasReference  		ifTrue: [ anInternalLink reference: (self newReferenceFor: anInternalLink) ].	super visitInternalLink: anInternalLink! !!PRCompilationContext class methodsFor: 'as yet unclassified' stamp: 'YannDubois 7/13/2016 14:44'!configuration: aConfiguration	^ self new configuration: aConfiguration! !!PRCompilationContext class methodsFor: 'as yet unclassified' stamp: 'YannDubois 7/13/2016 15:36'!isAbstract	^ false! !!PRCompilationContext class methodsFor: 'as yet unclassified' stamp: 'AutoDeprecationRefactoring 7/18/2016 14:18'!withDocument: aDocument withConfiguration: aConfiguration	^ self new		input: aDocument;		configuration: aConfiguration;		yourself! !!PRCompilationContext methodsFor: 'accessing' stamp: 'YannDubois 7/18/2016 14:49'!configuration	^ self propertyAt: #configuration! !!PRCompilationContext methodsFor: 'accessing' stamp: 'YannDubois 7/18/2016 14:46'!configuration: aConfiguration	self propertyAt: #configuration put: aConfiguration ! !!PRCompilationContext methodsFor: 'initialization' stamp: 'YannDubois 7/13/2016 14:03'!initialize	super initialize.	context := Dictionary new! !!PRCompilationContext methodsFor: 'accessing' stamp: 'YannDubois 7/18/2016 14:49'!input	^ self propertyAt: #input! !!PRCompilationContext methodsFor: 'accessing' stamp: 'YannDubois 7/18/2016 14:46'!input: anObject	self propertyAt: #input put: anObject! !!PRCreationPhase class methodsFor: 'meta-data' stamp: 'YannDubois 7/8/2016 16:54'!pipelineKey	^ #compilation! !!PRCreationPhase methodsFor: 'actions' stamp: 'ThibaultArloing 7/28/2016 13:27'!actionOn: anInput	^ PRCompilationContext withDocument: anInput configuration inputFile withConfiguration: anInput configuration! !!PRColumnsTransformer class methodsFor: 'meta-data' stamp: 'DamienCassou 7/21/2016 12:13'!dependencies	^ { PRCleanAnnotationInParagraphTransfomer }! !!PRColumnsTransformer class methodsFor: 'accessing' stamp: 'YannDubois 5/20/2016 11:19'!key	^ #columns! !!PRColumnsTransformer methodsFor: 'adding' stamp: 'CyrilFerlicot 6/18/2015 13:42'!addItem: documentItem	self columnsIsInCreation		ifTrue: [ self currentColumn add: documentItem ]		ifFalse: [ newChildren add: documentItem ]! !!PRColumnsTransformer methodsFor: 'testing' stamp: 'CyrilFerlicot 6/18/2015 13:32'!columnIsInCreation	^ self columnsIsInCreation and: [ tmpColumns children isNotEmpty ]! !!PRColumnsTransformer methodsFor: 'testing' stamp: 'CyrilFerlicot 6/18/2015 13:32'!columnsIsInCreation	^ tmpColumns isNotNil! !!PRColumnsTransformer methodsFor: 'private' stamp: 'CyrilFerlicot 6/18/2015 14:22'!createNewColumnWith: aColumnAnnotation	self columnsIsInCreation		ifFalse: [ 			PRError				signal:					'You can''t create a new column if you are not inside a column environment. Please use ${columns}$ before the beginning of a column.' ].	tmpColumns add: (PRColumn width: (aColumnAnnotation columnAnnotation parameters at: 'width'))! !!PRColumnsTransformer methodsFor: 'private' stamp: 'DamienCassou 7/21/2016 12:00'!createNewColumns	self columnsIsInCreation		ifTrue: [ PRError signal: 'You have to close a columns environment before you open an other. Use the ${endColumns}$ tag please.' ]		ifFalse: [ tmpColumns := PRColumns new ]! !!PRColumnsTransformer methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/18/2015 13:44'!currentColumn	"If there is no current column begin I return the columns environment and I raise a Warning."	^ tmpColumns children isNotEmpty		ifTrue: [ tmpColumns children last ]		ifFalse: [ tmpColumns ]! !!PRColumnsTransformer methodsFor: 'private' stamp: 'ThibaultArloing 8/3/2016 14:55'!manageItem: documentItem	documentItem isColumnsBeginning		ifTrue: [ self createNewColumns ]		ifFalse: [ 			documentItem isColumnBeginning				ifTrue: [ self createNewColumnWith: documentItem ]				ifFalse: [ 					documentItem isColumnsEnding						ifTrue: [ self pushColumns ]						ifFalse: [ self addItem: documentItem ] ] ]! !!PRColumnsTransformer methodsFor: 'private' stamp: 'CyrilFerlicot 6/18/2015 13:32'!possibleTransformationEnding	self columnsIsInCreation		ifTrue: [ PRError signal: 'Missing ending columns annotation. Please use ${endColumns}$ at the end of the columns environment.' ]! !!PRColumnsTransformer methodsFor: 'private' stamp: 'CyrilFerlicot 6/18/2015 13:32'!pushColumns	self columnsIsInCreation		ifTrue: [ 			newChildren add: tmpColumns.			tmpColumns := nil ]		ifFalse: [ PRError signal: 'Column environement ending encounter out of a column environment.' ]! !!PRDocumentChildrenTransformer class methodsFor: 'testing' stamp: 'YannDubois 5/20/2016 11:19'!isAbstract	^ self = PRDocumentChildrenTransformer ! !!PRDocumentChildrenTransformer class methodsFor: 'meta-data' stamp: 'DamienCassou 7/13/2016 15:00'!pipelineKey	^ #transform! !!PRDocumentChildrenTransformer methodsFor: 'actions' stamp: 'ThibaultArloing 8/3/2016 15:00'!actionOn: anInput	anInput input children		do: [ :documentItem | self manageItem: documentItem ].	self possibleTransformationEnding.	anInput input setChildren: newChildren asArray.	^ anInput! !!PRDocumentChildrenTransformer methodsFor: 'initialization' stamp: 'CyrilFerlicot 6/3/2015 12:59'!initialize	super initialize.	newChildren := OrderedCollection new! !!PRDocumentChildrenTransformer methodsFor: 'private' stamp: 'CyrilFerlicot 6/3/2015 13:38'!manageItem: documentItem	^ self subclassResponsibility ! !!PRDocumentChildrenTransformer methodsFor: 'private' stamp: 'CyrilFerlicot 6/3/2015 13:04'!possibleTransformationEnding	"Basicly I do nothing. Override me if you need to do an action before the end of the transformation."	! !!PRSectionTransformer class methodsFor: 'class initialization' stamp: 'CyrilFerlicot 6/2/2015 17:41'!initialize 	" self initialize "	MaxDepthLevel := self maxDepthLevelForSection! !!PRSectionTransformer class methodsFor: 'accessing' stamp: 'YannDubois 5/20/2016 11:33'!key	^ #sections! !!PRSectionTransformer class methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/2/2015 17:41'!maxDepthLevel: anObject	MaxDepthLevel := anObject! !!PRSectionTransformer class methodsFor: 'protected' stamp: 'CyrilFerlicot 6/2/2015 17:41'!maxDepthLevelForSection	^ 7! !!PRSectionTransformer methodsFor: 'testing' stamp: 'CyrilFerlicot 6/2/2015 17:15'!aSectionIsOpen	sections		do: [ :e | 			e isNotNil				ifTrue: [ ^ true ] ].	^ false! !!PRSectionTransformer methodsFor: 'private' stamp: 'CyrilFerlicot 6/2/2015 18:26'!cleanSections	self cleanSectionsUnderLevel: 1! !!PRSectionTransformer methodsFor: 'private' stamp: 'ThibaultArloing 6/2/2016 11:09'!cleanSectionsAndOpenNewWith: documentItem	| newSection |	documentItem level <= MaxDepthLevel		ifTrue: [ self cleanSectionsUnderLevel: documentItem level.			newSection := PRSection with: documentItem.			sections at: documentItem level put: newSection ]		ifFalse: [ self currentSection add: documentItem ].	^ newSection! !!PRSectionTransformer methodsFor: 'private' stamp: 'CyrilFerlicot 6/2/2015 18:26'!cleanSectionsUnderLevel: aNumber	[ self currentSectionIndex >= aNumber ] whileTrue: [ self closeLastSection ]! !!PRSectionTransformer methodsFor: 'private' stamp: 'CyrilFerlicot 6/2/2015 18:18'!closeLastSection	| lastSection |	lastSection := self currentSection.	sections at: self currentSectionIndex put: nil.	self aSectionIsOpen		ifTrue: [ self currentSection add: lastSection ]		ifFalse: [ newChildren add: lastSection ]! !!PRSectionTransformer methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/2/2015 17:44'!currentSection	^ sections at: self currentSectionIndex! !!PRSectionTransformer methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/2/2015 18:04'!currentSectionIndex	"I return the index of deeper section open now. If I don't have any section open I return -1."	| index |	index := MaxDepthLevel.	sections reverse		do: [ :each | 			each isNotNil				ifTrue: [ ^ index ].			index := index - 1 ].	^ -1! !!PRSectionTransformer methodsFor: 'initialization' stamp: 'CyrilFerlicot 6/3/2015 12:59'!initialize	super initialize.	sections := Array ofSize: MaxDepthLevel! !!PRSectionTransformer methodsFor: 'private' stamp: 'CyrilFerlicot 6/3/2015 13:01'!manageItem: documentItem	^ documentItem isHeader		ifTrue: [ self cleanSectionsAndOpenNewWith: documentItem ]		ifFalse: [ 			self aSectionIsOpen				ifTrue: [ self currentSection add: documentItem ]				ifFalse: [ newChildren add: documentItem ] ]! !!PRSectionTransformer methodsFor: 'private' stamp: 'CyrilFerlicot 6/3/2015 13:02'!possibleTransformationEnding	self cleanSections! !!PRSlideTransformer class methodsFor: 'meta-data' stamp: 'ThibaultArloing 8/3/2016 15:01'!dependencies	^ { PRCleanAnnotationInParagraphTransfomer . PRColumnsTransformer }! !!PRSlideTransformer class methodsFor: 'accessing' stamp: 'YannDubois 5/20/2016 11:35'!key	^ #slide! !!PRSlideTransformer methodsFor: 'testing' stamp: 'CyrilFerlicot 6/3/2015 13:41'!aSlideIsOpen	^ tmpSlide isNotNil! !!PRSlideTransformer methodsFor: 'private' stamp: 'CyrilFerlicot 6/5/2015 16:46'!createNewSlideWith: documentItem	| slideAnnotation |	slideAnnotation := documentItem slideAnnotation.	"We do that because our slideAnnotation could be inside a paragraph."	tmpSlide := (PRSlide titled: (slideAnnotation parameters at: 'title' ifAbsent: [ 'New Slide' ]))		label: (slideAnnotation parameters at: 'label' ifAbsent: [ nil ])! !!PRSlideTransformer methodsFor: 'private' stamp: 'CyrilFerlicot 6/3/2015 14:22'!manageItem: documentItem	^ documentItem isSlideBeginning		ifTrue: [ self pushSlideIfNeeded. self createNewSlideWith: documentItem ]		ifFalse: [ 			self aSlideIsOpen				ifTrue: [ self manageSlideWith: documentItem ]				ifFalse: [ newChildren add: documentItem ] ]! !!PRSlideTransformer methodsFor: 'private' stamp: 'CyrilFerlicot 6/3/2015 15:01'!manageSlideWith: documentItem	documentItem isHeader		ifTrue: [ 			self pushSlideIfNeeded.			newChildren add: documentItem ]		ifFalse: [ tmpSlide add: documentItem ]! !!PRSlideTransformer methodsFor: 'private' stamp: 'CyrilFerlicot 6/3/2015 14:53'!possibleTransformationEnding	self pushSlideIfNeeded! !!PRSlideTransformer methodsFor: 'private' stamp: 'CyrilFerlicot 6/3/2015 14:22'!pushSlideIfNeeded	self aSlideIsOpen		ifTrue: [ 			newChildren add: tmpSlide.			tmpSlide := nil ]! !!PRExportPhase class methodsFor: 'meta-data' stamp: 'ThibaultArloing 7/21/2016 12:23'!dependencies	^ { PRFileInclusion }! !!PRExportPhase class methodsFor: 'meta-data' stamp: 'YannDubois 7/8/2016 16:54'!pipelineKey	^ #compilation! !!PRExportPhase methodsFor: 'actions' stamp: 'YannDubois 8/9/2016 14:05'!actionOn: anInput	| writer output |	"We create the directories before the files to avoir a FileDoesNotExistException."	self configuration: anInput configuration.	writer := self instantiateWriter		configuration: self configuration;		yourself.	self configuration outputFile isStream		ifFalse: [ self configuration				outputFile: (self configuration outputFile withExtension: writer fileExtension) ].	output := self write: anInput input using: writer.	^ output! !!PRExportPhase methodsFor: 'private' stamp: 'YannDubois 8/9/2016 14:36'!asJson: anOutput withConfiguration: aConfig	| output config |		output := '' writeStream.	config := aConfig metadata properties jsonWriteOn: output.	^ output contents.! !!PRExportPhase methodsFor: 'actions' stamp: 'YannDubois 7/7/2016 16:21'!createSymbolicLink	| linkName |	(self configuration outputFile isStream		or: [ self configuration outputDirectory				= self configuration baseDirectory ])		ifTrue: [ ^ self ].	linkName := (self configuration outputDirectory		resolve: self configuration outputFile) parent fullName , '/root'.	PRCreateSymLink new		createSymbolic: linkName		to: self configuration outputDirectory fullName! !!PRExportPhase methodsFor: 'private' stamp: 'YannDubois 8/9/2016 14:35'!extractDataFrom: aDocument using: aWriter	| subConfiguration |	subConfiguration := self configuration class new.	subConfiguration parent: self configuration.	CCMagritteDictionaryReader		writeDictionary: aDocument properties copy		toConfiguration: subConfiguration.	self mergeConfiguration: subConfiguration.	^ subConfiguration! !!PRExportPhase methodsFor: 'private' stamp: 'CyrilFerlicot 6/15/2015 13:28'!instantiateWriter	^ self configuration outputType new! !!PRExportPhase methodsFor: 'private' stamp: 'ThibaultArloing 8/2/2016 10:20'!mergeConfiguration: aConfig	| conf |	aConfig parent		ifNil: [ ^ aConfig ].	conf := self mergeConfiguration: aConfig parent.	conf metadata properties		keysDo: [ :each | 			aConfig metadata				propertyAt: each				ifAbsentPut: [ conf metadata propertyAt: each ] ].	^ aConfig.! !!PRExportPhase methodsFor: 'actions'!outputFor: file	^ self configuration outputDirectory		resolve: (file relativeTo: self configuration baseDirectory) ! !!PRExportPhase methodsFor: 'private' stamp: 'ThibaultArloing 6/30/2016 14:20'!outputStreamDuring: aBlock	| output |	output := self configuration outputFile isStream		ifTrue: [ self configuration outputFile ]		ifFalse: [ self configuration outputDirectory resolve: self configuration outputFile ].	output pillarWriteDuring: aBlock.	self createSymbolicLink.	^ output! !!PRExportPhase methodsFor: 'private' stamp: 'YannDubois 8/9/2016 14:37'!write: aDocument using: aWriter	| output cocoonConfiguration |	cocoonConfiguration := self extractDataFrom: aDocument using: aWriter.	output := aWriter write: aDocument.	cocoonConfiguration metadata propertyAt: 'content' put: output.	^ self		outputStreamDuring: [ :outStream | 			self				writeOutput: (self asJson: output withConfiguration: cocoonConfiguration)				toStream: outStream ]! !!PRExportPhase methodsFor: 'private' stamp: 'CyrilFerlicot 6/15/2015 13:28'!writeOutput: output toStream: outputStream	outputStream nextPutAll: output.	outputStream flush! !!PRParsingPhase class methodsFor: 'meta-data' stamp: 'YannDubois 7/8/2016 17:03'!dependencies	^ {PRCreationPhase}! !!PRParsingPhase class methodsFor: 'meta-data' stamp: 'YannDubois 7/8/2016 16:54'!pipelineKey	^ #compilation! !!PRParsingPhase methodsFor: 'action' stamp: 'ThibaultArloing 7/28/2016 11:31'!actionOn: anInput	"I take a collection of files, I parse them, I can transform them and I return a collection of PRDocument."	self configuration: anInput configuration.	^ self parseInput: anInput input! !!PRParsingPhase methodsFor: 'error' stamp: 'CyrilFerlicot 6/15/2015 13:25'!errorNoInputFile	PRNoInputFileError signal: 'No input file'! !!PRParsingPhase methodsFor: 'parsing' stamp: 'CyrilFerlicot 8/31/2015 21:21'!parse: stdin on: documents	| input |	stdin atEnd		ifTrue: [ ^ self errorNoInputFile ].	input := String		streamContents: [ :s | [ stdin atEnd ] whileFalse: [ stdin next ifNotNil: [ :char | s nextPut: char ] ] ].	documents add: (PRDocument parser parse: input)! !!PRParsingPhase methodsFor: 'parsing' stamp: 'ThibaultArloing 7/21/2016 11:52'!parseFile: aFile	| result subConfiguration |	result := aFile		readStreamDo: [ :input | 			| znReadStream |			znReadStream := (ZnCharacterReadStream on: aFile binaryReadStream) contents asString readStream.			[ PRDocument parser parse: znReadStream ]				on: PRError, STONReaderError 				do: [ :exception | exception class signal: exception messageText , ' Inside: ' , aFile basename ] ].	subConfiguration := self configuration class new.	subConfiguration parent: self configuration.	CCMagritteDictionaryReader writeDictionary: result properties copy toConfiguration: subConfiguration.	self configuration: subConfiguration.	^ result! !!PRParsingPhase methodsFor: 'parsing' stamp: 'YannDubois 7/13/2016 17:02'!parseInput: aFile	^ PRCompilationContext		withDocument:			(aFile				ifNil: [ self parse: FileStream stdin on: Array new ]				ifNotNil: [ self parseFile: aFile ])		withConfiguration: self configuration! !!PRPhase class methodsFor: 'instance-creation' stamp: 'YannDubois 7/18/2016 11:22'!executeOn: anInput	^ self new		actionOn: anInput! !!PRPhase class methodsFor: 'testing' stamp: 'CyrilFerlicot 6/15/2015 13:59'!isAbstract	^ self = PRPhase! !!PRPhase class methodsFor: 'accessing' stamp: 'YannDubois 7/12/2016 10:05'!key	^ nil! !!PRPhase methodsFor: 'actions' stamp: 'CyrilFerlicot 6/16/2015 13:16'!actionOn: anInput	self subclassResponsibility! !!PRPhase methodsFor: 'accessing' stamp: 'CyrilFerlicot 10/29/2015 22:00'!configuration	^ configuration isNotNil		ifTrue: [ configuration ]		ifFalse: [ PRPillarConfiguration new ]! !!PRPhase methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/15/2015 10:01'!configuration: aConfiguration	configuration := aConfiguration! !!PRCheckPipeline class methodsFor: 'meta-data' stamp: 'YannDubois 7/11/2016 10:47'!dependencies	^ {PRParsingPhase}! !!PRCheckPipeline class methodsFor: 'accessing' stamp: 'YannDubois 7/8/2016 16:36'!key	^ #check! !!PRCheckPipeline class methodsFor: 'accessing' stamp: 'YannDubois 7/8/2016 16:36'!pipelineKey	^ #compilation! !!PRCompilationPipeline class methodsFor: 'accessing' stamp: 'YannDubois 7/8/2016 16:40'!key	^ #compilation! !!PRCompilationPipeline class methodsFor: 'accessing' stamp: 'YannDubois 7/8/2016 16:40'!pipelineKey	^ nil! !!PRNumeratingPipeline class methodsFor: 'accessing' stamp: 'YannDubois 7/8/2016 16:51'!key	^ #numerating! !!PRNumeratingPipeline class methodsFor: 'accessing' stamp: 'YannDubois 7/8/2016 16:51'!pipelineKey	^ #transform! !!PRPipeline class methodsFor: 'private' stamp: 'DamienCassou 7/13/2016 14:20'!allConcretePipeClasses 	^ PRTPipe users asArray flatCollect: [ :klass | klass withAllConcreteClasses ]! !!PRPipeline class methodsFor: 'building' stamp: 'YannDubois 7/12/2016 11:25'!allDependencies: aConfiguration	^ self dependencies		collect: [ :each | each buildPipe: aConfiguration ]! !!PRPipeline class methodsFor: 'building' stamp: 'DamienCassou 7/19/2016 10:48'!allPipeClasses: aConfiguration	^ self allConcretePipeClasses		select:			[ :each | each pipelineKey = self key and: [ each isEnabled: aConfiguration ] ]! !!PRPipeline class methodsFor: 'building' stamp: 'DamienCassou 7/18/2016 15:28'!allPipes: aConfiguration	^ (self allPipeClasses: aConfiguration)		collect: [ :each | each buildPipe: aConfiguration ]! !!PRPipeline class methodsFor: 'building' stamp: 'ThibaultArloing 8/3/2016 14:51'!buildPipe: aConfiguration	 ^ (LPPipeline pipes: (self allPipes: aConfiguration))		addAllDependencies: (self allDependencies: aConfiguration) sort! !!PRPipeline class methodsFor: 'testing' stamp: 'YannDubois 7/7/2016 17:00'!isAbstract	^ self = PRPipeline! !!PRTransformPipeline class methodsFor: 'meta-data' stamp: 'YannDubois 7/11/2016 10:47'!dependencies	^ {PRCheckPipeline}! !!PRTransformPipeline class methodsFor: 'accessing' stamp: 'YannDubois 7/8/2016 16:36'!key	^ #transform! !!PRTransformPipeline class methodsFor: 'accessing' stamp: 'YannDubois 7/8/2016 16:36'!pipelineKey	^ #compilation! !!PRExportError methodsFor: 'accessing' stamp: 'DamienCassou 4/2/2015 17:12'!inputFile: aFile	file := aFile! !!PRExportError methodsFor: 'accessing' stamp: 'DamienCassou 4/2/2015 17:19'!messageText	^ String		streamContents: [ :stream | 			stream << super messageText.			file ifNotNil: [ stream << ' (' << file basename << ')' ] ]! !!MAVisitor methodsFor: '*Pillar-ExporterCore' stamp: 'CyrilFerlicot 6/23/2015 11:57'!visitHeaderLevelDescription: aHeaderLevelDescription	self visitToOneRelationDescription: aHeaderLevelDescription! !!MAVisitor methodsFor: '*Pillar-ExporterCore' stamp: 'CyrilFerlicot 6/29/2015 09:58'!visitNewLineDescription: aNewLineDescription	self visitStringDescription: aNewLineDescription! !!MAVisitor methodsFor: '*Pillar-ExporterCore' stamp: 'CyrilFerlicot 8/5/2015 13:27'!visitPathOrStreamDescription: aPathOrStreamDescription	self visitElementDescription: aPathOrStreamDescription! !!MAVisitor methodsFor: '*Pillar-ExporterCore' stamp: 'CyrilFerlicot 6/22/2015 17:00'!visitScriptLanguageDescription: aScriptLanguageDescription	self visitElementDescription: aScriptLanguageDescription! !!CCMagritteDictionaryReader methodsFor: '*Pillar-ExporterCore' stamp: 'GuillermoPolito 8/13/2015 14:37'!buildConfiguration: confName with: confValues	| outputType |	outputType := confValues at: 'outputType' ifAbsent: nil.	configuration class		allSubclassesDo: [ :e | 			e isAbstract				ifFalse: [ 					(e configurationName = confName or: [ e configurationName = outputType ])						ifTrue: [ | subconfiguration |							subconfiguration := e new.							subconfiguration parent: configuration.							CCMagritteDictionaryReader writeDictionary: confValues toConfiguration: subconfiguration.							^ subconfiguration ] ] ].	^ self createConfigurationFrom: confValues! !!CCMagritteDictionaryReader methodsFor: '*Pillar-ExporterCore' stamp: 'CyrilFerlicot 8/7/2015 16:16'!configuration: aConfiguration	"This method is here to do some tests."	configuration := aConfiguration! !!CCMagritteDictionaryReader methodsFor: '*Pillar-ExporterCore' stamp: 'CyrilFerlicot 6/26/2015 17:44'!visitClassDescription: aClassDescription	self		tryToAddFrom: aClassDescription		withInterpretation: [ :value | PRDocumentWriter allSubclasses detect: [ :klass | klass isAbstract not and: [ klass writerName asString = value ] ] ]! !!CCMagritteDictionaryReader methodsFor: '*Pillar-ExporterCore' stamp: 'CyrilFerlicot 5/29/2016 00:55'!visitHeaderLevelDescription: aHeaderLevelDescription	self		tryToAddFrom: aHeaderLevelDescription		withInterpretation: [ :value | 			| return |			return := (configuration class headerConfigurations at: (value at: 'renderAs' ifAbsent: [ 'roman' ])) with: value.			return				level: aHeaderLevelDescription level;				configuration: configuration.			return ]! !!CCMagritteDictionaryReader methodsFor: '*Pillar-ExporterCore' stamp: 'CyrilFerlicot 6/29/2015 10:03'!visitNewLineDescription: aNewLineDescription	self		tryToAddFrom: aNewLineDescription		withInterpretation: [ :value | 			value isSymbol				ifTrue: [ 					(Dictionary						newFrom:							{#cr -> String cr.							#lf -> UnixPlatform new lineEnding.							#crlf -> Win32Platform new lineEnding.							#unix -> UnixPlatform new lineEnding.							#mac -> UnixPlatform new lineEnding.							#dos -> Win32Platform new lineEnding}) at: value ]				ifFalse: [ value ] ]! !!CCMagritteDictionaryReader methodsFor: '*Pillar-ExporterCore' stamp: 'CyrilFerlicot 8/5/2015 13:28'!visitPathOrStreamDescription: aPathOrStreamDescription	self		tryToAddFrom: aPathOrStreamDescription		withInterpretation: [ :path | RelativePath from: path ]! !!CCMagritteDictionaryReader methodsFor: '*Pillar-ExporterCore' stamp: 'CyrilFerlicot 6/22/2015 17:12'!visitScriptLanguageDescription: aScriptLanguageDescription	self tryToAddFrom: aScriptLanguageDescription withInterpretation: [ :value | PRAbstractScriptLanguage for: value ]! !!WriteStream methodsFor: '*pillar-exportercore' stamp: 'DamienCassou 6/4/2014 17:14'!pillarWriteDuring: aBlock	aBlock value: self! !!AbstractFileReference methodsFor: '*pillar-exportercore' stamp: 'CyrilFerlicot 8/18/2015 15:25'!pillarWriteDuring: aBlock	self parent ensureCreateDirectory.	self		ensureDelete;		writeStreamDo: aBlock! !!Trait method!buildPipe: aConfiguration	^ (LPPhase block: [ :input | self executeOn: input ])		addAllDependencies: (self dependencies collect: [ :each | each buildPipe: aConfiguration ])! !!Trait method!buildPipe: aConfiguration	^ (LPPhase block: [ :input | self executeOn: input ])		addAllDependencies: (self dependencies collect: [ :each | each buildPipe: aConfiguration ])! !!Trait method!buildPipe: aConfiguration	^ (LPPhase block: [ :input | self executeOn: input ])		addAllDependencies: (self dependencies collect: [ :each | each buildPipe: aConfiguration ])! !!Trait method!buildPipe: aConfiguration	^ (LPPhase block: [ :input | self executeOn: input ])		addAllDependencies: (self dependencies collect: [ :each | each buildPipe: aConfiguration ])! !!Trait method!dependencies	 ^ {  }! !!Trait method!dependencies	 ^ {  }! !!Trait method!dependencies	 ^ {  }! !!Trait method!dependencies	 ^ {  }! !!Trait method!executeOn: anInput	^ self explicitRequirement! !!Trait method!executeOn: anInput	^ self explicitRequirement! !!Trait method!executeOn: anInput	^ self explicitRequirement! !!Trait method!executeOn: anInput	^ self explicitRequirement! !!Trait method!isEnabled: aConfiguration	^ (aConfiguration disabledPhases includes: self key) not! !!Trait method!isEnabled: aConfiguration	^ (aConfiguration disabledPhases includes: self key) not! !!Trait method!isEnabled: aConfiguration	^ (aConfiguration disabledPhases includes: self key) not! !!Trait method!isEnabled: aConfiguration	^ (aConfiguration disabledPhases includes: self key) not! !!Trait method!key	"A symbol describing what I do."	^ self explicitRequirement! !!Trait method!key	"A symbol describing what I do."	^ self explicitRequirement! !!Trait method!key	"A symbol describing what I do."	^ self explicitRequirement! !!Trait method!key	"A symbol describing what I do."	^ self explicitRequirement! !!Trait method!pipelineKey	"A symbol representing in which pipeline I should be included. There must be a pipeline which answers my pipelineKey when sending it the message #key."	^ self explicitRequirement! !!Trait method!pipelineKey	"A symbol representing in which pipeline I should be included. There must be a pipeline which answers my pipelineKey when sending it the message #key."	^ self explicitRequirement! !!Trait method!pipelineKey	"A symbol representing in which pipeline I should be included. There must be a pipeline which answers my pipelineKey when sending it the message #key."	^ self explicitRequirement! !!Trait method!pipelineKey	"A symbol representing in which pipeline I should be included. There must be a pipeline which answers my pipelineKey when sending it the message #key."	^ self explicitRequirement! !"Pillar-ExporterCore"!!PRTextWriter commentStamp: 'TorstenBergmann 3/5/2015 22:21' prior: 0!A writer for text !!PRTextCanvas commentStamp: 'TorstenBergmann 3/5/2015 22:21' prior: 0!A canvas for writing text!!PRTextWriter class methodsFor: 'accessing' stamp: 'DamienCassou 2/26/2014 17:20'!fileExtension	^ 'txt'! !!PRTextWriter class methodsFor: 'accessing' stamp: 'DamienCassou 2/26/2014 17:10'!writerName	^ #text! !!PRTextWriter methodsFor: 'accessing' stamp: 'DamienCassou 2/26/2014 17:02'!canvasClass	^ PRTextCanvas! !!PRTextWriter methodsFor: 'private' stamp: 'DamienCassou 2/26/2014 17:08'!nest: aString do: aBlock	nesting add: aString.	aBlock ensure: [ nesting removeLast ]! !!PRTextWriter methodsFor: 'visiting' stamp: 'DamienCassou 2/27/2014 11:33'!start: anObject	nesting := OrderedCollection new.	super start: anObject.	canvas lastIsNewLine		ifTrue: [ stream trimLastNewLine ]! !!PRTextWriter methodsFor: 'visiting-document' stamp: 'lr 12/30/2007 23:25'!visitDataItem: anObject	self nest: ' ' do: [ super visitDataItem: anObject ]! !!PRTextWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/26/2014 17:05'!visitDefinitionList: anObject	canvas potentialNewLine.	self visitAll: anObject children! !!PRTextWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/26/2014 17:11'!visitHeader: anObject	super visitHeader: anObject.	canvas newLine! !!PRTextWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/26/2014 17:11'!visitHorizontalRule: anObject	canvas		nextPutAll: ((String new: 40) atAllPut: $-);		newLine! !!PRTextWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/26/2014 17:12'!visitListItem: anObject 	nesting last isInteger ifTrue: [ nesting addLast: nesting removeLast + 1 ].	nesting size - 1 timesRepeat: [ canvas tab ].	canvas nextPutAll: nesting last greaseString.	canvas nextPutAll: (nesting last isInteger 			ifTrue: [ '. ' ]			ifFalse: [ ' ' ]).	super visitListItem: anObject.	canvas potentialNewLine! !!PRTextWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/26/2014 17:12'!visitOrderedList: anObject	canvas potentialNewLine.	self nest: 0 do: [ super visitOrderedList: anObject ]! !!PRTextWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/26/2014 17:35'!visitParagraph: anObject	super visitParagraph: anObject.	canvas newLine! !!PRTextWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/26/2014 17:03'!visitPreformatted: anObject	anObject children do: [ :each | self visit: each. canvas newLine ]! !!PRTextWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/26/2014 17:14'!visitRaw: anObject	(anObject type isNil or: [ anObject type = 'text' ])		ifTrue: [ canvas nextPutAll: anObject text ]! !!PRTextWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 4/28/2015 14:48'!visitReference: anObject	anObject hasAlias		ifTrue: [ super visitReference: anObject ]		ifFalse: [ canvas nextPutAll: anObject title ]! !!PRTextWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/26/2014 17:14'!visitTableRow: anObject	anObject children		do: [ :each | self visit: each ]		separatedBy: [ canvas tab ].	canvas newLine! !!PRTextWriter methodsFor: 'visiting-document' stamp: 'lr 12/30/2007 23:24'!visitTermItem: anObject	self nest: '-' do: [ super visitDataItem: anObject ]! !!PRTextWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/26/2014 17:03'!visitText: anObject	canvas nextPutAll: anObject text! !!PRTextWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/26/2014 17:31'!visitUnorderedList: anObject	canvas potentialNewLine.	self nest: '*' do: [ super visitUnorderedList: anObject ]! !!PRDocument methodsFor: '*pillar-exportertext' stamp: 'DamienCassou 6/6/2014 17:03'!defaultTitle	^ 'No title'! !!PRDocument methodsFor: '*pillar-exportertext' stamp: 'DamienCassou 6/6/2014 16:37'!title	^ self propertyAt: 'title' ifAbsent: [ self titleFromFirstHeader ]! !!PRDocument methodsFor: '*pillar-exportertext' stamp: 'CyrilFerlicot 5/23/2015 20:10'!titleFromFirstHeader	^ self children		detect: [ :child | child isHeader ]		ifFound: [ :header | PRTextWriter write: header ]		ifNone: [ self defaultTitle ]! !!PRTextCanvas methodsFor: 'initialization' stamp: 'DamienCassou 2/26/2014 17:06'!initialize	super initialize.	lastIsNewLine := true! !!PRTextCanvas methodsFor: 'testing' stamp: 'DamienCassou 2/26/2014 17:06'!lastIsNewLine	^ lastIsNewLine! !!PRTextCanvas methodsFor: 'writing text' stamp: 'DamienCassou 2/26/2014 17:06'!newLine	super newLine.	lastIsNewLine := true! !!PRTextCanvas methodsFor: 'writing text' stamp: 'DamienCassou 2/26/2014 17:07'!nextPut: aCharacter	super nextPut: aCharacter.	lastIsNewLine := false! !!PRTextCanvas methodsFor: 'writing text' stamp: 'DamienCassou 2/26/2014 17:05'!potentialNewLine	lastIsNewLine		ifFalse: [ self newLine ]! !!PRTextCanvas methodsFor: 'writing text' stamp: 'DamienCassou 2/26/2014 17:07'!raw: aString	super raw: aString.	lastIsNewLine := false.! !!PRTextCanvas methodsFor: 'writing' stamp: 'DamienCassou 2/26/2014 17:13'!tab	self nextPut: Character tab! !"Pillar-ExporterText"!!PRHTMLBrush commentStamp: 'DamienCassou 6/2/2014 14:23' prior: 0!I'm an abstract brush dedicated to HTML documents. As of today, the only subclass is the tag brush but we can imagine others (e.g., to write HTML comments).!!PRHTMLEmptyTag commentStamp: 'CyrilFerlicot 6/3/2015 15:15' prior: 0!I'm a helper class to generate HTML code. For example, to generate:     <img href="figure/test.png"/>you can write something like this:String streamContents: [ :stream | | canvas |	stream := PROutputStream on: stream.	canvas := PRHTMLCanvas on: stream.	canvas emptyTag 		name: 'img';		parameterAt: 'href' put: 'figure/test.png';		closeTag	 ]!!PRHTMLTag commentStamp: 'DamienCassou 6/2/2014 14:45' prior: 0!I'm a helper class to generate HTML code. For example, to generate:     <p>foo <a href="url">bar</a></b>you can write something like this:String streamContents: [ :stream | | canvas |	stream := PROutputStream on: stream.	canvas := PRHTMLCanvas on: stream.	canvas tag 		name: 'p'; 		with: [ canvas nextPutAll: 'foo '.			    canvas tag 	     		      name: 'a';	    			parameterAt: 'href' put: 'url';	                  with: 'bar' ]	 ]!!PRHTMLWriter commentStamp: 'DamienCassou 6/2/2014 14:19' prior: 0!Writes a Pillar document as HTML.!!PRHTMLCanvas commentStamp: 'DamienCassou 6/2/2014 14:21' prior: 0!An HTML canvas that facilitates writing HTML to a stream. The main method is #tag that allow you to write something like this:canvas tag        name: 'a';        parameterAt: 'href' put: href;        with: [ "some code that generates the HTML inside the link" ]!!PRHTMLEmptyTag methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/3/2015 15:15'!closeTag	stream << '/>'! !!PRHTMLEmptyTag methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/3/2015 15:14'!name: aString	name := aString.	stream << $< << aString! !!PRHTMLEmptyTag methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/3/2015 15:15'!parameterAt: aString put: anotherString	stream space. stream << aString << '="' << anotherString << '"'! !!PRHTMLTag methodsFor: 'accessing' stamp: 'DamienCassou 10/14/2013 16:43'!name: aString	name := aString.	stream << $< << aString! !!PRHTMLTag methodsFor: 'accessing' stamp: 'DamienCassou 10/14/2013 16:45'!parameterAt: aString put: anotherString	stream space. stream << aString << '="' << anotherString << '"'! !!PRHTMLTag methodsFor: 'accessing' stamp: 'DamienCassou 10/14/2013 16:45'!with: aString	stream << $> << aString << '</' << name << $>! !!PRHTMLWriter class methodsFor: 'accessing' stamp: 'DamienCassou 12/9/2013 11:07'!fileExtension	^ 'html'! !!PRHTMLWriter class methodsFor: 'accessing' stamp: 'DamienCassou 12/11/2013 17:21'!writerName	^ #html! !!PRHTMLWriter methodsFor: 'private' stamp: 'CyrilFerlicot 6/8/2015 15:58'!addAnchorFrom: anInternalLink To: href	"I am here for the deck.js exporter or other exporter that would need to change the way anchor are generated."	^ href , '#' , anInternalLink anchor! !!PRHTMLWriter methodsFor: 'accessing' stamp: 'DamienCassou 10/14/2013 16:36'!canvasClass	^ PRHTMLCanvas! !!PRHTMLWriter methodsFor: 'private' stamp: 'YannDubois 5/4/2016 11:19'!createAnchorWith: anId	canvas tag		name: 'a';		parameterAt: 'id' put: anId;		with: ''! !!PRHTMLWriter methodsFor: 'private' stamp: 'LukasKomarek 4/21/2016 14:45'!exportImgFor: aFigure	| img |	img := canvas emptyTag		name: 'img';		parameterAt: 'src' put: (aFigure localFileOrExternalReference);		yourself.	aFigure parameters		at: 'width'		ifPresent:			[ :width | img parameterAt: 'width' put: width greaseString , '%' ].	img closeTag! !!PRHTMLWriter methodsFor: 'private' stamp: 'CyrilFerlicot 6/8/2015 15:56'!internalLinkWillBeRender: anInternalLink	(anInternalLink hasReference and: [ anInternalLink hasAnchor not ])		ifTrue: [ 			PRLinkWarning				signal:					'Your inter-file link will not be render because you export without separate output files. If you want your link to be render add an anchor to the beginning of your file.' ]! !!PRHTMLWriter methodsFor: 'private' stamp: 'YannDubois 5/4/2016 16:05'!noteAtEnd	self noteDictionary isNotEmpty		ifTrue: [ canvas newLine.			canvas tag				name: 'hr';				with: ''.			canvas newLine ].	self noteDictionary		keysAndValuesDo: [ :keys :value | 			canvas tag				name: 'sup';				parameterAt: 'id' put: 'footnote' , keys asString;				with: '[' , keys asString , '] ' , value.			canvas emptyTag				name: 'br';				closeTag.			canvas newLine ]! !!PRHTMLWriter methodsFor: 'accessing' stamp: 'YannDubois 5/4/2016 11:35'!noteDictionary	^ noteDictionary! !!PRHTMLWriter methodsFor: 'visiting' stamp: 'YannDubois 5/4/2016 11:46'!start: anObject	canvas := PRHTMLCanvas on: stream.	footnoteID := 0.	noteDictionary := Dictionary new.	super start: anObject.	self noteAtEnd.	canvas flush! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/4/2015 13:32'!visitAnchor: anAnchor	self createAnchorWith: anAnchor name! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 6/5/2014 15:39'!visitAnnotatedParagraph: anAnnotatedParagraph	"Annotations need to be defined as CSS styles. For example...		@@note 		@@dothis	could have...	 	<head><style>		p.note{colour:green}		p.dothis{colour:red}		</style></head> 	"	canvas tag		name: 'p';		parameterAt: 'class' put: anAnnotatedParagraph annotation;		with: [ 					"We call #visitParagraph: directly because we don't want 'self visitParagraph:' to be executed."					super visitParagraph: anAnnotatedParagraph ]! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:36'!visitBoldFormat: aFormat	canvas tag		name: 'strong';		with: [ super visitBoldFormat: aFormat ]! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 8/4/2015 13:24'!visitColumn: aColumn	canvas tag		name: 'div';		parameterAt: 'class' put: 'column';		parameterAt: 'style' put: 'float:left; margin:0; width:' , aColumn width greaseString , '%;';		with: [ super visitColumn: aColumn ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 8/4/2015 13:24'!visitColumns: aColumns	canvas tag		name: 'div';		parameterAt: 'class' put: 'columns';		parameterAt: 'style' put: 'margin:0px auto; width:100%';		with: [ super visitColumns: aColumns ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/1/2015 17:15'!visitDataItem: anItem	canvas tag		name: 'dd';		with: [ self visitAll: anItem children ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/1/2015 17:15'!visitDefinitionList: aList	canvas tag		name: 'dl';		with: [ super visitDefinitionList: aList ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'LukasKomarek 4/21/2016 14:45'!visitExternalLink: anExternalLink	canvas tag		name: 'a';		parameterAt: 'href' put: anExternalLink localFileOrExternalReference;		with: anExternalLink alias! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 9/6/2015 11:11'!visitFigure: aFigure	(aFigure hasLabel not and: [ aFigure hasCaption not ])		ifTrue: [ 			self exportImgFor: aFigure.			^ self ].	aFigure label ifNotNil: [ :label | self createAnchorWith: label ].	canvas newLine.	canvas tag		name: 'figure';		with:				[ 			canvas newLine.			canvas nextPut: Character tab.			self exportImgFor: aFigure.			canvas newLine.			canvas nextPut: Character tab.			canvas tag				name: 'figcaption';				with:						[ 					aFigure label ifNotNil: [ self writeCounterForFigure: aFigure ].					super visitFigure: aFigure ].			canvas newLine ]! !!PRHTMLWriter methodsFor: 'visiting-annotations' stamp: 'YannDubois 5/4/2016 14:43'!visitFootnote: aFootnote	footnoteID := footnoteID + 1.	canvas tag		name: 'sup';		with: [ canvas tag				name: 'a';				parameterAt: 'href' put: '#footnote' , footnoteID asString;				with: '[' , footnoteID asString , ']' ].	noteDictionary at: footnoteID ifAbsentPut: aFootnote note! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 6/21/2016 11:01'!visitHeader: aHeader	| level |	"h1 to h7 exist."	level := aHeader level min: 7 max: 1.	canvas tag		name: 'h' , level asString;		with: [ 					self writeCounterForHeader: aHeader.					super visitHeader: aHeader ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'BenjaminVanRyseghem 11/20/2013 00:54'!visitHorizontalRule: anHorizontalRule	canvas newLine; newLine.	canvas raw: '<hr>'.	canvas newLine.! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 7/2/2015 10:31'!visitInternalLink: anInternalLink	| href |	href := String new.	self configuration separateOutputFiles		ifTrue: [ 			anInternalLink hasReference				ifTrue: [ href := href , anInternalLink referenceAsHTML ] ]		ifFalse: [ self internalLinkWillBeRender: anInternalLink ].	anInternalLink hasAnchor		ifTrue: [ href := self addAnchorFrom: anInternalLink To: href ].	canvas tag		name: 'a';		parameterAt: 'href' put: href;		with: [ 					anInternalLink counter isValidCounter						ifTrue: [ 							self writeCounter: anInternalLink counter.							anInternalLink hasAlias								ifTrue: [ canvas nextPutAll: ' ' ] ].					super visitInternalLink: anInternalLink ]! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:47'!visitItalicFormat: aFormat	canvas tag		name: 'em';		with: [ super visitBoldFormat: aFormat ]! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/1/2015 17:16'!visitListItem: anItem	canvas tag		name: 'li';		with: [ super visitListItem: anItem ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 4/26/2014 18:18'!visitMailLink: aLink	canvas tag		name: 'a';		parameterAt: 'href' put: aLink unscrambledUrl;		with: aLink alias! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:47'!visitMonospaceFormat: aFormat	canvas tag		name: 'code';		with: [ super visitBoldFormat: aFormat ]! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/1/2015 17:16'!visitOrderedList: aList	canvas tag		name: 'ol';		with: [ super visitOrderedList: aList ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/4/2015 11:00'!visitParagraph: aParagraph	(aParagraph children size = 1 and: [ aParagraph children first isKindOf: PRRaw ])		ifTrue: [ 			self				flag:					'TODO: ugly fix. The idea is that you don''t want the <p> when using a Raw that potentially displays a <div>, because this is not HTML compliant'.			self visitRaw: aParagraph children first ]		ifFalse: [ 			canvas tag				name: 'p';				with: [ 							canvas newLine.							super visitParagraph: aParagraph.							canvas newLine ] ]! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 1/9/2014 12:17'!visitPreformatted: aPreformatted	canvas tag		name: 'pre';		with: [ aPreformatted children do: [ :child | self visit: child ] separatedBy: [ canvas newLine ] ]! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/29/2016 17:33'!visitScript: aScript	canvas tag		name: 'figure';		with: [ 					canvas tag						name: 'pre';						with: [ 									| code language |									code := canvas tag										name: 'code';										yourself.									language := self languageForScript: aScript.									language isSyntaxHighlightingPossible										ifTrue: [ code parameterAt: 'class' put: language printString ].									code with: [ canvas lines: aScript text ] ].					canvas tag						name: 'figcaption';						with: [ 									aScript hasLabel										ifTrue: [ 											self createAnchorWith: aScript label.											self writeCounterForScript: aScript ].									aScript hasCaption										ifTrue: [ self visitAll: aScript caption children ] ] ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/4/2015 10:57'!visitSection: aSection	canvas tag		name: 'section';		with: [ 					canvas newLine.					super visitSection: aSection ]! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:48'!visitStrikethroughFormat: aFormat	canvas tag		name: 's';		with: [ super visitStrikethroughFormat: aFormat ]! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:48'!visitSubscriptFormat: aFormat	canvas tag		name: 'sub';		with: [ super visitSubscriptFormat: aFormat ]! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:48'!visitSuperscriptFormat: aFormat	canvas tag		name: 'sup';		with: [ super visitSuperscriptFormat: aFormat ]! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/1/2015 17:16'!visitTable: aTable	canvas tag		name: 'table';		parameterAt: 'style' put: 'border: solid thin';		with: [ super visitTable: aTable ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/1/2015 17:16'!visitTableCell: aCell	| tagName tag |	tagName := aCell isHeading		ifTrue: [ 'th' ]		ifFalse: [ 'td' ].	tag := canvas tag name: tagName.	aCell isAligned		ifTrue: [ 			aCell isAlignedLeft				ifTrue: [ tag parameterAt: 'style' put: 'text-align: left' ].			aCell isAlignedCenter				ifTrue: [ tag parameterAt: 'style' put: 'text-align: center' ].			aCell isAlignedRight				ifTrue: [ tag parameterAt: 'style' put: 'text-align: right' ] ].	tag with: [ super visitTableCell: aCell ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/1/2015 17:16'!visitTableRow: aRow	canvas tag		name: 'tr';		with: [ super visitTableRow: aRow ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/1/2015 17:16'!visitTermItem: anItem	canvas tag		name: 'dt';		with: [ self visitAll: anItem children ].	canvas newLine! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:48'!visitUnderlineFormat: aFormat	canvas tag		name: 'u';		with: [ super visitUnderlineFormat: aFormat ]! !!PRHTMLWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/4/2015 13:40'!visitUnorderedList: aList	canvas tag		name: 'ul';		with: [ 					canvas newLine.					super visitUnorderedList: aList ].	canvas newLine! !!PRHTMLCanvas class methodsFor: 'class initialization' stamp: 'DamienCassou 12/19/2013 12:36'!initialize	HTMLCharacters := Dictionary new.	HTMLCharacters		at: $" put: '&quot;';		at: $& put: '&amp;';		at: $< put: '&lt;';		at: $> put: '&gt;'! !!PRHTMLCanvas methodsFor: 'tags' stamp: 'CyrilFerlicot 6/3/2015 15:17'!emptyTag	^ self brush: PRHTMLEmptyTag new! !!PRHTMLCanvas methodsFor: 'writing text' stamp: 'DamienCassou 12/19/2013 12:33'!nextPut: aCharacter	| string |	string := HTMLCharacters at: aCharacter ifAbsent: nil.	string isNil		ifTrue: [ super nextPut: aCharacter ]		ifFalse: [ self raw: string ]! !!PRHTMLCanvas methodsFor: 'tags' stamp: 'DamienCassou 10/14/2013 16:24'!tag	^ self brush: PRHTMLTag new! !"Pillar-ExporterHTML"!!PRMarkdownCanvas commentStamp: 'YannDubois 6/3/2016 09:13' prior: 0!A Markdown canvas that facilitates writing Markdown to a stream. It essentially use to nesting the lists!!PRMarkdownWriter commentStamp: '<historical>' prior: 0!I am a visitor generating markdown documents!!PRGithubMarkdownWriter commentStamp: 'YannDubois 5/31/2016 14:17' prior: 0!I am a writer for the GitHub markdown which differs a bit from the `original` markdown.!!PRMarkdownCanvas methodsFor: 'initialization' stamp: 'YannDubois 6/3/2016 09:09'!initialize	super initialize.	lastIsNewLine := true! !!PRMarkdownCanvas methodsFor: 'accessing' stamp: 'YannDubois 6/3/2016 09:08'!lastIsNewLine	^ lastIsNewLine! !!PRMarkdownCanvas methodsFor: 'writing text' stamp: 'YannDubois 6/3/2016 09:10'!newLine	super newLine.	lastIsNewLine := true! !!PRMarkdownCanvas methodsFor: 'writing text' stamp: 'YannDubois 6/3/2016 09:10'!nextPut: aCharacter	super nextPut: aCharacter.	lastIsNewLine := false! !!PRMarkdownCanvas methodsFor: 'writing text' stamp: 'YannDubois 6/3/2016 09:09'!potentialNewLine	lastIsNewLine ifFalse: [ self newLine ]! !!PRMarkdownCanvas methodsFor: 'writing text' stamp: 'YannDubois 6/3/2016 09:09'!raw: aString	super raw: aString.	lastIsNewLine := false! !!PRGithubMarkdownWriter class methodsFor: 'accessing' stamp: 'YannDubois 5/31/2016 14:29'!writerName	^ #githubmarkdown! !!PRGithubMarkdownWriter methodsFor: 'protected' stamp: 'YannDubois 5/31/2016 15:00'!scriptLayout: aScript	| language |	language := self languageForScript: aScript.	canvas nextPutAll: '```'.	language isSyntaxHighlightingPossible ifTrue: [ canvas raw: language printString ].	canvas raw: aScript text, '```'! !!PRGithubMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 5/31/2016 15:10'!visitTable: aTableCell	firstRow := true.	self visitDocumentGroup: aTableCell.	canvas newLine.! !!PRGithubMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 5/31/2016 15:16'!visitTableCell: aTableCell	canvas raw: aTableCell text! !!PRGithubMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 5/31/2016 15:11'!visitTableRow: aTableRow	stream << '| '.	self visitAll: aTableRow children separatedBy: [ stream << ' | ' ].	firstRow ifTrue: [ 		stream newLine.		firstRow := false.				aTableRow children do: [ :aTableCell | 			stream << '| '.					aTableCell isAligned 					ifTrue: [						aTableCell isAlignedLeft ifTrue: [ stream << ':---' ].						aTableCell isAlignedCenter ifTrue: [ stream << ':---:' ].						aTableCell isAlignedRight ifTrue: [ stream << '---:' ] ]					ifFalse: [ stream << ':---:' ] ] ].	stream newLine! !!PRGithubMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 5/31/2016 15:06'!visitUnderlineFormat: aFormat	super visitFormat: aFormat ! !!PRMarkdownWriter class methodsFor: 'accessing' stamp: 'DamienCassou 12/9/2013 11:08'!fileExtension	^ 'md'! !!PRMarkdownWriter class methodsFor: 'accessing' stamp: 'DamienCassou 12/11/2013 17:21'!writerName	^ #markdown! !!PRMarkdownWriter methodsFor: 'accessing' stamp: 'YannDubois 6/3/2016 09:13'!canvasClass	^ PRMarkdownCanvas! !!PRMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 6/2/2016 16:51'!nest: aString do: aBlock	nesting add: aString.	aBlock ensure: [ nesting removeLast ]! !!PRMarkdownWriter methodsFor: 'protected' stamp: 'YannDubois 5/31/2016 14:56'!scriptLayout: aScript	| text lines |	text := aScript text.	lines := (text substrings: self configuration newLine)		collect: [ :each | '    ' , each , self configuration newLine ].	canvas raw: lines.! !!PRMarkdownWriter methodsFor: 'visiting' stamp: 'YannDubois 6/2/2016 16:55'!start: anObject	nesting := OrderedCollection new.	super start: anObject! !!PRMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 5/30/2016 13:41'!visitBoldFormat: aFormat	canvas raw: '**', aFormat text, '**'! !!PRMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 5/30/2016 13:08'!visitExternalLink: anExternalLink	self writeExternalLink: anExternalLink.! !!PRMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 5/31/2016 10:12'!visitFigure: aFigure	canvas raw: '!!['.	aFigure hasLabel ifTrue: [ canvas raw: aFigure label ].	canvas raw: '](', aFigure localFileOrExternalReference.	aFigure hasCaption ifTrue: [ canvas raw: ' "', aFigure text, '"' ].	canvas raw: ')'.! !!PRMarkdownWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 6/21/2016 11:35'!visitHeader: aHeader	| level |	level := aHeader level min: 7 max: 1.	1 to: level do: [ :each | canvas nextPut: $# ].	self writeCounterForHeader: aHeader.	canvas raw: aHeader text.	canvas newLine	! !!PRMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 5/30/2016 10:54'!visitHorizontalRule: anHorizontalRule	canvas newLine; newLine.	canvas raw: '***'.	canvas newLine.	! !!PRMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 5/30/2016 13:32'!visitInternalLink: anInternalLink	| href |	href := String new.	self configuration separateOutputFiles		ifTrue: [ anInternalLink hasReference				ifTrue: [ href := href , anInternalLink referenceAsHTML ] ]		ifFalse: [ self internalLinkWillBeRender: anInternalLink ].	anInternalLink hasAnchor		ifTrue: [ href := self addAnchorFrom: anInternalLink To: href ].	self writeInternalLink: anInternalLink withRef: href.! !!PRMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 5/30/2016 13:41'!visitItalicFormat: aFormat	canvas raw: '*', aFormat text, '*'! !!PRMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 6/3/2016 09:14'!visitListItem: aListItem	nesting last isInteger ifTrue: [ nesting addLast: nesting removeLast + 1 ].	nesting size - 1 timesRepeat: [ canvas raw: '  ' ].	canvas nextPutAll: nesting last greaseString.	canvas nextPutAll: (nesting last isInteger 			ifTrue: [ '. ' ]			ifFalse: [ ' ' ]).	self visitDocumentGroup: aListItem.	canvas potentialNewLine! !!PRMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 5/31/2016 09:43'!visitMonospaceFormat: aFormat	canvas raw: '`', aFormat text, '`'! !!PRMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 6/3/2016 09:15'!visitOrderedList: aList	canvas potentialNewLine.	self nest: '1.' do: [ self visitDocumentGroup: aList ]! !!PRMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 5/31/2016 10:28'!visitParagraph: aParagraph	self visitDocumentGroup: aParagraph.! !!PRMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 5/31/2016 14:56'!visitScript: aScript	aScript hasLabel		ifTrue: [ self createAnchorWith: aScript label.			canvas newLine ].	self scriptLayout: aScript.	aScript hasCaption		ifTrue: [ canvas				raw: '**' , aScript caption text , '**';				newLine ]! !!PRMarkdownWriter methodsFor: 'visiting-document' stamp: 'YannDubois 6/3/2016 09:15'!visitUnorderedList: aList	canvas potentialNewLine.	self nest: '-' do: [ self visitDocumentGroup: aList ]! !!PRMarkdownWriter methodsFor: 'private' stamp: 'YannDubois 5/30/2016 13:27'!writeExternalLink: aExternalLink	canvas raw: '[', aExternalLink alias, '](', aExternalLink localFileOrExternalReference, ')'! !!PRMarkdownWriter methodsFor: 'private' stamp: 'YannDubois 5/30/2016 13:35'!writeInternalLink: anInternalLink withRef: href	canvas nextPut: $[.	anInternalLink counter isValidCounter		ifTrue: [ self writeCounter: anInternalLink counter.			anInternalLink hasAlias				ifTrue: [ canvas nextPutAll: ' ' ] ].	anInternalLink hasAlias		ifTrue: [ canvas nextPutAll: anInternalLink alias ].	canvas nextPut: $].	canvas raw: '(' , href , ')'! !"Pillar-ExporterMarkdown"!!PRDeckJSWriter commentStamp: 'CyrilFerlicot 6/8/2015 15:46' prior: 0!I'm a writer generating Deck.js slides from a Pillar document. Deck.js is a javascript framework specialized in slide creation.To generate the internalLinks I use an anchorMapping to know the number of the slide where is the anchor.!!PRAssociateAnchorToSlideNumber commentStamp: 'CyrilFerlicot 6/8/2015 15:41' prior: 0!On Deck.js the anchor doesn't work the same as HTML. At each slide deck.js create an anchor named "slide-X" where X is the number of the slide (we begin at 0). I am a visitor, I will visit a document and return a Dictionary with all the anchors of a document in key and the number of the slide where is the anchor as value.I work with the "slideInTemplateForDeckJS" configuration to know how many slides I have before the document in the template.currentSlide is the number of the current slide.anchorMapping is the dictionary of anchor/counter.!!PRDeckJSWriter class methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/1/2015 16:28'!writerName	^ #deckJS! !!PRDeckJSWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/8/2015 16:07'!addAnchorFrom: anInternalLink To: href	| anchor |	anchor := anchorMapping		at: anInternalLink anchor		ifPresent: [ :num | (num - 1) asString	"We do -1 because the first slide have an anchor with 0 and not 1" ]		ifAbsent: [ 			PRReferenceNotFound signal: 'Can''t find anchor named ''' , anInternalLink anchor , ''''.			'' ].	^ href , '#slide-' , anchor! !!PRDeckJSWriter methodsFor: 'private' stamp: 'DamienCassou 6/23/2015 17:30'!createNewSlideTitle: aTitle	canvas tag		name: 'h2';		with: aTitle.	canvas newLine! !!PRDeckJSWriter methodsFor: 'visiting' stamp: 'CyrilFerlicot 6/8/2015 15:50'!start: aDocument	anchorMapping := PRAssociateAnchorToSlideNumber new		configuration: self configuration;		start: aDocument.	super start: aDocument! !!PRDeckJSWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/8/2015 15:49'!visitAnchor: anAnchor	"I do nothing because the anchors created by the user doesn't work with Deck.js."	! !!PRDeckJSWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/4/2015 14:39'!visitHeader: aHeader	self configuration renderStructureAsSlide		ifTrue: [ 			canvas tag				name: 'div';				parameterAt: 'class' put: 'slide';				with: [ 							canvas newLine.							super visitHeader: aHeader ].			canvas newLine ]! !!PRDeckJSWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/4/2015 14:50'!visitSection: aSection	"Sections should not be render in a Deck.js file because it breack the transitions."	self visitDocumentGroup: aSection! !!PRDeckJSWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/5/2015 17:34'!visitSlide: aSlide	canvas tag		name: 'div';		parameterAt: 'class' put: 'slide';		with: [ 					canvas newLine.					aSlide hasLabel						ifTrue: [ 							self createAnchorWith: aSlide label.							canvas newLine ].					self createNewSlideTitle: aSlide title.					super visitSlide: aSlide ].	canvas newLine! !!PRAssociateAnchorToSlideNumber class methodsFor: 'testing' stamp: 'CyrilFerlicot 6/8/2015 14:29'!isAbstract	^ false! !!PRAssociateAnchorToSlideNumber methodsFor: 'accessing' stamp: 'CyrilFerlicot 10/29/2015 22:00'!configuration	^ configuration ifNil: [ configuration := PRPillarConfiguration new ]! !!PRAssociateAnchorToSlideNumber methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/8/2015 14:35'!configuration: aConfiguration	configuration := aConfiguration! !!PRAssociateAnchorToSlideNumber methodsFor: 'visiting' stamp: 'CyrilFerlicot 6/8/2015 15:31'!start: aDocument	currentSlide := 0 + self configuration slideInTemplateForDeckJS.	anchorMapping := Dictionary new.	super start: aDocument.	^ anchorMapping! !!PRAssociateAnchorToSlideNumber methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/8/2015 14:39'!visitAnchor: anObject	anchorMapping at: anObject name put: currentSlide.	super visitAnchor: anObject! !!PRAssociateAnchorToSlideNumber methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/8/2015 14:41'!visitFigure: anObject	anObject hasLabel		ifTrue: [ anchorMapping at: anObject label put: currentSlide ].	super visitFigure: anObject! !!PRAssociateAnchorToSlideNumber methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/8/2015 14:49'!visitHeader: aHeader	"If we create a slide when we have a header in DeckJS we need to increase the counter."	self configuration renderStructureAsSlide		ifTrue: [ currentSlide := currentSlide + 1 ].	super visitHeader: aHeader! !!PRAssociateAnchorToSlideNumber methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/8/2015 14:40'!visitScript: aScript	aScript hasLabel		ifTrue: [ anchorMapping at: aScript label put: currentSlide ].	super visitScript: aScript! !!PRAssociateAnchorToSlideNumber methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/8/2015 14:54'!visitSlide: aSlide	currentSlide := currentSlide + 1.	aSlide hasLabel		ifTrue: [ anchorMapping at: aSlide label put: currentSlide ].	super visitSlide: aSlide! !"Pillar-ExporterDeckJS"!!PREPubMenuWriter commentStamp: '<historical>' prior: 0!I am an abstract  writer for menus for ePub!!PREPubNavigationMenuWriter commentStamp: 'ThibaultArloing 6/2/2016 11:17' prior: 0!I write a document as a navigation menu for ePub!!PREPubTocMenuWriter commentStamp: 'ThibaultArloing 6/2/2016 11:17' prior: 0!I write a document as a ToC menu for ePub table of content.!!PREPubXHTMLWriter commentStamp: 'ThibaultArloing 6/2/2016 11:17' prior: 0!I write a document as XHTML for ePub!!PREPubMenuJustHeaderTransformer commentStamp: 'ThibaultArloing 6/2/2016 11:08' prior: 0!I am a transformer which Just keep headers with the hierarchy. I am useful for EPub Menus.!!PREPubMenuWriter class methodsFor: 'accessing' stamp: 'ThibaultAroing 5/26/2016 14:37'!fileExtension	^self subclassResponsibility ! !!PREPubMenuWriter class methodsFor: 'testing' stamp: 'ThibaultAroing 5/26/2016 14:37'!isAbstract	^ self = PREPubMenuWriter ! !!PREPubMenuWriter class methodsFor: 'accessing' stamp: 'ThibaultAroing 5/26/2016 14:37'!writerName	^ self subclassResponsibility ! !!PREPubMenuWriter methodsFor: 'private' stamp: 'ThibaultArloing 6/2/2016 16:41'!refFor: aHeader	^ 'chapter.xhtml#',aHeader text asValidSelector ! !!PREPubNavigationMenuWriter class methodsFor: 'accessing' stamp: 'ThibaultAroing 5/26/2016 14:37'!fileExtension	^'nav.xhtml'! !!PREPubNavigationMenuWriter class methodsFor: 'accessing' stamp: 'ThibaultAroing 5/26/2016 14:37'!writerName	^#navmenu! !!PREPubNavigationMenuWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 6/2/2016 11:29'!visitHeader: aHeader	canvas tag		name: 'li';		with: [ canvas tag				name: 'a';				parameterAt: 'href' put: (self refFor: aHeader);				with: [ self visitDocumentGroup: aHeader ] ]! !!PREPubNavigationMenuWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 6/2/2016 13:34'!visitSection: aSection	canvas tag		name: 'ol';		with: [ super visitDocumentGroup: aSection ]! !!PREPubTocMenuWriter class methodsFor: 'accessing' stamp: 'ThibaultAroing 5/26/2016 14:38'!fileExtension	^'toc.ncx'! !!PREPubTocMenuWriter class methodsFor: 'accessing' stamp: 'ThibaultAroing 5/26/2016 14:38'!writerName	^ #tocmenu! !!PREPubTocMenuWriter methodsFor: 'initialization' stamp: 'ThibaultAroing 5/26/2016 14:36'!initialize	counter := 0.	super initialize.! !!PREPubTocMenuWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 6/2/2016 11:32'!visitHeader: aHeader	canvas tag		name: 'navLabel';		with: [ canvas tag				name: 'text';				with: [ self visitDocumentGroup: aHeader ] ].	canvas emptyTag		name: 'content';		parameterAt: 'src' put: (self refFor: aHeader);		closeTag! !!PREPubTocMenuWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 6/2/2016 13:35'!visitSection: aSection			counter := counter + 1.			canvas tag				name: 'navPoint';				parameterAt: 'playOrder' put: counter;				with: [ super visitDocumentGroup: aSection ]! !!PREPubXHTMLWriter class methodsFor: 'accessing' stamp: 'ThibaultAroing 5/26/2016 14:40'!fileExtension	^'xhtml'! !!PREPubXHTMLWriter class methodsFor: 'accessing' stamp: 'ThibaultAroing 5/26/2016 14:40'!writerName	^#xhtml! !!PREPubXHTMLWriter methodsFor: 'visiting-document' stamp: 'ThibaultAroing 5/26/2016 14:40'!visitHeader: aHeader	canvas tag		name: 'div';		parameterAt: 'id' put: aHeader text asValidSelector;		with: [ super visitHeader: aHeader ].	canvas newLine! !!PREPubMenuJustHeaderTransformer class methodsFor: 'accessing' stamp: 'ThibaultArloing 6/2/2016 11:07'!key	^#justKeepHeaders! !!PREPubMenuJustHeaderTransformer class methodsFor: 'accessing' stamp: 'ThibaultArloing 6/2/2016 11:08'!writers	^ #(#tocmenu #navmenu)! !!PREPubMenuJustHeaderTransformer methodsFor: 'actions' stamp: 'AutoDeprecationRefactoring 7/18/2016 14:18'!actionOn: anInput	^ (self class writers		includes: anInput configuration outputType writerName)		ifTrue: [ maxHeader := self maxHeaderOf: anInput input.			super actionOn: anInput ]		ifFalse: [ anInput ]! !!PREPubMenuJustHeaderTransformer methodsFor: 'private' stamp: 'ThibaultArloing 6/2/2016 11:07'!initCurrentsArray	currentsArray := #(nil nil nil nil nil nil nil)! !!PREPubMenuJustHeaderTransformer methodsFor: 'private' stamp: 'ThibaultArloing 6/2/2016 15:07'!manageItem: aDocumentItem	| newSection parent |	^ (aDocumentItem isHeader and: [ aDocumentItem level = maxHeader ])		ifTrue: [ newSection := self cleanSectionsAndOpenNewWith: aDocumentItem.			self initCurrentsArray.			currentsArray at: maxHeader put: newSection ]		ifFalse: [ aDocumentItem isHeader				ifTrue: [ parent := self sectionToLinkWith: aDocumentItem.					newSection := PRSection with: aDocumentItem.					parent add: newSection.					currentsArray at: aDocumentItem level put: newSection ]				ifFalse: [ aDocumentItem isGroup						ifTrue: [ aDocumentItem children do: [ :each | self manageItem: each ] ] ] ]! !!PREPubMenuJustHeaderTransformer methodsFor: 'private' stamp: 'DamienCassou 7/13/2016 16:04'!maxHeaderOf: anObject	^ anObject isHeader		ifTrue: [ anObject level ]		ifFalse: [ anObject isGroup				ifTrue: [ anObject children size > 0						ifTrue: [ (anObject children								collect: [ :child | 									child isHeader										ifTrue: [ child level ]										ifFalse: [ 7 ] ]) min ] ]				ifFalse: [ 7 ] ]! !!PREPubMenuJustHeaderTransformer methodsFor: 'private' stamp: 'ThibaultArloing 6/2/2016 11:07'!sectionToLinkWith: aHeader	| headerLevel |	headerLevel := aHeader level - 1.	[ (currentsArray at: headerLevel) isNil ] whileTrue: [ headerLevel := headerLevel - 1 ].	^ currentsArray at: headerLevel! !"Pillar-ExporterEPub"!!PRCommandLineHandler commentStamp: 'TorstenBergmann 1/17/2015 01:21' prior: 0!I am the top level command line handler for Pillar.My keyword is "pillar".I can not be used by myself, but I dispatch the rest of the command line to my sub command line handlers (see PRSubCommandLineHandler and its subclasses)!!PRSubCommandLineHandler commentStamp: '<historical>' prior: 0!I am the abstract super class of all sub commands for Pillar (export, export-all etc).See subclasses for concrete implementations!!PRArchetypeCommandLineHandler commentStamp: '<historical>' prior: 0!I am a command line handler to download an archetype.I'm using like :./pillar archetype book : this command create a book archetypeFollow https://github.com/ThibaultAr/Pillar-Archetype to known all archetypes!!PRCommandLineHandler class methodsFor: 'accessing' stamp: 'DamienCassou 12/11/2013 15:23'!commandName	^ 'pillar'! !!PRCommandLineHandler class methodsFor: 'as yet unclassified' stamp: 'DamienCassou 12/11/2013 15:40'!isResponsibleFor: aCommandLineArguments	^ aCommandLineArguments includesSubCommand: self commandName! !!PRCommandLineHandler methodsFor: 'private' stamp: 'DamienCassou 12/11/2013 15:36'!subCommandsRoot	^ PRSubCommandLineHandler! !!PRArchetypeCommandLineHandler class methodsFor: 'accessing' stamp: 'YannDubois 6/23/2016 09:29'!commandName	^ 'archetype'! !!PRArchetypeCommandLineHandler methodsFor: 'activation' stamp: 'YannDubois 6/23/2016 10:56'!activate	| archetype tmp |	super activate.	tmp := (self baseDirectory / 'tmp') asFileReference.	tmp ensureCreateDirectory.	archetype := self parseArchetype.	self download: archetype.	(self baseDirectory / (archetype , '.zip')) asFileReference ensureDelete.	tmp ensureDeleteAll.	self exitSuccess! !!PRArchetypeCommandLineHandler methodsFor: 'as yet unclassified' stamp: 'YannDubois 6/23/2016 10:30'!download: aString	| path znClient |	path := 'https://ci.inria.fr/pharo-contribution/job/Pillar-Archetypes/ws/' , aString		, '/*zip*/' , aString , '.zip'.	znClient := ZnClient new path: path.	(znClient downloadTo: self baseDirectory)		ifTrue: [ self unzip: aString ]! !!PRArchetypeCommandLineHandler methodsFor: 'parsing' stamp: 'YannDubois 6/23/2016 09:30'!parseArchetype	self arguments ifEmpty: [ ^ nil ].	^ self arguments last 	! !!PRArchetypeCommandLineHandler methodsFor: 'as yet unclassified' stamp: 'YannDubois 6/23/2016 10:52'!unzip: aString	| archetype |	ZipArchive new		readFrom: self baseDirectory asFileReference / aString, 'zip';		extractAllTo: (self baseDirectory / 'tmp') asFileReference.	archetype := (self baseDirectory asFileReference / 'tmp' / aString).	archetype isDirectory ifTrue: [ archetype copyAllTo: self baseDirectory ]	! !!PRDependenciesCommandLineHandler class methodsFor: 'accessing' stamp: 'YannDubois 4/25/2016 16:38'!isAbstract	^ true.! !!PRDependenciesCommandLineHandler methodsFor: 'activation' stamp: 'YannDubois 4/26/2016 14:48'!activate	super activate.	self printDependencies.	self exitSuccess.! !!PRDependenciesCommandLineHandler methodsFor: 'private' stamp: 'YannDubois 4/28/2016 16:20'!depend	| cache inputFile |	cache := Set new.	inputFile := self baseDirectory resolve: self arguments last.	cache		addAll: (self visitorDependencies start: (PRDocument parser parse: inputFile contents)).	^ cache! !!PRDependenciesCommandLineHandler methodsFor: 'private' stamp: 'YannDubois 4/28/2016 16:20'!printDependencies	| path pathWithoutFile |	path := self arguments last substrings: '/'.	pathWithoutFile := path allButLast		inject: ''		into: [ :substring :next | substring , next , '/' ].	self depend		do: [ :each | 			self stdout				<< './';				<< pathWithoutFile;				<< each;				<< ' ' ].	self stdout flush! !!PRDependenciesCommandLineHandler methodsFor: 'private' stamp: 'YannDubois 4/25/2016 16:40'!visitorDependencies	self subclassResponsibility! !!PRFiledependCommandLineHandler class methodsFor: 'accessing' stamp: 'YannDubois 4/25/2016 16:45'!commandName	^ 'filedepend'! !!PRFiledependCommandLineHandler class methodsFor: 'accessing' stamp: 'YannDubois 4/25/2016 16:46'!isAbstract	^ false! !!PRFiledependCommandLineHandler methodsFor: 'private' stamp: 'YannDubois 4/25/2016 16:40'!visitorDependencies	^ PRFileDependencies new.! !!PRImagedependCommandLineHandler class methodsFor: 'accessing' stamp: 'YannDubois 4/25/2016 16:18'!commandName	^ 'imagedepend'! !!PRImagedependCommandLineHandler class methodsFor: 'accessing' stamp: 'YannDubois 4/25/2016 16:46'!isAbstract	^ false! !!PRImagedependCommandLineHandler methodsFor: 'private' stamp: 'YannDubois 4/25/2016 16:41'!visitorDependencies	^ PRImageDependencies new! !!PRExportCommandLineHandler class methodsFor: 'accessing' stamp: 'DamienCassou 12/11/2013 15:37'!commandName	^ 'export'! !!PRExportCommandLineHandler methodsFor: 'activation' stamp: 'YannDubois 7/27/2016 16:01'!activate	super activate.	self		optionAt: 'to'		ifPresent: [ :subconf | configuration defaultExporters: {subconf} ].	self parseInputFile.	self export.	self exitSuccess! !!PRExportCommandLineHandler methodsFor: 'activation' stamp: 'DamienCassou 6/20/2016 15:35'!export	[ configuration defaultExporters		do: [ :exporter | (configuration getConfigurationNamed: exporter) export ] ]		on: CCConfigurationError , PRNoInputFileError		do: [ :error | self exitFailure: error messageText ]! !!PRExportCommandLineHandler methodsFor: 'activation' stamp: 'DamienCassou 6/22/2016 10:47'!parseInputFile	| inputFile |	self arguments ifEmpty: [ ^ self ].	(self arguments last beginsWith: '--')		ifTrue: [ ^ self ].	inputFile := self baseDirectory resolve: self arguments last.	inputFile exists		ifFalse: [ self exitFailure: '"' , inputFile pathString , '" does not exist' ].	configuration inputFile: inputFile! !!PRExportCommandLineHandler methodsFor: 'activation' stamp: 'CyrilFerlicot 7/30/2015 17:41'!printConfiguration	"self stdout << subconfName.	self stdout lf."	configuration properties keysAndValuesDo: [ :key :value | self stdout << key << ' = ' << value printString; lf ]! !!PRSubCommandLineHandler class methodsFor: 'accessing' stamp: 'CyrilFerlicot 7/30/2015 15:15'!argumentsOutOfConfiguration	^ #('configurationFile' 'to')! !!PRSubCommandLineHandler class methodsFor: 'accessing' stamp: 'CyrilFerlicot 7/30/2015 13:37'!defaultConfigurationFileName	^ 'pillar.conf'! !!PRSubCommandLineHandler methodsFor: 'activation' stamp: 'CyrilFerlicot 7/30/2015 15:11'!activate	| confFilename |	self activateHelp		ifTrue: [ ^ self ].	confFilename := self optionAt: 'configurationFile' ifAbsent: [ self class defaultConfigurationFileName ].	self optionAt: 'baseDirectory' ifPresent: [ :dir | baseDirectory := dir asFileReference ].	self createConfiguration: confFilename! !!PRSubCommandLineHandler methodsFor: 'private' stamp: 'DamienCassou 9/7/2015 15:43'!add: argument to: arguments	"From the ==argument== string =='--key=value'==, add the ==key==/==value== pair to the ==arguments== dictionary."	| key value argumentStream |	argumentStream := argument readStream.	(argumentStream next: '--' size) ~= '--'		ifTrue: [ Error signal: 'Invalid parameter ', argument ].	key := argumentStream upTo: $=.	value := argumentStream upToEnd.	^ arguments at: key put: value! !!PRSubCommandLineHandler methodsFor: 'private' stamp: 'CyrilFerlicot 7/30/2015 15:18'!argumentsForConfigurationExtension	| arguments |	arguments := Dictionary new.	self arguments		do: [ :arg | 			(arg beginsWith: '--')				ifTrue: [ self add: arg to: arguments ] ].	self class argumentsOutOfConfiguration do: [ :each | arguments removeKey: each ifAbsent: [  ] ].	^ arguments! !!PRSubCommandLineHandler methodsFor: 'accessing' stamp: 'CyrilFerlicot 8/30/2015 23:13'!baseDirectory	^ baseDirectory ifNil: [ FileSystem workingDirectory ]! !!PRSubCommandLineHandler methodsFor: 'activation' stamp: 'YannDubois 7/27/2016 15:51'!createConfiguration: confFilename	| confFile |	confFile := self baseDirectory resolve: confFilename.	configuration := confFile exists		ifTrue: [ self readConfigurationFromFile: confFile ]		ifFalse: [ PRPillarConfiguration newFromDictionary: self argumentsForConfigurationExtension ]! !!PRSubCommandLineHandler methodsFor: 'error handling' stamp: 'DamienCassou 12/11/2013 16:34'!error: aString	self stderr << aString; lf.	self exitFailure! !!PRSubCommandLineHandler methodsFor: 'error handling' stamp: 'DamienCassou 1/8/2014 11:13'!errorMissingParameter: aParameterName	self error: 'Missing required parameter --', aParameterName ! !!PRSubCommandLineHandler methodsFor: 'activation' stamp: 'YannDubois 7/27/2016 15:49'!readConfigurationFromFile: confFile	^ [ PRPillarConfiguration newFromFile: confFile extendedWith: self argumentsForConfigurationExtension ]		on: STONReaderError		do: [ :error | self exitFailure: error messageText ]! !"Pillar-Cli"!!PRAsciiDocWriter commentStamp: 'ThibaultArloing 1/29/2016 17:03' prior: 0!Write a Pillar document to an AsciiDoc document!!PRAsciiDocCanvas commentStamp: 'ThibaultArloing 1/29/2016 17:07' prior: 0!An AsciiDoc canvas that facilitates writing AsciiDoc to a stream. The main methods are #surround:with: and #precede:by: that allow you to write something like this:canvas surround:  [ "some code that generates the string inside the bold" ] with: '*'canvas precede: [ "some code that generates the string which will be change by the label" ]  by: '[label]' !!PRAsciiDocWriter class methodsFor: 'accessing' stamp: 'ThibaultArloing 4/21/2016 15:25'!fileExtension	^ 'asciidoc'! !!PRAsciiDocWriter class methodsFor: 'testing' stamp: 'ThibaultArloing 1/29/2016 15:19'!isAbstract	^ false! !!PRAsciiDocWriter class methodsFor: 'accessing' stamp: 'YannDubois 2/12/2016 15:46'!writerName	^ #asciidoc! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'YannDubois 2/28/2016 17:45'!addAnnotatedKeywords: aString to: aKey 	annotatedKeywords at: aKey put: aString! !!PRAsciiDocWriter methodsFor: 'accessing' stamp: 'YannDubois 2/28/2016 17:43'!annotatedKeywords	^ annotatedKeywords ! !!PRAsciiDocWriter methodsFor: 'accessing' stamp: 'ThibaultArloing 1/29/2016 15:21'!canvasClass	^ PRAsciiDocCanvas! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 2/26/2016 14:01'!createAnchorWith: anId	canvas surround: anId with: '[[' and: ']]'! !!PRAsciiDocWriter methodsFor: 'initialization' stamp: 'ThibaultArloing 4/5/2016 16:30'!initAnnotatedKeywords	self addAnnotatedKeywords: 'CAUTION:' to: 'caution';		  addAnnotatedKeywords: 'IMPORTANT:' to: 'important';		  addAnnotatedKeywords: 'IMPORTANT:' to: 'todo';		  addAnnotatedKeywords: 'NOTE:' to: 'note';		  addAnnotatedKeywords: 'NOTE:' to: 'annotation';		  addAnnotatedKeywords: 'NOTE:' to: 'comment';		  addAnnotatedKeywords: 'TIP:' to: 'tip';		  addAnnotatedKeywords: 'TIP:' to: 'tips';		  addAnnotatedKeywords: 'WARNING:' to: 'warning'.! !!PRAsciiDocWriter methodsFor: 'initialization' stamp: 'YannDubois 2/28/2016 18:00'!initialize	super initialize.	annotatedKeywords := Dictionary new.	self initAnnotatedKeywords.! !!PRAsciiDocWriter methodsFor: 'writing-text' stamp: 'ThibaultArloing 4/5/2016 16:23'!link: anUrl named: name	stream 		<< anUrl		<< '[' << name << ']'! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 2/5/2016 15:23'!nest: aString do: aBlock	nesting add: aString.	aBlock ensure: [ nesting removeLast ]! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 4/5/2016 16:35'!searchAnnotation: anAnnotationName	^ annotatedKeywords at: anAnnotationName ifAbsent: [ '' ].! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 4/5/2016 16:46'!searchParam: aString in: aFigure"Search in the figure parameters if the parameter aString is present and return the parameter and its value folowing the scheme param=""value"" "	^		aFigure parameters			at: aString			ifPresent: [ :param |  aString, '="', param greaseString, '"']			ifAbsent: [ '' ]! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 2/5/2016 15:25'!start: anObject	nesting := OrderedCollection new.	super start: anObject.! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 2/26/2016 14:40'!visitAnchor: anAnchor	self createAnchorWith: anAnchor name! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 4/6/2016 09:45'!visitAnnotatedParagraph: anAnnotatedParagraph		|annotation|	annotation := self searchAnnotation: anAnnotatedParagraph annotation.		canvas precede: [ super visitParagraph: anAnnotatedParagraph ] by: (annotation, (annotation isEmpty ifTrue:[''] ifFalse:[' ']) ).	canvas potentialNewLine.  	! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'YannDubois 1/29/2016 21:45'!visitBoldFormat: aFormat	canvas surround: [super visitBoldFormat: aFormat] with: '*'! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 2/5/2016 17:14'!visitDataItem: anObject	self nest: '::' do: [ super visitDataItem: anObject ]! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'YannDubois 2/6/2016 11:15'!visitDefinitionList: anObject	canvas potentialNewLine.	self nest: '' do: [ super visitDefinitionList: anObject ]! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'LukasKomarek 4/21/2016 14:45'!visitExternalLink: anExternalLink	self link: anExternalLink localFileOrExternalReference named: [ stream << anExternalLink text ]! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'LukasKomarek 4/21/2016 14:45'!visitFigure: aFigure		| parameters |	parameters := Set  new.		parameters add: (self searchParam: 'width' in: aFigure);				  add: ('caption="', (self getStringForAll: aFigure children) ,'"').			aFigure label ifNotNil: [ :label | self createAnchorWith: label ].		canvas potentialNewLine;			 surround: (aFigure localFileOrExternalReference) with: 'image::' and: '[',parameters asCommaString ,']'.! !!PRAsciiDocWriter methodsFor: 'visiting-annotations' stamp: 'YannDubois 5/3/2016 17:06'!visitFootnote: aFootnote	canvas precede: ('[', (aFootnote note) , ']') by: 'footnote:'	! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 6/21/2016 11:33'!visitHeader: aHeader	aHeader level timesRepeat: [ canvas raw: '=' ].	canvas space.	super visitHeader: aHeader.	canvas newLine! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 4/5/2016 17:02'!visitHorizontalRule: anHorizontalRule	canvas newLine; newLine;			 raw: '''''''';			 newLine.! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 2/26/2016 15:51'!visitInternalLink: anInternalLink	|alias|	alias := 	anInternalLink hasAlias					ifTrue: [ ',' , anInternalLink alias ]					ifFalse: [ '' ].	anInternalLink hasAnchor 		ifTrue: [ canvas surround: anInternalLink anchor, alias with: '<<' and: '>>']! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 1/29/2016 16:37'!visitItalicFormat: aFormat	canvas surround: [super visitItalicFormat: aFormat] with: ''''! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 2/5/2016 15:57'!visitListItem: anObject	nesting last isInteger ifTrue: [ nesting addLast: nesting removeLast + 1 ].	nesting size - 1 timesRepeat: [ canvas tab ].	canvas nextPutAll: nesting last greaseString.	canvas nextPutAll: (nesting last isInteger 			ifTrue: [ '. ' ]			ifFalse: [ ' ' ]).	super visitListItem: anObject.	canvas potentialNewLine! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 4/5/2016 16:33'!visitMailLink: aMail	self link: aMail unscrambledUrl named: [ stream << aMail text ]! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'YannDubois 1/29/2016 21:46'!visitMonospaceFormat: aFormat	canvas surround: [super visitMonospaceFormat: aFormat] with: '+'! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 2/5/2016 16:05'!visitOrderedList: anObject	canvas newLine.	self nest: '.' do: [ super visitOrderedList: anObject ]! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'YannDubois 3/7/2016 10:46'!visitParagraph: aParagraph	super visitParagraph: aParagraph.		canvas potentialNewLine.	canvas newLine.! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'YannDubois 2/12/2016 15:29'!visitPreformatted: aPreformatted	canvas precede: [ aPreformatted children do: [ :child | self visit: child ] separatedBy: [canvas newLine; raw: ' ' ]] by: ' '! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 4/5/2016 17:07'!visitScript: aScript	|language   params |		aScript hasLabel		ifTrue: [ self createAnchorWith: aScript label ].		params := ''.		language := self languageForScript: aScript.	language isSyntaxHighlightingPossible		ifTrue: [ params := 'source,', language  printString, ','].		stream << '[' << params << 'caption="' << (self getStringForAll: aScript caption children) << '"]'.	canvas newLine.	stream << '----'.	canvas newLine.	stream << [ super visitScript: aScript ].	canvas newLine.	stream << '----'! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'YannDubois 1/29/2016 21:46'!visitStrikethroughFormat: aFormat	canvas precede: [super visitStrikethroughFormat: aFormat] by: '[line-through]'! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'YannDubois 2/12/2016 15:04'!visitSubscriptFormat: aFormat	canvas surround: [super visitSubscriptFormat: aFormat] with: '~'! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'YannDubois 2/12/2016 15:03'!visitSuperscriptFormat: aFormat	canvas surround: [super visitSuperscriptFormat: aFormat] with: '^'! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'YannDubois 2/12/2016 16:31'!visitTable: aTable	canvas surround: [super visitTable: aTable] with: '|==='.	canvas newLine.! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'YannDubois 2/12/2016 16:35'!visitTableCell: aCell	canvas precede: [ super visitTableCell: aCell ] by: '|'.	aCell isHeading 		ifFalse: [canvas newLine].! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'YannDubois 2/12/2016 16:44'!visitTableRow: aRow		canvas potentialNewLine.	canvas newLine.	super visitTableRow: aRow.! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 4/5/2016 17:09'!visitTermItem: anObject	self nest: '' do: [ super visitTermItem: anObject ]! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 2/5/2016 14:11'!visitUnderlineFormat: aFormat		canvas precede: [super visitStrikethroughFormat: aFormat] by: '[underline]'	! !!PRAsciiDocWriter methodsFor: 'visiting-document' stamp: 'YannDubois 2/6/2016 11:17'!visitUnorderedList: anObject	canvas potentialNewLine.	self nest: '*' do: [ super visitUnorderedList: anObject ]! !!PRAsciiDocCanvas methodsFor: 'initialization' stamp: 'ThibaultArloing 2/5/2016 15:50'!initialize	super initialize.	lastIsNewLine := true! !!PRAsciiDocCanvas methodsFor: 'accessing' stamp: 'ThibaultArloing 2/5/2016 15:48'!lastIsNewLine	^lastIsNewLine! !!PRAsciiDocCanvas methodsFor: 'writing text' stamp: 'ThibaultArloing 2/5/2016 15:48'!newLine	super newLine.	lastIsNewLine := true! !!PRAsciiDocCanvas methodsFor: 'writing text' stamp: 'ThibaultArloing 2/5/2016 15:46'!nextPut: aCharacter	super nextPut: aCharacter.	lastIsNewLine := false! !!PRAsciiDocCanvas methodsFor: 'writing text' stamp: 'ThibaultArloing 2/5/2016 15:47'!potentialNewLine	lastIsNewLine 		ifFalse: [ self newLine ]! !!PRAsciiDocCanvas methodsFor: 'writing text' stamp: 'ThibaultArloing 1/29/2016 16:59'!precede: aStringOrABlock by: anotherString	stream << anotherString << aStringOrABlock ! !!PRAsciiDocCanvas methodsFor: 'writing text' stamp: 'ThibaultArloing 2/5/2016 15:49'!raw: aString	super raw: aString.	lastIsNewLine := false! !!PRAsciiDocCanvas methodsFor: 'writing text' stamp: 'ThibaultArloing 2/23/2016 17:12'!surround: aStringOrBlock with: anotherString	self surround: aStringOrBlock with: anotherString and: anotherString ! !!PRAsciiDocCanvas methodsFor: 'writing text' stamp: 'YannDubois 2/12/2016 16:59'!surround: aStringOrBlock with: anotherString and: theLastString	stream << anotherString << aStringOrBlock << theLastString! !!PRAsciiDocCanvas methodsFor: 'stop conditions' stamp: 'ThibaultArloing 2/5/2016 15:50'!tab	self nextPut: Character tab! !"Pillar-ExporterAsciiDoc"!!PRPillarGrammar commentStamp: 'CyrilFerlicot 7/16/2015 15:06' prior: 0!I am a grammar to parse Pillar files with PetitParser.!!PRPillarParser commentStamp: 'CyrilFerlicot 8/12/2015 15:18' prior: 0!I am a parser for a Pillar syntax. I use the PRPillarGrammar and I build a PRDocument.!!ManifestPillarPetitPillar commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PRParseWarning commentStamp: 'CyrilFerlicot 9/9/2015 20:45' prior: 0!I am a warning for the parse of a Pillar file.!!PRPillarParserMain commentStamp: 'DamienCassou 10/15/2015 11:20' prior: 0!I'm responsible for starting the parsing process of a Pillar document. If possible, I will use a compiled version of PRPillarParser. I will also use the STON reader to read potentital metadata at the begining of the stream.!!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 8/19/2015 15:02'!defaultEndMarkups	| markups |	markups := Dictionary new.	markups		at: PRAbstractAnnotation put: '}$';		at: PRRaw put: '}}}';		at: PRScript put: ']]]'.	^ markups! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 9/3/2015 22:32'!defaultMarkupAnnotationSeparator	^ $:! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 8/21/2015 14:22'!defaultMarkupParameter	^ '|'! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 8/21/2015 14:22'!defaultMarkupParameterValue	^ '='! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 9/9/2015 20:15'!defaultMarkupRawType	^ ':'! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'DamienCassou 8/24/2015 17:41'!defaultMarkupReferenceAlias	^ '>'! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 9/9/2015 23:20'!defaultMarkupReferenceAnchor	^ '@'! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 9/10/2015 00:10'!defaultMarkupTableCenter	^ '|'! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 9/10/2015 00:10'!defaultMarkupTableHeader	^ '!!'! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 9/10/2015 00:10'!defaultMarkupTableLeft	^ '{'! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 9/10/2015 00:10'!defaultMarkupTableRight	^ '}'! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 9/9/2015 23:14'!defaultMarkups	^ self textMarkups , self lineMarkups! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 8/19/2015 15:01'!endMarkups	^ EndMarkups! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 8/19/2015 15:01'!endMarkups: anObject	EndMarkups := anObject! !!PRPillarGrammar class methodsFor: 'class initialization' stamp: 'CyrilFerlicot 8/19/2015 15:02'!initialize	Markups := self defaultMarkups.	EndMarkups := self defaultEndMarkups.! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 9/9/2015 23:09'!lineMarkups	| markups |	markups := Dictionary new.	markups		at: PRAnchor put: '@';		at: PRHeader put: '!!';		at: PROrderedList put: '#';		at: PRUnorderedList put: '-';		at: PRDataItem put: ':';		at: PRTermItem put: ';';		at: PRAnnotatedParagraph put: '@@';		at: PRPreformatted put: '= ';		at: PRHorizontalRule put: '_';		at: PRCommentedLine put: '%';		at: PRTableCell put: '|'.	^ markups! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 8/19/2015 14:07'!markups	^ Markups! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 8/19/2015 14:07'!markups: anObject	Markups := anObject! !!PRPillarGrammar class methodsFor: 'parsing' stamp: 'CyrilFerlicot 8/19/2015 11:15'!parse: aStringOrStream	| stream isSton ston doc |	stream := aStringOrStream readStream.	stream atEnd		ifTrue: [ ^ PRDocument new ].	isSton := stream next = ${ and: [ stream peek ~~ ${ ].	stream skip: -1.	ston := isSton		ifTrue: [ (STON reader on: stream) next ]		ifFalse: [ Dictionary new ].	doc := super parse: stream upToEnd.	ston keysAndValuesDo: [ :key :value | doc propertyAt: key put: value ].	^ doc! !!PRPillarGrammar class methodsFor: 'accessing' stamp: 'CyrilFerlicot 9/9/2015 23:23'!textMarkups	| markups |	markups := Dictionary new.	markups		at: PRBoldFormat put: '""';		at: PRItalicFormat put: '''''';		at: PRMonospaceFormat put: '==';		at: PRStrikethroughFormat put: '--';		at: PRSubscriptFormat put: '@@';		at: PRSuperscriptFormat put: '^^';		at: PRUnderlineFormat put: '__';		at: PRFigure put: '+';		at: PRLink put: '*';		at: PRScript put: '[[[';		at: PRRaw put: '{{{';		at: PRAbstractAnnotation put: '${'.	^ markups! !!PRPillarGrammar methodsFor: 'grammar - Anchor' stamp: 'CyrilFerlicot 8/19/2015 15:08'!anchor	^ (Markups at: PRAnchor) asParser , lineEnd negate plus flatten! !!PRPillarGrammar methodsFor: 'grammar - Paragraph' stamp: 'CyrilFerlicot 8/19/2015 14:41'!annotatedParagraph	^ (Markups at: PRAnnotatedParagraph) asParser , ($  asParser / newline) negate star flatten , ($  asParser , oneLineContent) optional! !!PRPillarGrammar methodsFor: 'grammar - Annotation' stamp: 'CyrilFerlicot 9/4/2015 00:05'!annotation	self flag: #todo.	"An annotation should have the possibility to be outside of a paragraph."	^ (Markups at: PRAbstractAnnotation) asParser , annotationTag , annotationParameters optional		, annotationEndMarkup , #blank asParser star! !!PRPillarGrammar methodsFor: 'grammar - Annotation' stamp: 'CyrilFerlicot 8/19/2015 15:07'!annotationEndMarkup	^ (EndMarkups at: PRAbstractAnnotation) asParser! !!PRPillarGrammar methodsFor: 'grammar - Annotation' stamp: 'CyrilFerlicot 9/3/2015 22:33'!annotationMarkupSeparator	^ self class defaultMarkupAnnotationSeparator asParser! !!PRPillarGrammar methodsFor: 'grammar - Annotation' stamp: 'CyrilFerlicot 9/4/2015 00:05'!annotationParameters	^ (annotationMarkupSeparator , parametersUntilEndAnnotation) ==> [ :array | array second ]! !!PRPillarGrammar methodsFor: 'grammar - Annotation' stamp: 'CyrilFerlicot 9/3/2015 23:56'!annotationTag	^ (escapedCharacter / annotationMarkupSeparator / annotationEndMarkup) negate plus! !!PRPillarGrammar methodsFor: 'grammar - Format' stamp: 'DamienCassou 8/24/2015 15:09'!boldFormat	^ self formatFor: boldMarkup! !!PRPillarGrammar methodsFor: 'grammar - Format' stamp: 'CyrilFerlicot 8/19/2015 14:25'!boldMarkup	^ (Markups at: PRBoldFormat) asParser! !!PRPillarGrammar methodsFor: 'grammar - Text' stamp: 'CyrilFerlicot 8/19/2015 14:42'!commentedLine	^ (Markups at: PRCommentedLine) asParser , lineEnd negate star flatten! !!PRPillarGrammar methodsFor: 'grammar - Document' stamp: 'CyrilFerlicot 8/17/2015 17:45'!content	^ oneLineContent , lineBreak optional! !!PRPillarGrammar methodsFor: 'grammar - Document' stamp: 'CyrilFerlicot 8/17/2015 17:45'!contents	^ content plus! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'DamienCassou 10/8/2015 16:30'!dataBasicListItem	^ (dataMarkup trimBlanks, listMarkup not , oneLineContent optional , lineEnd)		==> [ :array | array third ifNil: [ {} ] ]! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/19/2015 15:10'!dataListItem	self flag: #todo.	"This and the overriden method of the parser are REALLY bad. We parse several times the same input, this is bad."	^ dataMarkup and , dataBasicListItem optional , ((commentedLine , newline) ==> [ :array | array first ]) star , dataSubListItem optional! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/19/2015 15:10'!dataMarkup	^ (Markups at: PRDataItem) asParser! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/19/2015 15:11'!dataSubListItem	^ ((dataMarkup , subList) / (commentedLine , newline) flatten) plus! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/17/2015 11:19'!definitionList	^ (termListItem / dataListItem) plus! !!PRPillarGrammar methodsFor: 'grammar - Document' stamp: 'CyrilFerlicot 7/24/2015 15:59'!document	"A document contain everything that can be at the top of a document. It can contain for example some headers, paragraph, tables etc."	^ (elementsAtLineBeginning / paragraph) star! !!PRPillarGrammar methodsFor: 'grammar - Document' stamp: 'DamienCassou 9/24/2015 15:31'!elementWithNewline	^ (header / annotatedParagraph / anchor / commentedLine / horizontalRule , lineEnd) ==> #first! !!PRPillarGrammar methodsFor: 'grammar - Document' stamp: 'DamienCassou 9/24/2015 15:47'!elementsAtLineBeginning	^  elementWithNewline / list / script / table / commentedLine / preformatedText / emptyParagraph! !!PRPillarGrammar methodsFor: 'grammar - Paragraph' stamp: 'CyrilFerlicot 7/22/2015 16:16'!emptyParagraph	^ newline! !!PRPillarGrammar methodsFor: 'grammar - Document' stamp: 'DamienCassou 9/24/2015 15:32'!escapedCharacter	^ ($\ asParser , #any asParser) ==> #second! !!PRPillarGrammar methodsFor: 'grammar - Reference' stamp: 'DamienCassou 10/5/2015 11:15'!figure	^ figureMarkup , figureAlias optional , referenceFigure , parametersFigure optional , figureMarkup! !!PRPillarGrammar methodsFor: 'grammar - Reference' stamp: 'DamienCassou 10/5/2015 11:19'!figureAlias	^ ((escapedCharacter / (figureMarkup / referenceAliasMarkup) negate) star flatten, referenceAliasMarkup) ==> #first! !!PRPillarGrammar methodsFor: 'grammar - Reference' stamp: 'CyrilFerlicot 8/19/2015 15:22'!figureMarkup	^ (Markups at: PRFigure) asParser! !!PRPillarGrammar methodsFor: 'grammar - Reference' stamp: 'DamienCassou 8/24/2015 18:03'!figureReference	^ (figureMarkup / parameterMarkup) negate plus flatten! !!PRPillarGrammar methodsFor: 'grammar - Format' stamp: 'DamienCassou 8/24/2015 15:05'!format	self flag: 'Now a format can be empty (use of star instead of plus in these parsers). Do we really want this ? Some unit tests specify that a format can be empty but we can remove them'.	^ monospaceFormat / boldFormat / italicFormat / underlineFormat / strikethroughFormat / subscriptFormat / superscriptFormat! !!PRPillarGrammar methodsFor: 'from markdown' stamp: 'CyrilFerlicot 9/10/2015 02:35'!formatContent	^ (escapedCharacter / specialFormatMarkups negate) plus! !!PRPillarGrammar methodsFor: 'grammar - Format' stamp: 'CyrilFerlicot 9/10/2015 03:02'!formatFor: aMarkupParser	^ aMarkupParser , (aMarkupParser not , ( otherContent / formatContent)) star , aMarkupParser! !!PRPillarGrammar methodsFor: 'grammar - Header' stamp: 'DamienCassou 10/7/2015 17:30'!header	"A header begin by a certain amount of $!! and contains a text and/or some formatedText"	^ (Markups at: PRHeader) asParser plus , oneLineContent optional trimBlanks! !!PRPillarGrammar methodsFor: 'grammar - HorizontalRule' stamp: 'CyrilFerlicot 8/19/2015 14:43'!horizontalRule	^ (Markups at: PRHorizontalRule) asParser , #blank asParser star! !!PRPillarGrammar methodsFor: 'grammar - Format' stamp: 'DamienCassou 8/24/2015 15:09'!italicFormat	^ self formatFor: italicMarkup! !!PRPillarGrammar methodsFor: 'grammar - Format' stamp: 'CyrilFerlicot 8/19/2015 14:25'!italicMarkup	^ (Markups at: PRItalicFormat) asParser! !!PRPillarGrammar methodsFor: 'grammar - Text' stamp: 'CyrilFerlicot 8/18/2015 14:24'!lineBreak	^ newline , elementsAtLineBeginning not! !!PRPillarGrammar methodsFor: 'grammar - Document' stamp: 'CyrilFerlicot 8/13/2015 11:30'!lineEnd	^ newline / #eof asParser! !!PRPillarGrammar methodsFor: 'grammar - Reference' stamp: 'DamienCassou 10/3/2015 14:08'!link	^ linkMarkup , linkAlias optional , referenceLink , parametersLink optional , linkMarkup! !!PRPillarGrammar methodsFor: 'grammar - Reference' stamp: 'DamienCassou 10/3/2015 18:47'!linkAlias	^ ((escapedCharacter / (linkMarkup / referenceAliasMarkup) negate) star flatten, referenceAliasMarkup) ==> #first! !!PRPillarGrammar methodsFor: 'grammar - Reference' stamp: 'CyrilFerlicot 8/19/2015 15:23'!linkMarkup	^ (Markups at: PRLink) asParser! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/19/2015 12:56'!list	self flag: #todo.	"The list elements should be trim."	^ (unorderedList / orderedList / definitionList) memoized! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/19/2015 15:14'!listMarkup	^ orderedMarkup / unorderedMarkup / termMarkup / dataMarkup! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 7/28/2015 16:11'!lists	^ list plus! !!PRPillarGrammar methodsFor: 'grammar - Format' stamp: 'DamienCassou 8/24/2015 15:10'!monospaceFormat	^ self formatFor: monospaceMarkup! !!PRPillarGrammar methodsFor: 'grammar - Format' stamp: 'CyrilFerlicot 8/19/2015 14:25'!monospaceMarkup	^ (Markups at: PRMonospaceFormat) asParser! !!PRPillarGrammar methodsFor: 'grammar - Document' stamp: 'CyrilFerlicot 7/24/2015 16:14'!newline	^ String crlf asParser / String lf asParser / String cr asParser! !!PRPillarGrammar methodsFor: 'grammar - Document' stamp: 'DamienCassou 10/5/2015 10:33'!oneLineContent	^ (otherContent / text) plus! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'DamienCassou 10/8/2015 16:31'!orderedBasicListItem	^ (orderedMarkup trimBlanks, listMarkup not , oneLineContent optional , lineEnd)		==> [ :array | array third ifNil: [ {} ] ]! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/17/2015 11:15'!orderedList	^ orderedListItem plus! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/19/2015 15:12'!orderedListItem	self flag: #todo.	"This and the overriden method of the parser are REALLY bad. We parse several times the same input, this is bad."	^ orderedMarkup and , orderedBasicListItem optional , ((commentedLine , newline) ==> [ :array | array first ]) star , orderedSubListItem optional! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/19/2015 15:11'!orderedMarkup	^ (Markups at: PROrderedList) asParser! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/19/2015 15:12'!orderedSubListItem	^ ((orderedMarkup , subList) / (commentedLine , newline) flatten) plus! !!PRPillarGrammar methodsFor: 'grammar - Document' stamp: 'DamienCassou 9/24/2015 15:47'!otherContent	^ format / annotation / reference / raw! !!PRPillarGrammar methodsFor: 'grammar - Paragraph' stamp: 'CyrilFerlicot 7/28/2015 11:05'!paragraph	^ contents , lineEnd! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 16:44'!parameterKeyUntilEndAnnotation	^ self parameterKeyUntilParser: annotationEndMarkup! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 16:44'!parameterKeyUntilEndFigure	^ self parameterKeyUntilParser: figureMarkup! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 17:15'!parameterKeyUntilEndLink	^ self parameterKeyUntilParser: linkMarkup! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 16:44'!parameterKeyUntilNewline	^ self parameterKeyUntilParser: newline! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 16:42'!parameterKeyUntilParser: aParser	^ (escapedCharacter / (aParser / parameterMarkup / parameterValueMarkup) negate) star! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 8/21/2015 15:26'!parameterMarkup	^ self class defaultMarkupParameter asParser! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/4/2015 00:05'!parameterUntilEndAnnotation	^ parameterKeyUntilEndAnnotation , parameterValueUntilEndAnnotation optional! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 02:39'!parameterUntilEndFigure	^ parameterKeyUntilEndFigure , parameterValueUntilEndFigure optional! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 17:16'!parameterUntilEndLink	^ parameterKeyUntilEndLink , parameterValueUntilEndLink optional! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/3/2015 04:58'!parameterUntilNewline	^ parameterKeyUntilNewline , parameterValueUntilNewline optional! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'DamienCassou 8/25/2015 06:39'!parameterValue	^ (figureMarkup / parameterMarkup) negate star flatten! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 8/21/2015 15:30'!parameterValueMarkup	^ self class defaultMarkupParameterValue asParser! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 16:50'!parameterValueUntilEndAnnotation	^ self parameterValueUntilParser: annotationEndMarkup! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 16:50'!parameterValueUntilEndFigure	^ self parameterValueUntilParser: figureMarkup! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 17:16'!parameterValueUntilEndLink	^ self parameterValueUntilParser: linkMarkup! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 16:50'!parameterValueUntilNewline	^ self parameterValueUntilParser: newline! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 16:49'!parameterValueUntilParser: aParser	^ (parameterValueMarkup , (escapedCharacter / (aParser / parameterMarkup) negate) star) ==> [ :array | array second ]! !!PRPillarGrammar methodsFor: 'grammar - Reference' stamp: 'CyrilFerlicot 9/9/2015 02:46'!parametersFigure	^ (parameterMarkup , parametersUntilEndFigure) ==> [ :array | array second ]! !!PRPillarGrammar methodsFor: 'grammar - Reference' stamp: 'DamienCassou 10/5/2015 09:57'!parametersLink	^ (parameterMarkup , parametersUntilEndLink) ==> #second! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/3/2015 22:28'!parametersUntilEndAnnotation	^ parameterUntilEndAnnotation , ((parameterMarkup , parameterUntilEndAnnotation) ==> [ :array | array second ]) star! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 02:40'!parametersUntilEndFigure	^ parameterUntilEndFigure		, ((parameterMarkup , parameterUntilEndFigure) ==> [ :array | array second ]) star! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 17:16'!parametersUntilEndLink	^ parameterUntilEndLink		, ((parameterMarkup , parameterUntilEndLink) ==> [ :array | array second ]) star! !!PRPillarGrammar methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/3/2015 05:00'!parametersUntilNewline	^ parameterUntilNewline , ((parameterMarkup , parameterUntilNewline) ==> [ :array | array second ]) star! !!PRPillarGrammar methodsFor: 'grammar - Text' stamp: 'CyrilFerlicot 8/19/2015 14:44'!preformatedLine	^ (Markups at: PRPreformatted) asParser , lineEnd negate star flatten , lineEnd! !!PRPillarGrammar methodsFor: 'grammar - Text' stamp: 'CyrilFerlicot 7/25/2015 13:20'!preformatedText	^ preformatedLine plus! !!PRPillarGrammar methodsFor: 'grammar - Raw' stamp: 'CyrilFerlicot 9/9/2015 20:33'!raw	^ (Markups at: PRRaw) asParser , rawType optional		, rawEndMarkup negate star flatten , rawEndMarkup! !!PRPillarGrammar methodsFor: 'grammar - Raw' stamp: 'CyrilFerlicot 8/19/2015 15:22'!rawEndMarkup	^ (EndMarkups at: PRRaw) asParser! !!PRPillarGrammar methodsFor: 'grammar - Raw' stamp: 'CyrilFerlicot 9/9/2015 20:34'!rawType	^ (rawEndMarkup / rawTypeMarkup) negate plus flatten , rawTypeMarkup ==> [ :array | array first ] ! !!PRPillarGrammar methodsFor: 'grammar - Raw' stamp: 'CyrilFerlicot 9/9/2015 20:15'!rawTypeMarkup	^ self class defaultMarkupRawType asParser! !!PRPillarGrammar methodsFor: 'grammar - Reference' stamp: 'CyrilFerlicot 9/9/2015 17:30'!reference	^ link / figure! !!PRPillarGrammar methodsFor: 'grammar - Reference' stamp: 'CyrilFerlicot 9/9/2015 01:32'!referenceAliasMarkup	^ self class defaultMarkupReferenceAlias asParser! !!PRPillarGrammar methodsFor: 'from markdown' stamp: 'CyrilFerlicot 9/10/2015 02:35'!referenceContent	^ (escapedCharacter / specialReferenceMarkups negate) plus! !!PRPillarGrammar methodsFor: 'grammar - Reference' stamp: 'CyrilFerlicot 9/9/2015 17:06'!referenceFigure	^ self referenceUntil: figureMarkup! !!PRPillarGrammar methodsFor: 'grammar - Reference' stamp: 'CyrilFerlicot 9/9/2015 17:34'!referenceLink	^ self referenceUntil: linkMarkup! !!PRPillarGrammar methodsFor: 'grammar - Reference' stamp: 'CyrilFerlicot 9/9/2015 17:05'!referenceUntil: aParser	^ (escapedCharacter / (aParser / parameterMarkup / newline) negate) plus! !!PRPillarGrammar methodsFor: 'grammar - Script' stamp: 'DamienCassou 10/3/2015 07:07'!script	| endParser |	endParser := newline asParser , (EndMarkups at: PRScript) asParser , space star , lineEnd.	^ (Markups at: PRScript) asParser , scriptParameters , endParser negate plus flatten , endParser! !!PRPillarGrammar methodsFor: 'grammar - Script' stamp: 'CyrilFerlicot 9/3/2015 04:54'!scriptParameters	^ parametersUntilNewline , newline ==> [ :array | array first ]! !!PRPillarGrammar methodsFor: 'from markdown' stamp: 'DamienCassou 8/24/2015 16:30'!space	^ #blank asParser! !!PRPillarGrammar methodsFor: 'from markdown' stamp: 'CyrilFerlicot 9/10/2015 02:41'!specialFormatMarkups	^ boldMarkup  / italicMarkup / monospaceMarkup / strikethroughMarkup / subscriptMarkup / superscriptMarkup / underlineMarkup! !!PRPillarGrammar methodsFor: 'from markdown' stamp: 'CyrilFerlicot 9/10/2015 02:41'!specialReferenceMarkups	^ referenceAliasMarkup / linkMarkup / figureMarkup! !!PRPillarGrammar methodsFor: 'grammar - Document' stamp: 'CyrilFerlicot 7/16/2015 15:25'!start	^ document end! !!PRPillarGrammar methodsFor: 'grammar - Format' stamp: 'DamienCassou 8/24/2015 15:08'!strikethroughFormat	^ self formatFor: strikethroughMarkup! !!PRPillarGrammar methodsFor: 'grammar - Format' stamp: 'CyrilFerlicot 8/19/2015 14:25'!strikethroughMarkup	^ (Markups at: PRStrikethroughFormat) asParser! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 7/28/2015 15:19'!subList	^ (listMarkup plus , oneLineContent optional , lineEnd) flatten! !!PRPillarGrammar methodsFor: 'grammar - Format' stamp: 'DamienCassou 8/24/2015 15:10'!subscriptFormat	^ self formatFor: subscriptMarkup! !!PRPillarGrammar methodsFor: 'grammar - Format' stamp: 'CyrilFerlicot 8/19/2015 14:26'!subscriptMarkup	^ (Markups at: PRSubscriptFormat) asParser! !!PRPillarGrammar methodsFor: 'grammar - Format' stamp: 'DamienCassou 8/24/2015 15:10'!superscriptFormat	^ self formatFor: superscriptMarkup! !!PRPillarGrammar methodsFor: 'grammar - Format' stamp: 'CyrilFerlicot 8/19/2015 14:26'!superscriptMarkup	^ (Markups at: PRSuperscriptFormat) asParser! !!PRPillarGrammar methodsFor: 'grammar - Table' stamp: 'CyrilFerlicot 8/12/2015 17:26'!table	self flag: #todo. "Add the possibility to have comment inside a table. See PRPillarGrammarTest>>testTableWithComment."	^ tableRow plus! !!PRPillarGrammar methodsFor: 'grammar - Table' stamp: 'CyrilFerlicot 7/28/2015 16:54'!tableAlignMarkup	^ tableCenterMarkup / tableLeftMarkup / tableRightMarkup! !!PRPillarGrammar methodsFor: 'grammar - Table' stamp: 'DamienCassou 9/24/2015 07:33'!tableCell	| cellSeparator |	cellSeparator := (Markups at: PRTableCell) asParser.	^ tableMarkups , (escapedCharacter / (cellSeparator / lineEnd) negate) star flatten! !!PRPillarGrammar methodsFor: 'grammar - Table' stamp: 'CyrilFerlicot 9/10/2015 00:11'!tableCenterMarkup	^ self class defaultMarkupTableCenter asParser! !!PRPillarGrammar methodsFor: 'grammar - Table' stamp: 'CyrilFerlicot 9/10/2015 00:11'!tableHeadingMarkup	^ self class defaultMarkupTableHeader asParser! !!PRPillarGrammar methodsFor: 'grammar - Table' stamp: 'CyrilFerlicot 9/10/2015 00:11'!tableLeftMarkup	^ self class defaultMarkupTableLeft asParser! !!PRPillarGrammar methodsFor: 'grammar - Table' stamp: 'CyrilFerlicot 8/19/2015 15:25'!tableMarkups	| optionalParser |	self flag: #todo.	"In the future we will define the alignement before the headind."	optionalParser := (tableAlignMarkup / tableHeadingMarkup) optional.	^ (Markups at: PRTableCell) asParser , optionalParser , optionalParser! !!PRPillarGrammar methodsFor: 'grammar - Table' stamp: 'CyrilFerlicot 9/10/2015 00:11'!tableRightMarkup	^ self class defaultMarkupTableRight asParser! !!PRPillarGrammar methodsFor: 'grammar - Table' stamp: 'CyrilFerlicot 7/28/2015 16:53'!tableRow	^ tableCell plus , lineEnd! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'DamienCassou 10/8/2015 16:31'!termBasicListItem	^ (termMarkup trimBlanks, listMarkup not , oneLineContent optional , lineEnd)		==> [ :array | array third ifNil: [ {} ] ]! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/19/2015 15:13'!termListItem	self flag: #todo.	"This and the overriden method of the parser are REALLY bad. We parse several times the same input, this is bad."	^ termMarkup and , termBasicListItem optional , ((commentedLine , newline) ==> [ :array | array first ]) star , termSubListItem optional! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/19/2015 15:12'!termMarkup	^ (Markups at: PRTermItem) asParser! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/19/2015 15:13'!termSubListItem	^ ((termMarkup , subList) / (commentedLine , newline) flatten) plus! !!PRPillarGrammar methodsFor: 'grammar - Text' stamp: 'DamienCassou 8/24/2015 15:23'!text	"Everything that is a pure text and nothing else (not a format, not a link, ...)"	^  (escapedCharacter / ((newline , elementsAtLineBeginning) / otherContent / lineEnd) negate) plus! !!PRPillarGrammar methodsFor: 'grammar - Format' stamp: 'DamienCassou 8/24/2015 15:10'!underlineFormat	^ self formatFor: underlineMarkup! !!PRPillarGrammar methodsFor: 'grammar - Format' stamp: 'CyrilFerlicot 8/19/2015 14:26'!underlineMarkup	^ (Markups at: PRUnderlineFormat) asParser! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'DamienCassou 10/8/2015 16:31'!unorderedBasicListItem	^ (unorderedMarkup trimBlanks, listMarkup not , oneLineContent optional , lineEnd)		==> [ :array | array third ifNil: [ {} ] ]! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/17/2015 11:17'!unorderedList	^ unorderedListItem plus! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/19/2015 15:14'!unorderedListItem	self flag: #todo.	"This and the overriden method of the parser are REALLY bad. We parse several times the same input, this is bad."	^ unorderedMarkup and , unorderedBasicListItem optional , ((commentedLine , newline) ==> [ :array | array first ]) star , unorderedSubListItem optional! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/19/2015 15:13'!unorderedMarkup	^ (Markups at: PRUnorderedList) asParser! !!PRPillarGrammar methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/19/2015 15:14'!unorderedSubListItem	^ ((unorderedMarkup , subList) / (commentedLine , newline) flatten) plus! !!PRPillarParser methodsFor: 'grammar - Anchor' stamp: 'CyrilFerlicot 7/28/2015 17:35'!anchor	"An anchor is just a line that begin with the character $@ and contains a text that we trim."	^ super anchor ==> [ :array | PRAnchor named: array second ]! !!PRPillarParser methodsFor: 'grammar - Paragraph' stamp: 'CyrilFerlicot 7/28/2015 17:47'!annotatedParagraph	^ super annotatedParagraph		==> [ :array | PRAnnotatedParagraph withAll: (array third ifNil: [ {} ] ifNotNil: [ :elem | elem second ]) annotation: array second ]! !!PRPillarParser methodsFor: 'grammar - Annotation' stamp: 'YannDubois 5/2/2016 14:02'!annotation	^ super annotation		==>			[ :array | array second parameters: (array third ifNil: [ SmallDictionary new ]) ]! !!PRPillarParser methodsFor: 'grammar - Annotation' stamp: 'CyrilFerlicot 9/9/2015 21:19'!annotationParameters	^ super annotationParameters ==> [ :array | self parametersFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Annotation' stamp: 'CyrilFerlicot 9/3/2015 23:54'!annotationTag	^ super annotationTag		==> [ :array | PRAbstractAnnotation findClassAcceptingTag: (self stringFrom: array) ]! !!PRPillarParser methodsFor: 'grammar - Format' stamp: 'DamienCassou 8/24/2015 16:49'!boldFormat	^ super boldFormat ==> [ :array | self formatForArray: array ]! !!PRPillarParser methodsFor: 'grammar - Format' stamp: 'CyrilFerlicot 8/17/2015 13:45'!boldMarkup	^ super boldMarkup ==> [ :token | PRBoldFormat ]! !!PRPillarParser methodsFor: 'grammar - Text' stamp: 'CyrilFerlicot 7/28/2015 14:58'!commentedLine	^ super commentedLine ==> [ :array | PRCommentedLine content: array second ]! !!PRPillarParser methodsFor: 'grammar - Document' stamp: 'CyrilFerlicot 7/28/2015 14:10'!content	^ super content ==> [ :array | array second ifNil: [ {array first} ] ifNotNil: [ array ] ]! !!PRPillarParser methodsFor: 'grammar - Document' stamp: 'CyrilFerlicot 7/28/2015 15:04'!contents	^ super contents		==> [ :array | 			| result |			result := OrderedCollection new.			array				do: [ :each | 					result addAll: each first.					each size = 2						ifTrue: [ result add: each second ] ].			result ]! !!PRPillarParser methodsFor: 'grammar - List' stamp: 'DamienCassou 10/14/2015 17:33'!dataListItem	^ super dataListItem		==>			[ :array | 			| item |			item := array first withAll: (array second ifNil: [ {} ]).			item addAll: array third.			array fourth isNotNil				ifTrue:					[ item addAll: (self listsParser parse: array fourth) ].			item ]! !!PRPillarParser methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/19/2015 15:16'!dataMarkup	^ super dataMarkup ==> [ :token | PRDataItem ]! !!PRPillarParser methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/17/2015 11:45'!dataSubListItem	^ super dataSubListItem		==>			[ :array | 			| result |			result := '' writeStream.			array				do: [ :elem | 					elem isString						ifTrue: [ result nextPutAll: elem ]						ifFalse: [ result nextPutAll: elem second ] ].			result contents ]! !!PRPillarParser methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 7/28/2015 16:20'!definitionList	^ super definitionList ==> [ :array | PRDefinitionList withAll: array ]! !!PRPillarParser methodsFor: 'grammar - Document' stamp: 'CyrilFerlicot 7/28/2015 11:15'!document	"I build a PRDocument. I get a collection with all the children of the PRDocument and I dd them one by one."	^ super document ==> [ :array | PRDocument withAll: array ]! !!PRPillarParser methodsFor: 'grammar - Paragraph' stamp: 'CyrilFerlicot 7/28/2015 13:46'!emptyParagraph	^ super emptyParagraph ==> [ :array | PREmptyParagraph new ]! !!PRPillarParser methodsFor: 'grammar - Reference' stamp: 'YannDubois 5/2/2016 14:02'!figure	^ super figure		==>			[ :array | 			| fig |			fig := PRFigure reference: array third.			fig addAll: (array second ifNil: [ {} ]).			fig parameters: (array fourth ifNil: [ SmallDictionary new ]).			fig ]! !!PRPillarParser methodsFor: 'grammar - Reference' stamp: 'DamienCassou 10/5/2015 11:15'!figureAlias	^ super figureAlias		==>			[ :string | 			string				ifEmpty: [ {(PRText content: '')} ]				ifNotEmpty: [ self parse: string startingAt: #oneLineContent ] ]! !!PRPillarParser methodsFor: 'from markdown' stamp: 'CyrilFerlicot 9/9/2015 18:58'!formatContent	^ super formatContent ==> [ :array | PRText content: (self stringFrom: array) ]! !!PRPillarParser methodsFor: 'grammar - Format' stamp: 'CyrilFerlicot 9/9/2015 18:48'!formatForArray: array	^ array first withAll: (array second collect: [ :each | each second ])! !!PRPillarParser methodsFor: 'grammar - Header' stamp: 'CyrilFerlicot 7/28/2015 14:30'!header	"I create a PRHeader"	^ super header ==> [ :array | PRHeader withAll: (array second ifNil: [ {} ]) level: array first size ]! !!PRPillarParser methodsFor: 'grammar - HorizontalRule' stamp: 'CyrilFerlicot 7/28/2015 15:00'!horizontalRule	^ super horizontalRule ==> [ :array | PRHorizontalRule new ]! !!PRPillarParser methodsFor: 'grammar - Format' stamp: 'DamienCassou 8/24/2015 16:50'!italicFormat	^ super italicFormat ==> [ :array | self formatForArray: array ]! !!PRPillarParser methodsFor: 'grammar - Format' stamp: 'CyrilFerlicot 8/17/2015 13:45'!italicMarkup	^ super italicMarkup ==> [ :token | PRItalicFormat ]! !!PRPillarParser methodsFor: 'grammar - Document' stamp: 'CyrilFerlicot 7/28/2015 17:45'!lineBreak	^ super lineBreak ==> [ :array | PRLineBreak new ]! !!PRPillarParser methodsFor: 'grammar - Reference' stamp: 'YannDubois 5/2/2016 14:01'!link	^ super link		==>			[ :array | 			| linkRes |			linkRes := PRLink fromReference: array third.			array second ifNotNil: [ :aliasChildren | linkRes addAll: aliasChildren ].			linkRes parameters: (array fourth ifNil: [ SmallDictionary new ]).			linkRes ]! !!PRPillarParser methodsFor: 'grammar - Reference' stamp: 'DamienCassou 10/5/2015 10:52'!linkAlias	^ super linkAlias		==>			[ :string | 			string				ifEmpty: [ {(PRText content: '')} ]				ifNotEmpty: [ self parse: string startingAt: #oneLineContent ] ]! !!PRPillarParser methodsFor: 'helpers' stamp: 'DamienCassou 10/15/2015 15:54'!listsParser	"We cache the lists parser to be faster"	"Attention: we refer to PRPillarParser explicitely here instead of using ==self== so that the PRPillarCompiled parser, if it exists, can work."	^ PRPillarParser newStartingAt: #lists! !!PRPillarParser methodsFor: 'grammar - Format' stamp: 'DamienCassou 8/24/2015 16:56'!monospaceFormat	^ super monospaceFormat ==> [ :array | self formatForArray: array ]! !!PRPillarParser methodsFor: 'grammar - Format' stamp: 'CyrilFerlicot 8/17/2015 13:45'!monospaceMarkup	^ super monospaceMarkup ==> [ :token | PRMonospaceFormat ]! !!PRPillarParser methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 7/28/2015 16:19'!orderedList	^ super orderedList ==> [ :array | PROrderedList withAll: array ]! !!PRPillarParser methodsFor: 'grammar - List' stamp: 'DamienCassou 10/14/2015 17:33'!orderedListItem	^ super orderedListItem		==>			[ :array | 			| item |			item := PRListItem withAll: (array second ifNil: [ {} ]).			item addAll: array third.			array fourth isNotNil				ifTrue:					[ item addAll: (self listsParser parse: array fourth) ].			item ]! !!PRPillarParser methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/17/2015 11:46'!orderedSubListItem	^ super orderedSubListItem		==>			[ :array | 			| result |			result := '' writeStream.			array				do: [ :elem | 					elem isString						ifTrue: [ result nextPutAll: elem ]						ifFalse: [ result nextPutAll: elem second ] ].			result contents ]! !!PRPillarParser methodsFor: 'grammar - Paragraph' stamp: 'CyrilFerlicot 7/28/2015 11:38'!paragraph	^ super paragraph ==> [ :array | PRParagraph withAll: array first]! !!PRPillarParser methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/3/2015 22:55'!parameterKeyUntilEndAnnotation	^ super parameterKeyUntilEndAnnotation ==> [ :array | self stringFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 02:41'!parameterKeyUntilEndFigure	^ super parameterKeyUntilEndFigure ==> [ :array | self stringFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 17:17'!parameterKeyUntilEndLink	^ super parameterKeyUntilEndLink ==> [ :array | self stringFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/3/2015 05:02'!parameterKeyUntilNewline	^ super parameterKeyUntilNewline ==> [ :array | self stringFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/3/2015 22:55'!parameterValueUntilEndAnnotation	^ super parameterValueUntilEndAnnotation ==> [ :array | self stringFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 02:42'!parameterValueUntilEndFigure	^ super parameterValueUntilEndFigure ==> [ :array | self stringFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/9/2015 17:17'!parameterValueUntilEndLink	^ super parameterValueUntilEndLink ==> [ :array | self stringFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Parameter' stamp: 'CyrilFerlicot 9/3/2015 05:10'!parameterValueUntilNewline	^ super parameterValueUntilNewline ==> [ :array | self stringFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Reference' stamp: 'CyrilFerlicot 9/9/2015 21:19'!parametersFigure	^ super parametersFigure ==> [ :array | self parametersFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Paragraph' stamp: 'YannDubois 5/2/2016 14:01'!parametersFrom: array	| result |	result := SmallDictionary new.	array first first		ifNotEmpty:			[ :string | 			result at: string put: array first second.			array second				do:					[ :each | each first ifNotEmpty: [ result at: each first put: each second ] ] ].	^ result! !!PRPillarParser methodsFor: 'grammar - Reference' stamp: 'CyrilFerlicot 9/9/2015 21:19'!parametersLink	^ super parametersLink ==> [ :array | self parametersFrom: array ]! !!PRPillarParser methodsFor: 'helpers' stamp: 'DamienCassou 10/6/2015 06:10'!parse: anObject startingAt: aRule	^ (self class newStartingAt: aRule) parse: anObject! !!PRPillarParser methodsFor: 'grammar - Text' stamp: 'CyrilFerlicot 7/28/2015 14:50'!preformatedLine	^ super preformatedLine ==> [ :array | PRText content: array second ]! !!PRPillarParser methodsFor: 'grammar - Text' stamp: 'CyrilFerlicot 7/28/2015 14:50'!preformatedText	^ super preformatedText ==> [ :array | PRPreformatted withAll: array ]! !!PRPillarParser methodsFor: 'grammar - Raw' stamp: 'YannDubois 5/24/2016 11:04'!raw	^ super raw		==>			[ :array | 			| type contentRaw |			contentRaw := '' writeStream.			contentRaw nextPutAll: array third.			PRRaw content: contentRaw contents type: array second ]! !!PRPillarParser methodsFor: 'from markdown' stamp: 'CyrilFerlicot 9/10/2015 02:36'!referenceContent	^ super referenceContent ==> [ :array | PRText content: (self stringFrom: array) ]! !!PRPillarParser methodsFor: 'grammar - Reference' stamp: 'CyrilFerlicot 9/9/2015 02:00'!referenceFigure	self flag: #todo. "We should maybe check for a :// inside the reference and maybe an extension."	^ super referenceFigure ==> [ :array | self stringFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Reference' stamp: 'CyrilFerlicot 9/9/2015 17:45'!referenceLink	^ super referenceLink ==> [ :array | self stringFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Script' stamp: 'CyrilFerlicot 9/3/2015 01:59'!script	"I create a PRScript."	^ super script ==> [ :array | PRScript content: array third parameters: array second ]! !!PRPillarParser methodsFor: 'grammar - Script' stamp: 'CyrilFerlicot 9/9/2015 21:19'!scriptParameters	^ super scriptParameters ==> [ :array | self parametersFrom: array ]! !!PRPillarParser methodsFor: 'grammar - Format' stamp: 'DamienCassou 8/24/2015 16:56'!strikethroughFormat	^ super strikethroughFormat ==> [ :array | self formatForArray: array ]! !!PRPillarParser methodsFor: 'grammar - Format' stamp: 'CyrilFerlicot 8/17/2015 13:46'!strikethroughMarkup	^ super strikethroughMarkup ==> [ :token | PRStrikethroughFormat ]! !!PRPillarParser methodsFor: 'helpers' stamp: 'CyrilFerlicot 9/3/2015 05:02'!stringFrom: characterArray	^ String streamContents: [ :stream | characterArray do: [ :character | stream nextPut: character ] ]! !!PRPillarParser methodsFor: 'grammar - Format' stamp: 'DamienCassou 8/24/2015 16:56'!subscriptFormat	^ super subscriptFormat ==> [ :array | self formatForArray: array ]! !!PRPillarParser methodsFor: 'grammar - Format' stamp: 'CyrilFerlicot 8/17/2015 13:46'!subscriptMarkup	^ super subscriptMarkup ==> [ :token | PRSubscriptFormat ]! !!PRPillarParser methodsFor: 'grammar - Format' stamp: 'DamienCassou 8/24/2015 16:56'!superscriptFormat	^ super superscriptFormat ==> [ :array | self formatForArray: array ]! !!PRPillarParser methodsFor: 'grammar - Format' stamp: 'CyrilFerlicot 8/17/2015 13:46'!superscriptMarkup	^ super superscriptMarkup ==> [ :token | PRSuperscriptFormat ]! !!PRPillarParser methodsFor: 'grammar - Table' stamp: 'CyrilFerlicot 7/28/2015 16:55'!table	^ super table ==> [ :array | PRTable withAll: array ]! !!PRPillarParser methodsFor: 'grammar - Table' stamp: 'DamienCassou 10/5/2015 10:52'!tableCell	^ super tableCell		==>			[ :array | 			PRTableCell				align: array first first				heading: array first second				withAll:					(array second trim						ifEmpty: [ Array new ]						ifNotEmpty:							[ :string | self parse: string startingAt: #oneLineContent ]) ]! !!PRPillarParser methodsFor: 'grammar - Table' stamp: 'CyrilFerlicot 7/28/2015 16:55'!tableCenterMarkup	^ super tableCenterMarkup ==> [ :token | #center ]! !!PRPillarParser methodsFor: 'grammar - Table' stamp: 'CyrilFerlicot 7/28/2015 16:55'!tableHeadingMarkup	^ super tableHeadingMarkup ==> [ :token | true ]! !!PRPillarParser methodsFor: 'grammar - Table' stamp: 'CyrilFerlicot 7/28/2015 16:55'!tableLeftMarkup	^ super tableLeftMarkup ==> [ :token | #left ]! !!PRPillarParser methodsFor: 'grammar - Table' stamp: 'CyrilFerlicot 7/28/2015 16:55'!tableMarkups	^ super tableMarkups		==> [ :array | 			| result |			result := Array ofSize: 2.			result at: 2 put: (array second = true or: [ array third = true ]).			result				at: 1				put:					(array second isSymbol						ifTrue: [ array second ]						ifFalse: [ 							array third isSymbol								ifTrue: [ array third ] ]).			result ]! !!PRPillarParser methodsFor: 'grammar - Table' stamp: 'CyrilFerlicot 7/28/2015 16:56'!tableRightMarkup	^ super tableRightMarkup ==> [ :token | #right ]! !!PRPillarParser methodsFor: 'grammar - Table' stamp: 'CyrilFerlicot 7/28/2015 16:56'!tableRow	^ super tableRow		==> [ :array | 			| result |			result := PRTableRow new.			array first do: [ :cell | result add: cell ].			result ]! !!PRPillarParser methodsFor: 'grammar - List' stamp: 'DamienCassou 10/14/2015 17:34'!termListItem	^ super termListItem		==>			[ :array | 			| item |			item := array first withAll: (array second ifNil: [ {} ]).			item addAll: array third.			array fourth isNotNil				ifTrue:					[ item addAll: (self listsParser parse: array fourth) ].			item ]! !!PRPillarParser methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/19/2015 15:18'!termMarkup	^ super termMarkup ==> [ :token | PRTermItem ]! !!PRPillarParser methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/17/2015 11:45'!termSubListItem	^ super termSubListItem		==>			[ :array | 			| result |			result := '' writeStream.			array				do: [ :elem | 					elem isString						ifTrue: [ result nextPutAll: elem ]						ifFalse: [ result nextPutAll: elem second ] ].			result contents ]! !!PRPillarParser methodsFor: 'grammar - Text' stamp: 'CyrilFerlicot 7/28/2015 11:32'!text	"A text is a PRText with a string that contains any character inside."	^ super text		==> [ :array | 			| stream |			stream := '' writeStream.			array do: [ :letter | stream nextPut: letter ].			PRText content: stream contents ]! !!PRPillarParser methodsFor: 'grammar - Format' stamp: 'DamienCassou 8/24/2015 16:56'!underlineFormat	^ super underlineFormat ==> [ :array | self formatForArray: array ]! !!PRPillarParser methodsFor: 'grammar - Format' stamp: 'CyrilFerlicot 8/17/2015 13:47'!underlineMarkup	^ super underlineMarkup ==> [ :token | PRUnderlineFormat ]! !!PRPillarParser methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 7/28/2015 16:20'!unorderedList	^ super unorderedList ==> [ :array | PRUnorderedList withAll: array ]! !!PRPillarParser methodsFor: 'grammar - List' stamp: 'DamienCassou 10/14/2015 17:32'!unorderedListItem	^ super unorderedListItem		==>			[ :array | 			| item |			item := PRListItem withAll: (array second ifNil: [ {} ]).			item addAll: array third.			array fourth isNotNil				ifTrue:					[ item addAll: (self listsParser parse: array fourth) ].			item ]! !!PRPillarParser methodsFor: 'grammar - List' stamp: 'CyrilFerlicot 8/17/2015 11:45'!unorderedSubListItem	^ super unorderedSubListItem		==>			[ :array | 			| result |			result := '' writeStream.			array				do: [ :elem | 					elem isString						ifTrue: [ result nextPutAll: elem ]						ifFalse: [ result nextPutAll: elem second ] ].			result contents ]! !!PRDocumentItem class methodsFor: '*pillar-petitpillar' stamp: 'DamienCassou 10/15/2015 11:35'!parser	^ PRPillarParserMain! !!PRPillarParserMain class methodsFor: 'compiled parser' stamp: 'DamienCassou 10/15/2015 14:36'!beCompiled	UseCompiledParser := true! !!PRPillarParserMain class methodsFor: 'compiled parser' stamp: 'DamienCassou 10/15/2015 14:37'!beNonCompiled	UseCompiledParser := false! !!PRPillarParserMain class methodsFor: 'compiled parser' stamp: 'DamienCassou 10/15/2015 14:31'!compileParser	PRPillarParser new compileWithOptions: {#parserName: . self compiledParserName asSymbol}.	^ Smalltalk classNamed: self compiledParserName	! !!PRPillarParserMain class methodsFor: 'compiled parser' stamp: 'DamienCassou 10/15/2015 14:28'!compiledParser	^ (Smalltalk hasClassNamed: self compiledParserName)		ifTrue: [ Smalltalk classNamed: self compiledParserName ]		ifFalse: [ self compileParser ]! !!PRPillarParserMain class methodsFor: 'compiled parser' stamp: 'DamienCassou 10/15/2015 14:28'!compiledParserName	^ 'PRPillarCompiled'! !!PRPillarParserMain class methodsFor: 'accessing' stamp: 'DamienCassou 10/15/2015 15:42'!documentParser	^ (self useCompiled and: [ Smalltalk hasClassNamed: 'PPCompiledParser' ])		ifTrue: [ self compiledParser ]		ifFalse: [ PRPillarParser ]! !!PRPillarParserMain class methodsFor: 'parsing' stamp: 'DamienCassou 10/15/2015 11:24'!parse: aStringOrStream	| stream ston doc |	stream := aStringOrStream readStream.	stream atEnd		ifTrue: [ ^ PRDocument new ].	ston := self parseProperties: stream.	doc := self parseDocument: stream upToEnd.	ston		keysAndValuesDo: [ :key :value | doc propertyAt: key put: value ].	^ doc! !!PRPillarParserMain class methodsFor: 'parsing' stamp: 'DamienCassou 10/15/2015 11:31'!parse: aString startingAt: aSymbol	^ self documentParser parse: aString startingAt: aSymbol! !!PRPillarParserMain class methodsFor: 'parsing' stamp: 'DamienCassou 10/15/2015 11:32'!parseDocument: stream	^ self documentParser parse: stream! !!PRPillarParserMain class methodsFor: 'parsing' stamp: 'DamienCassou 10/15/2015 11:22'!parseProperties: stream	| ston isSton |	isSton := stream next = ${ and: [ stream peek ~~ ${ ].	stream skip: -1.	ston := isSton		ifTrue: [ (STON reader on: stream) next ]		ifFalse: [ Dictionary new ].	^ ston! !!PRPillarParserMain class methodsFor: 'compiled parser' stamp: 'DamienCassou 10/15/2015 14:40'!useCompiled	^ UseCompiledParser ifNil: [ self beCompiled. UseCompiledParser ]! !"Pillar-PetitPillar"!!PRPrepareForGitBookCommandLineHandler class methodsFor: 'accessing' stamp: 'DamienCassou 6/6/2014 15:32'!commandName	^ 'prepareForGitBook'! !!PRPrepareForGitBookCommandLineHandler methodsFor: 'activation' stamp: 'DamienCassou 6/6/2014 16:26'!activate	super activate.	self		optionAt: 'from'		ifPresent: [ :subconf | configuration := configuration subConfigurationNamed: subconf ]		ifAbsent: [ self errorMissingParameter: 'from' ].	self generateSummary.	self exitSuccess! !!PRPrepareForGitBookCommandLineHandler methodsFor: 'activation' stamp: 'DamienCassou 6/22/2016 10:42'!generateSummary	(baseDirectory / 'SUMMARY.md') asFileReference		writeStreamDo: [ :stream | 			stream << '# Summary' << String lf << String lf.			stream << 'Abstract (to be done)' << String lf << String lf.			self flag: #todo. "This cannot work anymore because inputFiles has been replaced by inputFile."			configuration inputFiles				do: [ :inputFile | 					| document title |					document := configuration parseFile: inputFile.					title := document title.					stream << '* [' << title << ']('.					(inputFile , PRMarkdownWriter fileExtension relativeTo: baseDirectory) printOn: stream delimiter: $/.					stream << ')' << String lf ] ]! !"Pillar-GitBook"!!PRMagritteAnnotationWriter commentStamp: 'CyrilFerlicot 6/30/2015 17:49' prior: 0!I am a magritte visitor use by the Pillar exporter to write the parameters as string.!!PRPillarWriter commentStamp: 'StephaneDucasse 6/28/2016 21:06' prior: 0!I'm  a visitor of Pillar object entities that generates pillar file back. I collaborate with a PillarCanvas (which encodes the low level formatting). I start with start: anPillarEntity.Now I also propose some utilities to escape markup elements. !!PRPillarCanvas commentStamp: 'TorstenBergmann 3/5/2015 22:20' prior: 0!A pillar canvasInstance Variables	lastIsNewLine:		<Object>lastIsNewLine	- xxxxx!!PRMagritteAnnotationWriter class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 6/30/2015 17:57'!write: anAnnotation	^ self new write: anAnnotation! !!PRMagritteAnnotationWriter class methodsFor: 'instance creation' stamp: 'CyrilFerlicot 6/30/2015 18:17'!write: anAnnotation on: aStream	^ self new		stream: aStream;		write: anAnnotation! !!PRMagritteAnnotationWriter methodsFor: 'initialization' stamp: 'CyrilFerlicot 6/30/2015 18:16'!initialize	stream := '' writeStream! !!PRMagritteAnnotationWriter methodsFor: 'instance creation' stamp: 'CyrilFerlicot 8/7/2015 14:07'!sortedDescriptionsFor: anAnnotation	"I return the sorted descriptions of an Annotation in order to keep the right order for the parameters. If one day the Pillar exporter become a normalizer and not an exact exporter just return ==anAnnotation magritteDescription children=="	| sortedDescriptions descriptions |	descriptions := anAnnotation magritteDescription children.	sortedDescriptions := OrderedCollection new.	anAnnotation parameters keysDo: [ :key | sortedDescriptions addAll: (descriptions select: [ :description | description accessor readSelector = key ]) ].	^ sortedDescriptions! !!PRMagritteAnnotationWriter methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/30/2015 18:16'!stream: anObject	stream := anObject! !!PRMagritteAnnotationWriter methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 9/9/2015 22:51'!tryToAddFrom: aDescription withInterpretation: aBlock	"I take a Description, check if an object of the dictionary match with the description, if I find one, I interpret it and add it to the new dictionary."	| accessor |	accessor := aDescription accessor selector.	annotation parameters		at: accessor		ifPresent:			[ :value | 			aDescription validate: value.			(annotation hadAllKeys				or:					[ (annotation class defaultParameterName = accessor) not ])				ifTrue:					[ 					stream						nextPutAll: accessor;						nextPutAll: PRPillarParser defaultMarkupParameterValue ].			stream nextPutAll: (aBlock value: value).			annotation parameters removeKey: accessor.			annotation hasParameters				ifTrue:					[ stream nextPutAll: PRPillarParser defaultMarkupParameter ] ]! !!PRMagritteAnnotationWriter methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 7/1/2015 09:54'!visitBooleanDescription: aDescription	self tryToAddFrom: aDescription withInterpretation: [ :value | value asString ]! !!PRMagritteAnnotationWriter methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 6/30/2015 17:57'!visitElementDescription: aDescription	self tryToAddFrom: aDescription withInterpretation: [ :value | value ]! !!PRMagritteAnnotationWriter methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 7/1/2015 09:57'!visitFileDescription: aDescription	self tryToAddFrom: aDescription withInterpretation: [ :value | (value relativeTo: FileSystem workingDirectory) printWithDelimiter: $/ ]! !!PRMagritteAnnotationWriter methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 7/1/2015 09:54'!visitNumberDescription: aDescription	self tryToAddFrom: aDescription withInterpretation: [ :value | value asString ]! !!PRMagritteAnnotationWriter methodsFor: 'visiting-description' stamp: 'CyrilFerlicot 7/1/2015 10:00'!visitPathDescription: aDescription	self tryToAddFrom: aDescription withInterpretation: [ :value | value printWithDelimiter: $/ ]! !!PRMagritteAnnotationWriter methodsFor: 'instance creation' stamp: 'CyrilFerlicot 9/9/2015 22:59'!write: anAnnotation	| descriptions |	annotation := anAnnotation.	stream		nextPutAll: (PRPillarParser markups at: PRAbstractAnnotation);		nextPutAll: anAnnotation class tag.	anAnnotation hasParameters		ifTrue:			[ stream nextPut: PRPillarParser defaultMarkupAnnotationSeparator ].	descriptions := self sortedDescriptionsFor: anAnnotation.	self visitAll: descriptions.	stream		nextPutAll: (PRPillarParser endMarkups at: PRAbstractAnnotation).	^ stream contents! !!PRPillarWriter class methodsFor: 'private' stamp: 'CyrilFerlicot 9/10/2015 00:15'!escapeMarkup: markup	^ String streamContents: [ :str | markup do: [ :each | str nextPut: $\; nextPut: each ] ]! !!PRPillarWriter class methodsFor: 'accessing' stamp: 'DamienCassou 2/20/2014 09:54'!fileExtension	^ 'pillar'! !!PRPillarWriter class methodsFor: 'accessing' stamp: 'DamienCassou 2/20/2014 09:23'!writerName	^ #pillar! !!PRPillarWriter methodsFor: 'accessing' stamp: 'DamienCassou 2/20/2014 09:14'!canvasClass	^ PRPillarCanvas! !!PRPillarWriter methodsFor: 'private' stamp: 'DamienCassou 9/24/2015 09:31'!escape: aString	^ self escape: aString all: markupsToEscape! !!PRPillarWriter methodsFor: 'private' stamp: 'CyrilFerlicot 9/9/2015 23:33'!escape: aString all: anArray	^ anArray		inject: (self escape: aString using: '\')		into: [ :result :each | self escape: result using: each ]! !!PRPillarWriter methodsFor: 'private' stamp: 'DamienCassou 9/24/2015 09:39'!escape: aString during: aBlock	"Protect ==aString== (additionally to already existing protected strings) by adding $\ while evaluating ==aBlock==."	^ (markupsToEscape includes: aString)		ifTrue: aBlock		ifFalse: [ 			markupsToEscape add: aString.			aBlock ensure: [ markupsToEscape remove: aString ] ]! !!PRPillarWriter methodsFor: 'private' stamp: 'CyrilFerlicot 9/9/2015 23:33'!escape: aString using: aSearchString	| string index escapedMarkup |	string := aString.	escapedMarkup := self escapeMarkup: aSearchString.	index := string findString: aSearchString.	[ index > 0 ] whileTrue: [		string := (string first: index - 1) , escapedMarkup , (string allButFirst: index - 1 + aSearchString size).		index := string findString: aSearchString startingAt: index + escapedMarkup size].	^ string! !!PRPillarWriter methodsFor: 'private' stamp: 'CyrilFerlicot 9/10/2015 00:15'!escapeMarkup: markup	^ self class escapeMarkup: markup! !!PRPillarWriter methodsFor: 'initialize-release' stamp: 'DamienCassou 9/24/2015 09:40'!initialize	super initialize.	markupsToEscape := PRPillarParser textMarkups values asSet! !!PRPillarWriter methodsFor: 'accessing' stamp: 'StephaneDucasse 6/28/2016 21:04'!markupEndFor: aPRObject	"Return the ending character for a given Pillar entity. Given a script (environment) returns ']]]'"	^ PRPillarGrammar endMarkups at: aPRObject class! !!PRPillarWriter methodsFor: 'accessing' stamp: 'StephaneDucasse 6/28/2016 21:03'!markupFor: aPRObject	"Return the markup for a given pillar object. For example, given a pillar PRAnchor returns '@'"	^ PRPillarGrammar markups at: aPRObject class! !!PRPillarWriter methodsFor: 'private' stamp: 'DamienCassou 2/20/2014 09:29'!nest: aString do: aBlock	nesting add: aString.	aBlock ensure: [ nesting removeLast ]! !!PRPillarWriter methodsFor: 'visiting' stamp: 'DamienCassou 2/27/2014 11:32'!start: anObject	nesting := OrderedCollection new.	super start: anObject.	canvas lastIsNewLine		ifTrue: [ stream trimLastNewLine ]! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 9/9/2015 22:13'!visitAnchor: anObject	canvas		raw: (self markupFor: anObject);		nextPutAll: anObject name;		newLine! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 9/9/2015 22:13'!visitAnnotatedParagraph: anObject	canvas 		raw: (self markupFor: anObject);		nextPutAll: anObject annotation.	anObject hasChildren 		ifTrue: [ canvas space ].	super visitAnnotatedParagraph: anObject! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 8/7/2015 14:45'!visitAnnotation: anAnnotation	canvas raw: (PRMagritteAnnotationWriter write: anAnnotation)! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 9/9/2015 22:14'!visitCommentedLine: aCommentedLine	canvas potentialNewLine.	canvas raw: (self markupFor: aCommentedLine).	canvas raw: aCommentedLine text.! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 9/9/2015 23:40'!visitDefinitionList: anObject	canvas potentialNewLine.	anObject children do: [ :each |		self 			nest: (self markupFor: each)			do: [ self visit: each ] ]! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'GuillermoPolito 6/9/2015 15:05'!visitDocument: aDocument	| propertiesSton |	aDocument properties ifNotEmpty: [		propertiesSton := String new: 100 streamContents: [ :internalStream |		(STON writer on: internalStream) nextPut: aDocument properties ].		canvas raw: propertiesSton.		canvas newLine ].	super visitDocument: aDocument! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 9/9/2015 23:45'!visitFigure: aFigure	canvas raw: (self markupFor: aFigure).	super visitFigure: aFigure.	canvas raw: (self markupFor: aFigure)! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 9/9/2015 23:36'!visitFormat: anObject	canvas raw: (self markupFor: anObject).	super visitFormat: anObject.	canvas raw: (self markupFor: anObject)! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 6/21/2016 11:36'!visitHeader: aHeader	aHeader level timesRepeat: [ canvas raw: (self markupFor: aHeader) ].	super visitHeader: aHeader.	canvas newLine! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 9/9/2015 23:46'!visitHorizontalRule: anHorizontalRule	canvas		raw: (self markupFor: anHorizontalRule);		newLine! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 9/9/2015 23:17'!visitLink: aLink	canvas raw: (PRPillarParser markups at: PRLink).	super visitLink: aLink.	canvas raw: (PRPillarParser markups at: PRLink)! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 9/9/2015 23:39'!visitList: aList	canvas potentialNewLine.	self nest: (self markupFor: aList) do: [ super visitList: aList ]! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/20/2014 14:12'!visitListItem: aListItem	nesting do: [ :each | canvas raw: each ].	super visitListItem: aListItem.	canvas potentialNewLine.! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 3/20/2014 18:37'!visitParagraph: aParagraph	super visitParagraph: aParagraph.	canvas newLine! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/29/2016 18:16'!visitParametersOf: objectWithParams	| needSeparator |	self flag: 'TODO: fix this ugly code. Caption here are treated separately because they contain Pillar text in a string (and this string should not be protected)'.	needSeparator := false.	objectWithParams parameters associations		do:			[ :assoc | 			assoc key = 'caption'				ifFalse:					[ needSeparator := true.					canvas nextPutAll: assoc key.					assoc value						ifNotNil:							[ :value | 							canvas								raw: PRPillarParser defaultMarkupParameterValue;								nextPutAll: value greaseString ] ] ]		separatedBy: [ canvas raw: PRPillarParser defaultMarkupParameter ].	objectWithParams parameters at: 'caption'		ifPresent:			[ :caption | needSeparator				ifTrue: [ canvas raw: PRPillarParser defaultMarkupParameter ].			canvas				nextPutAll: 'caption';				raw: PRPillarParser defaultMarkupParameterValue.				stream << [ self visitAll: objectWithParams caption children ] ]! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 9/9/2015 22:16'!visitPreformatted: aPreformatted	self		writeRawDuring: [ 			aPreformatted children				do: [ :child | 					canvas raw: (self markupFor: aPreformatted).					self visit: child.					canvas newLine ] ]! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 9/10/2015 00:14'!visitRaw: anObject	canvas raw: (self markupFor: anObject).	anObject type isNil		ifFalse: [ canvas nextPutAll: anObject type; raw: PRPillarParser defaultMarkupRawType ].	canvas raw: anObject text.	canvas raw: (self markupEndFor: anObject)! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 9/9/2015 23:42'!visitReference: aReference	aReference hasAlias		ifTrue:			[ 			super visitReference: aReference.			canvas raw: PRPillarParser defaultMarkupReferenceAlias ].	canvas		raw:			(aReference reference isNil				ifTrue: [ '' ]				ifFalse: [ aReference reference ]).	aReference hasAnchor		ifTrue:			[ 			canvas raw: PRPillarParser defaultMarkupReferenceAnchor.			canvas nextPutAll: aReference anchor ].	aReference hasParameters		ifTrue:			[ 			canvas raw: PRPillarParser defaultMarkupParameter.			self visitParametersOf: aReference ]! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 9/10/2015 00:05'!visitScript: aScript	canvas raw: (self markupFor: aScript).	self visitParametersOf: aScript.	canvas		newLine;		nextPutAllLines: aScript text;		newLine;		raw: (self markupEndFor: aScript)! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 9/24/2015 09:34'!visitTableCell: anObject	| cellMarkup |	cellMarkup := self markupFor: anObject.	canvas raw: cellMarkup.	anObject isAligned ifTrue: [		anObject isAlignedLeft ifTrue: [ canvas raw: PRPillarParser defaultMarkupTableLeft ].		anObject isAlignedCenter ifTrue: [ canvas raw: PRPillarParser defaultMarkupTableCenter ].		anObject isAlignedRight ifTrue: [ canvas raw: PRPillarParser defaultMarkupTableRight ] ].	anObject isHeading ifTrue: [ canvas raw: PRPillarParser defaultMarkupTableHeader ].	self escape: cellMarkup during: [	super visitTableCell: anObject ]! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/20/2014 13:37'!visitTableRow: aTableRow	super visitTableRow: aTableRow.	canvas newLine! !!PRPillarWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 9/9/2015 23:34'!visitText: anObject	"Write out ==anObject=='s text to the receivers output-stream and escape special characters within and at the beginning of a line."	| string |	string := anObject text.	writingRaw		ifTrue: [ 			canvas rawLines: string.			^ self ].	canvas lastIsNewLine		ifTrue:			[ 			| markup |			markup := PRPillarParser lineMarkups values detect: [ :each | string beginsWithSubCollection: each ] ifNone: [ nil ].			markup isNil				ifFalse: [ 					canvas						nextPut: $\;						raw: markup.					string := string allButFirst: markup size ] ].	canvas raw: (self escape: string)! !!PRPillarCanvas class methodsFor: 'class initialization' stamp: 'CyrilFerlicot 9/10/2015 00:41'!initialize	" self initialize "	PillarCharacters := Dictionary new.	PRPillarGrammar markups		valuesDo:			[ :markup | 			markup				do:					[ :char | 					char = Character space						ifFalse: [ PillarCharacters at: char put: '\' , char asString ] ] ]! !!PRPillarCanvas methodsFor: 'initialization' stamp: 'DamienCassou 2/20/2014 11:14'!initialize	super initialize.	lastIsNewLine := true! !!PRPillarCanvas methodsFor: 'writing text' stamp: 'DamienCassou 2/20/2014 13:16'!lastIsNewLine	^ lastIsNewLine! !!PRPillarCanvas methodsFor: 'writing text' stamp: 'DamienCassou 2/20/2014 13:35'!newLine	super newLine.	lastIsNewLine := true! !!PRPillarCanvas methodsFor: 'writing text' stamp: 'StephaneDucasse 6/28/2016 21:02'!nextPut: aCharacter	(PillarCharacters at: aCharacter ifAbsent: nil) 		ifNil: [ super nextPut: aCharacter ] 		ifNotNil: [ :string | self raw: string ].	lastIsNewLine := false! !!PRPillarCanvas methodsFor: 'writing text' stamp: 'DamienCassou 2/20/2014 13:35'!potentialNewLine	lastIsNewLine		ifFalse: [ self newLine ]! !!PRPillarCanvas methodsFor: 'writing text' stamp: 'DamienCassou 2/20/2014 14:12'!raw: aString	super raw: aString.	lastIsNewLine := false.! !"Pillar-ExporterPillar"!!ManifestPillarExporterLaTeX commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PRLaTeXWriter commentStamp: 'TorstenBergmann 3/5/2015 22:17' prior: 0!A LaTeX writer!!PRSBALaTeXWriter commentStamp: 'DamienCassou 2/29/2016 11:27' prior: 0!Writes LaTeX code in the style expected by sbabook (https://github.com/cdlm/sbabook). sbabook is a special LaTeX book class for our technical books.!!PRLaTeXCanvas commentStamp: 'TorstenBergmann 3/5/2015 22:17' prior: 0!A LaTeX canvas!!PRLaTeXBrush commentStamp: 'TorstenBergmann 3/5/2015 22:18' prior: 0!A LaTeX brush!!PRLaTeXCommand commentStamp: 'TorstenBergmann 3/5/2015 22:18' prior: 0!A LaTeX command!!PRLaTeXEnvironment commentStamp: 'TorstenBergmann 3/5/2015 22:18' prior: 0!A LaTeX environmentInstance Variables	name:		<Object>name	- xxxxx!!PRAbstractScriptLanguage methodsFor: '*Pillar-ExporterLaTeX' stamp: 'DamienCassou 2/29/2016 16:17'!sbaString	^ self printString! !!PRTableCell methodsFor: '*Pillar-ExporterLaTeX' stamp: 'DamienCassou 11/20/2013 16:56'!latexAlignment	self isAlignedCenter ifTrue: [ ^ 'c' ].	self isAlignedRight ifTrue: [ ^ 'r' ].	^ 'l'! !!PRUnspecifiedScriptLanguage methodsFor: '*Pillar-ExporterLaTeX' stamp: 'DamienCassou 2/29/2016 16:09'!sbaString	^ 'plain'! !!ManifestPillarExporterLaTeX class methodsFor: 'code-critics' stamp: 'DamienCassou 9/24/2015 11:14'!ruleRBSendsDifferentSuperRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#PRLaTeXWriter #visitAnnotatedParagraph: #false)) #'2015-09-24T11:14:45.010115+02:00') )! !!PRNoScriptLanguage methodsFor: '*Pillar-ExporterLaTeX' stamp: 'DamienCassou 3/1/2016 17:12'!sbaString	^ 'plain'! !!PRLaTeXWriter class methodsFor: 'accessing' stamp: 'DamienCassou 12/9/2013 11:03'!fileExtension	^ 'tex'! !!PRLaTeXWriter class methodsFor: 'accessing' stamp: 'DamienCassou 12/11/2013 17:21'!writerName	^ #latex! !!PRLaTeXWriter methodsFor: 'accessing' stamp: 'DamienCassou 10/14/2013 16:34'!canvasClass	^ PRLaTeXCanvas! !!PRLaTeXWriter methodsFor: 'helpers' stamp: 'CyrilFerlicot 7/1/2015 16:38'!createLinkToLabelWithAlias: anInternalLink	canvas command		name: 'hyperref';		optParameter: [ canvas nextPutAll: anInternalLink anchor ];		parameter: [ 					anInternalLink counter isValidCounter						ifTrue: [ self writeCounter: anInternalLink counter ].					canvas nextPutAll: anInternalLink alias ]! !!PRLaTeXWriter methodsFor: 'helpers' stamp: 'CyrilFerlicot 6/1/2015 14:41'!createLinkToLabelWithoutAlias: anInternalLink	canvas command		name: 'ref';		parameter: [ canvas raw: anInternalLink anchor ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 6/21/2016 11:30'!getLevelFor: aHeader	^ aHeader level! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 5/28/2015 17:53'!getTypeOfSectionFor: aHeader	| sections level section |	sections := self sectioningCommands.	level := self getLevelFor: aHeader.	section := sections at: (level min: sections size max: 1).	^ section! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'LukasKomarek 4/21/2016 14:45'!includeGraphicsFor: aFigure	canvas command		name: 'includegraphics';		optParameter: [ self writeGraphicsParametersOfExternalLink: aFigure ];		parameter: [ canvas raw: (aFigure localFileOrExternalReference) ]! !!PRLaTeXWriter methodsFor: 'protected' stamp: 'DamienCassou 3/2/2016 13:59'!monospaceMacro	^ 'code'! !!PRLaTeXWriter methodsFor: 'helpers' stamp: 'DamienCassou 3/17/2016 11:07'!protectUrl: aString	^ ((aString copyReplaceAll: '\' with: '\\') copyReplaceAll: '#' with: '\#') copyReplaceAll: '%' with: '\%'! !!PRLaTeXWriter methodsFor: 'helpers' stamp: 'DamienCassou 4/2/2015 11:04'!sectioningCommands	^ #('part' 'chapter' 'section' 'subsection' 'subsubsection' 'paragraph' 'subparagraph')! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:34'!visitAnchor: anAnchor	canvas command		name: 'label';		parameter: anAnchor name! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 9/24/2015 11:19'!visitAnnotatedParagraph: anAnnotatedParagraph	"Annotations need to be defined as environments in LaTeX include files (e.g. common.tex)"	canvas environment		name: anAnnotatedParagraph annotation;		with: [ super visitParagraph: anAnnotatedParagraph.			canvas newLine ]	"Attention: we do a super call on #visitParagraph: instead of #visitAnnotatedParagraph:. The goal of this hack is to avoid trailing new line characters. This is related to PRLaTeXWriterTest>>#testStrictLineBreaksInAnnotatedParagraphs"! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:34'!visitBoldFormat: aFormat	canvas command name: 'textbf'; parameter: [ super visitBoldFormat: aFormat ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'ThibaultArloing 5/3/2016 15:43'!visitCitation: aCitation	canvas command		name: 'cite';		parameter: aCitation ref.! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:34'!visitDataItem: anItem	super visitAll: anItem children.	canvas newLine.! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:34'!visitDefinitionList: aList	canvas environment		name: 'description';		with: [ super visitDefinitionList: aList ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 12/9/2013 13:03'!visitEmptyParagraph: aParagraph	! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'LukasKomarek 4/21/2016 14:45'!visitExternalLink: anExternalLink	| text reference |	reference := anExternalLink localFileOrExternalReference.	text := anExternalLink text.	(text isEmptyOrNil or: [ reference = text ])		ifTrue: [ canvas command				name: 'url';				parameter: reference ]		ifFalse: [			canvas command				name: 'href';				parameter: reference;				parameter: [ canvas nextPutAll: text ].			canvas command				name: 'footnote';				parameter: [ canvas command name: 'url'; parameter: (self protectUrl: reference) ] ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 9/6/2015 07:40'!visitFigure: aFigure	(aFigure hasCaption not and: [ aFigure hasLabel not ])		ifTrue: [ 			self includeGraphicsFor: aFigure.			^ self ].	canvas environment		name: 'figure';		with:				[ 			canvas environment				name: 'center';				with:						[ 					self includeGraphicsFor: aFigure.					canvas command						name: 'caption';						parameter: [ 							self								writeCaptionOfExternalLink: aFigure;								writeLabelOfExternalLink: aFigure ] ] ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'YannDubois 5/3/2016 15:06'!visitFootnote: aFootnote	canvas command name: 'footnote'; parameter: (aFootnote note)! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 5/28/2015 17:52'!visitHeader: aHeader	| section |	section := self getTypeOfSectionFor: aHeader.	canvas command		name: section;		parameter: [ super visitHeader: aHeader ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'BenjaminVanRyseghem 11/20/2013 00:54'!visitHorizontalRule: anHorizontalRule	canvas newLine; newLine.	canvas raw: '\rule{\textwidth}{0.1pt}'.	canvas newLine.! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/1/2015 14:41'!visitInternalLink: anInternalLink	(anInternalLink reference isNil or: [ self configuration separateOutputFiles not ])		ifTrue: [ 			anInternalLink hasAlias				ifTrue: [ 					anInternalLink hasAnchor						ifTrue: [ self createLinkToLabelWithAlias: anInternalLink ]						ifFalse: [ 							PRLinkWarning								signal:									(PRPillarWriter write: anInternalLink)										,											' will not be render because you export without separate output files. If you want your link to be render add an anchor to the beginning of your file.'.							canvas nextPutAll: anInternalLink alias ] ]				ifFalse: [ 					anInternalLink hasAnchor						ifTrue: [ self createLinkToLabelWithoutAlias: anInternalLink ] ] ]		ifFalse: [ 			anInternalLink hasAlias				ifTrue: [ 					self flag: #todo.	"If we don't render the link we can put it as Footer. We need to do it."					canvas nextPutAll: anInternalLink alias ]				ifFalse: [ 					PRLinkWarning						signal:							(PRPillarWriter write: anInternalLink)								,									' will not be exported because LaTeX doesn''t support the inter-files links. Please add an Alias to keep this internal link.' ] ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:34'!visitItalicFormat: aFormat	canvas command name: 'textit'; parameter: [ super visitItalicFormat: aFormat ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienPollet 2/18/2014 15:51'!visitListItem: anItem	canvas command name: 'item'.	canvas space.	canvas raw: [ super visitListItem: anItem ].	canvas newLine! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 4/26/2014 18:17'!visitMailLink: aLink	canvas command		name: 'href';		parameter: aLink unscrambledUrl;		parameter: aLink alias! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 3/2/2016 13:59'!visitMonospaceFormat: aFormat	canvas command		name: self monospaceMacro;		parameter: [ super visitMonospaceFormat: aFormat ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:34'!visitOrderedList: aList	canvas environment		name: 'enumerate';		with: [ super visitOrderedList: aList ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 12/9/2013 13:02'!visitParagraph: aParagraph	canvas newLine.	super visitParagraph: aParagraph.	canvas newLine.! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 1/30/2015 10:05'!visitPreformatted: aPreformatted	canvas environment		name: 'verbatim';		with: [ 					self						writeRawDuring: [ 							aPreformatted children								do: [ :child | 									self visit: child.									canvas newLine ] ] ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/29/2016 17:31'!visitScript: aScript	| env parameters |	parameters := OrderedCollection new.	aScript hasCaption		ifTrue: [ parameters add: 'caption={' , (self getStringForAll: aScript caption children), '}' ].	aScript hasLabel		ifTrue: [ parameters add: 'label=' , aScript label ].	(self languageForScript: aScript) isSyntaxHighlightingPossible		ifTrue:			[ parameters add: 'language=' , (self languageForScript: aScript) printString ].	env := canvas environment		name: 'listing';		yourself.	parameters ifNotEmpty: [ env optParameter: parameters asCommaString ].	env		with: [ self writeRawDuring: [ super visitScript: aScript ].			canvas newLine ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:34'!visitStrikethroughFormat: aFormat	canvas command name: 'sout'; parameter: [ super visitStrikethroughFormat: aFormat ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 3/22/2014 15:31'!visitSubscriptFormat: aFormat	canvas command		name: 'textsubscript';		parameter: [ super visitSubscriptFormat: aFormat ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 3/22/2014 15:31'!visitSuperscriptFormat: aFormat	canvas command		name: 'textsuperscript';		parameter: [ super visitSuperscriptFormat: aFormat ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 6/3/2014 10:03'!visitTable: aTable	| environment |	environment := canvas environment name: 'tabular'.	aTable rowCount = 0		ifTrue: [ 			environment with: [  ].			^ self ].	environment parameter: aTable latexSpecification.	environment		with: [ 			canvas command name: 'toprule'.			canvas newLine.			super visitTable: aTable.			canvas command name: 'bottomrule'.			canvas newLine ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 11/20/2013 16:58'!visitTableCell: aCell	aCell isAligned		ifFalse: [ self writeTableCellContent: aCell ]		ifTrue: [ 			canvas command				name: 'multicolumn';				parameter: '1';				parameter: aCell latexAlignment;				parameter: [ self writeTableCellContent: aCell ] ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 6/3/2014 10:23'!visitTableRow: aRow	self visitAll: aRow children separatedBy: [ canvas raw: ' & ' ].	canvas		raw: ' \\';		newLine.	aRow isHeading		ifTrue: [ 			canvas command name: 'midrule'.			canvas newLine ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:34'!visitTermItem: anItem	canvas command		name: 'item';		optParameter: [ self visitAll: anItem children ].	canvas space.! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:34'!visitUnderlineFormat: aFormat	canvas command		name: 'uline';		parameter: [ super visitUnderlineFormat: aFormat ]! !!PRLaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 10/14/2013 16:34'!visitUnorderedList: aList	canvas environment		name: 'itemize';		with: [ super visitUnorderedList: aList ]! !!PRLaTeXWriter methodsFor: 'helpers' stamp: 'DamienCassou 9/24/2015 13:32'!writeCaptionOfExternalLink: anExternalLink	self visitAll: anExternalLink children! !!PRLaTeXWriter methodsFor: 'helpers' stamp: 'CyrilFerlicot 4/13/2015 23:12'!writeGraphicsParametersOfExternalLink: anExternalLink	canvas		nextPutAll: 'width=';		nextPutAll: ((anExternalLink parameters at: 'width' ifAbsent: [ 100 ]) asNumber / 100.0) printString;		raw: '\textwidth'! !!PRLaTeXWriter methodsFor: 'helpers' stamp: 'LukasKomarek 4/21/2016 14:45'!writeLabelOfExternalLink: anExternalLink	| label |	label := anExternalLink parameters at: 'label' ifAbsent: [ anExternalLink localFileOrExternalReference ].	canvas command		name: 'label';		parameter: [ canvas raw: label ]! !!PRLaTeXWriter methodsFor: 'helpers' stamp: 'DamienCassou 11/20/2013 16:58'!writeTableCellContent: aCell	^ aCell isHeading		ifTrue: [ 			canvas command				name: 'textbf';				parameter: [ super visitTableCell: aCell ] ]		ifFalse: [ super visitTableCell: aCell ]! !!PRSBALaTeXWriter class methodsFor: 'accessing' stamp: 'DamienCassou 3/1/2016 10:06'!writerName	^ #latex:sbabook! !!PRSBALaTeXWriter methodsFor: 'protected' stamp: 'DamienCassou 3/2/2016 14:00'!monospaceMacro	^ 'textcode'! !!PRSBALaTeXWriter methodsFor: 'protected' stamp: 'DamienCassou 2/29/2016 16:42'!optionalParametersForFloatingScript: aScript 	| parameters |	parameters := OrderedCollection new.	parameters add: 'float'.	aScript hasLabel ifTrue: [ parameters add: 'label=', aScript label ].	aScript hasShortCaption ifTrue: [ parameters add: 'list text={', aScript shortCaption, '}' ].	^ parameters asCommaString! !!PRSBALaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/29/2016 16:59'!visitFloatingScript: aScript 	canvas environment		name: 'listing';		optParameter: (self optionalParametersForFloatingScript: aScript);		parameter: (self languageForScript: aScript) sbaString;		parameter: [ self visitAll: aScript caption children ];		with: [			self writeRawDuring: [ self visitText: aScript ].			canvas newLine ]! !!PRSBALaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/29/2016 16:50'!visitInFlowScript: aScript 	canvas environment		name: 'displaycode';		parameter: (self languageForScript: aScript) sbaString;		with: [			self writeRawDuring: [ self visitText: aScript ].			canvas newLine ]! !!PRSBALaTeXWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 2/29/2016 15:58'!visitScript: aScript	aScript hasCaption | aScript hasLabel		ifTrue: [ self visitFloatingScript: aScript ]		ifFalse: [ self visitInFlowScript: aScript ]! !!PRLaTeXCanvas class methodsFor: 'class initialization' stamp: 'DamienPollet 9/23/2015 23:12'!initialize	" self initialize "	LatexCharacters := Dictionary new.	LatexCharacters		at: $# put: '\#';		at: $& put: '\&';		at: $% put: '\%';		at: $$ put: '\$';		at: ${ put: '\{';		at: $} put: '\}';		at: $_ put: '\_';		at: $" put: '\symbol{34}';		" -- "		at: $[ put: '{[}';		at: $] put: '{]}';		at: $| put: '\textbar{}';		at: $< put: '\textless{}';		at: $> put: '\textgreater{}';		"at: $/ put: '\slash{}';"		at: $\ put: '\textbackslash{}';		at: $^ put: '\string^';		" -- "		at: $ put: '\"{a}';		at: $ put: '\"{A}';		at: $ put: '\"{e}';		at: $ put: '\"{E}';		at: $ put: '\"{i}';		at: $ put: '\"{I}';		at: $ put: '\"{o}';		at: $ put: '\"{O}';		at: $ put: '\"{u}';		at: $ put: '\"{U}';		at: $ put: '\"{y}';		at: (Character value: 159) put: '\"{Y}';		" -- "		at: $ put: '\^{a}';		at: $ put: '\^{A}';		at: $ put: '\^{e}';		at: $ put: '\^{E}';		at: $ put: '\^{i}';		at: $ put: '\^{I}';		at: $ put: '\^{o}';		at: $ put: '\^{O}';		at: $ put: '\^{u}';		at: $ put: '\^{U}';		" -- "		at: $ put: '\`{a}';		at: $ put: '\`{A}';		at: $ put: '\`{e}';		at: $ put: '\`{E}';		at: $ put: '\`{i}';		at: $ put: '\`{I}';		at: $ put: '\`{o}';		at: $ put: '\`{O}';		at: $ put: '\`{u}';		at: $ put: '\`{U}';		" -- "		at: $ put: '\''{a}';		at: $ put: '\''{A}';		at: $ put: '\''{e}';		at: $ put: '\''{i}';		at: $ put: '\''{I}';		at: $ put: '\''{o}';		at: $ put: '\''{O}';		at: $ put: '\''{u}';		at: $ put: '\''{U}';		" -- "		at: $ put: '\c{c}';		at: $ put: '\c{C}';		" -- "		at: $~ put: '\textasciitilde{}';		at: $ put: '\~{n}';		at: $ put: '\~{N}'! !!PRLaTeXCanvas methodsFor: 'tags' stamp: 'DamienCassou 10/8/2013 13:02'!command	^ self brush: PRLaTeXCommand new! !!PRLaTeXCanvas methodsFor: 'tags' stamp: 'DamienCassou 10/8/2013 13:53'!environment	^ self brush: PRLaTeXEnvironment new! !!PRLaTeXCanvas methodsFor: 'writing text' stamp: 'CyrilFerlicot 7/2/2015 13:46'!nextPut: aCharacter	| string |	string := LatexCharacters at: aCharacter ifAbsent: nil.	string isNil		ifTrue: [ super nextPut: aCharacter ]		ifFalse: [ self raw: string ]! !!PRLaTeXBrush methodsFor: 'accessing' stamp: 'DamienCassou 11/18/2013 17:35'!optParameter: aString 	stream		<< $[		<< aString		<< $]! !!PRLaTeXBrush methodsFor: 'accessing' stamp: 'DamienCassou 11/18/2013 17:35'!parameter: aString 	stream		<< ${		<< aString		<< $}! !!PRLaTeXCommand methodsFor: 'accessing' stamp: 'DamienCassou 10/7/2013 10:55'!name: aString 	stream		<< $\		<< aString! !!PRLaTeXEnvironment methodsFor: 'accessing' stamp: 'DamienCassou 6/3/2014 11:12'!name: aString	name := aString.	stream newLine.	stream << '\begin{' << aString << '}'! !!PRLaTeXEnvironment methodsFor: 'accessing' stamp: 'DamienCassou 11/18/2013 17:37'!with: aBlock	stream newLine.	aBlock value.	(stream << '\end{' << name)		<< '}';		newLine! !!PRTable methodsFor: '*Pillar-ExporterLaTeX' stamp: 'DamienCassou 11/20/2013 16:32'!latexSpecification	^ String new: self columnCount withAll: $l! !"Pillar-ExporterLaTeX"!!PRBeamerWriter commentStamp: 'DamienCassou 4/2/2015 14:38' prior: 0!I'm a writer generating Beamer slides from a Pillar document. Beamer is a LaTeX package specialized in slide creation.!!PRBeamerWriter class methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 6/1/2015 13:32'!codeSmalltalk	^ '% Source Code\usepackage{color}\definecolor{source}{gray}{0.85}% my comment style\newcommand{\myCommentStyle}[1]{{\footnotesize\sffamily\color{gray!!100!!white} #1}}% my string style\newcommand{\myStringStyle}[1]{{\footnotesize\sffamily\color{violet!!100!!black} #1}}% my symbol style\newcommand{\mySymbolStyle}[1]{{\footnotesize\sffamily\color{violet!!100!!black} #1}}% my keyword style\newcommand{\myKeywordStyle}[1]{{\footnotesize\sffamily\color{green!!70!!black} #1}}% my global style\newcommand{\myGlobalStyle}[1]{{\footnotesize\sffamily\color{blue!!100!!black} #1}}% my number style\newcommand{\myNumberStyle}[1]{{\footnotesize\sffamily\color{brown!!100!!black} #1}}\lstset{language={},tabsize=3,escapechar={!!},keepspaces=true,breaklines=true,alsoletter={\#},literate={\$}{{{\$}}}1,breakautoindent=true,columns=fullflexible,showstringspaces=false,frame=single,aboveskip=1em, % automatic space beforeframerule=0pt,basicstyle=\footnotesize\sffamily\color{black},keywordstyle=\myKeywordStyle,% keyword stylecommentstyle=\myCommentStyle,% comment styleframe=single,%backgroundcolor=\color{source},stepnumber=1,numbersep=10pt,numberstyle=\tiny,numberfirstline=true,captionpos=b,moredelim=[is][\bfseries]{&lt;b&gt;}{&lt;/b&gt;},moredelim=[is][\textit]{&lt;i&gt;}{&lt;/i&gt;},moredelim=[is][\underbar]{&lt;u&gt;}{&lt;/u&gt;},moredelim=[is][\color{red}\uwave]{&lt;wave&gt;}{&lt;/wave&gt;},moredelim=[is][\color{red}\sout]{&lt;del&gt;}{&lt;/del&gt;},moredelim=[is][\color{blue}\underbar]{&lt;ins&gt;}{&lt;/ins&gt;},morecomment=[s][\myCommentStyle]{"}{"},morestring=[b][\myStringStyle]'',moredelim=[is][]{&lt;sel&gt;}{&lt;/sel&gt;},moredelim=[is][]{&lt;rcv&gt;}{&lt;/rcv&gt;},moredelim=[is][\itshape]{&lt;symb&gt;}{&lt;/symb&gt;},moredelim=[is][\scshape]{&lt;class&gt;}{&lt;/class&gt;},morekeywords={true,false,nil,self,super,thisContext},identifierstyle=\idstyle,} \makeatletter\newcommand*\idstyle[1]{%\expandafter\id@style\the\lst@token{#1}\relax%}\def\id@style#1#2\relax{%\ifnum\pdfstrcmp{#1}{\#}=0%% this is a symbol\mySymbolStyle{\the\lst@token}%\else%\edef\tempa{\uccode`#1}%\edef\tempb{`#1}%\ifnum\tempa=\tempb%% this is a global\myGlobalStyle{\the\lst@token}%\else%\the\lst@token%\fi%\fi%}\makeatother\newcommand{\lct}{\texttt} \lstnewenvironment{code}{% \lstset{% frame=single, framerule=0pt, mathescape=false }% \noindent% \minipage{\linewidth}%}{% \endminipage%}%\lstnewenvironment{codeWithLineNumbers}{% \lstset{% frame=single, framerule=0pt, mathescape=false, numbers=left }% \noindent% \minipage{\linewidth}%}{% \endminipage%}%\newenvironment{codeNonSmalltalk}{\begin{alltt}\sffamily}{\end{alltt}\normalsize}'! !!PRBeamerWriter class methodsFor: 'accessing' stamp: 'DamienCassou 4/2/2015 14:42'!writerName	^ #beamer! !!PRBeamerWriter methodsFor: 'helpers' stamp: 'CyrilFerlicot 5/29/2015 10:35'!createFrametitle: aTitle	canvas command		name: 'frametitle';		parameter: aTitle! !!PRBeamerWriter methodsFor: 'helpers' stamp: 'CyrilFerlicot 6/5/2015 17:17'!createLinkToLabelWithAlias: anInternalLink	canvas command		name: 'hyperlink';		parameter: [ canvas raw: anInternalLink anchor ];		parameter: [ canvas raw: anInternalLink alias ]! !!PRBeamerWriter methodsFor: 'helpers' stamp: 'CyrilFerlicot 7/2/2015 10:57'!createTOCWith: aCollection	|  parameters highlight |	parameters := LinkedList new.	"highlight := aCollection at: 'highlight' ifPresent: [ :param | param ] ifAbsent: [ false ].	highlight = 1		ifTrue: [ parameters add: 'currentsection, hideallsubsections' ]		ifFalse: [ 			highlight = 2				ifTrue: [ parameters add: 'currentsection, currentsubsection' ]				ifFalse: [ self sectionOptionFrom: (aCollection at: 'level') asInteger To: (aCollection at: 'depthLevel') asInteger On: parameters ] ]."			self flag: #todo. "We need to change the highlight"	canvas command		name: 'tableofcontents';		optParameter:				(String streamContents: [ :s | parameters do: [ :each | s nextPutAll: each ] separatedBy: [ s nextPut: $, ] ])! !!PRBeamerWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 6/21/2016 11:31'!getLevelFor: aHeader	^ 2 + (super getLevelFor: aHeader)! !!PRBeamerWriter methodsFor: 'helpers' stamp: 'CyrilFerlicot 5/29/2015 13:27'!sectionOptionFrom: level To: depth On: parameters	parameters		add:			((1 > level and: [ 1 <= depth ])				ifTrue: [ 'sectionstyle=show/show' ]				ifFalse: [ 'sectionstyle=hide/hide' ]).	parameters		add:			((2 > level and: [ 2 <= depth ])				ifTrue: [ 'subsectionstyle=show/show/show' ]				ifFalse: [ 'subsectionstyle=hide/hide/hide' ]).	parameters		add:			((3 > level and: [ 3 <= depth ])				ifTrue: [ 'subsubsectionstyle=show/show/show' ]				ifFalse: [ 'subsubsectionstyle=hide/hide/hide' ])! !!PRBeamerWriter methodsFor: 'visiting-annotations' stamp: 'CyrilFerlicot 6/18/2015 14:31'!visitColumn: aColumn	canvas environment		name: 'column';		parameter: [ 					canvas						nextPutAll: (aColumn width asNumber / 100.0) printString;						raw: '\textwidth' ];		with: [ super visitColumn: aColumn ].	canvas newLine! !!PRBeamerWriter methodsFor: 'visiting-annotations' stamp: 'CyrilFerlicot 6/18/2015 14:01'!visitColumns: aColumns	canvas environment		name: 'columns';		with: [ 					super visitColumns: aColumns ].	canvas newLine! !!PRBeamerWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 6/24/2015 17:48'!visitFigure: aFigure	canvas environment		name: 'center';		with: [ self includeGraphicsFor: aFigure ]! !!PRBeamerWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/4/2015 14:24'!visitHeader: aHeader	super visitHeader: aHeader.	self configuration renderStructureAsSlide		ifTrue: [ 			canvas newLine.			canvas environment				name: 'frame';				with: [ 							canvas newLine.							canvas environment								name: 'center';								with: [ 											canvas newLine.											canvas command												name: 'huge';												parameter: [ self visitDocumentGroup: aHeader ].											canvas newLine ] ].			canvas newLine ]! !!PRBeamerWriter methodsFor: 'visiting-document' stamp: 'DamienCassou 4/25/2016 16:26'!visitScript: aScript	| env |	aScript language isSyntaxHighlightingPossible		ifTrue: [ 			canvas				raw: '% syntax highlighting = ' , (self languageForScript: aScript) printString;				newLine ].	env := (aScript hasCaption or: [ aScript hasLabel ])		ifTrue: [ 			canvas environment				name: 'script';				optParameter: aScript label;				parameter: [ self noNewLineDuring: [ self visit: aScript caption ] ];				yourself ]		ifFalse: [ 			canvas environment				name: 'listing';				parameter: '';				yourself ].	env with: [ self writeRawDuring: [ self visitText: aScript ]. canvas newLine ]! !!PRBeamerWriter methodsFor: 'visiting-document' stamp: 'CyrilFerlicot 6/5/2015 17:31'!visitSlide: aSlide	canvas newLine.	canvas environment		name: 'frame';		optParameter: 'fragile';		with: [ 					canvas newLine.					aSlide hasLabel						ifTrue: [ 							canvas command								name: 'label';								parameter: aSlide label.							canvas newLine ].					self createFrametitle: aSlide title.					canvas newLine.					super visitSlide: aSlide ].	canvas newLine! !!PRBeamerWriter methodsFor: 'visiting-annotations' stamp: 'CyrilFerlicot 6/3/2015 17:39'!visitTOCAnnotation: aTOCAnnotation	canvas newLine.	canvas environment		name: 'frame';		with: [ 					canvas newLine.					self createFrametitle: (aTOCAnnotation parameters at: 'title' ifAbsent: [ 'Table Of Content' ]).					canvas newLine.					self createTOCWith: aTOCAnnotation parameters.					canvas newLine ].	canvas newLine! !"Pillar-ExporterBeamer"!!PRToolIconSelector commentStamp: 'TorstenBergmann 3/6/2015 01:47' prior: 0!An item selector for SpotterInstance Variables	icon:		<Object>icon	- xxxxx!!PRToolLabelSelector commentStamp: 'TorstenBergmann 3/6/2015 01:00' prior: 0!A visitor to display the correct label in spotterInstance Variables	label:		<String>label	- xxxxx!!PRToolIcons commentStamp: 'TorstenBergmann 3/5/2015 23:46' prior: 0!An icon cache!!FileReference methodsFor: '*Pillar-Pharo-Tools' stamp: 'TudorGirba 5/22/2016 14:44'!gtInspectorPillarConfigurationIn: composite	<gtInspectorPresentationOrder: 40>	| pillarConfiguration |	(self basename = 'pillar.conf')		ifFalse: [ ^ self ].	pillarConfiguration := PRPillarConfiguration new baseDirectory: self parent; importFromFile: self.	(pillarConfiguration			gtInspectorInputFilesIn: composite)			title: 'Pillar'! !!FileReference methodsFor: '*Pillar-Pharo-Tools' stamp: 'TudorGirba 5/22/2016 14:43'!gtInspectorPillarProjectIn: composite	<gtInspectorPresentationOrder: 20>	| pillarFile pillarConfiguration |	self isDirectory not ifTrue: [ ^ self ].	pillarFile := self files 						detect: [:each | each basename = 'pillar.conf']						ifNone: [ ^ self ].	pillarConfiguration := PRPillarConfiguration new baseDirectory: self; importFromFile: pillarFile.	(pillarConfiguration			gtInspectorInputFilesIn: composite)			title: 'Pillar'! !!PRDocumentGroup methodsFor: '*Pillar-Pharo-Tools' stamp: 'DamienCassou 4/3/2015 15:35'!gtInspectorTreeRepresentationIn: composite	<gtInspectorPresentationOrder: 30>	composite tree		title: 'Tree';		children: [ :item | 					item hasChildren						ifTrue: [ item children ] ];		format: [ :item | (item class name allButFirst: 2) , '(' , ((PRPillarWriter write: item) printStringLimitedTo: 2000) , ')' ]! !!PRPillarConfiguration methodsFor: '*Pillar-Pharo-Tools' stamp: 'TudorGirba 5/22/2016 14:46'!gtInspectorInputFilesIn: composite	<gtInspectorPresentationOrder: 40>	^ composite list 		title: 'Files';		display: [self propertyAt: 'inputFiles' ];		format: #basename;		when: [ self hasProperty: 'inputFiles' ];		act: [			| c | 			c := self propertyAt: 'configurations' ifAbsent: [ #() ].			c isEmpty 				ifTrue: [ self export ] 				ifFalse: [ c do: #export ] ] 			icon: GLMUIThemeExtraIcons glamorousPlay 			entitled: 'Export'! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools' stamp: 'ThibaultArloing 2/5/2016 16:36'!gtInspectorAsciiDocRepresentationIn: composite	<gtInspectorPresentationOrder: 80>	composite text 		title: 'AsciiDoc';		display: [ 			(PRAsciiDocWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools' stamp: 'DamienCassou 4/3/2015 10:44'!gtInspectorBeamerRepresentationIn: composite	<gtInspectorPresentationOrder: 80>	composite text 		title: 'Beamer';		display: [ 			(PRBeamerWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools' stamp: 'CyrilFerlicot 6/18/2015 10:24'!gtInspectorDeckJSRepresentationIn: composite	<gtInspectorPresentationOrder: 51>	composite text 		title: 'DeckJS';		display: [ 			(PRDeckJSWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools' stamp: 'TorstenBergmann 3/6/2015 08:28'!gtInspectorHTMLRepresentationIn: composite	<gtInspectorPresentationOrder: 50>	composite text 		title: 'HTML';		display: [ 			(PRHTMLWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools' stamp: 'TorstenBergmann 3/6/2015 08:28'!gtInspectorLaTeXRepresentationIn: composite	<gtInspectorPresentationOrder: 80>	composite text 		title: 'LaTeX';		display: [ 			(PRLaTeXWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools' stamp: 'TorstenBergmann 3/6/2015 08:28'!gtInspectorMarkdownRepresentationIn: composite	<gtInspectorPresentationOrder: 70>	composite text 		title: 'Markdown';		display: [ 			(PRMarkdownWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools' stamp: 'TorstenBergmann 3/6/2015 08:28'!gtInspectorPillarRepresentationIn: composite	<gtInspectorPresentationOrder: 40>	composite text 		title: 'Pillar';		display: [ 			(PRPillarWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools' stamp: 'DamienCassou 5/11/2016 15:14'!gtInspectorSBALaTeXRepresentationIn: composite	<gtInspectorPresentationOrder: 80>	composite text 		title: 'LaTeX (sbabook)';		display: [ 			(PRSBALaTeXWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools' stamp: 'TorstenBergmann 3/6/2015 08:28'!gtInspectorTextRepresentationIn: composite	<gtInspectorPresentationOrder: 60>	composite text 		title: 'Text';		display: [ 			(PRTextWriter write: self) ]! !!PRDocumentItem methodsFor: '*Pillar-Pharo-Tools' stamp: 'TorstenBergmann 3/6/2015 01:03'!spotterForPillarDocumentFor: aStep	<spotterOrder: 40>	aStep listProcessor 		title: 'Children';		candidatesLimit: Float infinity;		allCandidates: [ self children ];		itemName: [:item | (PRToolLabelSelector new)									visit: item;									label ];		itemIcon: [:item | (PRToolIconSelector new)									visit: item;									icon ];		matchSubstring! !!PRToolIconSelector class methodsFor: 'testing' stamp: 'TorstenBergmann 3/6/2015 00:14'!isAbstract	^ false! !!PRToolIconSelector methodsFor: 'accessing' stamp: 'TorstenBergmann 3/6/2015 00:18'!icon	^icon! !!PRToolIconSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 00:54'!visitAnchor: anObject		icon := PRToolIcons anchorIcon ! !!PRToolIconSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 00:38'!visitBoldFormat: anObject	icon := PRToolIcons boldIcon! !!PRToolIconSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 00:48'!visitEmptyParagraph: anObject		icon := PRToolIcons emptyParagraphIcon ! !!PRToolIconSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 00:36'!visitHeader: aHeader	aHeader level = 1 ifTrue: [ icon := PRToolIcons heading1Icon ].	aHeader level = 2 ifTrue: [ icon := PRToolIcons heading2Icon ].	aHeader level = 3 ifTrue: [ icon := PRToolIcons heading3Icon ].	aHeader level = 4 ifTrue: [ icon := PRToolIcons heading4Icon ].	aHeader level = 5 ifTrue: [ icon := PRToolIcons heading5Icon ].	aHeader level = 6 ifTrue: [ icon := PRToolIcons heading6Icon ].	aHeader level > 6 ifTrue: [ icon := PRToolIcons headingXIcon ].! !!PRToolIconSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 01:46'!visitItalicFormat: anObject	icon := PRToolIcons italicIcon  ! !!PRToolIconSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 01:13'!visitListItem: anObject	icon := PRToolIcons listItemIcon! !!PRToolIconSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 01:09'!visitOrderedList: anObject	icon := PRToolIcons orderedList ! !!PRToolIconSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 00:48'!visitParagraph: anObject		icon := PRToolIcons paragraphIcon ! !!PRToolIconSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 01:23'!visitSubscriptFormat: anObject	icon := PRToolIcons subscriptIcon  ! !!PRToolIconSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 01:23'!visitSuperscriptFormat: anObject	icon := PRToolIcons superscriptIcon ! !!PRToolIconSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 01:54'!visitTable: anObject		icon := PRToolIcons tableIcon ! !!PRToolIconSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 01:56'!visitTableCell: anObject		icon := PRToolIcons tableCellIcon! !!PRToolIconSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 01:57'!visitTableRow: anObject		icon := PRToolIcons tableRowIcon! !!PRToolIconSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 01:30'!visitText: anObject	icon := PRToolIcons textIcon  ! !!PRToolIconSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 01:08'!visitUnorderedList: anObject	icon := PRToolIcons unorderedList ! !!PRToolLabelSelector class methodsFor: 'testing' stamp: 'TorstenBergmann 3/6/2015 01:04'!isAbstract	^ false! !!PRToolLabelSelector methodsFor: 'accessing' stamp: 'TorstenBergmann 3/6/2015 01:03'!label	^ label! !!PRToolLabelSelector methodsFor: 'accessing' stamp: 'TorstenBergmann 3/6/2015 01:03'!label: anObject	label := anObject! !!PRToolLabelSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 01:00'!visitAnchor: anObject		label := anObject name! !!PRToolLabelSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 01:35'!visitCommentedLine: aCommentedLine	label := aCommentedLine text! !!PRToolLabelSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 01:38'!visitEmptyParagraph: anObject	label := ''! !!PRToolLabelSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 01:42'!visitOrderedList: anObject	label := '#... (', anObject children size asString, ')' ! !!PRToolLabelSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 02:01'!visitTable: anObject	label := anObject rowCount asString, ' row(s) x ', anObject columnCount asString, ' column(s)'! !!PRToolLabelSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 01:27'!visitText: anObject	label := anObject text! !!PRToolLabelSelector methodsFor: 'visiting-document' stamp: 'TorstenBergmann 3/6/2015 01:41'!visitUnorderedList: anObject	label := '-... (', anObject children size asString, ')' ! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 00:54'!anchorIcon	^(self iconCache) 		at: #anchorIcon		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 4278190080 0 0 0 4278190080 4278190080 0 0 0 4278190080 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 4278190080 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 0 4278190080 4278190080 0 4278190080 4278190080 4278190080 4278190080 0 4278190080 4278190080 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 00:37'!boldIcon	^(self iconCache) 		at: #boldIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'utilities' stamp: 'TorstenBergmann 3/5/2015 23:47'!browseIcons	<script>		self iconCache inspect! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 01:33'!commentIcon	^(self iconCache) 		at: #commentIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 00:47'!emptyParagraphIcon	^(self iconCache) 		at: #emptyParagraphIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 4278190080 4278190080 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 4278190080 4278190080 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 4278190080 4278190080 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 4278190080 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 4278190080 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 4278190080 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 00:31'!heading1Icon	^(self iconCache) 		at: #heading1Icon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 00:31'!heading2Icon	^(self iconCache) 		at: #heading2Icon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 00:31'!heading3Icon	^(self iconCache) 		at: #heading3Icon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 00:32'!heading4Icon	^(self iconCache) 		at: #heading4Icon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 4278190080 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 00:32'!heading5Icon	^(self iconCache) 		at: #heading5Icon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 00:32'!heading6Icon	^(self iconCache) 		at: #heading6Icon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 00:33'!headingXIcon	^(self iconCache) 		at: #headingXIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 0 4278190080 0 0 0 4278190080 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 4278190080 0 4278190080 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'private accessing' stamp: 'TorstenBergmann 3/5/2015 23:47'!iconCache	^ IconCache ifNil: [ IconCache := Dictionary new ]! !!PRToolIcons class methodsFor: 'accessing' stamp: 'TorstenBergmann 3/5/2015 23:46'!iconNamed: aSymbol	"Returns the icon with the given name"		^(self iconCache) 		at: aSymbol 		ifAbsentPut: [ self perform: aSymbol ]! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 01:45'!italicIcon	^(self iconCache) 		at: #italicIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 01:13'!listItemIcon	^(self iconCache) 		at: #listItemIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 01:09'!orderedList	^(self iconCache) 		at: #orderedList 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 00:46'!paragraphIcon	^(self iconCache) 		at: #paragraphIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'initialization-release' stamp: 'TorstenBergmann 3/5/2015 23:47'!reset	"Reset the icon cache"		<script>		IconCache := nil! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 01:22'!subscriptIcon	^(self iconCache) 		at: #subscriptIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 4278190080 0 0 4278190080 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 01:22'!superscriptIcon	^(self iconCache) 		at: #superscriptIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 4278190080 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 01:56'!tableCellIcon	^(self iconCache) 		at: #tableCellIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 01:53'!tableIcon	^(self iconCache) 		at: #tableIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 01:57'!tableRowIcon	^(self iconCache) 		at: #tableRowIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 4278190080 0 0 0 4278190080 0 0 0 0 4278190080 0 0 0 4278190080 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 01:29'!textIcon	^(self iconCache) 		at: #textIcon 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 4278190080 0 0 0 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !!PRToolIcons class methodsFor: 'icons' stamp: 'TorstenBergmann 3/6/2015 01:08'!unorderedList	^(self iconCache) 		at: #unorderedList 		ifAbsentPut: (Form	extent: (16@16)	depth: 32	fromArray: #( 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4278190080 4278190080 4278190080 0 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 4278190080 0 0 0 4278190080 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0)	offset: (0@0))! !"Pillar-Pharo-Tools"!!PRSubCommandLineHandlerTest methodsFor: 'tests' stamp: 'DamienCassou 9/7/2015 15:30'!testAddingBaseDirectoryWithADash	|cli arguments |	cli := PRSubCommandLineHandler new.	arguments := Dictionary new.	cli add: '--baseDirectory=/foo/bar-baz' to: arguments.	self assert: (arguments at: 'baseDirectory') equals: '/foo/bar-baz'! !!PRSubCommandLineHandlerTest methodsFor: 'tests' stamp: 'DamienCassou 9/7/2015 15:31'!testAddingBaseDirectoryWithAnEqual	|cli arguments |	cli := PRSubCommandLineHandler new.	arguments := Dictionary new.	cli add: '--baseDirectory=/foo/bar=baz' to: arguments.	self assert: (arguments at: 'baseDirectory') equals: '/foo/bar=baz'! !"Pillar-Tests-Cli"!!PRObjectTest commentStamp: 'DamienCassou 4/3/2015 14:53' prior: 0!Tests for expectations that must be valid on all pillar objects!!PRAbstractScriptLanguageTest commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State the name of the class with one line description: For example, I'm xxx the root of the hierarchy of visitor objects.For the Responsibility part: Three sentences about my main responsibility, what I'm doing, what services do I offer.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!PRDocumentItemTest commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State the name of the class with one line description: For example, I'm xxx the root of the hierarchy of visitor objects.For the Responsibility part: Three sentences about my main responsibility, what I'm doing, what services do I offer.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!PRAbstractAnnotationTest commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State the name of the class with one line description: For example, I'm xxx the root of the hierarchy of visitor objects.For the Responsibility part: Three sentences about my main responsibility, what I'm doing, what services do I offer.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!PRScriptTest commentStamp: '' prior: 0!A PRRawTest is xxxxxxxxx.!!PRMockForParameters commentStamp: 'CyrilFerlicot 4/29/2015 13:22' prior: 0!I'm a Mock needed in order to test PRTParametrizable!!Trait method!hasParameters	^ self parameters isEmpty not! !!Trait method!parameterAt: aKey put: aValue	^ self parameters at: aKey put: aValue! !!Trait method!hasParameter: aKey	self		parameters at: aKey		ifAbsent: [ ^ false ].	^ true! !!Trait method!parameters	^ self explicitRequirement! !!PRMockAnnotation commentStamp: 'CyrilFerlicot 6/30/2015 17:03' prior: 0!I am a Mock to test the annotations.!!PRCycleTest methodsFor: 'tests' stamp: 'YannDubois 5/26/2016 13:38'!testAnyCycleDependencies	| packages cycleDetector |	packages := RPackageOrganizer default packages		select: [ :p | p name beginsWith: 'Pillar' ].	cycleDetector := (DAPackageCycleDetector		onPackagesNamed: (packages collect: [ :each | each packageName ])) runAlgorithm.	self assert: cycleDetector cycles size equals: 0! !!PRDocGeneratorAboutScriptLanguageTest methodsFor: 'tests' stamp: 'CyrilFerlicot 4/23/2015 16:34'!testWriteDocOf	| aStream |	aStream := String new writeStream.	PRDocGeneratorAboutScriptLanguage new writeDocOf: PRSmalltalkScriptLanguage on: aStream.	self assert: aStream contents equals: '- PRSmalltalkScriptLanguage which tag is: smalltalk' , String lf! !!PRAbstractScriptLanguageTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/8/2015 10:50'!isAbstract	^ true! !!PRAbstractScriptLanguageTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/8/2015 10:50'!actualClass	^ PRAbstractScriptLanguage! !!PRAbstractScriptLanguageTest methodsFor: 'tests' stamp: 'CyrilFerlicot 4/8/2015 11:12'!testEqueal	self assert: self instance = self instance.	self assert: self instance = self actualInstance! !!PRAbstractScriptLanguageTest methodsFor: 'tests' stamp: 'CyrilFerlicot 4/8/2015 10:49'!testHash	self assert: self instance hash = self instance copy hash! !!PRBashScriptLanguageTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/8/2015 10:58'!isAbstract	^ false! !!PRBashScriptLanguageTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/8/2015 10:58'!actualClass	^ PRBashScriptLanguage ! !!PRCSSScriptLanguageTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/8/2015 10:58'!isAbstract	^ false! !!PRCSSScriptLanguageTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/8/2015 10:59'!actualClass	^ PRCSSScriptLanguage! !!PRHTMLScriptLanguageTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/8/2015 10:59'!isAbstract	^ false! !!PRHTMLScriptLanguageTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/8/2015 10:59'!actualClass	^ PRHTMLScriptLanguage ! !!PRHTTPScriptLanguageTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/8/2015 11:00'!isAbstract	^ false! !!PRHTTPScriptLanguageTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/8/2015 11:00'!actualClass	^ PRHTTPScriptLanguage ! !!PRJSONScriptLanguageTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/8/2015 11:01'!isAbstract	^ false! !!PRJSONScriptLanguageTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/8/2015 11:01'!actualClass	^ PRJSONScriptLanguage ! !!PRJavaScriptScriptLanguageTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/8/2015 11:10'!isAbstract	^ false! !!PRJavaScriptScriptLanguageTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/8/2015 11:10'!actualClass	^ PRJavaScriptScriptLanguage ! !!PRNoScriptLanguageTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/8/2015 10:55'!isAbstract	^ false! !!PRNoScriptLanguageTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/8/2015 10:56'!actualClass	^ PRNoScriptLanguage! !!PRSQLScriptLanguageTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/8/2015 11:02'!isAbstract	^ false! !!PRSQLScriptLanguageTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/8/2015 11:02'!actualClass	^ PRSQLScriptLanguage ! !!PRSTONScriptLanguageTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/8/2015 11:03'!isAbstract	^ false! !!PRSTONScriptLanguageTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/8/2015 11:03'!actualClass	^ PRSTONScriptLanguage ! !!PRShellCommandsScriptLanguageTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/8/2015 11:04'!isAbstract	^ false! !!PRShellCommandsScriptLanguageTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/8/2015 11:04'!actualClass	^ PRShellCommandsScriptLanguage ! !!PRSmalltalkScriptLanguageTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/8/2015 10:52'!isAbstract	^ false! !!PRSmalltalkScriptLanguageTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/8/2015 10:51'!actualClass	^PRSmalltalkScriptLanguage ! !!PRUnspecifiedScriptLanguageTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/8/2015 11:05'!isAbstract	^ false! !!PRUnspecifiedScriptLanguageTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/8/2015 11:05'!actualClass	^ PRUnspecifiedScriptLanguage! !!PRUnsupportedScriptLanguageTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/8/2015 11:06'!isAbstract	^ false! !!PRUnsupportedScriptLanguageTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/8/2015 11:05'!actualClass	^ PRUnsupportedScriptLanguage ! !!PRAbstractAnnotationTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 5/28/2015 17:16'!isAbstract	^ self = PRAbstractAnnotationTest! !!PRAbstractAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 5/28/2015 17:17'!actualClass	^ self subclassResponsibility! !!PRAbstractAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 5/28/2015 17:20'!annoteName	^ self actualClass tag! !!PRAbstractAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 8/7/2015 13:33'!referenceParameters	self subclassResponsibility! !!PRAbstractAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 8/7/2015 13:26'!referenceString	self subclassResponsibility! !!PRAbstractAnnotationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 8/7/2015 13:40'!testParse	| wiki text tree |	wiki := '${' , self referenceString , '}$'.	text := ''.	tree := PRDocument new		add:			(PRParagraph new				add: (self actualClass parameters: self referenceParameters);				yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRCitationAnnotationTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 5/3/2016 15:54'!actualClass	^PRCitationAnnotation! !!PRCitationAnnotationTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 5/3/2016 15:55'!referenceParameters	^ SmallDictionary new		add: 'ref' -> 'hello';		yourself! !!PRCitationAnnotationTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 5/3/2016 15:55'!referenceString	^ 'cite:ref=hello'! !!PRColumnAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 6/30/2015 16:42'!actualClass	^ PRColumnAnnotation! !!PRColumnAnnotationTest methodsFor: 'helpers' stamp: 'YannDubois 5/2/2016 14:40'!referenceParameters	^ SmallDictionary new		add: 'width' -> '50';		yourself! !!PRColumnAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 8/7/2015 13:27'!referenceString	^ 'column:width=50'! !!PRColumnsAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 6/30/2015 16:42'!actualClass	^ PRColumnsAnnotation! !!PRColumnsAnnotationTest methodsFor: 'helpers' stamp: 'YannDubois 5/2/2016 14:41'!referenceParameters	^ SmallDictionary new! !!PRColumnsAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 8/7/2015 13:27'!referenceString	^ 'columns'! !!PREndColumnsAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 6/30/2015 16:42'!actualClass	^ PREndColumnsAnnotation! !!PREndColumnsAnnotationTest methodsFor: 'helpers' stamp: 'YannDubois 5/2/2016 14:40'!referenceParameters	^ SmallDictionary new! !!PREndColumnsAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 8/7/2015 13:27'!referenceString	^ 'endColumns'! !!PRIndexAnnotationTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/14/2015 14:23'!isAbstract	^ true "TODO The class is not finish. When the class will be finish put a false."! !!PRIndexAnnotationTest methodsFor: 'helpers' stamp: 'DamienCassou 4/3/2015 17:56'!actualClass	^ PRIndexAnnotation! !!PRInputFileAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 4/7/2015 15:18'!actualClass	^ PRInputFileAnnotation! !!PRInputFileAnnotationTest methodsFor: 'running' stamp: 'CyrilFerlicot 4/9/2015 16:30'!createFile1	| stream |	stream := (directory / 'foo.pillar') writeStream.	stream nextPutAll: '!!!!Hello World'.	stream close! !!PRInputFileAnnotationTest methodsFor: 'running' stamp: 'CyrilFerlicot 5/23/2015 19:16'!createFile2	| stream |	stream := (directory / 'bar.pillar') writeStream.	stream nextPutAll: '${inputFile:foo.pillar}$' , Smalltalk os lineEnding , '!!!!Bye World'.	stream close! !!PRInputFileAnnotationTest methodsFor: 'running' stamp: 'CyrilFerlicot 5/23/2015 19:16'!createFile3	| stream |	stream := (directory / 'timoleon.pillar') writeStream.	stream nextPutAll: '!!!!Hello World' , Smalltalk os lineEnding , 'test'.	stream close! !!PRInputFileAnnotationTest methodsFor: 'running' stamp: 'ThibaultArloing 7/21/2016 10:59'!createFile4	| stream |	(directory / 'tata') ensureCreateDirectory.	stream := (directory / 'tata' / 'toto.pillar') writeStream.	stream nextPutAll: '+fig.png|width=50+'.	stream close! !!PRInputFileAnnotationTest methodsFor: 'helpers' stamp: 'YannDubois 5/2/2016 14:43'!referenceParameters	^ SmallDictionary new		add: 'value' -> 'foo/myFile.pillar';		yourself! !!PRInputFileAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 8/7/2015 13:27'!referenceString	^ 'inputFile:value=foo/myFile.pillar'! !!PRInputFileAnnotationTest methodsFor: 'running' stamp: 'ThibaultArloing 7/19/2016 16:28'!setUp	super setUp.	directory := FileSystem workingDirectory.	self createFile1.	self createFile2.	self createFile3.	self createFile4! !!PRInputFileAnnotationTest methodsFor: 'running' stamp: 'ThibaultArloing 7/21/2016 11:20'!tearDown	super tearDown.	(directory / 'foo.pillar') delete.	(directory / 'bar.pillar') delete.	(directory / 'tata/toto.pillar') delete.	(directory / 'tata') ensureDelete.	(directory / 'timoleon.pillar') delete! !!PRInputFileAnnotationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 4/15/2015 00:01'!testInclude1File	| wiki wikiTransform text tree |	wiki := '${inputFile:foo.pillar}$'.	wikiTransform := '!!!!Hello World'.	text := 'Hello World'.	tree := PRDocument new		add:				(PRHeader new						level: 2;						add: (PRText content: 'Hello World');						yourself);		yourself.	self assertWikiTransform: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wikiTransform.	self assertTree: tree equalsText: text! !!PRInputFileAnnotationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 5/23/2015 19:18'!testInclude1FileContentInto1Paragraph	| wiki wikiTransform text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := 'Foo ${inputFile:timoleon.pillar}$'.	wikiTransform := 'Foo !!!!Hello World' , nLine , 'test' , nLine.	text := 'Foo Hello World' , nLine , 'test' , nLine.	tree := PRDocument new		add:				(PRParagraph new						add: (PRText content: 'Foo ');						add:								(PRHeader new										level: 2;										add: (PRText content: 'Hello World');										yourself);						add: (PRParagraph new add: (PRText content: 'test')));		yourself.	self assertWikiTransform: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wikiTransform.	self assertTree: tree equalsText: text! !!PRInputFileAnnotationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 5/23/2015 19:18'!testInclude1FileHeaderInto1Paragraph	| wiki wikiTransform text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := 'Foo ${inputFile:foo.pillar}$'.	wikiTransform := 'Foo !!!!Hello World', nLine.	text := 'Foo Hello World', nLine.	tree := PRDocument new		add:				(PRParagraph new						add: (PRText content: 'Foo ');						add:								(PRHeader new										level: 2;										add: (PRText content: 'Hello World');										yourself));		yourself.	self assertWikiTransform: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wikiTransform.	self assertTree: tree equalsText: text! !!PRInputFileAnnotationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 5/23/2015 19:18'!testInclude1FileInto1Include	| wiki wikiTransform text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := '${inputFile:bar.pillar}$'.	wikiTransform := '!!!!Hello World' , nLine , '!!!!Bye World'.	text := 'Hello World' , nLine , 'Bye World'.	tree := PRDocument new		add:				(PRHeader new						level: 2;						add: (PRText content: 'Hello World');						yourself);		add:				(PRHeader new						level: 2;						add: (PRText content: 'Bye World');						yourself);		yourself.	self assertWikiTransform: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wikiTransform.	self assertTree: tree equalsText: text! !!PRInputFileAnnotationTest methodsFor: 'tests' stamp: 'ThibaultArloing 7/21/2016 11:24'!testInclude1FileWithFigure	| wiki wikiTransform text tree |	wiki := '${inputFile:tata/toto.pillar}$'.	wikiTransform := '+tata/fig.png|width=50+'.	text := 'tata/fig.png'.	tree := PRDocument new		add:			(PRParagraph new				add:					(PRFigure new						reference: 'tata/fig.png';						parameterAt: 'width' put: '50'; 						yourself);				yourself);		yourself.	self assertWikiTransform: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wikiTransform.	self assertTree: tree equalsText: text! !!PRInputFileAnnotationTest methodsFor: 'tests' stamp: 'YannDubois 7/1/2016 10:07'!testInclude1FileWithLineBreak	| wiki wikiTransform text tree |	wiki := '${inputFile:foo.pillar}$'.	wikiTransform := '!!!!Hello World'.	text := 'Hello World'.	tree := PRDocument new		add:				(PRHeader new						level: 2;						add: (PRText content: 'Hello World');						yourself);		yourself.	self assertWikiTransform: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wikiTransform.	self assertTree: tree equalsText: text! !!PRInputFileAnnotationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 4/10/2015 13:34'!testNoInclude	| wiki text tree|	wiki := '!!!!Hello World'.	text := 'Hello World'.	tree := PRDocument new		add:							(PRHeader new								level: 2;								add: (PRText content: 'Hello World');								yourself);		yourself.	self assertWikiTransform: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRMockAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 6/30/2015 17:07'!actualClass	^ PRMockAnnotation! !!PRMockAnnotationTest methodsFor: 'helpers' stamp: 'YannDubois 5/2/2016 14:40'!referenceParameters	^ SmallDictionary new		add: 'value' -> 'Foo';		add: 'number' -> '5';		yourself! !!PRMockAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 8/7/2015 13:27'!referenceString	^ 'mock:value=Foo|number=5'! !!PRMockAnnotationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 9/9/2015 23:54'!testParseTooMuchParameters	| input  |	input := '${mock:Foo|option=bar}$'.	self should: [ PRDocument parser parse: input ] raise: PRWarning! !!PRMockAnnotationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 9/9/2015 23:55'!testParseWithBadInterpretation	| input |	input := '${mock:Foo|number=cinq}$'.	self should: [ PRDocument parser parse: input ] raise: PRError! !!PRMockAnnotationTest methodsFor: 'tests' stamp: 'DamienCassou 10/15/2015 11:00'!testParseWithInterpretation	| input expected |	input := '${mock:Foo|number=5}$'.	expected := PRMockAnnotation new		hadAllKeys: false;		yourself.	expected parameters		at: 'value' put: 'Foo';		at: 'number' put: 5.	self		assert:			(PRDocument parser parse: input startingAt: #annotation)		equals: expected! !!PRMockAnnotationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 9/10/2015 00:00'!testParseWithWrongValue	| input |	input := '${mock:Foo|number=100}$'.	self should: [PRDocument parser parse: input ] raise: MAError! !!PRMockAnnotationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 9/10/2015 00:00'!testParseWithoutARequiredParameter	| input |	input := '${mock}$'.	self should: [ PRDocument parser parse: input ] raise: PRError! !!PRMockAnnotationTest methodsFor: 'tests' stamp: 'DamienCassou 10/15/2015 11:01'!testParseWithoutFirstKey	| input expected |	input := '${mock:Foo}$'.	expected := PRMockAnnotation new.	expected hadAllKeys: false.	expected parameters at: 'value' put: 'Foo'.	self assert: (PRDocument parser parse: input startingAt: #annotation) equals: expected! !!PRSlideTitleAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 6/1/2015 16:21'!actualClass	^ PRSlideTitleAnnotation! !!PRSlideTitleAnnotationTest methodsFor: 'helpers' stamp: 'YannDubois 5/2/2016 14:41'!referenceParameters	^ SmallDictionary new		add: 'title' -> 'Foo';		yourself! !!PRSlideTitleAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 8/7/2015 13:27'!referenceString	^ 'slide:title=Foo'! !!PRSlideTitleAnnotationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/3/2015 14:15'!testIsSlideBeginning	self assert: self actualInstance isSlideBeginning! !!PRSlideTitleAnnotationTest methodsFor: 'tests' stamp: 'YannDubois 5/2/2016 14:41'!testSlideAnnotation	| slide |	slide := PRSlideTitleAnnotation		parameters:			(SmallDictionary new				at: 'title' put: 'Foo';				yourself).	self assert: slide slideAnnotation equals: slide! !!PRTocAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 4/17/2015 13:38'!actualClass	^ PRTocAnnotation! !!PRTocAnnotationTest methodsFor: 'helpers' stamp: 'YannDubois 5/2/2016 14:41'!referenceParameters	^ SmallDictionary new		add: 'depthLevel' -> '2';		add: 'level' -> '3';		yourself! !!PRTocAnnotationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 8/7/2015 13:28'!referenceString	^ 'toc:depthLevel=2|level=3'! !!PRAnchorTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRAnchorTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRAnchor! !!PRAnchorTest methodsFor: 'tests-comparing' stamp: 'lr 4/5/2007 13:16'!testEqualName	self deny: (self actualClass named: 'foo') = (self actualClass named: 'bar')! !!PRAnchorTest methodsFor: 'tests-accessing' stamp: 'lr 3/9/2006 11:31'!testName	self instance name: 'zork'.	self assert: self instance name = 'zork'! !!PRAnchorTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 13:08'!testParseBasic	| wiki text tree |	wiki := '@name'.	text := ''.	tree := PRDocument new		add: (PRAnchor named: 'name');		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRAnchorTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:17'!testParseMultiple	| wiki text tree nLine|	nLine := Smalltalk os lineEnding.	wiki := '@one' , nLine , '@two' , nLine , nLine , '@tree'.	text := ''.	tree := PRDocument new		add: (PRAnchor named: 'one');		add: (PRAnchor named: 'two');		add: PREmptyParagraph new;		add: (PRAnchor named: 'tree');		yourself.	self 		assertWiki: wiki		equalsTree: tree.	self 		assertTree: tree		equalsWiki: wiki.	self 		assertTree: tree		equalsText: text! !!PRAnchorTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 13:08'!testParseSpaces	| wiki text tree |	wiki := '@one two'.	text := ''.	tree := PRDocument new		add: (PRAnchor named: 'one two');		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRAnchorTest methodsFor: 'tests-instantiation' stamp: 'lr 4/5/2007 13:16'!testWith	instance := self actualClass named: 'test'.	self assert: self instance name = 'test'! !!PRCitationTest class methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 5/3/2016 15:56'!isAbstract	^false! !!PRCitationTest methodsFor: 'private' stamp: 'ThibaultArloing 5/3/2016 15:55'!actualClass	^ PRCitation ! !!PRCitationTest methodsFor: 'tests' stamp: 'ThibaultArloing 5/3/2016 15:55'!testHaveRef	|citation|	citation := self actualClass ref: 'foo'.	self assert: citation ref equals: 'foo'! !!PRAnnotatedParagraphTest class methodsFor: 'testing' stamp: 'lr 5/26/2009 22:22'!isAbstract	^ false! !!PRAnnotatedParagraphTest methodsFor: 'private' stamp: 'lr 5/26/2009 22:21'!actualClass	^ PRAnnotatedParagraph! !!PRAnnotatedParagraphTest methodsFor: 'tests-parsing' stamp: 'lr 5/26/2009 22:31'!testParseBasic	| wiki text tree |	wiki := '@@foo bar zork'.	text := 'bar zork'.	tree := PRDocument new		add: (PRAnnotatedParagraph new			annotation: 'foo';			add: (PRText content: 'bar zork');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRAnnotatedParagraphTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:17'!testParseEmptyFollwedByPreformatted	| wiki text tree nLine|	nLine := Smalltalk os lineEnding.	wiki := '@@foo' , nLine , '= bar'.	text := nLine , 'bar'.	tree := PRDocument new		add: (PRAnnotatedParagraph new			annotation: 'foo';			yourself);		add: (PRPreformatted new			add: (PRText content: 'bar');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRAnnotatedParagraphTest methodsFor: 'tests-parsing' stamp: 'lr 5/26/2009 22:31'!testParseOnlyAnnotation	| wiki text tree |	wiki := '@@foo'.	text := ''.	tree := PRDocument new		add: (PRAnnotatedParagraph new			annotation: 'foo';			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRAnnotatedParagraphTest methodsFor: 'tests-parsing' stamp: 'lr 5/26/2009 22:31'!testParseOnlyNothing	| wiki text tree |	wiki := '@@'.	text := ''.	tree := PRDocument new		add: (PRAnnotatedParagraph new			annotation: '';			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRAnnotatedParagraphTest methodsFor: 'tests-parsing' stamp: 'lr 5/26/2009 22:31'!testParseOnlyText	| wiki text tree |	wiki := '@@ foo bar'.	text := 'foo bar'.	tree := PRDocument new		add: (PRAnnotatedParagraph new			add: (PRText content: 'foo bar');			annotation: '';			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRColumnTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 6/18/2015 11:30'!isAbstract	^ false! !!PRColumnTest methodsFor: 'private' stamp: 'CyrilFerlicot 6/18/2015 11:30'!actualClass	^ PRColumn! !!PRColumnsTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 6/18/2015 11:30'!isAbstract	^ false! !!PRColumnsTest methodsFor: 'private' stamp: 'CyrilFerlicot 6/18/2015 11:31'!actualClass	^ PRColumns! !!PRDocumentGroupTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ true! !!PRDocumentGroupTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRDocumentGroup! !!PRDocumentGroupTest methodsFor: 'tests-adding' stamp: 'lr 3/9/2006 11:31'!testAdd	self instance add: self fooInstance.	self assert: self instance children size = 1.	self assert: self instance children first = self fooInstance.	self instance add: self barInstance.	self assert: self instance children size = 2.	self assert: self instance children first = self fooInstance.	self assert: self instance children second = self barInstance! !!PRDocumentGroupTest methodsFor: 'tests-adding' stamp: 'lr 3/9/2006 11:31'!testAddAll	self instance addAll: self foobarInstances.	self assert: self instance children size = 2.	self assert: self instance children first = self fooInstance.	self assert: self instance children second = self barInstance! !!PRDocumentGroupTest methodsFor: 'tests-copying' stamp: 'lr 3/9/2006 11:31'!testCopyChildren	self instance addAll: self foobarInstances.	self assert: self instance children = self instance copy children.	self deny: self instance children == self instance copy children.	self instance children		with: self instance copy children		do: [ :a :b | self assert: a = b. self deny: a == b ]! !!PRDocumentGroupTest methodsFor: 'tests-testing' stamp: 'lr 3/20/2006 19:08'!testHasChildren	self deny: self instance hasChildren.	self instance add: self fooInstance.	self assert: self instance hasChildren! !!PRDocumentGroupTest methodsFor: 'tests-accessing' stamp: 'lr 3/30/2009 21:55'!testSize	self assert: self instance size = 0.	self instance add: self fooInstance.	self assert: self instance size = 1! !!PRDocumentGroupTest methodsFor: 'tests-accessing' stamp: 'lr 3/9/2006 11:31'!testText	self instance addAll: self foobarInstances.	self assert: self instance text = 'foobar'! !!PRDocumentGroupTest methodsFor: 'tests-instantiation' stamp: 'lr 3/9/2006 11:31'!testWith	instance := self actualClass with: self fooInstance.	self assert: instance children size = 1.	self assert: instance children first = self fooInstance! !!PRDocumentGroupTest methodsFor: 'tests-instantiation' stamp: 'lr 3/9/2006 11:31'!testWithAll	instance := self actualClass withAll: self foobarInstances.	self assert: instance children size = 2.	self assert: instance children first = self fooInstance.	self assert: instance children second = self barInstance! !!PRDocumentTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRDocumentTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRDocument! !!PRDocumentTest methodsFor: 'tests-parsing' stamp: 'lr 12/9/2007 17:02'!testParseEmpty	| wiki text tree |	wiki := String new.	text := String new.	tree := PRDocument new.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRDocumentTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 8/19/2015 13:27'!testParseMultipleProperties	| wiki text tree document|	wiki := '{''title'':''The title'',''authors'':''Someone else and me''}'.	text := String new.	tree := PRDocument new		propertyAt: 'title' put: 'The title';		propertyAt: 'authors' put: 'Someone else and me';		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text.	document := self parser parse: wiki.	self assert: document properties equals: tree properties! !!PRDocumentTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 8/19/2015 13:27'!testParseProperties	| wiki text tree document |	wiki := '{''title'':''The title''}'.	text := String new.	tree := PRDocument new		propertyAt: 'title' put: 'The title';		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text.	document := self parser parse: wiki.	self assert: document properties equals: tree properties! !!PRDocumentTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 8/19/2015 13:27'!testParsePropertiesWithText	| wiki text tree document |	wiki := '{''title'':''The title''}' , Smalltalk os lineEnding , 'foobar'.	text := 'foobar'.	tree := PRDocument new		propertyAt: 'title' put: 'The title';		add:				(PRParagraph new						add: (PRText content: 'foobar');						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text.	document := self parser parse: wiki.	self assert: document properties equals: tree properties! !!PRBoldFormatTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRBoldFormatTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRBoldFormat! !!PRFormatTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ true! !!PRFormatTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRFormat! !!PRFormatTest methodsFor: 'accessing' stamp: 'lr 4/5/2007 16:08'!otherClass	^ otherClass ifNil: [ otherClass := PRFormat allSubclasses detect: [ :each | self actualClass ~= each ] ]! !!PRFormatTest methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 8/19/2015 14:30'!setUp	super setUp.	markup := PRPillarGrammar markups at: self actualClass! !!PRFormatTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 8/19/2015 14:31'!testParseBasic	| wiki text tree |	wiki := '1' , markup , '2' , markup , '3'.	text := '123'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2'));				add: (PRText content: '3');				yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRFormatTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 8/19/2015 14:31'!testParseEnd	| wiki text tree |	wiki := '1' , markup , '2' , markup.	text := '12'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2'));				yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRFormatTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 9/10/2015 00:16'!testParseEscaped	| wiki text tree |	wiki := ' ' , (PRPillarWriter escapeMarkup: markup) , (PRPillarWriter escapeMarkup: markup).	text := ' ' , markup , markup.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: ' ' , markup , markup);				yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRFormatTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 9/10/2015 00:16'!testParseIncomplete	| wiki1 wiki2 text tree |	wiki1 := '1' , markup , '2'.	wiki2 := '1' , (PRPillarWriter escapeMarkup: markup) , '2'.	text := '1' , markup , '2'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1' , markup , '2');				yourself);		yourself.	self assertWiki: wiki1 equalsTree: tree.	self assertWiki: wiki2 equalsTree: tree.	self assertTree: tree equalsWiki: wiki2.	self assertTree: tree equalsText: text! !!PRFormatTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 8/19/2015 14:32'!testParseMany	| wiki text tree |	wiki := '1' , markup , '2' , markup , '3' , markup , '4' , markup , '5'.	text := '12345'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2'));				add: (PRText content: '3');				add: (self actualClass with: (PRText content: '4'));				add: (PRText content: '5');				yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRFormatTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 8/19/2015 14:32'!testParseNested	| wiki text tree |	wiki := '1' , markup , '2' , (PRPillarGrammar markups at: self otherClass) , '3'		, (PRPillarGrammar markups at: self otherClass) , '4' , markup , '5'.	text := '12345'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add:					(self actualClass new						add: (PRText content: '2');						add:							(self otherClass new								add: (PRText content: '3');								yourself);						add: (PRText content: '4');						yourself);				add: (PRText content: '5');				yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRFormatTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 8/19/2015 14:32'!testParseNestedTight	| wiki text tree |	wiki := ' ' , markup , (PRPillarGrammar markups at: self otherClass)		, (PRPillarGrammar markups at: self otherClass) , markup.	text := ' '.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: ' ');				add: (self actualClass new add: self otherClass new yourself);				yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRFormatTest methodsFor: 'tests-parsing' stamp: 'DamienCassou 8/24/2015 17:19'!testParseWithNewLine	| wiki text tree |	wiki := '1' , markup , '2', Smalltalk os lineEnding, '3' , markup , '4'.	text := '12', Smalltalk os lineEnding, '34'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2', Smalltalk os lineEnding, '3'));				add: (PRText content: '4');				yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRFormatTest methodsFor: 'tests-parsing' stamp: 'DamienCassou 8/24/2015 17:12'!testParseWithSpace	| wiki text tree |	wiki := '1' , markup , '2 3' , markup , '4'.	text := '12 34'.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: '1');				add: (self actualClass with: (PRText content: '2 3'));				add: (PRText content: '4');				yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRItalicFormatTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRItalicFormatTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRItalicFormat! !!PRMonospaceFormatTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRMonospaceFormatTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRMonospaceFormat! !!PRStrikethroughFormatTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRStrikethroughFormatTest methodsFor: 'private' stamp: 'lr 5/31/2007 07:48'!actualClass	^ PRStrikethroughFormat! !!PRSubscriptFormatTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRSubscriptFormatTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRSubscriptFormat! !!PRSuperscriptFormatTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRSuperscriptFormatTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRSuperscriptFormat! !!PRUnderlineFormatTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRUnderlineFormatTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRUnderlineFormat! !!PRHeaderTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRHeaderTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRHeader! !!PRHeaderTest methodsFor: 'tests-comparing' stamp: 'lr 3/9/2006 11:31'!testEqualLevel	self deny: (self actualClass new level: 1) = (self actualClass new level: 2)! !!PRHeaderTest methodsFor: 'tests' stamp: 'CyrilFerlicot 5/23/2015 20:09'!testIsHeader	self assert: self actualInstance isHeader! !!PRHeaderTest methodsFor: 'tests-accessing' stamp: 'lr 3/9/2006 11:31'!testName	self instance level: 3.	self assert: self instance level = 3! !!PRHeaderTest methodsFor: 'tests-parsing' stamp: 'lr 10/18/2007 19:22'!testParseEmpty	| wiki text tree |	wiki := '!!'.	text := ''.	tree := PRDocument new		add: (PRHeader new			level: 1;			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRHeaderTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:33'!testParseLevel1	| wiki text tree |	wiki := '!!foo'.	text := 'foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 1;			add: (PRText content: 'foo');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRHeaderTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:33'!testParseLevel2	| wiki text tree |	wiki := '!!!!foo'.	text := 'foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 2;			add: (PRText content: 'foo');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRHeaderTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:33'!testParseLevel3	| wiki text tree |	wiki := '!!!!!!foo'.	text := 'foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 3;			add: (PRText content: 'foo');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRHeaderTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:33'!testParseLevel4	| wiki text tree |	wiki := '!!!!!!!!foo'.	text := 'foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 4;			add: (PRText content: 'foo');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRHeaderTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:33'!testParseLevel5	| wiki text tree |	wiki := '!!!!!!!!!!foo'.	text := 'foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 5;			add: (PRText content: 'foo');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRHeaderTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:33'!testParseLevel6	| wiki text tree |	wiki := '!!!!!!!!!!!!foo'.	text := 'foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 6;			add: (PRText content: 'foo');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRHeaderTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:18'!testParseMultiline	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := '!!!!Hello ""This is' , nLine , 'bold"" end' , nLine , 'new'.	text := 'Hello This is' , nLine , 'bold end' , nLine , 'new'.	tree := PRDocument new		add:				(PRHeader new						level: 2;						add: (PRText content: 'Hello ');						add: (self addText: 'This is' , nLine , 'bold' to: PRBoldFormat new);						add: (PRText content: ' end');						yourself);		add: (self addText: 'new' to: PRParagraph new);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRHeaderTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:33'!testParseNested	| wiki text tree |	wiki := '!!!!Hello *Link*'.	text := 'Hello Link'.	tree := PRDocument new		add: (PRHeader new			level: 2;			add: (PRText content: 'Hello ');			add: (PRInternalLink new				reference: 'Link';				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRHeaderTest methodsFor: 'tests-parsing' stamp: 'DamienCassou 10/7/2015 17:31'!testParseWithTrailingSpaces	| wiki text tree |	wiki := '!!  foo'.	text := 'foo'.	tree := PRDocument new		add: ((PRHeader new)			level: 1;			add: (PRText content: 'foo');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsText: text! !!PRHeaderTest methodsFor: 'tests-instantiation' stamp: 'lr 3/9/2006 11:31'!testWithAllLevel	instance := self actualClass withAll: self foobarInstances level: 3.	self assert: self instance children size = 2.	self assert: self instance children first = self fooInstance.	self assert: self instance children second = self barInstance.	self assert: self instance level = 3! !!PRListItemTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRListItemTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRListItem! !!PRDefinitionDataTest class methodsFor: 'testing' stamp: 'lr 12/30/2007 21:37'!isAbstract	^ false! !!PRDefinitionDataTest methodsFor: 'private' stamp: 'lr 12/30/2007 21:37'!actualClass	^ PRDefinitionList! !!PRDefinitionDataTest methodsFor: 'private' stamp: 'lr 12/30/2007 23:30'!listItemClass	^ PRDataItem! !!PRDefinitionDataTest methodsFor: 'tests' stamp: 'CyrilFerlicot 5/23/2015 19:19'!testParseBug	| wiki1 wiki2 tree nLine |	nLine := Smalltalk os lineEnding.	wiki1 := '::1' , nLine , '::-2'.	wiki2 := ':' , nLine , '::1' , nLine , '::-2'.	tree := PRDocument new		add:				(PRDefinitionList new						add:								(PRDataItem new										add:												(PRDefinitionList new														add:																(PRDataItem new																		add: (PRText content: '1');																		add:																				(PRUnorderedList new																						add:																								(PRListItem new																										add: (PRText content: '2');																										yourself);																						yourself);																		yourself);														yourself);										yourself);						yourself);		yourself.	self assertWiki: wiki1 equalsTree: tree.	self assertWiki: wiki2 equalsTree: tree.	self assertTree: tree equalsWiki: wiki2! !!PRDefinitionDataTest methodsFor: 'tests' stamp: 'CyrilFerlicot 5/23/2015 19:19'!testParseMixed	| wiki tree |	wiki := ';1' , Smalltalk os lineEnding , ':2'.	tree := PRDocument new		add:				(PRDefinitionList new						add:								(PRTermItem new										add: (PRText content: '1');										yourself);						add:								(PRDataItem new										add: (PRText content: '2');										yourself);						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki! !!PRDefinitionDataTest methodsFor: 'private' stamp: 'lr 12/30/2007 23:33'!textString: anObject level: anInteger	^ (super textString: anObject level: anInteger) , '  '! !!PRDefinitionDataTest methodsFor: 'private' stamp: 'lr 12/30/2007 23:30'!wikiString	^ ':'! !!PRDefinitionTermTest class methodsFor: 'testing' stamp: 'lr 12/30/2007 23:29'!isAbstract	^ false! !!PRDefinitionTermTest methodsFor: 'private' stamp: 'lr 12/30/2007 23:29'!actualClass	^ PRDefinitionList! !!PRDefinitionTermTest methodsFor: 'private' stamp: 'lr 12/30/2007 23:30'!listItemClass	^ PRTermItem! !!PRDefinitionTermTest methodsFor: 'tests' stamp: 'CyrilFerlicot 5/23/2015 19:19'!testParseMixed	| wiki tree nLine |	nLine := Smalltalk os lineEnding.	wiki := ';1' , nLine , ';2' , nLine , ':3' , nLine , ':4'.	tree := PRDocument new		add:				(PRDefinitionList new						add:								(PRTermItem new										add: (PRText content: '1');										yourself);						add:								(PRTermItem new										add: (PRText content: '2');										yourself);						add:								(PRDataItem new										add: (PRText content: '3');										yourself);						add:								(PRDataItem new										add: (PRText content: '4');										yourself);						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki! !!PRDefinitionTermTest methodsFor: 'private' stamp: 'lr 12/30/2007 23:33'!textString: anObject level: anInteger	^ (super textString: anObject level: anInteger) , '- '! !!PRDefinitionTermTest methodsFor: 'private' stamp: 'lr 12/30/2007 23:29'!wikiString	^ ';'! !!PRListTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ true! !!PRListTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRList! !!PRListTest methodsFor: 'private' stamp: 'lr 12/30/2007 23:28'!listItemClass	^ PRListItem! !!PRListTest methodsFor: 'private' stamp: 'lr 12/30/2007 23:28'!listItemWithText: aString	^ self listItemClass new		add: (PRText content: aString);		yourself! !!PRListTest methodsFor: 'tests-parsing' stamp: 'lr 12/30/2007 23:31'!testParseEmpty	| wiki text tree |	wiki := self wikiString.	text := self textString: 1 level: 1.	tree := PRDocument new		add: (self actualClass new			add: self listItemClass new;			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRListTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:19'!testParseFlat	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := self wikiString , '1st' , nLine , self wikiString , '2nd' , nLine , self wikiString , '3rd'.	text := (self textString: 1 level: 1) , '1st' , nLine , (self textString: 2 level: 1) , '2nd' , nLine		, (self textString: 3 level: 1) , '3rd'.	tree := PRDocument new		add:				(self actualClass new						add: (self listItemWithText: '1st');						add: (self listItemWithText: '2nd');						add: (self listItemWithText: '3rd');						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRListTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:19'!testParseMultiple	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := self wikiString , '1st' , nLine , self wikiString , '2nd' , nLine , nLine , self wikiString , '3rd'.	text := (self textString: 1 level: 1) , '1st' , nLine , (self textString: 2 level: 1) , '2nd' , nLine , nLine		, (self textString: 1 level: 1) , '3rd'.	tree := PRDocument new		add:				(self actualClass new						add: (self listItemWithText: '1st');						add: (self listItemWithText: '2nd');						yourself);		add: PREmptyParagraph new;		add:				(self actualClass new						add: (self listItemWithText: '3rd');						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRListTest methodsFor: 'tests-parsing' stamp: 'DamienCassou 10/8/2015 16:27'!testParseWithTrailingSpaces	| wiki tree |	wiki := self wikiString , ' 1st'.	tree := PRDocument new		add:			(self actualClass new				add: (self listItemWithText: '1st');				yourself);		yourself.	self assertWiki: wiki equalsTree: tree! !!PRListTest methodsFor: 'private' stamp: 'lr 12/20/2007 23:21'!textString: anObject level: anInteger	^ (2 to: anInteger) inject: '' into: [ :result :each | result , '	' ]! !!PRListTest methodsFor: 'private' stamp: 'lr 2/7/2007 16:22'!wikiString	self subclassResponsibility! !!PROrderedListTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PROrderedListTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PROrderedList! !!PROrderedListTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:19'!testParseMixed	| wiki tree nLine |	nLine := Smalltalk os lineEnding.	wiki := '#1' , nLine , '#2' , nLine , '-3'.	tree := PRDocument new		add:				(PROrderedList new						add: (self listItemWithText: '1');						add: (self listItemWithText: '2');						yourself);		add:				(PRUnorderedList new						add: (self listItemWithText: '3');						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki! !!PROrderedListTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:19'!testParseNested	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := self wikiString , '1' , nLine , self wikiString , self wikiString , '1.1' , nLine , self wikiString		, self wikiString , '1.2'.	text := (self textString: 1 level: 1) , '1' , nLine , (self textString: 1 level: 2) , '1.1' , nLine		, (self textString: 2 level: 2) , '1.2'.	tree := PRDocument new		add:				(self actualClass new						add:								(PRListItem new										add: (PRText content: '1');										add:												(self actualClass new														add: (self listItemWithText: '1.1');														add: (self listItemWithText: '1.2');														yourself);										yourself);						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PROrderedListTest methodsFor: 'private' stamp: 'jf 9/30/2009 01:10'!textString: anObject level: anInteger 	^ (super 		textString: anObject		level: anInteger) , anObject greaseString , '. '! !!PROrderedListTest methodsFor: 'private' stamp: 'lr 12/20/2007 20:13'!wikiString	^ '#'! !!PRUnorderedListTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRUnorderedListTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRUnorderedList! !!PRUnorderedListTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:19'!testParseMixed	| wiki tree text nLine |	nLine := Smalltalk os lineEnding.	wiki := '#1' , nLine , '##2' , nLine , '###3' , nLine , '#-4' , nLine , '#-5' , nLine , '##6' , nLine , '#7'.	text := '1. 1' , nLine , '	1. 2' , nLine , '		1. 3' , nLine , '	* 4' , nLine , '	* 5' , nLine , '	1. 6' , nLine		, '2. 7'.	tree := PRDocument new		add:				(PROrderedList new						add:								(PRListItem new										add: (PRText content: '1');										add:												(PROrderedList new														add:																(PRListItem new																		add: (PRText content: '2');																		add:																				(PROrderedList new																						add: (self listItemWithText: '3');																						yourself);																		yourself);														yourself);										add:												(PRUnorderedList new														add: (self listItemWithText: '4');														add: (self listItemWithText: '5');														yourself);										add:												(PROrderedList new														add: (self listItemWithText: '6');														yourself);										yourself);						add: (self listItemWithText: '7');						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRUnorderedListTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:19'!testParseNested	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := self wikiString , '1' , nLine , self wikiString , self wikiString , '1.1' , nLine , self wikiString		, self wikiString , self wikiString , '1.1.1'.	text := (self textString: 1 level: 1) , '1' , nLine , (self textString: 1 level: 2) , '1.1' , nLine		, (self textString: 1 level: 3) , '1.1.1'.	tree := PRDocument new		add:				(self actualClass new						add:								(PRListItem new										add: (PRText content: '1');										add:												(self actualClass new														add:																(PRListItem new																		add: (PRText content: '1.1');																		add:																				(self actualClass new																						add: (self listItemWithText: '1.1.1');																						yourself);																		yourself);														yourself);										yourself);						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRUnorderedListTest methodsFor: 'private' stamp: 'lr 12/20/2007 23:20'!textString: anObject level: anInteger	^ (super textString: anObject level: anInteger) , '* '! !!PRUnorderedListTest methodsFor: 'private' stamp: 'lr 2/7/2007 16:23'!wikiString	^ '-'! !!PREmptyParagraphTest methodsFor: 'private' stamp: 'DamienCassou 3/20/2014 10:46'!actualClass	^ PREmptyParagraph! !!PREmptyParagraphTest methodsFor: 'tests' stamp: 'CyrilFerlicot 5/23/2015 19:20'!testParseEmptyParagraphAtBeginning	| wiki text tree content |	content := 'Lorem ipsum dolor sit amet.'.	wiki := Smalltalk os lineEnding , content.	text := wiki.	tree := PRDocument new		add: PREmptyParagraph new;		add:				(PRParagraph new						add: (PRText content: content);						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PREmptyParagraphTest methodsFor: 'tests' stamp: 'CyrilFerlicot 5/23/2015 19:20'!testParseEmptyParagraphInTheMiddle	| wiki text tree content nLine|	nLine := Smalltalk os lineEnding.	content := 'Lorem ipsum dolor sit amet.'.	wiki := content , nLine , nLine , content.	text := wiki.	tree := PRDocument new		add:				(PRParagraph new						add: (PRText content: content);						yourself);		add: PREmptyParagraph new;		add:				(PRParagraph new						add: (PRText content: content);						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRParagraphTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRParagraphTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRParagraph! !!PRParagraphTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:19'!testParseEmptyLineAtBeginning	| wiki text tree |	wiki := '' , Smalltalk os lineEnding , 'Lorem ipsum dolor sit amet.'.	text := wiki.	tree := PRDocument new		add: PREmptyParagraph new;		add:				(PRParagraph new						add: (PRText content: 'Lorem ipsum dolor sit amet.');						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRParagraphTest methodsFor: 'tests-parsing' stamp: 'lr 12/9/2007 09:38'!testParseOneLine	| wiki text tree |	wiki := 'Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Nulla quis urna.'.	text := wiki.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: wiki);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRParagraphTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:19'!testParseThreeEmptyLines	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := 'Lorem ipsum dolor sit amet.' , nLine , nLine , nLine , 'Nulla mattis elementum nulla.'.	text := wiki.	tree := PRDocument new		add:				(PRParagraph new						add: (PRText content: 'Lorem ipsum dolor sit amet.');						yourself);		add: PREmptyParagraph new;		add: PREmptyParagraph new;		add:				(PRParagraph new						add: (PRText content: 'Nulla mattis elementum nulla.');						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRParagraphTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:20'!testParseTwoConsecutiveNonTextLines	| wiki text tree sentence title nLine |	nLine := Smalltalk os lineEnding.	sentence := 'sentence'.	title := 'title'.	wiki := sentence , nLine , '!!' , title.	text := sentence , nLine , title.	tree := PRDocument new		add:				(PRParagraph new						add: (PRText content: sentence);						yourself);		add:				(PRHeader new						level: 1;						add: (PRText content: title);						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRParagraphTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:20'!testParseTwoEmptyLines	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := 'Lorem ipsum dolor sit amet.' , nLine , nLine , 'Nulla mattis elementum nulla.'.	text := wiki.	tree := PRDocument new		add:				(PRParagraph new						add: (PRText content: 'Lorem ipsum dolor sit amet.');						yourself);		add: PREmptyParagraph new;		add:				(PRParagraph new						add: (PRText content: 'Nulla mattis elementum nulla.');						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRPreformattedTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRPreformattedTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRPreformatted! !!PRPreformattedTest methodsFor: 'tests-parsing' stamp: 'DamienPollet 2/20/2014 18:47'!testParseBasic	| wiki text tree |	wiki := '= Line'.	text := 'Line'.	tree := PRDocument new		add: (PRPreformatted new			add: (PRText content: 'Line');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRPreformattedTest methodsFor: 'tests-parsing' stamp: 'DamienPollet 2/20/2014 18:47'!testParseEmpty	| wiki text tree |	wiki := '= '.	text := ''.	tree := PRDocument new		add: (PRPreformatted new			add: (PRText content: '');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRPreformattedTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:20'!testParseMultiple	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := '= line 1.1' , nLine , '= line 1.2' , nLine , nLine , '= line 2.1'.	text := 'line 1.1' , nLine , 'line 1.2' , nLine , nLine , 'line 2.1'.	tree := PRDocument new		add:				(PRPreformatted new						add: (PRText content: 'line 1.1');						add: (PRText content: 'line 1.2');						yourself);		add: PREmptyParagraph new;		add:				(PRPreformatted new						add: (PRText content: 'line 2.1');						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRPreformattedTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:20'!testParseSpaces	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := '=    A line with 3 spaces' , nLine , '= 	A line with a tab'.	text := '   A line with 3 spaces' , nLine , '	A line with a tab'.	tree := PRDocument new		add:				(PRPreformatted new						add: (PRText content: '   A line with 3 spaces');						add: (PRText content: '	A line with a tab');						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRPreformattedTest methodsFor: 'tests-parsing' stamp: 'DamienPollet 2/20/2014 18:48'!testParseSpecials	| wiki text tree |	wiki := '= |, {, }, *, *, [, ||, |{, |}, +, +'.	text := '|, {, }, *, *, [, ||, |{, |}, +, +'.	tree := PRDocument new		add: (PRPreformatted new			add: (PRText content: '|, {, }, *, *, [, ||, |{, |}, +, +');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRFigureTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 4/28/2015 16:23'!isAbstract	^ false! !!PRFigureTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/28/2015 16:25'!actualClass	^ PRFigure! !!PRFigureTest methodsFor: 'private' stamp: 'CyrilFerlicot 9/9/2015 23:45'!markup	^ PRPillarParser markups at: PRFigure! !!PRFigureTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/28/2015 16:27'!referenceString	^ 'file://test.png'! !!PRFigureTest methodsFor: 'tests' stamp: 'DamienCassou 9/6/2015 10:25'!testHasCaption	self deny: PRFigure new hasCaption.	self assert: (self addText: 'foo' to: PRFigure new) hasCaption! !!PRExternalLinkTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRExternalLinkTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRExternalLink! !!PRExternalLinkTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!referenceString	^ 'http://www.lukas-renggli.ch'! !!PRExternalLinkTest methodsFor: 'tests' stamp: 'lr 4/1/2009 22:29'!testIsExternal	self assert: self instance isExternal! !!PRExternalLinkTest methodsFor: 'tests' stamp: 'CyrilFerlicot 4/29/2015 10:57'!testLinkToAFigureIsExternalLink	| wiki text tree |	wiki := '*file://foo.png*'.	text := self actualClass new		reference: 'file://foo.png';		title.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: 'file://foo.png';				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRExternalLinkTest methodsFor: 'tests-accessing' stamp: 'lr 10/20/2006 12:06'!testTitle	self instance reference: 'http://www.lukas-renggli.ch'.	self assert: self instance title = 'http://www.lukas-renggli.ch'! !!PRExternalLinkTest methodsFor: 'tests-accessing' stamp: 'lr 3/9/2006 11:31'!testUrl	self instance reference: 'http://www.lukas-renggli.ch'.	self assert: self instance url = 'http://www.lukas-renggli.ch'! !!PRMailLinkTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRMailLinkTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRMailLink! !!PRMailLinkTest methodsFor: 'private' stamp: 'lr 11/13/2008 14:15'!referenceString	^ 'renggli@gmail.com'! !!PRMailLinkTest methodsFor: 'as yet unclassified' stamp: 'LukasKomarek 4/28/2016 13:34'!testLinkToAFigureIsExternalLink	"This test has no meaning in PRMailLinkTest."! !!PRMailLinkTest methodsFor: 'tests-parsing' stamp: 'lr 9/22/2008 08:25'!testParseBogus	| wiki text tree |	wiki := '*ab12@x.com*'.	text := 'ab12@x.com'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: 'ab12@x.com';				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRMailLinkTest methodsFor: 'tests-accessing' stamp: 'lr 11/13/2008 14:16'!testTitle	super testTitle.	self instance reference: self referenceString.	self assert: self instance title = self referenceString! !!PRMailLinkTest methodsFor: 'tests-accessing' stamp: 'DamienCassou 4/26/2014 18:08'!testUrl	self instance reference: self referenceString.	self assert: (self instance url beginsWith: 'mailto:').	self assert: self instance url ~= ('mailto:' , self referenceString).	self assert: self instance scrambledUrl ~= ('mailto:' , self referenceString).	self assert: self instance unscrambledUrl = ('mailto:' , self referenceString)! !!PRSemanticLinkTest class methodsFor: 'testing' stamp: 'LukasKomarek 4/21/2016 16:01'!isAbstract	^ true! !!PRSemanticLinkTest methodsFor: 'private' stamp: 'LukasKomarek 4/28/2016 12:15'!expectedUrlForReferenceString	self subclassResponsibility ! !!PRSemanticLinkTest methodsFor: 'private' stamp: 'LukasKomarek 4/28/2016 12:16'!expectedUrlForSimpleReferenceString	self subclassResponsibility ! !!PRSemanticLinkTest methodsFor: 'private' stamp: 'LukasKomarek 4/28/2016 12:16'!referenceString	self subclassResponsibility ! !!PRSemanticLinkTest methodsFor: 'private' stamp: 'LukasKomarek 4/28/2016 12:16'!simpleReferenceString	self subclassResponsibility ! !!PRSemanticLinkTest methodsFor: 'tests' stamp: 'LukasKomarek 4/28/2016 12:05'!testLinkToAFigureIsExternalLink	self expectedFailures! !!PRSemanticLinkTest methodsFor: 'tests' stamp: 'LukasKomarek 4/28/2016 12:07'!testTitle	self instance reference: self referenceString.	self assert: self instance title equals: self referenceString! !!PRSemanticLinkTest methodsFor: 'tests' stamp: 'LukasKomarek 4/28/2016 12:11'!testUrl	self instance reference: self referenceString.	self assert: self instance url equals: self expectedUrlForReferenceString.		self instance reference: self simpleReferenceString.	self assert: self instance url equals: self expectedUrlForSimpleReferenceString! !!PRWikipediaSemLinkTest class methodsFor: 'testing' stamp: 'LukasKomarek 4/21/2016 16:04'!isAbstract	^ false! !!PRWikipediaSemLinkTest methodsFor: 'private' stamp: 'LukasKomarek 4/21/2016 16:05'!actualClass	^ PRWikipediaSemLink! !!PRWikipediaSemLinkTest methodsFor: 'private' stamp: 'LukasKomarek 4/28/2016 12:14'!expectedUrlForReferenceString	^ 'https://en.wikipedia.org/wiki/Atom'! !!PRWikipediaSemLinkTest methodsFor: 'private' stamp: 'LukasKomarek 4/28/2016 12:14'!expectedUrlForSimpleReferenceString	^ 'https://en.wikipedia.org/'! !!PRWikipediaSemLinkTest methodsFor: 'private' stamp: 'LukasKomarek 4/21/2016 16:30'!referenceString	^ 'wikipedia:Atom'! !!PRWikipediaSemLinkTest methodsFor: 'private' stamp: 'LukasKomarek 4/28/2016 12:14'!simpleReferenceString	^ 'wikipedia:'! !!PRWikipediaSemLinkTest methodsFor: 'as yet unclassified' stamp: 'LukasKomarek 5/18/2016 16:47'!testUrlWithParameters	"this link could be for example *link to atom on wiki>wikipedia:Atom|lang=fr*"		self instance reference: self referenceString;		parameters: (Dictionary with: 'lang' -> 'fr').	self assert: self instance url equals: 'https://fr.wikipedia.org/wiki/Atom'! !!PRYoutubeSemLinkTest class methodsFor: 'testing' stamp: 'LukasKomarek 4/21/2016 16:04'!isAbstract	^ false! !!PRYoutubeSemLinkTest methodsFor: 'private' stamp: 'LukasKomarek 4/21/2016 16:05'!actualClass	^ PRYoutubeSemLink ! !!PRYoutubeSemLinkTest methodsFor: 'private' stamp: 'LukasKomarek 4/28/2016 12:09'!expectedUrlForReferenceString	^ 'https://www.youtube.com/watch?v=MYSVMgRr6pw'! !!PRYoutubeSemLinkTest methodsFor: 'private' stamp: 'LukasKomarek 4/28/2016 12:10'!expectedUrlForSimpleReferenceString	^ 'https://www.youtube.com/'! !!PRYoutubeSemLinkTest methodsFor: 'private' stamp: 'LukasKomarek 4/21/2016 16:32'!referenceString	^ 'youtube:MYSVMgRr6pw'! !!PRYoutubeSemLinkTest methodsFor: 'private' stamp: 'LukasKomarek 4/28/2016 12:10'!simpleReferenceString	^ 'youtube:'! !!PRInternalLinkTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRInternalLinkTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRInternalLink! !!PRInternalLinkTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!referenceString	^ 'Page'! !!PRInternalLinkTest methodsFor: 'tests-accessing' stamp: 'lr 3/9/2006 11:31'!testAnchor	self instance anchor: 'zork'.	self assert: self instance anchor = 'zork'.	self assert: self instance hasAnchor! !!PRInternalLinkTest methodsFor: 'tests-comparing' stamp: 'lr 3/9/2006 11:31'!testEqualAnchor	self deny: (self actualClass new anchor: 'foo'; yourself) = ((self actualClass new) anchor: 'bar'; yourself)! !!PRInternalLinkTest methodsFor: 'tests' stamp: 'lr 3/30/2009 21:35'!testIsInternal	self assert: self instance isInternal! !!PRInternalLinkTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 9/8/2015 19:02'!testParseAnchored	| wiki text tree |	wiki := '*' , self referenceString , '@Anchor*'.	text := self actualClass new		reference: self referenceString;		anchor: 'Anchor';		title.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: self referenceString;				anchor: 'Anchor';				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRInternalLinkTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:33'!testParseEverything	| wiki text tree |	wiki := '*Alias>' , self referenceString , '@Anchor*'.	text := 'Alias'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: 'Alias');				reference: self referenceString;				anchor: 'Anchor';				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRInternalLinkTest methodsFor: 'tests-accessing' stamp: 'CyrilFerlicot 5/21/2015 14:51'!testReferenceAsHTML	| link |	link := PRInternalLink reference: 'foo.pillar'.	self assert: link referenceAsHTML equals: 'foo.html'.	link := PRInternalLink reference: 'foo.pilla'.	self should: [ link referenceAsHTML ] raise: PRLinkWarning! !!PRInternalLinkTest methodsFor: 'tests-accessing' stamp: 'CyrilFerlicot 5/21/2015 14:51'!testReferenceAsMarkdown	| link |	link := PRInternalLink reference: 'foo.pillar'.	self assert: link referenceAsMarkdown equals: 'foo.md'.	link := PRInternalLink reference: 'foo.pilla'.	self should: [ link referenceAsMarkdown ] raise: PRLinkWarning! !!PRInternalLinkTest methodsFor: 'tests-accessing' stamp: 'lr 10/20/2006 11:45'!testTitle	super testTitle.	self instance reference: 'page'.	self assert: self instance title = 'page'! !!PRLinkTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ true! !!PRLinkTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRLink! !!PRLinkTest methodsFor: 'private' stamp: 'CyrilFerlicot 9/9/2015 23:44'!markup	^ PRPillarParser markups at: PRLink! !!PRLinkTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!referenceString	self subclassResponsibility! !!PRLinkTest methodsFor: 'tests' stamp: 'lr 3/30/2009 21:35'!testIsBroken	self assert: (self instance isBroken or: [ self instance isBroken not ])! !!PRLinkTest methodsFor: 'tests' stamp: 'lr 4/1/2009 22:28'!testIsExternal	self deny: self instance isExternal! !!PRLinkTest methodsFor: 'tests' stamp: 'lr 3/30/2009 21:35'!testIsInternal	self deny: self instance isInternal! !!PRLinkTest methodsFor: 'tests' stamp: 'lr 3/30/2009 21:36'!testIsLink	self assert: self instance isLink! !!PRLinkTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:33'!testParseAliased	| wiki text tree |	wiki := '*Alias>' , self referenceString , '*'.	text := 'Alias'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: 'Alias');				reference: self referenceString;				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRLinkTest methodsFor: 'tests-parsing' stamp: 'lr 2/2/2009 16:01'!testParseAliasedEmpty	| wiki text tree |	wiki := '*>' , self referenceString , '*'.	text := ''.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: '');				reference: self referenceString;				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRLinkTest methodsFor: 'tests-parsing' stamp: 'lr 2/7/2007 15:06'!testParseBasic	| wiki text tree |	wiki := '*' , self referenceString , '*'.	text := self actualClass new		reference: self referenceString;		title.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: self referenceString;				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRLinkTest methodsFor: 'tests-parsing' stamp: 'YannDubois 5/2/2016 14:44'!testParseParameters	| wiki text tree |	wiki := '*Alias>' , self referenceString , '|a=1|b=2|c*'.	text := 'Alias'.	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(SmallDictionary new														add: 'a' -> '1';														add: 'b' -> '2';														add: 'c' -> nil;														yourself);										yourself);						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRLinkTest methodsFor: 'tests-parsing' stamp: 'YannDubois 5/2/2016 14:44'!testParseParametersEmpty	| wiki text tree |	wiki := '*Alias>' , self referenceString , '|a||b|*'.	text := 'Alias'.	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(SmallDictionary new														add: 'a' -> nil;														add: 'b' -> nil;														yourself);										yourself);						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsText: text! !!PRLinkTest methodsFor: 'tests-parsing' stamp: 'YannDubois 5/2/2016 14:44'!testParseParametersEscaped	| wiki text tree |	wiki := '*Alias>' , self referenceString , '|2=\|\=|\|\==1*'.	text := 'Alias'.	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(SmallDictionary new														add: '2' -> '|=';														add: '|=' -> '1';														yourself);										yourself);						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRReferenceTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/28/2015 16:20'!actualClass	^ PRReference! !!PRReferenceTest methodsFor: 'private' stamp: 'CyrilFerlicot 9/8/2015 18:54'!markup	^ self subclassResponsibility! !!PRReferenceTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/28/2015 16:28'!referenceString	self subclassResponsibility! !!PRReferenceTest methodsFor: 'tests' stamp: 'CyrilFerlicot 4/28/2015 16:21'!testAlias	self deny: self instance hasAlias.	self instance add: self fooInstance.	self assert: self instance hasAlias.	self assert: self instance alias = 'foo'.	self instance add: self barInstance.	self assert: self instance hasAlias.	self assert: self instance alias = 'foobar'! !!PRReferenceTest methodsFor: 'tests-accessing' stamp: 'CyrilFerlicot 4/28/2015 17:42'!testAnchor	self deny: self instance hasAnchor! !!PRReferenceTest methodsFor: 'tests-comparing' stamp: 'CyrilFerlicot 4/28/2015 17:38'!testEqualReference	self deny: (self actualClass new reference: 'foo'; yourself) = (self actualClass new reference: 'bar'; yourself)! !!PRReferenceTest methodsFor: 'tests-parameters' stamp: 'CyrilFerlicot 4/28/2015 17:38'!testHasParameter	self instance parameters: (Dictionary with: 'foo' -> 'zork' with: 'bar' -> nil).	self assert: (self instance hasParameter: 'foo').	self assert: (self instance hasParameter: 'bar').	self deny: (self instance hasParameter: 'zork')! !!PRReferenceTest methodsFor: 'tests' stamp: 'DamienCassou 9/24/2015 15:07'!testNonTextAlias	| wiki text tree |	wiki := self markup , 'foo ""Alias"">' , self referenceString , self markup.	text := 'foo Alias'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: 'foo ');				add: (self addText: 'Alias' to: PRBoldFormat new);				reference: self referenceString;				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRReferenceTest methodsFor: 'tests-parameters' stamp: 'CyrilFerlicot 4/28/2015 17:39'!testParameterAt	self instance parameters: (Dictionary with: 'foo' -> 'bar').	self assert: (self instance parameters at: 'foo' ifAbsent: [nil]) = 'bar'.	self assert: (self instance parameters at: 'bar' ifAbsent: [nil]) isNil! !!PRReferenceTest methodsFor: 'tests-parameters' stamp: 'CyrilFerlicot 4/28/2015 17:39'!testParameterAtIfAbsent	self instance parameters: (Dictionary with: 'foo' -> 'bar').	self assert: (self instance parameters at: 'foo' ifAbsent: [ 'zork' ]) = 'bar'.	self assert: (self instance parameters at: 'bar'  ifAbsent: [ 'zork' ]) = 'zork'! !!PRReferenceTest methodsFor: 'tests-parameters' stamp: 'CyrilFerlicot 4/28/2015 17:39'!testParameterAtIfPresent	self instance parameters: (Dictionary with: 'foo' -> 'bar').	self assert: (self instance parameters at: 'foo' ifPresent: [ :value | '!!' , value ]) = '!!bar'.	self assert: (self instance parameters at: 'bar' ifPresent: [ :value | '!!' , value ]) isNil! !!PRReferenceTest methodsFor: 'tests-parameters' stamp: 'CyrilFerlicot 4/28/2015 17:39'!testParameterAtPut	self assert: (self instance parameters at: 'foo' put: 'bar') = 'bar'.	self assert: (self instance parameters size = 1).	self assert: (self instance parameters keys first = 'foo').	self assert: (self instance parameters values first = 'bar').	self assert: (self instance parameters at: 'foo' put: 'zork') = 'zork'.	self assert: (self instance parameters size = 1).	self assert: (self instance parameters keys first = 'foo').	self assert: (self instance parameters values first = 'zork')! !!PRReferenceTest methodsFor: 'tests-parameters' stamp: 'CyrilFerlicot 4/28/2015 17:39'!testParameterCopy	| copy |	self instance parameters at: 'class' put: 'active'.	copy := self instance copy.	copy parameters at: 'class' put: 'inactive'.	copy parameters at: 'foo' put: 'bar'.		self assert: (self instance parameters at: 'class') = 'active'.	self deny: (self instance hasParameter: 'foo').		self assert: (copy parameters at: 'class') = 'inactive'.	self assert: (copy parameters at: 'foo') = 'bar'! !!PRReferenceTest methodsFor: 'tests-parameters' stamp: 'CyrilFerlicot 4/28/2015 17:39'!testParameters	self assert: self instance parameters isEmpty.	self instance parameters: (Array with: 'foo' -> 'bar').	self assert: self instance parameters size = 1! !!PRReferenceTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 9/8/2015 18:54'!testParseAliased	| wiki text tree |	wiki := self markup , 'Alias>' , self referenceString , self markup.	text := 'Alias'.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				add: (PRText content: 'Alias');				reference: self referenceString;				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRReferenceTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 9/8/2015 18:56'!testParseAliasedEmpty	| wiki text tree |	wiki := self markup , '>' , self referenceString , self markup.	text := ''.	tree := PRDocument new		add:			(PRParagraph new				add:					(self actualClass new						add: (PRText content: '');						reference: self referenceString;						yourself);				yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRReferenceTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 9/8/2015 18:56'!testParseBasic	| wiki text tree |	wiki := self markup  , self referenceString , self markup .	text := self actualClass new		reference: self referenceString;		title.	tree := PRDocument new		add: (PRParagraph new			add: (self actualClass new				reference: self referenceString;				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRReferenceTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 9/8/2015 18:59'!testParseEasyness	| wiki1 wiki2 text tree |	wiki1 := self markup , Smalltalk os lineEnding , self markup , self referenceString.	wiki2 := '\' , self markup , Smalltalk os lineEnding , '\' , self markup , self referenceString.	text := self markup , Smalltalk os lineEnding , self markup , self referenceString.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: self markup);				add: PRLineBreak new;				add: (PRText content: self markup , self referenceString);				yourself);		yourself.	self assertWiki: wiki1 equalsTree: tree.	self assertWiki: wiki2 equalsTree: tree.	self assertTree: tree equalsWiki: wiki2.	self assertTree: tree equalsText: text! !!PRReferenceTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 9/8/2015 19:01'!testParseEmpty	| wiki1 wiki2 text tree |	wiki1 := self markup , self markup.	wiki2 := '\' , self markup , '\' , self markup.	text := self markup , self markup.	tree := PRDocument new		add:			(PRParagraph new				add: (PRText content: self markup , self markup);				yourself);		yourself.	self assertWiki: wiki1 equalsTree: tree.	self assertWiki: wiki2 equalsTree: tree.	self assertTree: tree equalsWiki: wiki2.	self assertTree: tree equalsText: text! !!PRReferenceTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:20'!testParseEscaped	| wiki text tree |	wiki := 'Star \*' , self referenceString , '\*' , Smalltalk os lineEnding , 'Cross \+' , self referenceString , '\+'.	text := 'Star *' , self referenceString , '*' , Smalltalk os lineEnding , 'Cross +' , self referenceString , '+'.	tree := PRDocument new		add:				(PRParagraph new						add: (PRText content: 'Star *' , self referenceString , '*');						add: PRLineBreak new;						add: (PRText content: 'Cross +' , self referenceString , '+');						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRReferenceTest methodsFor: 'tests-parsing' stamp: 'YannDubois 5/2/2016 14:43'!testParseParameters	| wiki text tree |	wiki := self markup , 'Alias>' , self referenceString , '|a=1|b=2|c' , self markup .	text := 'Alias'.	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(SmallDictionary new														add: 'a' -> '1';														add: 'b' -> '2';														add: 'c' -> nil;														yourself);										yourself);						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRReferenceTest methodsFor: 'tests-parsing' stamp: 'YannDubois 5/2/2016 14:43'!testParseParametersEmpty	| wiki text tree |	wiki := self markup , 'Alias>' , self referenceString , '|a||b|' , self markup  .	text := 'Alias'.	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(SmallDictionary new														add: 'a' -> nil;														add: 'b' -> nil;														yourself);										yourself);						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsText: text! !!PRReferenceTest methodsFor: 'tests-parsing' stamp: 'YannDubois 5/2/2016 14:43'!testParseParametersEscaped	| wiki text tree |	wiki := self markup , 'Alias>' , self referenceString , '|2=\|\=|\|\==1' , self markup .	text := 'Alias'.	tree := PRDocument new		add:				(PRParagraph new						add:								(self actualClass new										add: (PRText content: 'Alias');										reference: self referenceString;										parameters:												(SmallDictionary new														add: '2' -> '|=';														add: '|=' -> '1';														yourself);										yourself);						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRReferenceTest methodsFor: 'tests-accessing' stamp: 'CyrilFerlicot 4/28/2015 17:42'!testReference	self instance reference: 'zork'.	self assert: self instance reference = 'zork'! !!PRReferenceTest methodsFor: 'tests-accessing' stamp: 'CyrilFerlicot 4/28/2015 17:41'!testTitle	self deny: self instance title notNil! !!PRSectionTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 6/3/2015 13:50'!isAbstract	^ false! !!PRSectionTest methodsFor: 'private' stamp: 'CyrilFerlicot 6/3/2015 13:50'!actualClass	^ PRSection! !!PRSlideTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 6/3/2015 13:50'!isAbstract	^ false! !!PRSlideTest methodsFor: 'private' stamp: 'CyrilFerlicot 6/3/2015 13:50'!actualClass	^ PRSlide! !!PRSlideTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/3/2015 17:21'!testHaveTitle	| slide |	slide := self actualClass titled: 'Foo'.	self assert: slide title equals: 'Foo'! !!PRTableCellTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRTableCellTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRTableCell! !!PRTableCellTest methodsFor: 'tests-accessing' stamp: 'lr 3/9/2006 11:31'!testAlign	self instance align: #right.	self assert: self instance align = #right! !!PRTableCellTest methodsFor: 'tests-accessing' stamp: 'lr 3/9/2006 11:31'!testBeAlignedCenter	self instance beAlignedCenter.	self assert: self instance align = #center.	self assert: self instance isAlignedCenter.	self deny: self instance isAlignedLeft.	self deny: self instance isAlignedRight! !!PRTableCellTest methodsFor: 'tests-accessing' stamp: 'lr 3/9/2006 11:31'!testBeAlignedLeft	self instance beAlignedLeft.	self assert: self instance align = #left.	self deny: self instance isAlignedCenter.	self assert: self instance isAlignedLeft.	self deny: self instance isAlignedRight! !!PRTableCellTest methodsFor: 'tests-accessing' stamp: 'lr 3/9/2006 11:31'!testBeAlignedRight	self instance beAlignedRight.	self assert: self instance align = #right.	self deny: self instance isAlignedCenter.	self deny: self instance isAlignedLeft.	self assert: self instance isAlignedRight! !!PRTableCellTest methodsFor: 'tests-comparing' stamp: 'lr 3/9/2006 11:31'!testEqualAlign	self deny: self actualClass new beAlignedRight				= self actualClass new beAlignedCenter.	self deny: self actualClass new beAlignedCenter				= self actualClass new beAlignedLeft! !!PRTableCellTest methodsFor: 'tests-accessing' stamp: 'lr 8/14/2008 08:59'!testHeading	self deny: self instance heading.	self deny: self instance isHeading.		self instance heading: true.	self assert: self instance heading.	self assert: self instance isHeading.		self instance heading: false.	self deny: self instance heading.	self deny: self instance isHeading! !!PRTableCellTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:34'!testParseAlign1	| wiki text tree |	wiki := '|{left||center|}right'.	text := 'left	center	right'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beAlignedLeft;					add: (PRText content: 'left');					yourself);				add: (PRTableCell new					beAlignedCenter;					add: (PRText content: 'center');					yourself);				add: (PRTableCell new					beAlignedRight;					add: (PRText content: 'right');					yourself);				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRTableCellTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:34'!testParseAlign2	| wiki text tree |	wiki := '|}right|none|{left|none'.	text := 'right	none	left	none'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beAlignedRight;					add: (PRText content: 'right');					yourself);				add: (PRTableCell new					add: (PRText content: 'none');					yourself);				add: (PRTableCell new					beAlignedLeft;					add: (PRText content: 'left');					yourself);				add: (PRTableCell new					add: (PRText content: 'none');					yourself);				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRTableCellTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 9/8/2015 18:52'!testParseEncoding	| wiki text tree |	wiki := '|*link*|+file://embedded.png+|foo{}'.	text := 'link	file://embedded.png	foo{}'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					add: (PRInternalLink new						reference: 'link';						yourself);					yourself);				add: (PRTableCell new					add: (PRFigure new						reference: 'file://embedded.png';						yourself);					yourself);				add: (PRTableCell new					add: (PRText content: 'foo{}');					yourself);				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRTableCellTest methodsFor: 'tests-parsing' stamp: 'lr 8/14/2008 09:17'!testParseHeading1	| wiki text tree |	wiki := '|!!head|{!!left||!!center|}!!right'.	text := 'head	left	center	right'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beHeading;					add: (PRText content: 'head');					yourself);				add: (PRTableCell new					beHeading;					beAlignedLeft;					add: (PRText content: 'left');					yourself);				add: (PRTableCell new					beHeading;					beAlignedCenter;					add: (PRText content: 'center');					yourself);				add: (PRTableCell new					beHeading;					beAlignedRight;					add: (PRText content: 'right');					yourself);				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRTableCellTest methodsFor: 'tests-parsing' stamp: 'lr 8/14/2008 09:17'!testParseHeading2	| wiki1 wiki2 text tree |	wiki1 := '|!!head|!!{left|!!|center|!!}right'.	wiki2 := '|!!head|{!!left||!!center|}!!right'.	text := 'head	left	center	right'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					beHeading;					add: (PRText content: 'head');					yourself);				add: (PRTableCell new					beHeading;					beAlignedLeft;					add: (PRText content: 'left');					yourself);				add: (PRTableCell new					beHeading;					beAlignedCenter;					add: (PRText content: 'center');					yourself);				add: (PRTableCell new					beHeading;					beAlignedRight;					add: (PRText content: 'right');					yourself);				yourself);			yourself);		yourself.	self assertWiki: wiki1 equalsTree: tree.	self assertTree: tree equalsWiki: wiki2.	self assertTree: tree equalsText: text! !!PRTableRowTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRTableRowTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRTableRow! !!PRTableRowTest methodsFor: 'tests-accessing' stamp: 'lr 3/9/2006 11:31'!testCount	self instance add: PRTableCell new.	self assert: self instance columnCount = 1.	self instance add: PRTableCell new.	self assert: self instance columnCount = 2! !!PRTableRowTest methodsFor: 'tests-accessing' stamp: 'DamienCassou 6/3/2014 10:38'!testRowWithHeadingCellIsHeading	self instance		add:			(self				addText: 'foo'				to:					(PRTableCell new						beHeading;						yourself)).	self assert: self instance isHeading! !!PRTableRowTest methodsFor: 'tests-accessing' stamp: 'DamienCassou 6/3/2014 10:37'!testRowWithHeadingCellsAndOneEmptyCellIsHeading	self instance		add:				(self						addText: 'foo'						to:							(PRTableCell new								beHeading;								yourself));		add: PRTableCell new.	self assert: self instance isHeading! !!PRTableRowTest methodsFor: 'tests-accessing' stamp: 'DamienCassou 6/3/2014 10:39'!testRowWithOnlyEmptyCellIsNotHeading	self instance		add: PRTableCell new;		add: PRTableCell new.	self deny: self instance isHeading! !!PRTableTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRTableTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRTable! !!PRTableTest methodsFor: 'tests-accessing' stamp: 'lr 3/21/2006 18:43'!testCount	self instance add: (PRTableRow new add: PRTableCell new; yourself).	self assert: self instance rowCount = 1; assert: self instance columnCount = 1.	self instance add: (PRTableRow new add: PRTableCell new; add: PRTableCell new; yourself).	self assert: self instance rowCount = 2; assert: self instance columnCount = 2.	self instance add: (PRTableRow new add: PRTableCell new; yourself).	self assert: self instance rowCount = 3; assert: self instance columnCount = 2! !!PRTableTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:34'!testParseBasic	| wiki text tree |	wiki := '|cell'.	text := 'cell'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					add: (PRText content: 'cell');					yourself);				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRTableTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:21'!testParseSquare	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := '|a11|a12' , nLine , '|a21|a22'.	text := 'a11	a12' , nLine , 'a21	a22'.	tree := PRDocument new		add:				(PRTable new						add:								(PRTableRow new										add:												(PRTableCell new														add: (PRText content: 'a11');														yourself);										add:												(PRTableCell new														add: (PRText content: 'a12');														yourself);										yourself);						add:								(PRTableRow new										add:												(PRTableCell new														add: (PRText content: 'a21');														yourself);										add:												(PRTableCell new														add: (PRText content: 'a22');														yourself);										yourself);						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRTableTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:21'!testParseTriangle	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := '|a11' , nLine , '|a21|a22' , nLine , '|a31|a32|a33'.	text := 'a11' , nLine , 'a21	a22' , nLine , 'a31	a32	a33'.	tree := PRDocument new		add:				(PRTable new						add:								(PRTableRow new										add:												(PRTableCell new														add: (PRText content: 'a11');														yourself);										yourself);						add:								(PRTableRow new										add:												(PRTableCell new														add: (PRText content: 'a21');														yourself);										add:												(PRTableCell new														add: (PRText content: 'a22');														yourself);										yourself);						add:								(PRTableRow new										add:												(PRTableCell new														add: (PRText content: 'a31');														yourself);										add:												(PRTableCell new														add: (PRText content: 'a32');														yourself);										add:												(PRTableCell new														add: (PRText content: 'a33');														yourself);										yourself);						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRTableTest methodsFor: 'tests-parsing' stamp: 'damiencassou 7/23/2009 16:35'!testParseWithPreformattedAndLinkWithParameters	| wiki tree |	wiki := '|==\+link\|a\+==|'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new					add: (PRMonospaceFormat new						add: (PRText content: '+link|a+');						yourself);					yourself);				add: (PRTableCell new					yourself);				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.! !!PRTableTest methodsFor: 'tests-parsing' stamp: 'DamienCassou 9/24/2015 09:41'!testParseWithPreformattedAndProtectedPipe	| wiki tree |	wiki := '|==\|==|'.	tree := PRDocument new		add: (PRTable new			add: (PRTableRow new				add: (PRTableCell new				  					add: (PRMonospaceFormat new						add: (PRText content: '|');						yourself);								yourself);				add: (PRTableCell new					yourself);				yourself);			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.! !!PRDocumentItemTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ true! !!PRDocumentItemTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRDocumentItem! !!PRDocumentItemTest methodsFor: 'utilities' stamp: 'DamienCassou 2/10/2014 14:39'!addText: aString to: aDocumentItem	^ aDocumentItem		add: (PRText content: aString);		yourself! !!PRDocumentItemTest methodsFor: 'utilities' stamp: 'DamienCassou 2/27/2014 11:33'!assertTree: aDocument equalsText: aString	self assert: (PRTextWriter write: aDocument) = aString description: aString resumable: true! !!PRDocumentItemTest methodsFor: 'utilities' stamp: 'DamienCassou 9/24/2015 09:16'!assertTree: aDocument equalsWiki: aString	"Assert that traversing aDocument using the wiki writer results in aString."	self assert: (PRPillarWriter write: aDocument) = aString description: aString resumable: false! !!PRDocumentItemTest methodsFor: 'utilities' stamp: 'CyrilFerlicot 8/19/2015 13:26'!assertWiki: aString equalsTree: aDocument	"Assert that parsing aString results in aDocument."	self		assert: (self parser parse: aString) = aDocument		description: aString resumable: true! !!PRDocumentItemTest methodsFor: 'utilities' stamp: 'ThibaultArloing 7/19/2016 17:12'!assertWikiTransform: aString equalsTree: aDocument	"Assert that parsing aString results in aDocument."	self		assert:			(PRFileInclusion new				configuration:					(PRPillarConfiguration new						outputType: PRPillarWriter ;						disabledPhases: { #sections };						yourself);				start: (self parser parse: aString)) = aDocument		description: aString		resumable: true! !!PRDocumentItemTest methodsFor: 'private' stamp: 'lr 4/5/2007 14:32'!barInstance	^ PRText content: 'bar'! !!PRDocumentItemTest methodsFor: 'private' stamp: 'lr 4/5/2007 14:32'!fooInstance	^ PRText content: 'foo'! !!PRDocumentItemTest methodsFor: 'private' stamp: 'lr 3/9/2006 11:31'!foobarInstances	^ Array with: self fooInstance with: self barInstance! !!PRDocumentItemTest methodsFor: 'helper' stamp: 'DamienCassou 10/15/2015 11:34'!parser	^ PRDocument parser! !!PRDocumentItemTest methodsFor: 'tests-copying' stamp: 'lr 3/9/2006 11:31'!testCopy	self assert: self instance = self instance copy.	self assert: self instance hash = self instance copy hash.	self deny: self instance == self instance copy! !!PRDocumentItemTest methodsFor: 'tests-comparing' stamp: 'lr 3/9/2006 11:31'!testEqueal	self assert: self instance = self instance.	self assert: self instance = self actualInstance! !!PRDocumentItemTest methodsFor: 'tests-comparing' stamp: 'lr 3/9/2006 11:31'!testEquealNil	self deny: self instance isNil! !!PRDocumentItemTest methodsFor: 'tests-comparing' stamp: 'lr 3/9/2006 11:31'!testEquealOther	self deny: self instance = self fooInstance.	self deny: self instance = self barInstance! !!PRDocumentItemTest methodsFor: 'tests-testing' stamp: 'lr 3/9/2006 11:31'!testHasChildren	self deny: self instance hasChildren! !!PRDocumentItemTest methodsFor: 'tests-comparing' stamp: 'lr 3/9/2006 11:31'!testHash	self assert: self instance hash = self instance copy hash! !!PRDocumentItemTest methodsFor: 'tests' stamp: 'CyrilFerlicot 5/23/2015 20:09'!testIsHeader	self deny: self instance isHeader! !!PRDocumentItemTest methodsFor: 'tests' stamp: 'lr 3/30/2009 21:36'!testIsLink	self deny: self instance isLink! !!PRDocumentItemTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/3/2015 13:48'!testIsSlideBeginning	self deny: self instance isSlideBeginning! !!PRDocumentItemTest methodsFor: 'tests-accessing' stamp: 'lr 3/9/2006 11:31'!testText	self assert: self instance text isString! !!PRHorizontalRuleTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRHorizontalRuleTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRHorizontalRule! !!PRHorizontalRuleTest methodsFor: 'tests-parsing' stamp: 'lr 2/7/2007 16:42'!testParseBasic	| wiki text tree |	wiki := '_'.	text := self textString.	tree := PRDocument new		add: PRHorizontalRule new;		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRHorizontalRuleTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 15:59'!testParseLink	| wiki1 wiki2 text tree |	wiki1 := '_ *link*'.	wiki2 := '\_ *link*'.	text := '_ link'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: '_ ');			add: (PRInternalLink new				reference: 'link';				yourself);			yourself);		yourself.	self assertWiki: wiki1 equalsTree: tree.	self assertWiki: wiki2 equalsTree: tree.	self assertTree: tree equalsWiki: wiki2.	self assertTree: tree equalsText: text! !!PRHorizontalRuleTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:18'!testParseMultiple	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := '_' , nLine , '_' , nLine , nLine , '_'.	text := self textString , nLine , self textString , nLine , nLine , self textString.	tree := PRDocument new		add: PRHorizontalRule new;		add: PRHorizontalRule new;		add: PREmptyParagraph new;		add: PRHorizontalRule new;		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRHorizontalRuleTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:33'!testParseParagraph	| wiki text tree |	wiki := '\_ is parsed as paragraph'.	text := '_ is parsed as paragraph'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: '_ is parsed as paragraph');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRHorizontalRuleTest methodsFor: 'tests-parsing' stamp: 'nfr 9/26/2007 09:55'!testParseSpaces	| wiki text tree |	wiki := '_       '.	text := self textString.	tree := PRDocument new		add: PRHorizontalRule new;		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: '_'.	self assertTree: tree equalsText: text! !!PRHorizontalRuleTest methodsFor: 'private' stamp: 'lr 2/7/2007 16:42'!textString	^ String new: 40 withAll: $-! !!PRLineBreakTest class methodsFor: 'testing' stamp: 'lr 12/9/2007 09:24'!isAbstract	^ false! !!PRLineBreakTest methodsFor: 'private' stamp: 'lr 12/9/2007 09:24'!actualClass	^ PRLineBreak! !!PRLineBreakTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:18'!testParseOneEmptyLine	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := 'Lorem ipsum dolor sit amet.' , nLine , nLine , 'Nulla quis urna.'.	text := wiki.	tree := PRDocument new		add:				(PRParagraph new						add: (PRText content: 'Lorem ipsum dolor sit amet.');						yourself);		add: PREmptyParagraph new;		add: (PRParagraph new add: (PRText content: 'Nulla quis urna.') yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRLineBreakTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:18'!testParseTreeLines	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := 'Lorem ipsum dolor sit amet.' , nLine , 'Nulla quis urna.' , nLine , 'Vestibulum turpis.'.	text := wiki.	tree := PRDocument new		add:				(PRParagraph new						add: (PRText content: 'Lorem ipsum dolor sit amet.');						add: PRLineBreak new;						add: (PRText content: 'Nulla quis urna.');						add: PRLineBreak new;						add: (PRText content: 'Vestibulum turpis.');						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRLineBreakTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:19'!testParseTwoEmptyLines	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := 'Lorem ipsum dolor sit amet.' , nLine , nLine , nLine , 'Nulla quis urna.'.	text := wiki.	tree := PRDocument new		add:				(PRParagraph new						add: (PRText content: 'Lorem ipsum dolor sit amet.');						yourself);		add: PREmptyParagraph new;		add: PREmptyParagraph new;		add: (PRParagraph new add: (PRText content: 'Nulla quis urna.') yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: text.	self assertTree: tree equalsText: text! !!PRLineBreakTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:19'!testParseTwoLines	| wiki text tree |	wiki := 'Lorem ipsum dolor sit amet.' , Smalltalk os lineEnding , 'Nulla quis urna.'.	text := wiki.	tree := PRDocument new		add:				(PRParagraph new						add: (PRText content: 'Lorem ipsum dolor sit amet.');						add: PRLineBreak new;						add: (PRText content: 'Nulla quis urna.') yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRStructureTest methodsFor: 'private' stamp: 'ThibaultArloing 5/24/2016 17:00'!actualClass	^PRStructure! !!PRCommentedLineTest methodsFor: 'private' stamp: 'DamienCassou 3/5/2014 17:14'!actualClass	^ PRCommentedLine! !!PRCommentedLineTest methodsFor: 'tests-parsing' stamp: 'DamienCassou 3/5/2014 17:17'!testParseBasic	| wiki text tree |	wiki := '%some comment'.	text := ''.	tree := PRDocument new		add: (PRCommentedLine content: 'some comment');		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRCommentedLineTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:17'!testParseDontInterruptLists	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := '#item one' , nLine , '##item one-point-one' , nLine , '%comment' , nLine , '##item one-point-two'.	text := '1. item one' , nLine , '	1. item one-point-one' , nLine , '	2. item one-point-two'.	tree := PRDocument new		add:				(PROrderedList new						add:								(PRListItem new										add: (PRText content: 'item one');										add:												(PROrderedList new														add:																(PRListItem new																		add: (PRText content: 'item one-point-one');																		add: (PRCommentedLine content: 'comment');																		yourself);														add:																(PRListItem new																		add: (PRText content: 'item one-point-two');																		yourself);														yourself);										yourself);						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRCommentedLineTest methodsFor: 'tests-parsing' stamp: 'DamienCassou 3/5/2014 17:23'!testParseDontParseContent	| wiki text tree |	wiki := '%some *comment*'.	text := ''.	tree := PRDocument new		add: (PRCommentedLine content: 'some *comment*');		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRRawTest class methodsFor: 'testing' stamp: 'lr 2/2/2010 15:40'!isAbstract	^ false! !!PRRawTest methodsFor: 'private' stamp: 'DamienCassou 11/20/2013 17:18'!actualClass	^ PRRaw! !!PRRawTest methodsFor: 'tests-parsing' stamp: 'DamienCassou 11/20/2013 17:18'!testParseBasic	| wiki text tree |	wiki := '{{{abc}}}'.	text := 'abc'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'abc');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRRawTest methodsFor: 'tests-parsing' stamp: 'DamienCassou 11/20/2013 17:18'!testParseEmpty	| wiki text tree |	wiki := '{{{}}}'.	text := ''.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: '');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRRawTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:20'!testParseMultiline	| wiki text tree nLine|	nLine := Smalltalk os lineEnding.	wiki := '{{{a' , nLine , 'b}}}'.	text := 'a' , nLine , 'b'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'a' , nLine , 'b');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRRawTest methodsFor: 'tests-parsing' stamp: 'DamienCassou 11/20/2013 17:18'!testParseMultiple	| wiki text tree |	wiki := '{{{a}}}b{{{c}}}'.	text := 'abc'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'a');			add: (PRText content: 'b');			add: (PRRaw content: 'c');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRRawTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:20'!testParseMultipleMultiline	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := '{{{a' , nLine , 'b}}}c{{{d' , nLine , 'e}}}'.	text := 'a' , nLine , 'bcd' , nLine , 'e'.	tree := PRDocument new		add:				(PRParagraph new						add: (PRRaw content: 'a' , nLine , 'b');						add: (PRText content: 'c');						add: (PRRaw content: 'd' , nLine , 'e');						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRRawTest methodsFor: 'tests-parsing' stamp: 'DamienCassou 11/20/2013 17:18'!testParseStrange	| wiki text tree |	wiki := '{{{a{{||}}b}}}'.	text := 'a{{||}}b'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'a{{||}}b');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRRawTest methodsFor: 'tests-parsing' stamp: 'DamienCassou 11/20/2013 17:18'!testParseTypeHtml	| wiki text tree |	wiki := '{{{html:abc}}}'.	text := ''.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'abc' type: 'html');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRRawTest methodsFor: 'tests-parsing' stamp: 'DamienCassou 11/20/2013 17:18'!testParseTypeLatex	| wiki text tree |	wiki := '{{{latex:abc}}}'.	text := ''.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'abc' type: 'latex');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRRawTest methodsFor: 'tests-parsing' stamp: 'DamienCassou 11/20/2013 17:18'!testParseTypeText	| wiki text tree |	wiki := '{{{text:abc}}}'.	text := 'abc'.	tree := PRDocument new		add: (PRParagraph new			add: (PRRaw content: 'abc' type: 'text');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRRawTest methodsFor: 'tests-accessing' stamp: 'lr 2/2/2010 16:01'!testText	self instance text: 'zork'.	self assert: self instance text = 'zork'! !!PRRawTest methodsFor: 'tests-accessing' stamp: 'lr 9/25/2011 13:37'!testType	self instance type: 'html'.	self assert: self instance type = 'html'! !!PRScriptTest class methodsFor: 'testing' stamp: 'DamienCassou 1/8/2014 17:57'!isAbstract	^ false! !!PRScriptTest methodsFor: 'private' stamp: 'DamienCassou 1/8/2014 17:57'!actualClass	^ PRScript! !!PRScriptTest methodsFor: 'tests' stamp: 'CyrilFerlicot 4/10/2015 11:00'!testEqualScript	self deny: (self actualClass content: 'foo') = (self actualClass content: 'bar').	self assert: (self actualClass content: 'foo') = (self actualClass content: 'foo')! !!PRScriptTest methodsFor: 'tests' stamp: 'YannDubois 5/2/2016 14:41'!testEqualScriptWithLanguage	| param1 param2 |	param1 := SmallDictionary new		at: 'language' put: 'smalltalk';		yourself.	param2 := SmallDictionary new		at: 'language' put: 'html';		yourself.	self		deny:			(self actualClass content: 'foo' parameters: param1)				= (self actualClass content: 'foo' parameters: param2).	self		assert:			(self actualClass content: 'foo' parameters: param1)				= (self actualClass content: 'foo' parameters: param1)! !!PRScriptTest methodsFor: 'tests-comparing' stamp: 'CyrilFerlicot 4/7/2015 14:09'!testHash	| a b |	a := self actualClass content: 'foo'.	b := self actualClass content: 'foo'.	self assert: a hash = a copy hash.	self assert: a hash = b hash! !!PRScriptTest methodsFor: 'tests' stamp: 'ThibaultArloing 5/9/2016 10:11'!testIsStructure	| ston nLine script |	nLine := Smalltalk os lineEnding.	ston := '[[[structure=Test' , nLine , 'Foo' , nLine , ']]]'.	script := (self parser parse: ston) children first.	self assert: script isStructure! !!PRScriptTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 9/25/2015 01:08'!testParseEscape	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := '[[[language=foo\|' , nLine , 'foo' , nLine , ']]]'.	text := 'foo'.	tree := PRDocument new		add:			((PRScript content: 'foo')				language: 'foo|';				yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRScriptTest methodsFor: 'tests-parsing' stamp: 'DamienCassou 1/10/2014 16:13'!testParseLanguage! !!PRScriptTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 9/25/2015 01:08'!testParseRealLanguage	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := '[[[language=smalltalk' , nLine , 'foo' , nLine , ']]]'.	text := 'foo'.	tree := PRDocument new		add:			((PRScript content: 'foo')				language: PRSmalltalkScriptLanguage default;				yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRScriptTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 9/25/2015 01:08'!testParseSimple	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := '[[[' , nLine , 'foo' , nLine , ']]]'.	text := 'foo'.	tree := PRDocument new		add: (PRScript content: 'foo');		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRScriptTest methodsFor: 'tests-parsing' stamp: 'DamienCassou 6/3/2014 11:36'!testParseSimpleOn1Line	"This test does *not* specify a valid usage of script. This test is here to ensure that there is a sensible default when writing invalid Pillar text."	| wiki text tree |	wiki := '[[[foo]]]'.	text := '[[[foo]]]'.	tree := PRDocument new		add: (self addText: '[[[foo]]]' to: PRParagraph new);		yourself.	self assertWiki: wiki equalsTree: tree.	! !!PRScriptTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 9/25/2015 01:09'!testParseWithSimpleCaption	| wiki text tree nLine |	nLine := Smalltalk os lineEnding.	wiki := '[[[caption=foo' , nLine , 'foo' , nLine , ']]]'.	text := 'foo'.	tree := PRDocument new		add:			((PRScript content: 'foo')				caption: 'foo';				yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRScriptTest methodsFor: 'tests' stamp: 'ThibaultArloing 5/9/2016 10:11'!testStructureName	| ston nLine script |	nLine := Smalltalk os lineEnding.	ston := '[[[structure=Test' , nLine , 'Foo' , nLine , ']]]'.	script := (self parser parse: ston) children first.	self assert: script structureName equals: 'Test'! !!PRTextTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ false! !!PRTextTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRText! !!PRTextTest methodsFor: 'tests-instantiation' stamp: 'lr 4/5/2007 14:41'!testContent	instance := self actualClass content: 'zork'.	self assert: self instance text = 'zork'! !!PRTextTest methodsFor: 'tests-comparing' stamp: 'lr 4/5/2007 14:43'!testEqualText	self deny: (self actualClass content: 'foo') = (self actualClass content: 'bar')! !!PRTextTest methodsFor: 'tests-parsing' stamp: 'lr 9/4/2009 17:04'!testEscapeCpp	| wiki tree |	wiki := 'Text: \+\+'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: 'Text: ++');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki! !!PRTextTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:17'!testEscapeFirst	| wiki tree nLine |	nLine := Smalltalk os lineEnding.	wiki := '\* text' , nLine , '\+ text' , nLine , '\= text' , nLine , '\@ text' , nLine , '\!! text' , nLine , '\| text'		, nLine , '\# text' , nLine , '\- text'.	tree := PRDocument new		add:				(PRParagraph new						add: (PRText content: '* text');						add: PRLineBreak new;						add: (PRText content: '+ text');						add: PRLineBreak new;						add: (PRText content: '= text');						add: PRLineBreak new;						add: (PRText content: '@ text');						add: PRLineBreak new;						add: (PRText content: '!! text');						add: PRLineBreak new;						add: (PRText content: '| text');						add: PRLineBreak new;						add: (PRText content: '# text');						add: PRLineBreak new;						add: (PRText content: '- text');						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki! !!PRTextTest methodsFor: 'tests-parsing' stamp: 'CyrilFerlicot 5/23/2015 19:17'!testEscapeStrange	| wiki tree |	wiki := '< text' , Smalltalk os lineEnding , '> text'.	tree := PRDocument new		add:				(PRParagraph new						add: (PRText content: '< text');						add: PRLineBreak new;						add: (PRText content: '> text');						yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki! !!PRTextTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:37'!testEscapeText	| wiki tree |	wiki := 'Text: \*\+'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: 'Text: *+');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki! !!PRTextTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:39'!testEscapeWiki	| wiki tree |	wiki := 'Wiki: =, |, !!, #, {, }, |{, ||, |}, [, ] and -'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: 'Wiki: =, |, !!, #, {, }, |{, ||, |}, [, ] and -');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki! !!PRTextTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:39'!testParseBasic	| wiki tree |	wiki := 'abcdefghijklmnopqrstuvwxyz... ABCDEFGHIJKLMNOPQRSTUVWXYZ... 0123456789...'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: 'abcdefghijklmnopqrstuvwxyz... ABCDEFGHIJKLMNOPQRSTUVWXYZ... 0123456789...');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki! !!PRTextTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:40'!testParseHtml	| wiki tree |	wiki := '<strong>strong <emph>strong, emph</emph></strong>'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: '<strong>strong <emph>strong, emph</emph></strong>');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki! !!PRTextTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:40'!testParseLatex	| wiki text tree |	wiki := '\\begin{foo}[bar]$zork$\\end{foo}'.	text := '\begin{foo}[bar]$zork$\end{foo}'.	tree := PRDocument new		add: (PRParagraph new			add: (PRText content: '\begin{foo}[bar]$zork$\end{foo}');			yourself);		yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki.	self assertTree: tree equalsText: text! !!PRTextTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:40'!testParseSpecial	| wiki tree |	wiki := '???????????????????????????????????????????????'.	tree := (PRDocument new)				add: ((PRParagraph new)							add: (PRText										content: '???????????????????????????????????????????????');							yourself);				yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki! !!PRTextTest methodsFor: 'tests-parsing' stamp: 'lr 4/5/2007 14:40'!testParseWiki	| wiki tree |	wiki := ' !!_#-|=]@:<>\*'.	tree := (PRDocument new)				add: ((PRParagraph new)							add: (PRText content: ' !!_#-|=]@:<>*');							yourself);				yourself.	self assertWiki: wiki equalsTree: tree.	self assertTree: tree equalsWiki: wiki! !!PRTextTest methodsFor: 'tests-printing' stamp: 'DamienCassou 3/20/2014 18:04'!testPrinting	| text |	text := PRText content: 'abcdef'.	'*abcdef*' match: text printString! !!PRTextTest methodsFor: 'tests-accessing' stamp: 'lr 3/9/2006 11:31'!testText	self instance text: 'zork'.	self assert: self instance text = 'zork'! !!PRObjectTest class methodsFor: 'testing' stamp: 'lr 3/30/2007 22:22'!isAbstract	^ true! !!PRObjectTest class methodsFor: 'accessing' stamp: 'DamienCassou 10/8/2013 09:37'!packageNamesUnderTest	^ #('Pillar-Model')! !!PRObjectTest class methodsFor: 'testing' stamp: 'lr 3/9/2006 11:31'!shouldInheritSelectors	^ true! !!PRObjectTest methodsFor: 'private' stamp: 'lr 3/30/2007 22:22'!actualClass	^ PRObject! !!PRObjectTest methodsFor: 'private' stamp: 'DamienCassou 2/5/2014 14:23'!actualInstance	^ self actualClass new! !!PRObjectTest methodsFor: 'accessing' stamp: 'DamienCassou 2/5/2014 14:21'!instance	^ instance! !!PRObjectTest methodsFor: 'running' stamp: 'DamienCassou 2/5/2014 14:23'!setUp	super setUp.	instance := self actualInstance! !!PRObjectTest methodsFor: 'tests-copying' stamp: 'lr 6/22/2008 18:24'!testCopyProperties	self deny: self instance properties == self instance copy properties! !!PRObjectTest methodsFor: 'tests-properties' stamp: 'lr 3/9/2006 11:31'!testProperties	self assert: self instance properties notNil.	self instance instVarNamed: 'properties' put: nil.	self instance propertyAt: #foo put: #bar.	self instance instVarNamed: 'properties' put: nil.	self instance propertyAt: #foo ifAbsent: [ nil ].	self instance instVarNamed: 'properties' put: nil.	self instance propertyAt: #foo ifAbsentPut: [ #bar ].	self instance instVarNamed: 'properties' put: nil.	self instance hasProperty: #foo.	self instance instVarNamed: 'properties' put: nil! !!PRObjectTest methodsFor: 'tests-properties' stamp: 'DamienCassou 10/28/2013 16:47'!testPropertiesAt	self assert: (self instance propertyAt: #foo put: 'bar') = 'bar'.	self assert: (self instance propertyAt: #foo) = 'bar'.	self should: [ self instance propertyAt: #bar ] raise: PRPropertyError! !!PRObjectTest methodsFor: 'tests-properties' stamp: 'lr 3/9/2006 11:31'!testPropertiesAtIfAbsent	self assert: (self instance propertyAt: #foo put: 'bar') = 'bar'.	self assert: (self instance propertyAt: #foo ifAbsent: [ 'baz' ]) = 'bar'.	self assert: (self instance propertyAt: #bar ifAbsent: [ 'baz' ]) = 'baz'! !!PRObjectTest methodsFor: 'tests-properties' stamp: 'lr 3/9/2006 11:31'!testPropertiesAtIfAbsentPut	self assert: (self instance propertyAt: #foo put: 'bar') = 'bar'.	self assert: (self instance propertyAt: #foo ifAbsentPut: [ 'baz' ]) = 'bar'.	self assert: (self instance propertyAt: #foo) = 'bar'.	self assert: (self instance propertyAt: #bar ifAbsentPut: [ 'baz' ]) = 'baz'.	self assert: (self instance propertyAt: #bar) = 'baz'! !!PRObjectTest methodsFor: 'tests-properties' stamp: 'lr 3/9/2006 11:31'!testPropertiesAtPut	self instance propertyAt: #foo put: 'bar'.	self assert: (self instance propertyAt: #foo) = 'bar'.	self instance propertyAt: #foo put: 'baz'.	self assert: (self instance propertyAt: #foo) = 'baz'! !!PRObjectTest methodsFor: 'tests-properties' stamp: 'lr 3/9/2006 11:31'!testPropertiesHas	self deny: (self instance hasProperty: #foo).	self instance propertyAt: #foo put: 'bar'.	self assert: (self instance hasProperty: #foo).	self deny: (self instance hasProperty: #bar)! !!PRObjectTest methodsFor: 'tests' stamp: 'lr 3/9/2006 11:31'!testSanity	"If this test case fails, there is something wrong with the setup of the test-case."	self		assert: self actualClass isAbstract not		description: 'Unable to test abstract class.'.	self		assert: self instance class = self actualClass		description: 'Invalid test instance.'! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'private' stamp: 'CyrilFerlicot 6/11/2015 10:30'!actualClass	^ PRAssociateAnchorToSlideNumber! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testVisitDocumentWithFigure	| item dictionary config |	item := PRDocument new		add:				(PRFigure new						reference: 'file://picture.png';						parameterAt: 'label' put: 'foo';						yourself);		yourself.	dictionary := Dictionary with: 'foo' -> 1.	config := PRPillarConfiguration new renderStructureAsSlide: false; yourself.	self		assert:			(self actualInstance				configuration: config;				start: item)		equals: dictionary! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testVisitDocumentWithScript	| item dictionary config |	item := PRDocument new		add:				((PRScript content: '|test| test := test')						label: 'foo';						yourself);		yourself.	dictionary := Dictionary with: 'foo' -> 1.	config := PRPillarConfiguration new renderStructureAsSlide: false; yourself.	self		assert:			(self actualInstance				configuration: config;				start: item)		equals: dictionary! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testVisitDocumentWithSlideWithLabel	| item dictionary config |	item := PRDocument new		add: (PRSlide new label: 'foo');		yourself.	dictionary := Dictionary with: 'foo' -> 2.	config := PRPillarConfiguration new renderStructureAsSlide: false; yourself.	self		assert:			(self actualInstance				configuration: config;				start: item)		equals: dictionary! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testVisitWithSlideInTemplate	| item dictionary config |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'Foo'));		add: (PRAnchor named: 'Bar');		add:				(PRSlide new						add: (PRAnchor named: 'bar');						yourself) yourself.	dictionary := Dictionary with: 'Bar' -> 3 with: 'bar' -> 4.	config := PRPillarConfiguration new		renderStructureAsSlide: true;		slideInTemplateForDeckJS: 2; yourself.	self		assert:			(self actualInstance				configuration: config;				start: item)		equals: dictionary! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testVisitWithSlideWithHeaderRendering	| item dictionary config |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'Foo'));		add: (PRAnchor named: 'Bar');		add:				(PRSlide new						add: (PRAnchor named: 'bar');						yourself) yourself.	dictionary := Dictionary with: 'Bar' -> 2 with: 'bar' -> 3.	config := PRPillarConfiguration new renderStructureAsSlide: true; yourself.	self		assert:			(self actualInstance				configuration: config;				start: item)		equals: dictionary! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testVisitWithSlideWithoutHeaderRendering	| item dictionary config |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'Foo'));		add: (PRAnchor named: 'Bar');		add:				(PRSlide new						add: (PRAnchor named: 'bar');						yourself) yourself.	dictionary := Dictionary with: 'Bar' -> 1 with: 'bar' -> 2.	config := PRPillarConfiguration new renderStructureAsSlide: false; yourself.	self		assert:			(self actualInstance				configuration: config;				start: item)		equals: dictionary! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testVisitWithoutSlideWithHeaderRendering	| item dictionary config |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'Foo'));		add: (PRAnchor named: 'Bar');		yourself.	dictionary := Dictionary with: 'Bar' -> 2.	config := PRPillarConfiguration new renderStructureAsSlide: true; yourself.	self		assert:			(self actualInstance				configuration: config;				start: item)		equals: dictionary! !!PRAssociateAnchorToSlideNumberTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testVisitWithoutSlideWithoutHeaderRendering	| item dictionary config |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'Foo'));		add: (PRAnchor named: 'Bar');		yourself.	dictionary := Dictionary with: 'Bar' -> 1.	config := PRPillarConfiguration new renderStructureAsSlide: false; yourself.	self		assert:			(self actualInstance				configuration: config;				start: item)		equals: dictionary! !!PRFileDependenciesTest methodsFor: 'private' stamp: 'YannDubois 4/25/2016 16:42'!actualClass	^ PRFileDependencies ! !!PRFileDependenciesTest methodsFor: 'tests' stamp: 'YannDubois 4/26/2016 15:51'!testDocumentWithFigure	| item set |	item := PRDocument new		add:			(PRFigure new				reference: 'file://foo.png';				yourself);		yourself.	set := Set new.	self		assert: (self actualInstance start: item)		equals: set! !!PRFileDependenciesTest methodsFor: 'tests' stamp: 'YannDubois 4/26/2016 15:43'!testDocumentWithFile	| item set |	item := PRDocument new		add:			(PRInternalLink new				reference: 'file://foo.pillar';				yourself);		yourself.	set := Set with: 'foo.pillar'.	self		assert: (self actualInstance start: item)		equals: set! !!PRImageDependenciesTest methodsFor: 'private' stamp: 'YannDubois 4/25/2016 16:18'!actualClass	^ PRImageDependencies ! !!PRImageDependenciesTest methodsFor: 'tests' stamp: 'YannDubois 4/26/2016 15:43'!testDocumentWithFigure	| item set |	item := PRDocument new		add:			(PRFigure new				reference: 'file://picture.png';				parameterAt: 'label' put: 'foo';				yourself);		yourself.	set := Set with: 'picture.png'.	self		assert: (self actualInstance start: item)		equals: set! !!PRVisitorTest class methodsFor: 'testing' stamp: 'DamienCassou 4/5/2015 10:24'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self = PRVisitorTest! !!PRVisitorTest methodsFor: 'private' stamp: 'DamienCassou 4/5/2015 10:23'!actualClass	^ PRVisitor! !!PRVisitorTest methodsFor: 'helpers' stamp: 'DamienCassou 4/5/2015 10:31'!addText: aString to: aDocumentItem	^ aDocumentItem		add: (PRText content: aString);		yourself! !!PRScriptLanguageTest methodsFor: 'tests' stamp: 'CyrilFerlicot 4/8/2015 10:34'!testEquals	self assert: (PRAbstractScriptLanguage for: 'smalltalk') = (PRAbstractScriptLanguage for: 'smalltalk')! !!PRScriptLanguageTest methodsFor: 'tests' stamp: 'DamienCassou 3/20/2014 17:57'!testFinding	self assert: (PRAbstractScriptLanguage concreteClassFor: '') equals: PRNoScriptLanguage.	self assert: (PRAbstractScriptLanguage concreteClassFor: '') default isSpecified.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'no language') equals: PRNoScriptLanguage.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'no language') default isSpecified.	self assert: (PRAbstractScriptLanguage concreteClassFor: nil) equals: PRUnspecifiedScriptLanguage.	self assert: (PRAbstractScriptLanguage concreteClassFor: nil) default isSpecified not.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'smalltalk') equals: PRSmalltalkScriptLanguage.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'smalltalk') default isSpecified.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'html') equals: PRHTMLScriptLanguage.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'html') default isSpecified.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'HTML') equals: PRHTMLScriptLanguage.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'HTML') default isSpecified.	self assert: (PRAbstractScriptLanguage concreteClassFor: 'non existing language foobar') equals: PRUnsupportedScriptLanguage .	self assert: (PRAbstractScriptLanguage concreteClassFor: 'non existing language foobar') new isSpecified not.! !!PRMockForParameters methodsFor: 'accessing-parameters' stamp: 'CyrilFerlicot 4/29/2015 13:22' prior: 35545696!parameters	^ parameters! !!PRMockForParameters methodsFor: 'accessing' stamp: 'CyrilFerlicot 7/1/2015 13:39'!parameters: aCollection	parameters := aCollection! !!PRMockAnnotation class methodsFor: 'protected' stamp: 'CyrilFerlicot 6/30/2015 17:04'!tag	^ #mock! !!PRMockAnnotation methodsFor: 'acessing-magritte' stamp: 'CyrilFerlicot 6/30/2015 17:09'!descriptionNumber	<magritteDescription>	^ MANumberDescription new		accessor: #number;		min: 0 max: 10;		yourself! !!PRMockAnnotation methodsFor: 'acessing-magritte' stamp: 'CyrilFerlicot 6/30/2015 17:06'!descriptionValue	<magritteDescription>	^ MAStringDescription new		accessor: #value;		required: true;		yourself! !"Pillar-Tests-Model"!!PRTSliderWriterTest commentStamp: 'CyrilFerlicot 6/4/2015 18:19' prior: 0!I am a class of trait used to test different exporter of slide. (e.g. Beamer exporter, DeckJS exporter etc...)!!PRMockWriter commentStamp: 'DamienCassou 2/28/2014 09:38' prior: 0!I'm a class responsible for mimicking the behavior of a document writer. I'm useful for some testing classes that need a stupid writer.!!PRDocumentWriterTest commentStamp: 'DamienCassou 2/28/2014 09:35' prior: 0!I provide abstract tests and helper methods to test the subclasses of PRDocumentWriter.!!PRManualNumberingWriterTest commentStamp: 'DamienCassou 2/28/2014 09:34' prior: 0!Abstract writer to facilitate the job of writers that need their headers/figures/scripts to be numbered. My subclasses include the html and markdown writers. On the contrary, the latex writer relies on the latex engine to number these elements automatically.!!PRNodeTransformerTest commentStamp: 'DamienCassou 7/20/2016 16:30' prior: 0!Abstract class that should be subclassed for all subclasses of PRNodeTransformer.!!PRCascadingCounterTest commentStamp: 'DamienCassou 2/28/2014 09:36' prior: 0!I test the PRCascadingCounter class.!!PRTransformPipelineTest commentStamp: 'DamienCassou 7/21/2016 11:27' prior: 0!Tests for PRTransformPipeline!!PRTSliderWriterTest methodsFor: 'private' stamp: 'CyrilFerlicot 6/4/2015 18:20'!actualClass	^ self explicitRequirement! !!PRTSliderWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/4/2015 18:24'!endSlideTag	^ self explicitRequirement! !!PRTSliderWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/5/2015 15:48'!headerInSlide	"I return one string that define a header rendering in a slide."	^ self explicitRequirement! !!PRTSliderWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/5/2015 17:24'!representationOfAnchor	"I return a string which reprensent an anchor in the slider format."	^ self explicitRequirement! !!PRTSliderWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/4/2015 18:21'!slideRepresentation	^ self explicitRequirement! !!PRTSliderWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/5/2015 16:09'!slideTitle	"I return a collection with an explicite rendering of a slide title."	^ self explicitRequirement! !!PRTSliderWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/4/2015 18:21'!testExport1SimpleSlide	"self debug: #testExportSlideTitle"	| item |	item := PRDocument new		add: (PRSlide titled: 'Slide title');		add: (PRText content: 'Presentation text');		yourself.	self		assertWriting: item		includesTexts: self slideRepresentation.! !!PRTSliderWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/4/2015 18:24'!testExport2SlidesCloseAllFrames	"self debug: #testExportSlideTitle"	| item resultString index |	item := PRDocument new		add: (PRSlide titled: 'Slide 1');		add: (PRSlide titled: 'Slide 2');		yourself.	resultString := self write: item.	index := resultString findString: self endSlideTag startingAt: 0.	self assert: index > 0.	index := resultString findString: self endSlideTag startingAt: index + 1.	self assert: index > 0! !!PRTSliderWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/5/2015 15:47'!testRenderStructureAsSlide	| item |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'Foo');						yourself);		add: (PRSlide titled: 'Slide');		yourself.	self configuration renderStructureAsSlide: true.	self assertWriting: item includesTexts: {(self headerInSlide)}.	self configuration renderStructureAsSlide: false.	self deny: [ (self write: item) includesSubstring: self headerInSlide ]! !!PRTSliderWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/5/2015 16:09'!testTitleOfSlide	"self debug: #testExportSlideTitle"	| item |	item := PRDocument new		add: (PRSlide titled: 'Slide title');		yourself.	self		assertWriting: item		includesTexts: self slideTitle.! !!PRTSliderWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/5/2015 17:25'!testslideWithLabel	"self debug: #testExportSlideTitle"	| item |	item := PRDocument new		add:				((PRSlide titled: 'Slide title')						label: 'Foo';						yourself);		yourself.	self assertWriting: item includesTexts: {(self representationOfAnchor)}! !!PRPillarConfigurationTest methodsFor: 'helper' stamp: 'YannDubois 6/1/2016 11:03'!jsonStreamWithContent: aString	| expected |	expected := '' writeStream		<< '{';		<< '"content":"';		<< aString;		<< '"}';		yourself.	^ expected! !!PRPillarConfigurationTest methodsFor: 'helper' stamp: 'CyrilFerlicot 3/31/2015 16:58'!mockWriterClass	^ PRMockWriter ! !!PRPillarConfigurationTest methodsFor: 'accessing' stamp: 'CyrilFerlicot 3/31/2015 16:58'!packageNamesUnderTest	^ #('Pillar-ExporterCore')! !!PRPillarConfigurationTest methodsFor: 'running' stamp: 'CyrilFerlicot 3/31/2015 16:58'!setUp	super setUp.	baseDirectory := FileSystem memory root! !!PRPillarConfigurationTest methodsFor: 'helper' stamp: 'PavelKrivanek 10/16/2015 12:08'!someUnicodeString	^ 'Pli luouk k pl belsk dy.'! !!PRPillarConfigurationTest methodsFor: 'tests' stamp: 'YannDubois 6/1/2016 11:26'!testAsJsonWithTitle	| conf expected |	conf := PRPillarConfiguration new		title: 'titre';		yourself.	expected := '' writeStream		<< '{';		<< '"title":';		<< '"titre"';		<< '}';		yourself.	self assert: conf asJson equals: expected contents! !!PRPillarConfigurationTest methodsFor: 'tests' stamp: 'YannDubois 6/1/2016 11:01'!testAsJsonWithTitleWithAutoAnchor	| conf expected |	conf := PRPillarConfiguration new		title: 'titre';		autoAnchor: true;		yourself.	expected := '' writeStream		<< '{';		<< '"title":';		<< '"titre",';		<< '"autoAnchor":';		<< 'true';		<< '}';		yourself.	self assert: conf asJson equals: expected contents! !!PRPillarConfigurationTest methodsFor: 'tests' stamp: 'YannDubois 6/1/2016 11:26'!testAsJsonWithoutProperties	| conf expected |	conf := PRPillarConfiguration new.	expected := '' writeStream		<< '{';		<< '}';		yourself.	self assert: conf asJson equals: expected contents! !!PRPillarConfigurationTest methodsFor: 'tests' stamp: 'YannDubois 6/1/2016 11:01'!testDefaultConfigurationsExistsWithOthersConfigurations	"I check that, when womeone creatd a new subconfiguration, the defaults configurations still exists."	| ston output expected |	ston := '{		"support": [  ],		"configurations":{			"foo": { 				"outputType": #mock			 }		}}'.	output := ('' writeStream).	expected := ('' writeStream) << '{'; << '"content":"Test"'; << '}'.		(PRPillarConfiguration newFromString: ston)		inputString: 'Test';		outputStream: output;		export: 'mock'.	self assert: output contents equals: (expected contents)! !!PRPillarConfigurationTest methodsFor: 'tests' stamp: 'DamienCassou 4/11/2016 15:42'!testDescriptionOutputDirectoryAcceptsNotYetCreatedDirectories		| directory |	directory := FileLocator imageDirectory / UUID new printString.	self deny: directory exists.	self shouldnt: [ PRPillarConfiguration new outputDirectory: directory ] raise: Error.! !!PRPillarConfigurationTest methodsFor: 'tests' stamp: 'LukasKomarek 4/5/2016 18:36'!testDescriptionOutputDirectoryAllowsDirsOnly		| directory |	directory := FileLocator imageDirectory.	self shouldnt: [ PRPillarConfiguration new outputDirectory: directory ] raise: Error.	directory := Smalltalk imageFile.	self should: [ PRPillarConfiguration new outputDirectory: directory ] raise: Error.! !!PRPillarConfigurationTest methodsFor: 'tests' stamp: 'LukasKomarek 4/5/2016 18:40'!testDescriptionOutputDirectoryAllowsKindAbstractFileReference	self shouldnt: 		[ PRPillarConfiguration new outputDirectory: FileLocator imageDirectory ]		raise: Error.	self shouldnt:		[ PRPillarConfiguration new outputDirectory: FileLocator imageDirectory asFileReference ]		raise: Error! !!PRPillarConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testLevelIsGood	| configuration header |	configuration := PRPillarConfiguration new.	configuration		level1:			((PRLevelNumberConfiguration with: (Dictionary with: 'numbering' -> true))				level: 1;				configuration: configuration;				yourself).	configuration		level2:			((PRLevelNumberConfiguration with: (Dictionary with: 'numbering' -> false))				level: 2;				configuration: configuration;				yourself).	header := PRHeader new		level: 2;		add: (PRText content: 'foo');		yourself.	self deny: (configuration levelConfigurationFor: header) numbering! !!PRPillarConfigurationTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:56'!testRelativePathFromFile	| confFile configuration |	FileSystem workingDirectory / 'fileForTest1.pillar' writeStreamDo: [ :stream | stream nextPutAll: 'foo' ].	confFile := FileSystem workingDirectory / 'pillar.conf'.	confFile writeStreamDo: [ :stream | stream nextPutAll: '{ #inputFile : "fileForTest1.pillar" }' ].	configuration := PRPillarConfiguration newFromFile: confFile.	self assert: configuration inputFile exists.	(FileSystem workingDirectory / 'fileForTest1.pillar') ensureDelete.	(FileSystem workingDirectory / 'pillar.conf') ensureDelete! !!PRPillarConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testSubNoInfiniteRecursion	PRPillarConfiguration new subConfigurationNamed: self mockWriterClass writerName	"If this tests terminates, it passes :-). I tried to use #should:notTakeMoreThan: but it failed on Jenkins"! !!PRPillarConfigurationTest methodsFor: 'tests' stamp: 'YannDubois 6/9/2016 10:58'!testSupportFilesWithFolderInsideOutputDirectoryAreNotExported	"I check that, when womeone creatd a new subconfiguration, the defaults configurations still exists."	| ston folder config |	folder := FileSystem memory root.	(folder / 'bar') ensureCreateDirectory.	(folder / 'bar' / 'foo.html') ensureCreateFile.	ston := '{		"support": [ "bar/foo.html" ],		"outputDirectory": "bar"}'.	config := PRPillarConfiguration new		baseDirectory: folder;		yourself.	CCMagritteDictionaryReader		writeDictionary: (STON fromString: ston)		toConfiguration: config.	config		inputString: 'Test';		outputStream: String new writeStream;		export: #text.	self assert: (folder / 'bar' / 'bar' / 'foo.html') exists not! !!PRPillarConfigurationTest methodsFor: 'tests' stamp: 'DamienCassou 6/22/2016 10:48'!testUTFInputFromDiskFile	| fileName file output expected |	fileName := UUID new asString , '.pillar'.	file := FileSystem disk workingDirectory / fileName.	file		writeStreamDo: [ :input | 			| znWriteStream |			znWriteStream := ZnCharacterWriteStream on: input binary.			znWriteStream nextPutAll: self someUnicodeString ].	output := String		streamContents: [ :s | 			PRPillarConfiguration new				inputFile: file;				outputStream: s;				outputType: PRTextWriter;				export ].		expected := self jsonStreamWithContent: (self someUnicodeString ).			file ensureDelete.	self assert: output equals: expected contents! !!PRPillarConfigurationTest methodsFor: 'tests' stamp: 'DamienCassou 6/22/2016 10:48'!testUTFInputFromMemoryFile		| fileName file output expected |		fileName := UUID new asString, '.pillar'.	file := FileSystem memory workingDirectory / fileName.	file writeStreamDo: [ :input |		| znWriteStream |		znWriteStream := ZnCharacterWriteStream on: input binary.		znWriteStream nextPutAll: self someUnicodeString ].	output := String streamContents: [ :s |		PRPillarConfiguration new			inputFile: file;			outputType: PRTextWriter;			outputStream: s;			export.	].		file ensureDelete.		expected := self jsonStreamWithContent: (self someUnicodeString ).		self assert: output equals: expected contents.! !!PRPillarConfigurationTest methodsFor: 'tests' stamp: 'ThibaultArloing 4/18/2016 17:16'!testUTFInputString		| output expected |		output := String streamContents: [ :s |		PRPillarConfiguration new			inputString: self someUnicodeString;			outputType: PRTextWriter;			outputStream: s;			export.	].		expected := self jsonStreamWithContent: (self someUnicodeString ).		self assert: output equals: expected contents.! !!PRPillarConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testWithUndefinedConfigurationDefault	(PRPillarConfiguration newFromString: '{}')		inputString: 'input';		export: 'mock'! !!PRPillarConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testWithUndefinedConfigurationNotDefault	self should: [ (PRPillarConfiguration newFromString: '{}')							export: 'not existing' ] raise: PRConfigurationError! !!PRMockWriter class methodsFor: 'accessing' stamp: 'DamienCassou 1/8/2014 10:45'!fileExtension	^ 'mock'! !!PRMockWriter class methodsFor: 'accessing' stamp: 'CyrilFerlicot 7/11/2015 19:47'!writerName	^ #mock! !!PRMockWriter methodsFor: 'accessing' stamp: 'DamienCassou 6/4/2014 17:24'!canvasClass	^ PRExportCanvas! !!PRCheckPhaseTest class methodsFor: 'testing' stamp: 'DamienCassou 7/13/2016 16:59'!isAbstract	^self = PRCheckPhaseTest ! !!PRCheckRawTest methodsFor: 'as yet unclassified' stamp: 'YannDubois 5/24/2016 11:17'!actualClass	^ PRCheckRaw ! !!PRCheckRawTest methodsFor: 'as yet unclassified' stamp: 'AutoDeprecationRefactoring 7/18/2016 14:18'!testCheckRawWithGoodType	| input |	input := PRDocument new		add:			(PRParagraph new				add: (PRRaw content: '<p>Timoleon</p>' type: 'html');				yourself);		yourself.	self		assert:			(self actualClass				executeOn:					(PRCompilationContext						withDocument: input						withConfiguration: PRPillarConfiguration new)) input		equals: input! !!PRCheckRawTest methodsFor: 'as yet unclassified' stamp: 'YannDubois 7/13/2016 16:05'!testCheckRawWithWrongType	| input |	input := PRDocument new		add:			(PRParagraph new				add: (PRRaw content: 'bar' type: 'foo');				yourself);		yourself.	self		should: [ self actualClass executeOn: (PRCompilationContext withDocument: input withConfiguration: PRPillarConfiguration new ) ]		raise: PRWarning! !!PRDocumentWriterTest class methodsFor: 'testing' stamp: 'DamienCassou 2/28/2014 09:31'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self name = #PRDocumentWriterTest! !!PRDocumentWriterTest methodsFor: 'private' stamp: 'DamienCassou 2/28/2014 09:28'!actualClass	^ PRDocumentWriter! !!PRDocumentWriterTest methodsFor: 'private' stamp: 'DamienCassou 2/5/2014 14:26'!actualInstance	^  self createWriterOn: String new! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'BenComan 6/2/2014 17:18'!annotation		^ self shouldBeImplemented.  ! !!PRDocumentWriterTest methodsFor: 'asserting' stamp: 'DamienCassou 2/26/2014 17:17'!assert: result includesSubstring: expected	expected isEmpty ifTrue: [ ^ self ].	self		assert: (result includesSubstring: expected)		description:			('''{1}'' not in ''{2}'''				format:					{expected.					result})! !!PRDocumentWriterTest methodsFor: 'asserting' stamp: 'DamienCassou 11/21/2013 11:22'!assertWriting: aDocumentItem includesText: aString	| result |	result := self write: aDocumentItem.	self assert: result includesSubstring: aString! !!PRDocumentWriterTest methodsFor: 'asserting' stamp: 'DamienCassou 11/21/2013 11:23'!assertWriting: aDocumentItem includesTexts: aCollection	| resultString |	resultString := self write: aDocumentItem.	aCollection do: [ :testString | self assert: resultString includesSubstring: testString ]! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 15:06'!boldFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 10/29/2015 22:00'!configuration	^ configuration ifNil: [ configuration := PRPillarConfiguration new ]! !!PRDocumentWriterTest methodsFor: 'helpers' stamp: 'DamienCassou 1/10/2014 16:08'!createWriterOn: aWriteStream 	^ (self actualClass on: aWriteStream)		configuration: self configuration;		yourself! !!PRDocumentWriterTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 10/29/2015 22:00'!createWriterWithSeparateOutputFilesOn: aWriteStream	^ (self actualClass on: aWriteStream)		configuration:				(PRPillarConfiguration new						separateOutputFiles: true;						yourself);		yourself! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:20'!dataItemWithBar	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 14:37'!definitionListBegin	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 1/28/2014 14:48'!emailToFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:20'!figureAnchorForPierLogo	^ self subclassResponsibility ! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/21/2013 17:46'!figureBegin	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'data' stamp: 'DamienCassou 11/21/2013 07:49'!foo	^ 'foo'! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/3/2016 16:24'!footnoteBar	^ ''! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 3/5/2014 18:30'!horizontalRule	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 13:51'!italicFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/21/2013 11:43'!level1HeaderBegin	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 1/7/2014 14:17'!level1HeaderWithFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 1/7/2014 15:01'!level2HeaderBegin	^ self subclassResponsibility ! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 14:42'!listItemWith1	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 13:51'!monospaceFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 14:32'!orderedListBegin	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 1/15/2014 16:53'!packageNamesUnderTest	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/21/2013 17:45'!paragraphFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'helpers' stamp: 'DamienCassou 10/15/2015 11:39'!parser	^ PRPillarParserMain! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 15:55'!preformattedFooBegin	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 15:55'!preformattedTextFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/21/2013 17:44'!rawText	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/22/2013 18:21'!referenceToFigurePierLogo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/20/2015 17:55'!resultWithRefWithAnchorWithSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/20/2015 18:06'!resultWithRefWithAnchorWithoutSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 10:37'!resultWithRefWithoutAnchorWithSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 10:41'!resultWithRefWithoutAnchorWithoutSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 11:26'!resultWithoutAliasWithRefWithAnchorWithoutSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:20'!resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:24'!resultWithoutAliasWithoutRefWithAnchorWithoutSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 11:11'!resultWithoutRefWithAnchorWithSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 11:15'!resultWithoutRefWithAnchorWithoutSeparateOutputFiles	self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 1/9/2014 15:43'!scriptAnchorForMyScript	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:16'!scriptWithCaptionBegin	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:10'!scriptWithoutCaptionBegin	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 13:53'!strikethroughFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 13:53'!subscriptFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 13:53'!superscriptFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 1/10/2014 17:07'!supportSyntaxHighlighting	^ true! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/20/2013 15:44'!tableBegin	^ self subclassResponsibility ! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/20/2013 15:45'!tableCellWithFoo	^ self subclassResponsibility ! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/20/2013 16:02'!tableCellWithHeadingFoo	^ self subclassResponsibility ! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/20/2013 15:44'!tableRow	^ self subclassResponsibility ! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 14:37'!termItemWithFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'BenComan 6/2/2014 22:07'!testAnnotation	| item |	{ 'note' . 'dothis' } do:	[	:annotation |			item := PRAnnotatedParagraph new			annotation: annotation;			add: (PRText content: 'foo');			yourself.		self 			assertWriting: item			includesTexts: 				{self annotationBegin: annotation . 'foo'}. 	].! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testBoldFormat	| item |	item := self addText: 'foo' to: PRBoldFormat new.	self		assertWriting: item		includesTexts:			{self boldFoo}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 3/5/2014 17:44'!testCommentedLineNotVisibleInOutput	| item result |	item := PRCommentedLine content: 'some comment'.	result := self write: item.	self assert: result isEmpty.! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 3/20/2014 18:32'!testConsecutiveTextsInAParagraphAreSeparatedByWhitespace	| item |	item := PRParagraph new		add: (PRText content: 'foo');		add: (PRLineBreak new);		add: (PRText content: 'bar');		yourself.	self assertWriting: item includesText: 'foo', self configuration newLine, 'bar'! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testDefinitionList	| item |	item := PRDefinitionList new		add: (self addText: 'foo' to: PRTermItem new);		add: (self addText: 'bar' to: PRDataItem new);		yourself.	self		assertWriting: item		includesTexts:			{self definitionListBegin.			self termItemWithFoo.			self dataItemWithBar}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 9/8/2015 18:42'!testFigure	| item |	item := PRFigure new		reference: 'file://picture.png';		yourself.	self		assertWriting: item		includesText:			'picture.png'! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 9/8/2015 18:42'!testFigureLabelGenerateAnchor	| item |	item := PRFigure new		reference: 'file://picture.png';		parameterAt: 'label' put: 'pierLogo';		yourself.	self		assertWriting: item		includesTexts:			{(self figureAnchorForPierLogo).			'pierLogo'}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 9/8/2015 18:42'!testFigureReference	| item resultString indexOfReference referenceString |	item := PRParagraph new		add:				(PRFigure new						reference: 'file://picture.png';						parameterAt: 'label' put: 'pierLogo';						counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 2 );						yourself);		add: (PRText content: 'See figure ');		add: ((PRInternalLink reference: '@pierLogo') counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 2 ));		yourself.		resultString := self write: item.	indexOfReference := resultString indexOfSubCollection: 'See figure ' startingAt: 1 ifAbsent: [ self fail: 'The string ''See figure '' should have been found' ].	referenceString := resultString allButFirst: indexOfReference - 1.	self assert: referenceString includesSubstring: self referenceToFigurePierLogo! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 9/8/2015 18:43'!testFigureWithLabelAndWithCaptionAreExportedWithEnvironment	| item |	item := PRFigure new		reference: 'file://picture.png';		add: (PRText content: 'caption');		label: 'label';		yourself.	self assertWriting: item includesText: self figureBegin! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 9/8/2015 18:43'!testFigureWithLabelAndWithoutCaptionAreExportedWithEnvironment	| item |	item := PRFigure new		reference: 'file://picture.png';		label: 'label';		yourself.	self assertWriting: item includesText: self figureBegin! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 9/8/2015 18:43'!testFigureWithWidth	| item width |	width := '50'.	item := PRFigure new		reference: 'file://picture.png';		parameterAt: 'width' put: width;		yourself.	self assertWriting: item includesText: self widthFor50percents! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 9/8/2015 18:43'!testFigureWithoutLabelAndWithCaptionAreExportedWithEnvironment	| item |	item := PRFigure new		reference: 'file://picture.png';		add: (PRText content: 'caption');		yourself.	self assertWriting: item includesText: self figureBegin! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 10/8/2015 16:43'!testFigureWithoutLabelAndWithoutCaptionAreExportedWithoutEnvironment	| item result |	item := PRFigure new		reference: 'file://picture.png';		yourself.	result := self write: item.	self figureBegin ifNotEmpty: [ self deny: (result includesSubstring: self figureBegin) ]! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 9/8/2015 18:42'!testFiguresHaveACaption	| item caption filename |	caption := 'A description'.	filename := 'picture.png'.	item := PRFigure new		reference: 'file://' , filename;		label: 'picture';		add: (PRText content: caption);		yourself.	self		assertWriting: item		includesTexts:			{(self figureBegin).			filename.			caption}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 12/9/2013 14:04'!testFileExtension	| fileExtension |	fileExtension := self instance fileExtension.	self assert: fileExtension notNil.	self assert: fileExtension isString! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks' stamp: 'YannDubois 5/3/2016 16:24'!testFootnote	| item |	item := PRParagraph new		add: (PRText content: 'timo');		add: (PRFootnote noted: 'Bar');		add: (PRText content: 'leon');		yourself.	self assertWriting: item includesText: self footnoteBar! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 12/11/2013 17:22'!testHasName	self assert: self actualClass writerName notEmpty! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 6/21/2016 13:29'!testHeader	| item |	item := PRHeader new		level: 1;		add: (PRText content: 'foo');		yourself.	self assertWriting: item includesTexts: {self level1HeaderWithFoo}.! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 3/5/2014 18:29'!testHorizontalRule	| item  |	item := PRHorizontalRule new.	self assertWriting: item includesText: self horizontalRule! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:38'!testInternalLinkWithAliasWithRefWithAncorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: 'ref.pillar@foo')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithRefWithAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithAnchorWithSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:38'!testInternalLinkWithAliasWithRefWithAncorWithoutSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: 'ref.pillar@foo')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	resultString := self write: item.	self resultWithRefWithAnchorWithoutSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithAnchorWithoutSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:38'!testInternalLinkWithAliasWithReferenceWithoutAnchorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: 'ref.pillar')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithRefWithoutAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithoutAnchorWithSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:38'!testInternalLinkWithAliasWithReferenceWithoutAnchorWithoutSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: 'ref.pillar')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	resultString := self write: item.	self resultWithRefWithoutAnchorWithoutSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithoutAnchorWithoutSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 11:11'!testInternalLinkWithAliasWithoutReferenceWithAnchorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: '@foo')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithoutRefWithAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithoutRefWithAnchorWithSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:24'!testInternalLinkWithAliasWithoutReferenceWithAnchorWithoutSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: '@foo')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	resultString := self write: item.	self resultWithoutRefWithAnchorWithoutSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithoutRefWithAnchorWithoutSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:38'!testInternalLinkWithoutAliasWithRefWithAncorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: 'ref.pillar@foo');		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithRefWithAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithAnchorWithSeparateOutputFiles) ]! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:38'!testInternalLinkWithoutAliasWithRefWithAncorWithoutSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: 'ref.pillar@foo');		yourself.	resultString := self write: item.	self resultWithoutAliasWithRefWithAnchorWithoutSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithoutAliasWithRefWithAnchorWithoutSeparateOutputFiles) ]! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:38'!testInternalLinkWithoutAliasWithReferenceWithoutAnchorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: 'ref.pillar');		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithRefWithoutAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithoutAnchorWithSeparateOutputFiles) ]! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:38'!testInternalLinkWithoutAliasWithReferenceWithoutAnchorWithoutSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: 'ref.pillar')						yourself);		yourself.	resultString := self write: item.	self resultWithRefWithoutAnchorWithoutSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithoutAnchorWithoutSeparateOutputFiles) ].! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:22'!testInternalLinkWithoutAliasWithoutReferenceWithAnchorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: '@foo')						yourself);		yourself.	resultString := self writeWithSeparateOutputFiles: item.	self resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles) ]! !!PRDocumentWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:24'!testInternalLinkWithoutAliasWithoutReferenceWithAnchorWithoutSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: '@foo')						yourself);		yourself.	resultString := self write: item.	self resultWithoutAliasWithoutRefWithAnchorWithoutSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithoutAliasWithoutRefWithAnchorWithoutSeparateOutputFiles) ]! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testItalicFormat	| item |	item := self addText: 'foo' to: PRItalicFormat new.	self		assertWriting: item		includesTexts:			{self italicFoo}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testLanguageForScript	| item smalltalk writer http |	writer := self instance.	item := PRScript content: 'foo'.	smalltalk := PRSmalltalkScriptLanguage new.	http := PRHTTPScriptLanguage new.	self assert: (writer languageForScript: item) class equals: PRUnspecifiedScriptLanguage.	self configuration defaultScriptLanguage: smalltalk.	self assert: (writer languageForScript: item) equals: smalltalk.	item := (PRScript content: 'foo') language: http.	self assert: (writer languageForScript: item) equals: http! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 4/26/2014 18:16'!testMailLink	| item |	configuration scrambledEmailAddresses: false.	item := self addText: 'Foo Bar' to: (PRMailLink reference: 'foo@bar.com').	self		assertWriting: item		includesTexts:			{self emailToFoo . 'Foo Bar'}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 12/9/2013 14:04'!testMarkupType	| markupType |	markupType := self instance markupType.	self assert: markupType notNil.	self assert: markupType isSymbol! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testMonospaceFormat	| item |	item := self addText: 'foo' to: PRMonospaceFormat new.	self		assertWriting: item		includesTexts:			{self monospaceFoo}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testOrderedList	| item |	item := PROrderedList new		add: (self addText: '1' to: PRListItem new);		yourself.	self		assertWriting: item		includesTexts:			{(self orderedListBegin).			(self listItemWith1)}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testParagraph	| item |	item := self addText: 'foo' to: PRParagraph new.	self assertWriting: item includesText: self paragraphFoo! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testPreformatted	| item |	item := self addText: 'foo' to: PRPreformatted new.	self assertWriting: item includesTexts: {self preformattedFooBegin . self preformattedTextFoo}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testPreformattedWithMultipleLines	| item |	item := PRPreformatted new		add: (PRText content: 'foo');		add: (PRText content: 'bar');		yourself.	self assertWriting: item includesText: 'foo' , self configuration newLine! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testRaw	| item |	item := PRRaw content: self rawText.	self		assertWriting: item		includesText:			self rawText! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testScript	| item |	item := PRScript content: 'foo'.	self assertWriting: item includesTexts: {self scriptWithoutCaptionBegin . self foo}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/12/2016 13:30'!testScriptDefaultLanguage	| item |	self supportSyntaxHighlighting		ifFalse: [ self skip ].	item := PRScript content: 'foo'.	configuration defaultScriptLanguage: PRHTMLScriptLanguage default.	self assertWriting: item includesTexts: {PRHTMLScriptLanguage standardName}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testScriptLabelGenerateAnchor	| item |	item := (PRScript content: 'foo')		label: 'myScript';		yourself.	self		assertWriting: item		includesTexts:			{(self scriptAnchorForMyScript).			'myScript'}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testScriptLanguage	| item |	self supportSyntaxHighlighting ifFalse: [ self skip ].	item := (PRScript content: 'foo')		language: 'html';		yourself.	self assertWriting: item includesTexts: {(PRHTMLScriptLanguage standardName)}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/29/2016 17:01'!testScriptWithFormattedCaption	| item |	item := (PRScript content: 'bar')		caption: '""foo""';		yourself.	self assertWriting: item includesText: self boldFoo! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testScriptWithProblematicEval	| item nonExistingMethod |	nonExistingMethod := 'FooBarDoesNotExistX'.	item := (PRScript content: 'Object ' , nonExistingMethod)		eval: true;		yourself.	self assert: item isEvaluated.	self assertWriting: item includesText: nonExistingMethod! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testScriptsHaveACaption	| item caption |	caption := 'A description'.	item := (PRScript content: 'foo')		caption:  caption;		yourself.	self		assertWriting: item		includesTexts:			{(self scriptWithCaptionBegin).			caption}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 1/15/2014 16:53'!testSpecifyPackageNamesUnderTest	self assert: self packageNamesUnderTest isCollection.	self deny: self packageNamesUnderTest isEmpty.	self packageNamesUnderTest		do: [ :packageName | self deny: (RPackage organizer packageNamed: packageName) methodReferences isEmpty ]! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testStrikethroughFormat	| item |	item := self addText: 'foo' to: PRStrikethroughFormat new.	self		assertWriting: item		includesTexts:			{self strikethroughFoo}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testSubscriptFormat	| item |	item := self addText: 'foo' to: PRSubscriptFormat new.	self		assertWriting: item		includesTexts:			{self subscriptFoo}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testSuperscriptFormat	| item |	item := self addText: 'foo' to: PRSuperscriptFormat new.	self		assertWriting: item		includesTexts:			{self superscriptFoo}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testTable	| item |	item := PRTable new		add:				(PRTableRow new						add: (self addText: 'foo' to: PRTableCell new);						yourself);		yourself.	self		assertWriting: item		includesTexts:			{(self tableBegin).			(self tableRow).			(self tableCellWithFoo)}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testTableWith2CellsInARow	| item |	item := PRTable new		add:				(PRTableRow new						add: (self addText: 'foo' to: PRTableCell new);						add: (self addText: 'foo' to: PRTableCell new);						yourself);		yourself.	self		assertWriting: item		includesTexts:			{(self tableBegin).			(self tableRow).			(self tableCellWithFoo)}.	^ item! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testTableWithHeading	| item |	item := PRTable new		add:				(PRTableRow new						add:								(self										addText: 'foo'										to:											(PRTableCell new												beHeading;												yourself));						yourself);		yourself.	self		assertWriting: item		includesTexts:			{(self tableBegin).			(self tableRow).			(self tableCellWithHeadingFoo)}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testUnderlineFormat	| item |	item := self addText: 'foo' to: PRUnderlineFormat new.	self		assertWriting: item		includesTexts:			{self underlineFoo}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testUnorderedList	| item |	item := PRUnorderedList new		add: (self addText: '1' to: PRListItem new);		yourself.	self		assertWriting: item		includesTexts:			{(self unorderedListBegin).			(self listItemWith1)}! !!PRDocumentWriterTest methodsFor: 'tests' stamp: 'DamienCassou 6/21/2016 13:28'!testWritersAreNotResponsibleForHeadingLevelOffset	| item |	item := PRHeader new		level: 1;		add: (PRText content: 'foo');		yourself.	self assertWriting: item includesTexts: {self level1HeaderWithFoo}.	self configuration headingLevelOffset: 2.	"Writers should *not* take care of headingLevelOffset:"	self assertWriting: item includesTexts: {self level1HeaderWithFoo}! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 13:53'!underlineFoo	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 14:32'!unorderedListBegin	^ self subclassResponsibility! !!PRDocumentWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/21/2014 17:39'!widthFor50percents	^ '50'! !!PRDocumentWriterTest methodsFor: 'helpers' stamp: 'DamienCassou 1/10/2014 16:07'!write: aDocumentItem	| writer |	^ String		streamContents: [ :stream | 			writer := self createWriterOn: stream.			writer start: aDocumentItem ]! !!PRDocumentWriterTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 5/20/2015 17:54'!writeWithSeparateOutputFiles: aDocumentItem	| writer |	^ String		streamContents: [ :stream | 			writer := self createWriterWithSeparateOutputFilesOn: stream.			writer start: aDocumentItem ]! !!PRManualNumberingWriterTest class methodsFor: 'testing' stamp: 'DamienCassou 11/21/2013 07:40'!isAbstract	"Override to true if a TestCase subclass is Abstract and should not have	TestCase instances built from it"	^self name = #PRManualNumberingWriterTest! !!PRManualNumberingWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/21/2013 11:36'!counter11DefinitionString	^ '1.1. '! !!PRManualNumberingWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/21/2013 12:42'!counter11ReferenceString	^ '1.1'! !!PRManualNumberingWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/21/2013 11:35'!counter1DefinitionString	^ '1. '! !!PRManualNumberingWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/21/2013 11:36'!counter1ReferenceString	^ '1'! !!PRManualNumberingWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/21/2013 11:36'!counter2DefinitionString	^ '2. '! !!PRManualNumberingWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 1/7/2014 14:57'!level1HeaderWith1Foo	^ self level1HeaderBegin , self counter1DefinitionString , self foo! !!PRManualNumberingWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 1/7/2014 15:04'!level2HeaderWith11Foo	^ self level2HeaderBegin , self counter11DefinitionString , self foo! !!PRManualNumberingWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 1/7/2014 15:00'!level2HeaderWith1Foo	^ self level2HeaderBegin , self counter1DefinitionString , self foo! !!PRManualNumberingWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 1/7/2014 15:00'!level2HeaderWithFoo	^ self level2HeaderBegin , self foo! !!PRManualNumberingWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/22/2013 18:21'!referenceToFigurePierLogo	^ '0.1'! !!PRManualNumberingWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/25/2015 16:32'!testHeadersAreNumbered	| item |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'foo');						counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 1);						yourself);		add:				(PRHeader new						level: 1;						add: (PRText content: 'foo');						counter:								((PRCascadingCounter maxLevel: 5)										incrementAt: 1;										incrementAt: 1);						yourself);		yourself.	self configuration		level1:			((PRLevelNumberConfiguration with: (Dictionary with: 'rendering' -> true with: 'size' -> 1 with: 'renderAs' -> 'number'))				level: 1;				configuration: self configuration;				yourself).	self		assertWriting: item		includesTexts:			{self counter1DefinitionString.			self counter2DefinitionString}! !!PRManualNumberingWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 9/8/2015 18:43'!testReferenceToFigureAnchor	| item resultString indexOfReference referenceString |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'foo');						counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 1);						yourself);		add:				(PRParagraph new						add:								(PRFigure new										reference: 'file://picture.png';										parameterAt: 'label' put: 'fig:picture';										counter:												((PRCascadingCounter maxLevel: 5)														incrementAt: 1;														incrementAt: 2);										yourself);						add: (PRText content: 'See Figure ');						add:								((PRInternalLink reference: 'fig:picture')										counter:												((PRCascadingCounter maxLevel: 5)														incrementAt: 1;														incrementAt: 2);										yourself);						yourself).	[resultString := self write: item] on: PRLinkWarning do: [:w | w resume ].	indexOfReference := resultString		indexOfSubCollection: 'See Figure '		startingAt: 1		ifAbsent: [ self fail: 'The string ''See Figure '' should have been found' ].	referenceString := resultString allButFirst: indexOfReference - 1.	self assert: referenceString includesSubstring: self counter11ReferenceString! !!PRManualNumberingWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 5/21/2015 10:58'!testReferenceToHeaderAnchor	| item resultString indexOfReference referenceString |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'foo');						counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 1);						yourself);		add: (PRAnchor named: 'chap:foo');		add:				(PRParagraph new						add: (PRText content: 'See Chapter ');						add:								((PRInternalLink reference: 'chap:foo')										counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 1);										yourself);						yourself);		yourself.	[resultString := self write: item] on: PRLinkWarning do: [:w | w resume ].	indexOfReference := resultString		indexOfSubCollection: 'See Chapter '		startingAt: 1		ifAbsent: [ self fail: 'The string ''See Chapter '' should have been found' ].	referenceString := resultString allButFirst: indexOfReference - 1.	self assert: referenceString includesSubstring: self counter1ReferenceString! !!PRManualNumberingWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/25/2015 16:39'!testSubHeadersAreNumbered	| item |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'foo');						counter: ((PRCascadingCounter maxLevel: 5) incrementAt: 1);						yourself);		add:				(PRHeader new						level: 2;						add: (PRText content: 'foo');						counter:								((PRCascadingCounter maxLevel: 5)										incrementAt: 1;										incrementAt: 2);						yourself);		yourself.	self configuration		level1:			((PRLevelNumberConfiguration with: (Dictionary with: 'rendering' -> true with: 'size' -> 1 with: 'renderAs' -> 'number'))				level: 1;				configuration: configuration;				yourself).	self		assertWriting: item		includesTexts:			{self counter1DefinitionString.			self counter11DefinitionString}! !!PRAnchorOfSectionTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/20/2015 15:15'!actualClass	^ PRAnchorOfSection ! !!PRAnchorOfSectionTest methodsFor: 'tests' stamp: 'CyrilFerlicot 5/29/2016 00:55'!addHeader: aDictionary ofLevel: aNumber to: aConfiguration	| headerConfig |	headerConfig := (aConfiguration class headerConfigurations at: (aDictionary at: 'renderAs' ifAbsent: [ 'roman' ]))		with: aDictionary.	headerConfig		level: aNumber;		configuration: aConfiguration.	aConfiguration perform: ('level' , aNumber asString , ':') asSymbol with: headerConfig! !!PRAnchorOfSectionTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 13:48'!testAnchorWithSimpleTitle	| input expected config |	config := self configuration.	self addHeader: (Dictionary with: 'autoAnchor' -> true) ofLevel: 2 to: config.	input := PRDocument new		add:			(PRHeader new				level: 2;				add: (PRText content: 'foo'));		yourself.	expected := PRDocument new		add:			(PRHeader new				level: 2;				add: (PRText content: 'foo'));		add: (PRAnchor named: 'foo@1');		yourself.	self assert: (self executePhase: input with: config) equals: expected! !!PRAnchorOfSectionTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 13:50'!testAnchorWithSimpleTitleAndAnchorNumberName	| input expected config |	config := self configuration.	self addHeader: (Dictionary with: 'autoAnchor' -> true) ofLevel: 2 to: config.	input := PRDocument new		add:				(PRHeader new	level: 2;						add: (PRText content: '42'));						add: (PRAnchor named: '42') yourself..		expected := PRDocument new		add:				(PRHeader new						level: 2;						add: (PRText content: '42'));		add: (PRAnchor named: '42@1');		add: (PRAnchor named: '42') yourself.	self assert: (self executePhase: input with: config) equals: expected! !!PRAnchorOfSectionTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 13:50'!testAnchorWithSimpleTitleAndAnchorWithSameName	| input expected config |	config := self configuration.	self addHeader: (Dictionary with: 'autoAnchor' -> true) ofLevel: 2 to: config.		input := PRDocument new		add:				(PRHeader new	level: 2;						add: (PRText content: 'foo'));						add: (PRAnchor named: 'foo@41') yourself..		expected := PRDocument new		add:				(PRHeader new						level: 2;						add: (PRText content: 'foo'));		add: (PRAnchor named: 'foo@42');		add: (PRAnchor named: 'foo@41') yourself.	self assert: (self executePhase: input with: config) equals: expected! !!PRAnchorOfSectionTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 13:52'!testAnchorWithTwoSameTitle	| input expected config |	config := self configuration.	self addHeader: (Dictionary with: 'autoAnchor' -> true) ofLevel: 2 to: config.		input := PRDocument new		add:				(PRHeader new	level: 2;						add: (PRText content: 'foo'));		add:				(PRHeader new	level: 2;						add: (PRText content: 'foo'));		yourself.	expected := PRDocument new		add:				(PRHeader new						level: 2;						add: (PRText content: 'foo'));		add: (PRAnchor named: 'foo@1');		add:				(PRHeader new						level: 2;						add: (PRText content: 'foo'));		add: (PRAnchor named: 'foo@2') yourself.	self assert: (self executePhase: input with: config) equals: expected! !!PRAnchorOfSectionTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 13:51'!testAnchorWithoutTitle	| input config |	config := self configuration.	input := PRDocument new		add: (PRText content: 'foo');		yourself.	self assert: (self executePhase: input with: config) equals: input! !!PRCitationTransformerTest methodsFor: 'private' stamp: 'ThibaultArloing 5/3/2016 15:56'!actualClass	^PRCitationTransformer! !!PRCitationTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 13:54'!testTransformWithAnnotationAndText	| input expected |	input := PRDocument new		add:			(PRParagraph new				add: (PRText new text: 'hello');				add: PRCitationAnnotation new;				add: (PRText new text: 'hello');				yourself).	expected := PRDocument new		add:			(PRParagraph new				add: (PRText new text: 'hello');				add: (PRCitation new);				add: (PRText new text: 'hello');				yourself).	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRCitationTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 13:54'!testTransformWithListInList	| input expected |	input := PRDocument new		add:			(PROrderedList new				add:					(PRUnorderedList new						add: PRCitationAnnotation new;						yourself);				yourself).	expected := PRDocument new		add:			(PROrderedList new				add:					(PRUnorderedList new						add: PRCitation new;						yourself);				yourself).	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRCitationTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 13:55'!testTransformWithOneAnnotation	| input expected |	input := PRDocument new		add: PRCitationAnnotation new;		yourself.	expected := PRDocument new add: PRCitation new.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRCitationTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 13:56'!testTransformWithOneAnnotationithRef	| input expected |	input := PRDocument new		add:			(PRCitationAnnotation new				parameterAt: 'ref' put: 'foo';				yourself).	expected := PRDocument new add: (PRCitation ref: 'foo').	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRCleanAnnotationInParagraphTransfomerTest methodsFor: 'private' stamp: 'DamienCassou 7/21/2016 12:08'!actualClass	^ PRCleanAnnotationInParagraphTransfomer! !!PRCleanAnnotationInParagraphTransfomerTest methodsFor: 'helpers' stamp: 'DamienCassou 7/20/2016 16:37'!exampleAnnotation	^ PRFootnoteAnnotation new		parameterAt: 'note' put: 'Foo';		yourself! !!PRCleanAnnotationInParagraphTransfomerTest methodsFor: 'helpers' stamp: 'DamienCassou 7/20/2016 16:44'!exampleMisc	^ PRText content: 'foo'! !!PRCleanAnnotationInParagraphTransfomerTest methodsFor: 'tests' stamp: 'ThibaultArloing 7/21/2016 17:04'!testShouldNotBreakWithEmptyParagraph	| document |	document := PRDocument with: PREmptyParagraph new.	self executePhase: document! !!PRCleanAnnotationInParagraphTransfomerTest methodsFor: 'tests' stamp: 'DamienCassou 7/20/2016 16:44'!testShouldNotRemoveWhenSomethingElseFollowsTheAnnotationInParagraph	| document result misc annotation |	annotation := self exampleAnnotation.	misc := self exampleMisc.	document := PRDocument		with:			(PRParagraph				withAll:					{annotation.					misc}).	self assert: (document children first isKindOf: PRParagraph).	self deny: document children first = annotation.	result := self executePhase: document.	self assert: (document children first isKindOf: PRParagraph).	self deny: document children first = annotation! !!PRCleanAnnotationInParagraphTransfomerTest methodsFor: 'tests' stamp: 'DamienCassou 7/20/2016 16:44'!testShouldNotRemoveWhenSomethingElseThanAnnotationInParagraph	| document result misc |	misc := self exampleMisc.	document := PRDocument with: (PRParagraph with: misc).	self assert: (document children first isKindOf: PRParagraph).	self deny: document children first = misc.	result := self executePhase: document.	self assert: (document children first isKindOf: PRParagraph).	self deny: document children first = misc! !!PRCleanAnnotationInParagraphTransfomerTest methodsFor: 'tests' stamp: 'DamienCassou 7/20/2016 16:40'!testShouldRemoveWhenAnnotationAloneInParagraph	| document result annotation |	annotation := self exampleAnnotation.	document := PRDocument with: (PRParagraph with: annotation).	self assert: (document children first isKindOf: PRParagraph).	self deny: document children first = annotation.	result := self executePhase: document.	self deny: (document children first isKindOf: PRParagraph).	self assert: document children first = annotation! !!PRCleanAnnotationInParagraphTransfomerTest methodsFor: 'tests' stamp: 'DamienCassou 7/20/2016 16:48'!testShouldRemoveWhenAnnotationAloneWithLineBreakInParagraph	| document result misc annotation |	annotation := self exampleAnnotation.	misc := PRLineBreak new.	document := PRDocument		with:			(PRParagraph				withAll:					{annotation.					misc}).	self assert: (document children first isKindOf: PRParagraph).	self deny: document children first = annotation.	result := self executePhase: document.	self deny: (document children first isKindOf: PRParagraph).	self assert: document children first = annotation.	self assert: document children size equals: 1! !!PRColumnsTransformerTest methodsFor: 'private' stamp: 'CyrilFerlicot 6/18/2015 11:32'!actualClass	^ PRColumnsTransformer! !!PRColumnsTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 7/21/2016 12:12'!testDependOnCleanAnnotationInParagraphTransfomer	self assert: (self actualClass dependencies anySatisfy: [ :pipe | pipe key = #cleanAnnotationInParagraph ])! !!PRColumnsTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 7/21/2016 11:39'!testTransformationBeginningColumnsWithoutEnding	| input |	input := PRDocument		withAll:			{PRColumnsAnnotation new.			(PRColumnAnnotation				parameters:					(SmallDictionary new						at: 'width' put: '100';						yourself)).			(PRText content: 'Foo')}.	self should: [ self executePhase: input ] raise: PRError whoseDescriptionIncludes: 'Missing end' description: 'Code must detect the absence of end annotation'! !!PRColumnsTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 7/21/2016 11:42'!testTransformationEndColumnsWithoutBeginning	| input |	input := PRDocument with: PREndColumnsAnnotation new.	self should: [ (self executePhase: input with: self configuration) ] raise: PRError whoseDescriptionIncludes: 'out of a column environment' description: 'Code should detect a missing annotation'! !!PRColumnsTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 7/21/2016 11:54'!testTransformationOnColumn	| input expected |	input := PRDocument new		add:				PRColumnsAnnotation new;		add:				(PRColumnAnnotation parameters: (SmallDictionary new								at: 'width' put: '100';								yourself) yourself);		add:	(PRParagraph new						add: (PRText content: 'Foo');						yourself);		add:				PREndColumnsAnnotation new;		yourself.	expected := PRDocument new		add:				(PRColumns new						add:							((PRColumn width: '100')								add:										(PRParagraph new												add: (PRText content: 'Foo');												yourself);								yourself));		yourself.	self assert: (self executePhase: input) equals: expected! !!PRColumnsTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 7/21/2016 11:56'!testTransformationTwoColumns	| input expected |	input := PRDocument new		add:				PRColumnsAnnotation new;		add:				(PRColumnAnnotation parameters: ((SmallDictionary new								at: 'width' put: '50';								yourself)) yourself);		add:				(PRParagraph new						add: (PRText content: 'Foo');						yourself);		add:				(PRColumnAnnotation parameters: ((SmallDictionary new								at: 'width' put: '50';								yourself)) yourself);		add:				(PRParagraph new						add: (PRText content: 'Bar');						yourself);		add:				PREndColumnsAnnotation new;		yourself.	expected := PRDocument new		add:				(PRColumns new						add:								((PRColumn width: '50')										add:											(PRParagraph new												add: (PRText content: 'Foo');												yourself));						add:								((PRColumn width: '50')										add:												(PRParagraph new														add: (PRText content: 'Bar');														yourself);										yourself));		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRColumnsTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 7/21/2016 11:58'!testTransformationWithColumnWithoutColumns	| input |	input := PRDocument new		add:				PRColumnAnnotation new;		add:				(PRParagraph new						add: (PRText content: 'Foo');						yourself);		add:				PREndColumnsAnnotation new;		yourself.	self should: [ self executePhase: input] raise: PRError whoseDescriptionIncludes: 'not inside a column environment' description: 'Code is missing a check'! !!PRColumnsTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 7/21/2016 12:00'!testTransformationWithColumnsInColumns	| input |	input := PRDocument new		add:				PRColumnsAnnotation new;		add:				PRColumnsAnnotation new;		add:				PREndColumnsAnnotation new;		add:				PREndColumnsAnnotation new;		yourself.	self should: [ self executePhase: input ] raise: PRError whoseDescriptionIncludes: 'close a columns environment' description: 'Code is missing a check'! !!PRColumnsTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 7/21/2016 12:02'!testTransformationWithContentInsideColumnsBeforeColumn	| input expected |	input := PRDocument new		add:				PRColumnsAnnotation new;		add: (PRParagraph with: (PRText content: 'Foo') yourself);		add:				(PRColumnAnnotation parameters: ((SmallDictionary new								at: 'width' put: '100';								yourself)) yourself);		add: (PRParagraph with: (PRText content: 'Bar') yourself);		add:				PREndColumnsAnnotation new;		yourself.	expected := PRDocument new		add:				(PRColumns new						add: (PRParagraph with: (PRText content: 'Foo') yourself);						add: ((PRColumn width: '100') add: (PRParagraph with: (PRText content: 'Bar') yourself) yourself);						yourself);		yourself.	self assert: (self executePhase: input) equals: expected! !!PRColumnsTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:00'!testTransformationWithoutColumns	| input |	input := PRDocument new		add:				(PRParagraph new						add: (PRText content: 'Foo');						yourself);		add: (PRParagraph with: (PRText content: 'Bar') yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: input! !!PRFootnoteTransformerTest methodsFor: 'private' stamp: 'YannDubois 5/3/2016 10:33'!actualClass	^ PRFootnoteTransformer! !!PRFootnoteTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:07'!testTransformationFootnoteWithList	| input expected |	input := PRDocument new		add:			(PROrderedList new				add:					(PRListItem new						add: (PRText content: 'Timo');						add:							(PRFootnoteAnnotation new								parameterAt: 'note' put: 'Foo';								yourself);						add: (PRText content: 'Leon');						yourself);				yourself);		yourself.	expected := PRDocument new		add:			(PROrderedList new				add:					(PRListItem new						add: (PRText content: 'Timo');						add: (PRFootnote noted: 'Foo');						add: (PRText content: 'Leon');						yourself);				yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRFootnoteTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:08'!testTransformationFootnoteWithParagraph	| input expected |	input := PRDocument new		add:			(PRParagraph new				add: (PRText content: 'Timo');				add:					(PRFootnoteAnnotation new						parameterAt: 'note' put: 'Foo';						yourself);				add: (PRText content: 'Leon');				yourself);		yourself.	expected := PRDocument new		add:			(PRParagraph new				add: (PRText content: 'Timo');				add: (PRFootnote noted: 'Foo');				add: (PRText content: 'Leon');				yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRHeaderCapitalizationTransformerTest methodsFor: 'private' stamp: 'ThibaultArloing 4/6/2016 14:52'!actualClass	^ PRHeaderCapitalizationTransformer! !!PRHeaderCapitalizationTransformerTest methodsFor: 'adding' stamp: 'CyrilFerlicot 5/29/2016 00:55'!addHeader: aDictionary ofLevel: aNumber to: aConfiguration	| headerConfig |	headerConfig := (aConfiguration class headerConfigurations at: (aDictionary at: 'renderAs' ifAbsent: [ 'roman' ]))		with: aDictionary.	headerConfig		level: aNumber;		configuration: aConfiguration.	aConfiguration perform: ('level' , aNumber asString , ':') asSymbol with: headerConfig! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests' stamp: 'ThibaultArloing 4/6/2016 15:16'!testCapitalizeCapitalization	self testTemplateForCapitalizationHeader: 'capitalize' text: 'i am a header' expected: 'I Am A Header'.	self testTemplateForCapitalizationHeaderWithBold: 'capitalize' text: 'i am a header' expected: 'I Am A Header'.! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests' stamp: 'YannDubois 5/23/2016 10:56'!testCapitalizeEnglish	self assert: (self actualClass new capitalizeEnglish: 'i am a header') equals: 'I Am a Header'.	self assert: (self actualClass new capitalizeEnglish: 'i am a header of level 1') equals: 'I Am a Header of Level 1'.	self assert: (self actualClass new capitalizeEnglish: 'i like to code in Pharo for a long time') equals: 'I Like to Code in Pharo for a Long Time'.! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests' stamp: 'ThibaultArloing 4/8/2016 14:54'!testCapitalizeEnglishCapitalization	self testTemplateForCapitalizationHeader: 'capitalize english' text: 'i am a header' expected: 'I Am a Header'.	self testTemplateForCapitalizationHeaderWithBold: 'capitalize english' text: 'i like to code in Pharo for a long time' expected: 'I Like to Code in Pharo for a Long Time'.! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests' stamp: 'YannDubois 5/23/2016 10:56'!testCapitalizeHeader	self assert: (self actualClass new capitalizeHeader: 'i am a header') equals: 'I Am A Header'.	self assert: (self actualClass new capitalizeHeader: 'i am a header of level 1') equals: 'I Am A Header Of Level 1'! !!PRHeaderCapitalizationTransformerTest methodsFor: 'as yet unclassified' stamp: 'DamienCassou 7/13/2016 15:39'!testCapitalizeHeaderShouldntCapitalizeAllText	| input expected config newInstance |	config := PRPillarConfiguration new.	self addHeader: (Dictionary with: 'capitalization' -> 'upper case') ofLevel: 2 to: config.	newInstance := self actualInstance configuration: config.	input := PRDocument new		add: (PRParagraph new add: (PRText content: 'should not be capitalized'));		add:			(PRHeader new				level: 2;				add: (PRText content: 'Header'));		add: (PRParagraph new add: (PRText content: 'should not be capitalized'));		yourself.	expected := PRDocument new		add: (PRParagraph new add: (PRText content: 'should not be capitalized'));		add:			(PRHeader new				level: 2;				add: (PRText content: 'HEADER'));		add: (PRParagraph new add: (PRText content: 'should not be capitalized'));		yourself.	self		assert:			(newInstance				start: input)		equals: expected! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests' stamp: 'ThibaultArloing 4/7/2016 08:50'!testDefaultValueForCapitalization	self testTemplateForDefaultValueForCapitalization: 'i am a header'.	self testTemplateForDefaultValueForCapitalization: 'I am A hEader'! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests' stamp: 'ThibaultArloing 4/6/2016 15:15'!testLowerCaseCapitalization	self testTemplateForCapitalizationHeader: 'lower case' text: 'I AM A HEADER' expected: 'i am a header'.	self testTemplateForCapitalizationHeaderWithBold: 'lower case' text: 'I AM A HEADER' expected: 'i am a header'.! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests' stamp: 'ThibaultArloing 4/8/2016 10:51'!testNotUnderstandCapitalizationType	self testTemplateForCapitalizationHeader: 'hello' text: 'i aM A HeaDer' expected: 'i aM A HeaDer'.	self testTemplateForCapitalizationHeaderWithBold: 'hello' text: 'i aM A HeaDer' expected: 'i aM A HeaDer'.! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:10'!testTemplateForCapitalizationHeader: aType text: aString expected: anotherString	|input expected config |	config := self configuration.	self addHeader: (Dictionary with: 'capitalization' -> aType) ofLevel: 2 to: config.		input := PRDocument new 		add:				(PRHeader new level: 2;					add: (PRText content: aString));		yourself.		expected := PRDocument new 		add:				(PRHeader new level: 2;					add: (PRText content: anotherString));		yourself.	self assert: (self executePhase: input with: config) equals: expected! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:10'!testTemplateForCapitalizationHeaderWithBold: aType text: aString expected: anotherString	|input expected config |	config := self configuration.	self addHeader: (Dictionary with: 'capitalization' -> aType) ofLevel: 2 to: config.		input := PRDocument new 		add:				(PRHeader new level: 2;					add: (PRBoldFormat new								add: (PRText content: aString)));		yourself.		expected := PRDocument new 		add:				(PRHeader new level: 2;					add: (PRBoldFormat new								add: (PRText content: anotherString)));		yourself.	self assert: (self executePhase: input with: config) equals: expected! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:11'!testTemplateForDefaultValueForCapitalization: aString	|input config |	config := self configuration.	self addHeader: (Dictionary new ) ofLevel: 2 to: config.		input := PRDocument new 		add:				(PRHeader new level: 2;					add: (PRText content: aString));		yourself.	self assert: (self executePhase: input with: config) equals: input! !!PRHeaderCapitalizationTransformerTest methodsFor: 'tests' stamp: 'ThibaultArloing 4/6/2016 15:14'!testUpperCaseCapitalization	self testTemplateForCapitalizationHeader: 'upper case' text: 'i am a header' expected: 'I AM A HEADER'.	self testTemplateForCapitalizationHeaderWithBold: 'upper case' text: 'i am a header' expected: 'I AM A HEADER'.! !!PRHeadingLevelOffsetTest methodsFor: 'private' stamp: 'DamienCassou 6/21/2016 11:17'!actualClass	^ PRHeadingLevelOffset! !!PRHeadingLevelOffsetTest methodsFor: 'tests' stamp: 'DamienCassou 6/21/2016 11:22'!checkWithOffset: offset	| result input configuration |	configuration := self configuration.	configuration headingLevelOffset: offset.	input := PRHeader new		level: 3;		add: (PRText content: 'a title');		yourself.	result := self executePhase: input with: configuration.	self assert: result level equals: offset + 3! !!PRHeadingLevelOffsetTest methodsFor: 'tests' stamp: 'DamienCassou 6/21/2016 11:23'!testPositiveOffset	self checkWithOffset: 2! !!PRHeadingLevelOffsetTest methodsFor: 'tests' stamp: 'DamienCassou 6/21/2016 11:23'!testZeroOffset	self checkWithOffset: 0! !!PRNodeTransformerTest class methodsFor: 'testing' stamp: 'DamienCassou 6/21/2016 13:38'!isAbstract	^ self = PRNodeTransformerTest ! !!PRNodeTransformerTest methodsFor: 'private' stamp: 'DamienCassou 6/21/2016 11:24'!actualClass	^ PRNodeTransformer! !!PRNodeTransformerTest methodsFor: 'accessing' stamp: 'DamienCassou 7/19/2016 15:51'!configuration	^ PRPillarConfiguration new! !!PRNodeTransformerTest methodsFor: 'transformation' stamp: 'DamienCassou 7/20/2016 16:29'!executePhase: anInput	^ self executePhase: anInput with: self configuration! !!PRNodeTransformerTest methodsFor: 'transformation' stamp: 'DamienCassou 7/19/2016 15:45'!executePhase: anInput with: aConfig	^ (self actualClass		executeOn:			(PRCompilationContext withDocument: anInput withConfiguration: aConfig))		input! !!PRRemoveHideableScriptsTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 4/5/2016 16:00'!actualClass	^ PRRemoveHideableScripts ! !!PRRemoveHideableScriptsTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:12'!testScriptWhenHideable	| input expected |	input := PRDocument new 		add: ((PRScript content: 'Object') 					hideable: true;					yourself);				yourself.	expected := PRDocument new.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRRemoveHideableScriptsTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:12'!testScriptWhenNotHideable	| input |	input := PRDocument new 		add: ((PRScript content: 'Object') 					hideable: false;					yourself);				yourself.	self assert: (self executePhase: input with: self configuration) equals: input! !!PRRemoveHideableScriptsTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:12'!testScriptWithoutHideableParameter	| input |	input := PRDocument new 		add: ((PRScript content: 'Object') 					yourself);				yourself.	self assert: (self executePhase: input with: self configuration) equals: input! !!PRScriptEvaluatorTest methodsFor: 'private' stamp: 'DamienCassou 4/5/2015 10:23'!actualClass	^ PRScriptEvaluator ! !!PRScriptEvaluatorTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:13'!testScriptWithEvalThatDoesntReturnAParagraph	| input expected |	input := PRDocument new		add:			(PRParagraph new				add:						((PRScript content: 'stream nextPutAll: ''-test''')								eval: true;								yourself);				yourself) yourself.	expected := PRDocument new		add:			(PRParagraph new				add: (PRUnorderedList new add: (PRListItem new add: (PRText content: 'test')));				yourself) yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptEvaluatorTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:13'!testScriptWithProblematicEval	| input |	input := PRDocument new		add:				((PRScript content: 'Object SomethingThatIsNotAMethod')						eval: true;						yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: input! !!PRScriptEvaluatorTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:14'!testScriptWithoutEval	| input expected |	input := PRDocument new		add:				((PRScript content: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						eval: false;						yourself);		yourself.	expected := PRDocument new		add:				((PRScript content: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						eval: false;						yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptFromFileTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 4/30/2015 19:03'!aCode	| code |	code := String new writeStream.	code		nextPutAll: self headingCode;		nextPutAll: self middleCode;		nextPutAll: self endingCode.	^ code contents! !!PRScriptFromFileTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/30/2015 15:29'!actualClass	^ PRScriptFromFile! !!PRScriptFromFileTest methodsFor: 'as yet unclassified' stamp: 'DamienCassou 7/19/2016 15:47'!baseDirectory	^ baseDirectory! !!PRScriptFromFileTest methodsFor: 'as yet unclassified' stamp: 'YannDubois 5/23/2016 17:06'!configuration	^ super configuration		baseDirectory: baseDirectory;		newLine: Smalltalk os lineEnding;		yourself.! !!PRScriptFromFileTest methodsFor: 'actions' stamp: 'CyrilFerlicot 4/30/2015 16:00'!createFile: aName With: text In: aDirectory	| stream |	stream := (aDirectory / aName) writeStream.	stream nextPutAll: text.	stream close! !!PRScriptFromFileTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 5/23/2015 19:16'!endingCode	| code |	code := String new writeStream.	code nextPutAll: Smalltalk os lineEnding.	code nextPut: Character tab.	^ code contents! !!PRScriptFromFileTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 4/30/2015 19:02'!firstLine	^ 5! !!PRScriptFromFileTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 5/23/2015 19:16'!headingCode	| code |	code := String new writeStream.	self firstLine timesRepeat: [ code nextPutAll: Smalltalk os lineEnding ].	^ code contents! !!PRScriptFromFileTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 5/23/2015 19:16'!middleCode	| code |	code := String new writeStream.	code		nextPutAll: '|test|';		nextPutAll: Smalltalk os lineEnding;		nextPutAll: 'test := 1.';		nextPutAll: Smalltalk os lineEnding;		nextPutAll: 'test := 1+1'.	^ code contents! !!PRScriptFromFileTest methodsFor: 'running' stamp: 'DamienCassou 7/19/2016 15:48'!setUp	super setUp.	baseDirectory := FileSystem memory root.	self		createFile: 'code.st'		With: self aCode		In: baseDirectory! !!PRScriptFromFileTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:15'!testCanGetFileInsideAnOtherDirectory	| input expected |	(baseDirectory / 'foo') ensureCreateDirectory.	self createFile: 'code.st' With: self aCode In: baseDirectory / 'foo'.	input := PRDocument new		add: ((PRScript content: '') fromFile: 'foo/code.st' yourself);		yourself.	expected := PRDocument new		add:			((PRScript content: self aCode)				fromFile: 'foo/code.st';				yourself);		yourself.	self		assert: (self executePhase: input with: self configuration)		equals: expected! !!PRScriptFromFileTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:15'!testFirstAndLastLineDefine	| input expected |	input := PRDocument new		add:				((PRScript content: '')						fromFile: 'code.st';						firstLine: self firstLine +1;						lastLine: self firstLine + 3 yourself);		yourself.	expected := PRDocument new		add:				((PRScript content: self middleCode)						fromFile: 'code.st';						firstLine: self firstLine +1;						lastLine: self firstLine + 3 yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptFromFileTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:17'!testFirstLineDefine	| input expected |	input := PRDocument new		add:				((PRScript content: '')						fromFile: 'code.st';						firstLine: self firstLine + 1 yourself);		yourself.	expected := PRDocument new		add:				((PRScript content: self middleCode , self endingCode)						fromFile: 'code.st';						firstLine: self firstLine + 1 yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptFromFileTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:18'!testFirstLineOutOfBounds	| input |	input := PRDocument new		add:				((PRScript content: '')						fromFile: 'code.st';						firstLine: 500 yourself);		yourself.	self should: [ self executePhase: input with: self configuration ] raise: PRPropertyError! !!PRScriptFromFileTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:20'!testHasFileFrom	| input expected |	input := PRDocument new		add: ((PRScript content: '') fromFile: 'code.st' yourself);		yourself.	expected := PRDocument new		add:				((PRScript content: self aCode)						fromFile: 'code.st';						yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptFromFileTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:20'!testHasWrongFileFrom	| input |	input := PRDocument new		add: ((PRScript content: '') fromFile: 'wrong.st' yourself);		yourself.	self should: [ self executePhase: input with: self configuration ] raise: PRInputFileError ! !!PRScriptFromFileTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:21'!testLastLineDefine	| input expected |	input := PRDocument new		add:				((PRScript content: '')						fromFile: 'code.st';						lastLine: self firstLine + 3 yourself);		yourself.	expected := PRDocument new		add:				((PRScript content: self headingCode , self middleCode)						fromFile: 'code.st';						lastLine: self firstLine + 3 yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptFromFileTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:21'!testLastLineLowestThanFirstLine	| input |	input := PRDocument new		add:				((PRScript content: '')						fromFile: 'code.st';						firstLine: 5;						lastLine: 0 yourself);		yourself.	self should: [ self executePhase: input with: self configuration ] raise: PRPropertyError! !!PRScriptFromFileTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:22'!testLastLineOutOfBounds	| input |	input := PRDocument new		add:				((PRScript content: '')						fromFile: 'code.st';						lastLine: 500 yourself);		yourself.	self should: [ self executePhase: input with: self configuration ] raise: PRPropertyError! !!PRScriptFromFileTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:22'!testWarningWhenScriptNotEmpty	| input  |	input := PRDocument new		add: ((PRScript content: 'foo') fromFile: 'code.st' yourself);		yourself.	self should: [ self executePhase: input with: self configuration ] raise: PRWarning! !!PRScriptFromFileTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:22'!testtestFirstLineIsNotANumber	| input |	input := PRDocument new		add:				((PRScript content: '')						fromFile: 'code.st';						firstLine: 'foo' yourself);		yourself.	self should: [ self executePhase: input with: self configuration ] raise: PRPropertyError! !!PRScriptLineNumberTest methodsFor: 'private' stamp: 'CyrilFerlicot 4/23/2015 11:16'!actualClass	^ PRScriptLineNumber ! !!PRScriptLineNumberTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:24'!testScriptWithLineNumber	| input expected |	input := PRDocument new		add:				((PRScript content: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						lineNumber: true;						eval: false;						yourself);		yourself.	expected := PRDocument new		add:				((PRScript content: '1	stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						lineNumber: true;						eval: false;						yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptLineNumberTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:25'!testScriptWithLineNumberFalse	| input expected |	input := PRDocument new		add:				((PRScript content: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						lineNumber: false;						eval: false;						yourself);		yourself.	expected := PRDocument new		add:				((PRScript content: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						lineNumber: false;						eval: false;						yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptLineNumberTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:25'!testScriptWithoutParameter	| input expected |	input := PRDocument new		add:				((PRScript content: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						yourself);		yourself.	expected := PRDocument new		add:				((PRScript content: 'stream nextPut: $h; nextPut: $e; nextPut: $l; nextPutAll: ''lo''')						yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptStructureTransformerTest methodsFor: 'private' stamp: 'ThibaultArloing 5/25/2016 09:06'!actualClass	^PRScriptStructureTransformer ! !!PRScriptStructureTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:26'!testTransformScriptStructure	| input expected |	input := PRDocument new		add:			((PRScript 				content:'{"postCode":"59000","name":"Lille"}')				structureName:'city';				yourself).	expected := PRDocument new		add:			(PRStructure new				tag: 'city';				structDict: (Dictionary with: 'name' -> 'Lille'												with: 'postCode' -> '59230');				yourself).	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRScriptStructureTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:26'!testTransformScriptStructureWithTwoStructure	| input expected |	input := PRDocument new		add:			((PRScript content: '{"name":"Zimbabwe"}')				structureName: 'country';				yourself);		add:			((PRScript content: '{"name":"Bidon", "postCode":"07034"}')				structureName: 'city';				yourself).	expected := PRDocument new		add:			(PRStructure new				tag: 'country';				structDict: (Dictionary with: 'name' -> 'Zimbabwe');				yourself);		add:			(PRStructure new				tag: 'city';				structDict: (Dictionary with: 'name' -> 'Bidon' with: 'postCode' -> '07034');				yourself).	self		assert: (self executePhase: input with: self configuration)		equals: expected! !!PRSectionTransformerTest methodsFor: 'private' stamp: 'CyrilFerlicot 6/3/2015 10:04'!actualClass	^ PRSectionTransformer! !!PRSectionTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:26'!testTransformWithChangedMaxDepthLevel	| input expected |	input := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Bar') yourself);		add: (PRParagraph with: (PRText content: 'Foo') yourself);		add:			(PRHeader new				level: 2;				add: (PRText content: 'Bar2') yourself);		add: (PRParagraph with: (PRText content: 'Foo2') yourself);		yourself.	expected := PRDocument new		add:			(PRSection new				add:					(PRHeader new						level: 1;						add: (PRText content: 'Bar') yourself);				add: (PRParagraph with: (PRText content: 'Foo') yourself);				add:					(PRHeader new						level: 2;						add: (PRText content: 'Bar2') yourself);				add: (PRParagraph with: (PRText content: 'Foo2') yourself);				yourself) yourself.	self actualClass maxDepthLevel: 1.	self		assert: (self executePhase: input with: self configuration)		equals: expected.	"After the test we reinitialize the PRSectionTransformer to get the normal MaxDepthLevel"	self actualClass initialize! !!PRSectionTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:27'!testTransformWithOneSection	| input expected |	input := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'Bar') yourself);		add: (PRParagraph with: (PRText content: 'Foo!!') yourself);		yourself.	expected := PRDocument new		add:			(PRSection new				add:						(PRHeader new								level: 1;								add: (PRText content: 'Bar') yourself);				add: (PRParagraph with: (PRText content: 'Foo!!') yourself);				yourself) yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRSectionTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:27'!testTransformWithParagraphBeforeSection	| input expected |	input := PRDocument new		add: (PRParagraph with: (PRText content: 'Hello World') yourself);		add:				(PRHeader new						level: 1;						add: (PRText content: 'Bar') yourself);		add: (PRParagraph with: (PRText content: 'Foo') yourself);		yourself.	expected := PRDocument new		add: (PRParagraph with: (PRText content: 'Hello World') yourself);		add:				(PRSection new						add:								(PRHeader new										level: 1;										add: (PRText content: 'Bar') yourself);						add: (PRParagraph with: (PRText content: 'Foo') yourself);						yourself) yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRSectionTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:28'!testTransformWithTwoSections	| input expected |	input := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'Bar') yourself);		add: (PRParagraph with: (PRText content: 'Foo') yourself);		add:				(PRHeader new						level: 1;						add: (PRText content: 'Bar2') yourself);		add: (PRParagraph with: (PRText content: 'Foo2') yourself);		yourself.	expected := PRDocument new		add:				(PRSection new						add:								(PRHeader new										level: 1;										add: (PRText content: 'Bar') yourself);						add: (PRParagraph with: (PRText content: 'Foo') yourself);						yourself);		add:				(PRSection new						add:								(PRHeader new										level: 1;										add: (PRText content: 'Bar2') yourself);						add: (PRParagraph with: (PRText content: 'Foo2') yourself);						yourself) yourself.	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRSectionTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:28'!testTransformWithoutSection	| input |	input := PRDocument new		add: (PRParagraph with: (PRText content: 'Foo!!') yourself);		yourself.	self assert: (self executePhase: input with: self configuration) equals: input! !!PRSectionTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:29'!testTransformationKeepSameContent	| input |	input := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Bar') yourself);		add: (PRParagraph with: (PRText content: 'Foo') yourself);		add:			(PRHeader new				level: 2;				add: (PRText content: 'Bar2') yourself);		add: (PRParagraph with: (PRText content: 'Foo2') yourself);		yourself.	self		assert: (PRPillarWriter write: (self executePhase: input with: self configuration))		equals: (PRPillarWriter write: input)! !!PRSlideTransformerTest methodsFor: 'private' stamp: 'CyrilFerlicot 6/3/2015 14:24'!actualClass	^ PRSlideTransformer! !!PRSlideTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 7/21/2016 12:13'!testDependOnCleanAnnotationInParagraphTransfomer	self assert: (self actualClass dependencies anySatisfy: [ :pipe | pipe key = #cleanAnnotationInParagraph ])! !!PRSlideTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 7/21/2016 12:04'!testTransformAnnotationStopAtTitle	| input expected |	input := PRDocument new		add:				PRSlideTitleAnnotation new;		add: (PRParagraph with: (PRText content: 'Foo!!') yourself);		add:				(PRHeader new						level: 1;						add: (PRText content: 'Foo');						yourself);		yourself.	expected := PRDocument new		add:				(PRSlide new						add: (PRParagraph with: (PRText content: 'Foo!!') yourself);						yourself);		add:				(PRHeader new						level: 1;						add: (PRText content: 'Foo');						yourself);		yourself.	self assert: (self executePhase: input) equals: expected! !!PRSlideTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 7/21/2016 12:04'!testTransformWithOneAnnotation	| input expected |	input := PRDocument new		add:				PRSlideTitleAnnotation new;		add: (PRParagraph with: (PRText content: 'Foo!!') yourself);		yourself.	expected := PRDocument new		add:			(PRSlide new				add: (PRParagraph with: (PRText content: 'Foo!!') yourself);				yourself) yourself.	self assert: (self executePhase: input) equals: expected! !!PRSlideTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 7/21/2016 12:05'!testTransformWithTwoAnnotation	| input expected |	input := PRDocument new		add:				PRSlideTitleAnnotation new;		add: (PRParagraph with: (PRText content: 'Foo!!') yourself);		add:				PRSlideTitleAnnotation new;		add: (PRParagraph with: (PRText content: 'Bar') yourself);		yourself.	expected := PRDocument new		add:				(PRSlide new						add: (PRParagraph with: (PRText content: 'Foo!!') yourself);						yourself);		add:				(PRSlide new						add: (PRParagraph with: (PRText content: 'Bar') yourself);						yourself);		yourself.	self assert: (self executePhase: input) equals: expected! !!PRSlideTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:31'!testTransformationKeepSameContent	| input |	input := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'Bar') yourself);		add: (PRParagraph with: (PRText content: 'Foo') yourself);		add: PRSlideTitleAnnotation new;		add: (PRParagraph with: (PRText content: 'Foo2') yourself);		yourself.	self assert: (PRPillarWriter write: (self executePhase: input with: self configuration)) equals: (PRPillarWriter write: input)! !!PRStructureTransformerTest methodsFor: 'private' stamp: 'ThibaultArloing 5/25/2016 09:40'!actualClass	^PRStructureTransfomer ! !!PRStructureTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:34'!testTransformExerciseStructure	| input expected |	input := PRDocument new		add:			(PRStructure new				tag: 'exercise';				structDict: (Dictionary with: 'question' -> 'question ?' with: 'answer' -> '42')).	expected := PRDocument new		add:			(PRDefinitionList new				add: (PRTermItem with: (PRText new text: 'question'));				add: (PRDataItem with: (PRText new text: 'question ?'));				add: (PRTermItem with: (PRText new text: 'answer'));				add: (PRDataItem with: (PRText new text: '42'));				yourself).	self assert: (self executePhase: input with: self configuration) equals: expected! !!PRStructureTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:34'!testTransformWithTwoStructure	| input expected |	input := PRDocument new	add:			(PRStructure new				tag: 'exercise';				structDict: (Dictionary with: 'question' -> 'question ?' with: 'answer' -> '42'));		add:			(PRStructure new				tag: 'country';				structDict: (Dictionary with: 'name' -> 'Zimbabwe'));		yourself.			expected := PRDocument new		add:			(PRDefinitionList new				add: (PRTermItem with: (PRText new text: 'question'));				add: (PRDataItem with: (PRText new text: 'question ?'));				add: (PRTermItem with: (PRText new text: 'answer'));				add: (PRDataItem with: (PRText new text: '42'));				yourself);		add:			(PRTable new				add:					(PRTableRow new						add: (PRTableCell with: (PRText new text: 'name'));						add: (PRTableCell with: (PRText new text: 'Zimbabwe'));						yourself));		yourself.	self		assert: (self executePhase: input with: self configuration)		equals: expected! !!PRCreationPhaseTest methodsFor: 'private' stamp: 'CyrilFerlicot 6/15/2015 13:59'!actualClass	^ PRCreationPhase! !!PRCreationPhaseTest methodsFor: 'tests' stamp: 'AutoDeprecationRefactoring 7/18/2016 14:18'!testCreationOfFile	| directory file configuration |	directory := FileSystem memory root.	file := directory / 'foo.pillar'.	configuration := PRPillarConfiguration new		baseDirectory: directory;		inputFile: file;		yourself.	self		assert:			(self actualClass				executeOn: (PRCompilationContext configuration: configuration))				input		equals: file! !!PRExportPhaseTest methodsFor: 'private' stamp: 'CyrilFerlicot 6/15/2015 14:00'!actualClass	^ PRExportPhase! !!PRExportPhaseTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/15/2015 14:48'!testDocumentPropertiesAreAccessible	| doc data |	doc := PRDocument new propertyAt: 'authors' put: 'Someone'; yourself.	data := self actualClass new extractDataFrom: doc using: PRMockWriter new.	self assert: (data hasProperty: 'authors').	self assert: (data propertyAt: 'authors') equals: 'Someone'! !!PRExportPhaseTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testDocumentPropertiesTakePrecedence	| doc data conf |	doc := PRDocument new		propertyAt: 'title' put: 'Should win';		yourself.	conf := PRPillarConfiguration new.	conf title: 'Should fail'.	data := self actualClass new		configuration: conf;		extractDataFrom: doc using: PRMockWriter new.	self assert: (data hasProperty: 'title').	self assert: (data propertyAt: 'title') equals: 'Should win'! !!PRExportPhaseTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/29/2015 11:17'!testEnsureNewFileWhenExporting	| configuration phase |	FileSystem workingDirectory / 'foo.html' writeStreamDo: [ :stream | stream nextPutAll: 'some very long string' ].	configuration := self fromString: '{ #outputFile: "foo.html" }'.	phase := self actualClass new configuration: configuration.	phase outputStreamDuring: [ :outStream | phase writeOutput: 'short' toStream: outStream ].	self assert: (FileSystem workingDirectory / 'foo.html') readStream contents asString equals: 'short'.	(FileSystem workingDirectory / 'foo.html') ensureDelete! !!PRParsingPhaseTest methodsFor: 'private' stamp: 'CyrilFerlicot 6/15/2015 14:00'!actualClass	^ PRParsingPhase! !!PRParsingPhaseTest methodsFor: 'tests' stamp: 'YannDubois 7/13/2016 16:55'!testDocumentConfigurationIsUsed	| configuration ston |	FileSystem workingDirectory / 'fileForTest2.pillar'		writeStreamDo: [ :stream | 			stream				nextPutAll:					'{			"mockProperty":true		}		foo' ].	ston := '{		"outputType":#mock,		#inputFile : "fileForTest2.pillar",		"mockProperty":false	}'.	configuration := (self fromString: ston)		baseDirectory: FileSystem workingDirectory;		yourself.	self assert: ((self actualClass executeOn: (PRCompilationContext withDocument: configuration inputFile withConfiguration: configuration)) configuration propertyAt: 'mockProperty').	(FileSystem workingDirectory / 'fileForTest2.pillar') ensureDelete! !!PRParsingPhaseTest methodsFor: 'tests' stamp: 'AutoDeprecationRefactoring 7/18/2016 14:18'!testParsing	| ston configuration |	ston := '{ #inputFile : "fileForTest1.pillar" }'.	FileSystem workingDirectory / 'fileForTest1.pillar'		writeStreamDo: [ :stream | stream nextPutAll: 'foo' ].	configuration := (self fromString: ston)		baseDirectory: FileSystem workingDirectory;		yourself.	self		assert:			(self actualClass				executeOn:					(PRCompilationContext						withDocument: configuration inputFile						withConfiguration: configuration)) input		equals:			(PRDocument new				add: (PRParagraph new add: (PRText content: 'foo'));				yourself).	(FileSystem workingDirectory / 'fileForTest1.pillar') ensureDelete! !!PRParsingPhaseTest methodsFor: 'tests' stamp: 'ThibaultArloing 5/4/2016 14:08'!testWrongSTONError	| file configuration |	file := FileSystem workingDirectory / 'foo.pillar'.	file writeStreamDo: [ :stream | stream nextPutAll: '{"title"="titre"}' ].	configuration := PRPillarConfiguration new		baseDirectory: FileSystem workingDirectory;		yourself.	self		should: [ self actualClass new parseFile: configuration baseDirectory / 'foo.pillar' ]		raise: STONReaderError		whoseDescriptionIncludes: 'foo.pillar'		description: 'foo.pillar'.	(FileSystem workingDirectory / 'foo.pillar') ensureDelete! !!PRParsingPhaseTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testWrongTagError	| file configuration |	file := FileSystem workingDirectory / 'foo.pillar'.	file writeStreamDo: [ :stream | stream nextPutAll: '${wrongTag}$' ].	configuration := PRPillarConfiguration new		baseDirectory: FileSystem workingDirectory;		yourself.	self		should: [ self actualClass new parseFile: configuration baseDirectory / 'foo.pillar' ]		raise: PRError		whoseDescriptionIncludes: 'foo.pillar'		description: 'foo.pillar'.	(FileSystem workingDirectory / 'foo.pillar') ensureDelete! !!PRPhaseTest class methodsFor: 'testing' stamp: 'CyrilFerlicot 6/15/2015 13:58'!isAbstract	^ self = PRPhaseTest! !!PRPhaseTest methodsFor: 'private' stamp: 'CyrilFerlicot 6/15/2015 13:58'!actualClass	self subclassResponsibility! !!PRPhaseTest methodsFor: 'running' stamp: 'YannDubois 7/18/2016 13:41'!createMockClass	"I create a Mock Phase that just do nothing on the input."	PRNodeTransformer		subclass: #PRMockPhase		instanceVariableNames: ''		classVariableNames: ''		category: 'Pillar-Tests-ExporterCore'.	(Smalltalk globals at: #PRMockPhase) class		compile:			'priority	^ 90'.	(Smalltalk globals at: #PRMockPhase) class		compile:			'key	^ #mock'.	(Smalltalk globals at: #PRMockPhase) class		compile:			'pipelineKey	^ #transform'.	(Smalltalk globals at: #PRMockPhase)		compile:			'start: anInput	^ super start: (anInput add: (PRText content: ''Bar''); yourself)'.	(Smalltalk globals at: #PRMockPhase)		compile:			'visitDocumentGroup: aGroup			aGroup add: (PRText content: ''Timoleon'')'.	(Smalltalk globals at: #PRMockPhase)		compile:			'transformerMock: aCollection			<pillarTransformer: 100 key: ''mock'' documentation:''mock transformer''>'! !!PRPhaseTest methodsFor: 'instance creation' stamp: 'CyrilFerlicot 10/29/2015 22:00'!fromString: aString	^ PRPillarConfiguration newFromString: aString! !!PRPhaseTest methodsFor: 'accessing' stamp: 'YannDubois 6/1/2016 11:24'!jsonStreamWithContent: aString	| expected |	expected := '' writeStream		<< '{';		<< '"content":"';		<< aString;		<< '"}';		yourself.	^ expected! !!PRPhaseTest methodsFor: 'accessing' stamp: 'YannDubois 6/1/2016 11:25'!jsonStreamWithContent: aString withTitle: anOtherString	| expected |	expected := '' writeStream		<< '{';		<< '"content":"';		<< aString;		<< '",';		<< '"title":"';		<< anOtherString;		<< '"';		<< '}';		yourself.	^ expected! !!PRPhaseTest methodsFor: 'running' stamp: 'CyrilFerlicot 6/17/2015 13:19'!runCase	"I'm here because PRPhaseTest will create a Mock and we don't want to inform Nautilus."	SystemAnnouncer uniqueInstance suspendAllWhile: [ super runCase ]! !!PRPhaseTest methodsFor: 'running' stamp: 'DamienCassou 7/19/2016 15:49'!setUp	super setUp.	self createMockClass! !!PRPhaseTest methodsFor: 'running' stamp: 'CyrilFerlicot 7/2/2015 13:58'!tearDown	super tearDown.	(Smalltalk globals classNamed: 'PRMockPhase') ifNotNil: [ :class | class removeFromSystem ]! !!PRPhaseTest methodsFor: 'tests' stamp: 'DamienCassou 7/13/2016 15:22'!testDocumentAreTransformed	| configuration input output expected |	input := 'Foo'.	output := WriteStream on: String new.	configuration := PRPillarConfiguration new		inputString: input;		outputStream: output;		outputType: PRMockWriter;		export.			expected := self jsonStreamWithContent: 'FooBarTimoleon'.	self assert: (Json readFrom: output contents readStream) equals: (Json readFrom: expected contents readStream).! !!PRPhaseTest methodsFor: 'tests' stamp: 'YannDubois 7/13/2016 09:35'!testDocumentAreTransformedWithMetadata  	| configuration input output expected ston expectedJson outputJson |  	input := 'Foo'.  	output := '' writeStream.		ston := '{		"outputType":#mock,		"metadata": { 			"title":"Test"		 }	}'.	configuration := PRPillarConfiguration newFromString: ston.	configuration outputStream: output; inputString: input; yourself; export.		expected := self jsonStreamWithContent: 'FooBarTimoleon' withTitle: 'Test'.	expectedJson := Json readFrom: expected contents readStream.	outputJson := Json readFrom: output contents readStream.  	self assert: outputJson equals: expectedJson .! !!PRPhaseTest methodsFor: 'tests' stamp: 'DamienCassou 7/13/2016 17:02'!testPhaseAndTransformersAreCollected	| configuration input output expected |	input := 'Foo'.	output := WriteStream on: String new.	configuration := PRPillarConfiguration new		inputString: input;		outputStream: output;		outputType: PRMockWriter;		export.		expected := self jsonStreamWithContent: 'FooBarTimoleon'.	self assert: (Json readFrom: output contents readStream) equals: (Json readFrom: expected contents readStream).! !!PRPhaseTest methodsFor: 'tests' stamp: 'YannDubois 7/12/2016 14:49'!testTransformerCanBeDisable	| configuration input output expected |	input := 'Foo'.	output := WriteStream on: String new.	configuration := PRPillarConfiguration new		inputString: input;		outputStream: output;		outputType: PRMockWriter;		disabledPhases: (Array with: 'mock');		export.		expected := self jsonStreamWithContent: 'Foo'.	self assert: (Json readFrom: output contents readStream) equals: (Json readFrom: expected contents readStream).! !!PRUpdateFileInclusionReferenceTest methodsFor: 'private' stamp: 'ThibaultArloing 7/19/2016 14:08'!actualClass	^PRUpdateFileInclusionReference ! !!PRUpdateFileInclusionReferenceTest methodsFor: 'private' stamp: 'ThibaultArloing 7/19/2016 14:23'!testNewReferenceFor	|figure result expected |	figure := PRFigure new reference: 'file://foo.pillar'.	result := self actualClass start: figure with: 'bar'.	expected := PRFigure new reference: 'file://bar/foo.pillar'.		self assert: result equals: expected! !!PRCascadingCounterTest methodsFor: 'accessing' stamp: 'DamienCassou 1/15/2014 16:10'!packageNamesUnderTest	^ #('Pillar-ExporterCore')! !!PRCascadingCounterTest methodsFor: 'tests' stamp: 'DamienCassou 11/21/2013 13:00'!testElementsForNonSimpleCounter	| counter |	counter := PRCascadingCounter maxLevel: 5.	self assert: counter elements equals: { 0 }.	counter incrementAt: 2.	self assert: counter elements equals: { 0 . 1 }! !!PRCascadingCounterTest methodsFor: 'tests' stamp: 'DamienCassou 11/21/2013 12:59'!testElementsForSimpleCounter	| counter |	counter := PRCascadingCounter maxLevel: 5.	self assert: counter elements equals: { 0 }.	counter incrementAt: 1.	self assert: counter elements equals: { 1 }! !!PRCascadingCounterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 5/20/2015 15:08'!testIsValidCounter	self assert: (PRCascadingCounter maxLevel: 5) isValidCounter.	self deny: (PRNotFoundCounter maxLevel: 5) isValidCounter! !!PRLevelLetterConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:16'!actualClass	^ PRLevelLetterConfiguration ! !!PRLevelLetterConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:11'!representationOf26	^ 'z'! !!PRLevelLetterConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:11'!representationOf27	^ 'a'''! !!PRLevelLetterConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:09'!representationOfOne	^ 'a'! !!PRLevelNumberConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:16'!actualClass	^ PRLevelNumberConfiguration ! !!PRLevelNumberConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:11'!representationOf26	^ '26'! !!PRLevelNumberConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:11'!representationOf27	^ '27'! !!PRLevelNumberConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:09'!representationOfOne	^ '1'! !!PRLevelRomanConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:16'!actualClass	^ PRLevelRomanConfiguration ! !!PRLevelRomanConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:13'!representationOf26	^ 'XXVI'! !!PRLevelRomanConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:13'!representationOf27	^ 'XXVII'! !!PRLevelRomanConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:10'!representationOfOne	^ 'I'! !!PRLevelUpperLetterConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:16'!actualClass	^ PRLevelUpperLetterConfiguration ! !!PRLevelUpperLetterConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:14'!representationOf26	^ 'Z'! !!PRLevelUpperLetterConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:14'!representationOf27	^ 'A'''! !!PRLevelUpperLetterConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:10'!representationOfOne	^ 'A'! !!PRTitleConfigurationTest class methodsFor: 'testing' stamp: 'ThibaultArloing 4/6/2016 15:52'!isAbstract	^ self = PRTitleConfigurationTest! !!PRTitleConfigurationTest methodsFor: 'requirement' stamp: 'ThibaultArloing 4/6/2016 15:43'!actualClass	^ PRTitleConfiguration! !!PRTitleConfigurationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 5/29/2016 00:55'!addHeader: aDictionary ofLevel: aNumber to: aConfiguration	| headerConfig |	headerConfig := (aConfiguration class headerConfigurations at: (aDictionary at: 'renderAs' ifAbsent: [ 'roman' ]))		with: aDictionary.	headerConfig		level: aNumber;		configuration: aConfiguration.	aConfiguration perform: ('level' , aNumber asString , ':') asSymbol with: headerConfig! !!PRTitleConfigurationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 5/17/2015 18:56'!counterLevel3	^ Array with: 1 with: -1 with: 3! !!PRTitleConfigurationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 5/17/2015 17:46'!defaultDictionary	^ Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'roman'! !!PRTitleConfigurationTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 5/18/2015 15:01'!newDefaultConfiguration	^ self actualClass with: self defaultDictionary! !!PRTitleConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:10'!representationOf26	^ self subclassResponsibility! !!PRTitleConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:10'!representationOf27	^ self subclassResponsibility! !!PRTitleConfigurationTest methodsFor: 'requirement' stamp: 'CyrilFerlicot 5/18/2015 15:03'!representationOfOne	^ self subclassResponsibility! !!PRTitleConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testCounter	| config |	config := PRPillarConfiguration new.	self		addHeader: (Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'roman')		ofLevel: 1		to: config.	self		addHeader: (Dictionary with: 'numbering' -> true with: 'size' -> 0 with: 'renderAs' -> 'letter')		ofLevel: 2		to: config.	self		addHeader: (Dictionary with: 'numbering' -> true with: 'size' -> 3 with: 'renderAs' -> 'letter')		ofLevel: 3		to: config.	self assert: (config level3 printCounter: self counterLevel3) equals: 'I.c'! !!PRTitleConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testEquals	| config |	config := PRPillarConfiguration new.	self addHeader: self defaultDictionary ofLevel: 1 to: config.	self addHeader: self defaultDictionary ofLevel: 2 to: config.	self assert: config level1 = config level1.	self deny: config level2 = config level1! !!PRTitleConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 5/17/2015 17:54'!testHash	| headerConfig |	headerConfig := self newDefaultConfiguration.	self assert: headerConfig hash equals: headerConfig copy hash.	self assert: headerConfig hash = self newDefaultConfiguration hash! !!PRTitleConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 5/18/2015 15:11'!testPrintElement	| headerConfig |	headerConfig := self newDefaultConfiguration.	self assert: (headerConfig printElement: -1) equals: ''.	self assert: (headerConfig printElement: 1) equals: self representationOfOne.	self assert: (headerConfig printElement: 26) equals: self representationOf26.	self assert: (headerConfig printElement: 27) equals: self representationOf27! !!PRTitleConfigurationTest methodsFor: 'tests' stamp: 'ThibaultArloing 4/6/2016 09:19'!testSize	| config |	config := PRPillarConfiguration new.	self		addHeader: (Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'roman')		ofLevel: 1		to: config.	self		addHeader: (Dictionary with: 'numbering' -> true with: 'size' -> 0 with: 'renderAs' -> 'number')		ofLevel: 2		to: config.	self		addHeader: (Dictionary with: 'numbering' -> true with: 'size' -> 3 with: 'renderAs' -> 'letter')		ofLevel: 3		to: config.	self assert: (config level3 printCounter: #(1 -1 1)) equals: 'I.a'.	config level2 numbering: true.	config level2 size: 2.	self assert: (config level3 printCounter: #(1 1 1)) equals: 'I.1.a'! !!PRTitleConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testSizeHigherThanThePossible	| config |	config := PRPillarConfiguration new.	self		addHeader: (Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'roman')		ofLevel: 1		to: config.	self		addHeader: (Dictionary with: 'numbering' -> true with: 'size' -> 2 with: 'renderAs' -> 'number')		ofLevel: 1		to: config.	self assert: (config level2 printCounter: #(-1 1)) equals: '1'! !!PRTitleConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testSizeIsNotTheFullSizePossible	| config |	config := PRPillarConfiguration new.	self		addHeader: (Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'roman')		ofLevel: 1		to: config.	self		addHeader: (Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'number')		ofLevel: 2		to: config.	self assert: (config level1 printCounter: #(1)) equals: 'I'.	self assert: (config level2 printCounter: #(1 1)) equals: '1'! !!PRTitleConfigurationTest methodsFor: 'tests' stamp: 'ThibaultArloing 4/6/2016 15:43'!testSizeWhenNumeratingIsFalse	| headerConfig |	headerConfig := PRTitleConfiguration with: ( Dictionary with: 'numbering' -> false with: 'size' -> 0).	self assert: (headerConfig size) equals: 0.		headerConfig := PRTitleConfiguration with: ( Dictionary with: 'numbering' -> false with: 'size' -> 3).	self assert: (headerConfig size) equals: 0! !!PRTransformersDocumentationTest methodsFor: 'tests' stamp: 'ThibaultArloing 7/21/2016 14:56'!testDocumentsSomeTransformers	| result |	result := String streamContents: [ :stream | PRTransformersDocumentation on: stream ].	self assert: (result includesSubstring: 'numerating' caseSensitive: false).	self assert: (result includesSubstring: 'slide').! !!PRPillarConfigurationInterpreterTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 10/29/2015 22:00'!fromString: aString	^ PRPillarConfiguration newFromString: aString! !!PRPillarConfigurationInterpreterTest methodsFor: 'accessing' stamp: 'CyrilFerlicot 3/31/2015 17:03'!packageNamesUnderTest	^ #('Pillar-ExporterCore')! !!PRPillarConfigurationInterpreterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 3/31/2015 17:05'!testDefaultScriptLanguage	| ston configuration |	ston := '{ #defaultScriptLanguage : "smalltalk" }'.	configuration := self fromString: ston.	self assert: configuration defaultScriptLanguage class equals: PRSmalltalkScriptLanguage.		ston := '{ #defaultScriptLanguage : "" }'.	configuration := self fromString: ston.	self assert: configuration defaultScriptLanguage class equals: PRNoScriptLanguage.! !!PRPillarConfigurationInterpreterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 3/31/2015 17:06'!testNewLine	| ston configuration |	ston := '{ #newLine : #crlf }'.	configuration := self fromString: ston.	self assert: configuration newLine equals: String crlf.		ston := '{ #newLine : ''my newline'' }'.	configuration := self fromString: ston.	self assert: configuration newLine equals: 'my newline'.	configuration newLine: 'another'.	self assert: configuration newLine equals: 'another'! !!PRPillarConfigurationInterpreterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 3/31/2015 17:07'!testSimpleConfiguration	| ston configuration |	ston := '{ #headingLevelOffset : 2 }'.	configuration := self fromString: ston.	self assert: configuration headingLevelOffset equals: 2! !!PRPillarConfigurationInterpreterTest methodsFor: 'helpers' stamp: 'CyrilFerlicot 3/31/2015 17:04'!unexistingFilename	| name |	name := 'foo'.	[ name asFileReference exists] whileTrue: [ name := name, 'a' ].	^ name! !!PRPipelineTest class methodsFor: 'testing' stamp: 'DamienCassou 7/21/2016 11:25'!isAbstract	^ self = PRPipelineTest! !!PRPipelineTest methodsFor: 'private' stamp: 'DamienCassou 7/21/2016 11:25'!actualClass	^ PRPipeline! !!PRTransformPipelineTest methodsFor: 'private' stamp: 'DamienCassou 7/21/2016 11:27'!actualClass	^ PRTransformPipeline! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingDefaultScriptLanguage	| dictionary config |	dictionary := Dictionary with: 'defaultScriptLanguage' -> 'smalltalk'.	config := PRPillarConfiguration newFromDictionary: dictionary.	self assert: config defaultScriptLanguage equals: (PRAbstractScriptLanguage for: 'smalltalk')! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingDisableTransformers	| dictionary config |	dictionary := Dictionary with: 'disableTransformers' -> (Array with: 'foo' with: 'bar').	config := PRPillarConfiguration newFromDictionary: dictionary.	self assert: config disableTransformers equals: (Array with: 'foo' with: 'bar')! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingHeadingLevelOffset	| dictionary config |	dictionary := Dictionary with: 'headingLevelOffset' -> 1.	config := PRPillarConfiguration newFromDictionary: dictionary.	self assert: config headingLevelOffset equals: 1! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 15:02'!testReadingInputFile	| dictionary config fileSystem |	fileSystem := FileSystem memory root.	fileSystem / 'test.txt' writeStreamDo: [ :st | st nextPutAll: 'bar' ].	dictionary := Dictionary		with: 'baseDirectory' -> fileSystem		with: 'inputFile' -> 'test.txt'.	config := PRPillarConfiguration newFromDictionary: dictionary.	self assert: config inputFile contents equals: 'bar'! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingLevel1	| dictionary config |	dictionary := Dictionary		with: 'level1' -> (Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'number').	config := PRPillarConfiguration newFromDictionary: dictionary.	self		assert: config level1		equals:			((PRLevelNumberConfiguration with: (Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'number'))				configuration: config;				level: 1;				yourself)! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingLevel2	| dictionary config |	dictionary := Dictionary		with: 'level2' -> (Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'number').	config := PRPillarConfiguration newFromDictionary: dictionary.	self		assert: config level2		equals:			((PRLevelNumberConfiguration with: (Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'number'))				configuration: config;				level: 2;				yourself)! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingLevel3	| dictionary config |	dictionary := Dictionary		with: 'level3' -> (Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'number').	config := PRPillarConfiguration newFromDictionary: dictionary.	self		assert: config level3		equals:			((PRLevelNumberConfiguration with: (Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'number'))				configuration: config;				level: 3;				yourself)! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingLevel4	| dictionary config |	dictionary := Dictionary		with: 'level4' -> (Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'number').	config := PRPillarConfiguration newFromDictionary: dictionary.	self		assert: config level4		equals:			((PRLevelNumberConfiguration with: (Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'number'))				configuration: config;				level: 4;				yourself)! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingLevel5	| dictionary config |	dictionary := Dictionary		with: 'level5' -> (Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'number').	config := PRPillarConfiguration newFromDictionary: dictionary.	self		assert: config level5		equals:			((PRLevelNumberConfiguration with: (Dictionary with: 'numbering' -> true with: 'size' -> 1 with: 'renderAs' -> 'number'))				configuration: config;				level: 5;				yourself)! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingNewLine	| dictionary config |	dictionary := Dictionary with: 'newLine' -> #unix.	config := PRPillarConfiguration newFromDictionary: dictionary.	self assert: config newLine equals: UnixPlatform new lineEnding! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingOutputDirectory	| dictionary config fileSystem |	fileSystem := FileSystem memory root.	(fileSystem / 'foo') ensureCreateDirectory.	dictionary := Dictionary with: 'baseDirectory' -> fileSystem with: 'outputDirectory' -> 'foo'.	config := PRPillarConfiguration newFromDictionary: dictionary.	self assert: config outputDirectory equals: fileSystem / 'foo'! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingOutputFile	| dictionary config fileSystem |	fileSystem := FileSystem memory root.	dictionary := Dictionary		with: 'baseDirectory' -> fileSystem		with: 'outputFile' -> '/foo/bar'.	config := PRPillarConfiguration newFromDictionary: dictionary.	self		assert: config outputFile		equals: (RelativePath from: '/foo/bar')! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingOutputType	| dictionary config |	dictionary := Dictionary with: 'outputType' -> 'html'.	config := PRPillarConfiguration newFromDictionary: dictionary.	self assert: config outputType equals: PRHTMLWriter! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingRenderStructureAsSlide	| dictionary config |	dictionary := Dictionary with: 'renderStructureAsSlide' -> false.	config := PRPillarConfiguration newFromDictionary: dictionary.	self assert: config renderStructureAsSlide equals: false! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingScrambledEmailAddresses	| dictionary config |	dictionary := Dictionary with: 'scrambledEmailAddresses' -> false.	config := PRPillarConfiguration newFromDictionary: dictionary.	self assert: config scrambledEmailAddresses equals: false! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingSeparateOutputFiles	| dictionary config |	dictionary := Dictionary with: 'separateOutputFiles' -> false.	config := PRPillarConfiguration newFromDictionary: dictionary.	self assert: config separateOutputFiles equals: false! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingSlideInTemplateForDeckJS	| dictionary config |	dictionary := Dictionary with: 'slideInTemplateForDeckJS' -> 3.	config := PRPillarConfiguration newFromDictionary: dictionary.	self assert: config slideInTemplateForDeckJS equals: 3! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingTitle	| dictionary config |	dictionary := Dictionary with: 'title' -> 'foo'.	config := PRPillarConfiguration newFromDictionary: dictionary.	self assert: config title equals: 'foo'! !!PRDictionaryToConfigurationTest methodsFor: 'tests' stamp: 'CyrilFerlicot 10/29/2015 22:00'!testReadingVerbose	| dictionary config |	dictionary := Dictionary with: 'verbose' -> false.	config := PRPillarConfiguration newFromDictionary: dictionary.	self assert: config verbose equals: false! !"Pillar-Tests-ExporterCore"!!PRTextWriterTest methodsFor: 'private' stamp: 'DamienCassou 2/26/2014 16:55'!actualClass	^ PRTextWriter! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'BenComan 6/2/2014 22:15'!annotationBegin: annotationString	^''! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:14'!boldFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:15'!dataItemWithBar	^ 'bar'! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:15'!definitionListBegin	^ ''! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 4/26/2014 18:14'!emailToFoo	^ 'foo@bar.com'! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:18'!figureAnchorForPierLogo	^ ''! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:18'!figureBegin	^ ''! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 3/5/2014 18:32'!horizontalRule	^ ''! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:21'!italicFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:21'!level1HeaderWithFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:23'!listItemWith1	^ '1'! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:23'!monospaceFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:23'!orderedListBegin	^ ''! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:28'!packageNamesUnderTest	^ #('Pillar-ExporterText')! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:26'!paragraphFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:26'!preformattedFooBegin	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:26'!preformattedTextFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:27'!rawText	^ 'nothing raw in plain text'! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:20'!referenceToFigurePierLogo	^ ''! !!PRTextWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/20/2015 18:02'!resultWithRefWithAnchorWithSeparateOutputFiles	^ ''! !!PRTextWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/20/2015 18:08'!resultWithRefWithAnchorWithoutSeparateOutputFiles	^ self resultWithRefWithAnchorWithSeparateOutputFiles! !!PRTextWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 10:40'!resultWithRefWithoutAnchorWithSeparateOutputFiles	^ ''! !!PRTextWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 10:48'!resultWithRefWithoutAnchorWithoutSeparateOutputFiles	^ self resultWithRefWithoutAnchorWithSeparateOutputFiles ! !!PRTextWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 11:26'!resultWithoutAliasWithRefWithAnchorWithoutSeparateOutputFiles	^ ''! !!PRTextWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:22'!resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles	^ ''! !!PRTextWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:25'!resultWithoutAliasWithoutRefWithAnchorWithoutSeparateOutputFiles	^ ''! !!PRTextWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 11:13'!resultWithoutRefWithAnchorWithSeparateOutputFiles	^ ''! !!PRTextWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 11:16'!resultWithoutRefWithAnchorWithoutSeparateOutputFiles	^ ''! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:27'!scriptAnchorForMyScript	^ ''! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:27'!scriptWithCaptionBegin	^ ''! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:27'!scriptWithoutCaptionBegin	^ ''! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:29'!strikethroughFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:29'!subscriptFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:29'!superscriptFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/12/2016 14:04'!supportSyntaxHighlighting	^ false! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:29'!tableBegin	^ ''! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:30'!tableCellWithFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:30'!tableCellWithHeadingFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:29'!tableRow	^ ''! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:15'!termItemWithFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/26/2014 17:37'!testFigureLabelGenerateAnchor	"ignore as there is no anchor support in simple text"! !!PRTextWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/27/2014 16:47'!testFigureWithWidth	"ignore as there is no figure language support in simple text"! !!PRTextWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/26/2014 17:37'!testFiguresHaveACaption	"ignore as there is no caption support in simple text"! !!PRTextWriterTest methodsFor: 'tests' stamp: 'DamienCassou 4/26/2014 22:08'!testMailLink	"ignore as there is the email address is not written"! !!PRTextWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/26/2014 17:37'!testScriptLabelGenerateAnchor	"ignore as there is no anchor support in simple text"! !!PRTextWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/26/2014 17:38'!testScriptLanguage	"ignore as there is no script language support in simple text"! !!PRTextWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/29/2016 18:15'!testScriptWithFormattedCaption	"ignore as there is no caption support in simple text"! !!PRTextWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/26/2014 17:39'!testScriptsHaveACaption	"ignore as there is no caption support in simple text"! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:30'!underlineFoo	^ 'foo'! !!PRTextWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/26/2014 17:30'!unorderedListBegin	^ ''! !!PRDocumentTest methodsFor: '*pillar-tests-exportertext' stamp: 'DamienCassou 6/6/2014 16:41'!testTitle	| tree |	tree := PRDocument new		propertyAt: 'title' put: 'Atom heart mother';		yourself.	self assert: tree title equals: 'Atom heart mother'.	tree := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Echoes');				yourself).	self assert: tree title equals: 'Echoes'.	self assert: PRDocument new title equals: 'No title'! !"Pillar-Tests-ExporterText"!!PRPillarWriterTest methodsFor: 'private' stamp: 'DamienCassou 2/20/2014 09:10'!actualClass	^ PRPillarWriter! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'BenComan 6/2/2014 22:05'!annotationBegin: annotationString	^'@@' , annotationString.! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 09:13'!boldFoo	^ '""foo""'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:24'!dataItemWithBar	^ ':bar'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 09:35'!definitionListBegin	^ ';'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 4/26/2014 18:15'!emailToFoo	^ 'foo@bar.com*'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:02'!figureAnchorForPierLogo	^ 'label=pierLogo'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 09:53'!figureBegin	^ '+'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 3/5/2014 18:31'!horizontalRule	^ '_'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 09:38'!italicFoo	^ '''foo'''! !!PRPillarWriterTest methodsFor: 'accessing' stamp: 'DamienCassou 2/12/2016 13:26'!level1HeaderBegin	^ self shouldBeImplemented! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 09:20'!level1HeaderWithFoo	^ '!!foo'! !!PRPillarWriterTest methodsFor: 'accessing' stamp: 'DamienCassou 2/12/2016 13:26'!level2HeaderBegin	^ self shouldBeImplemented! !!PRPillarWriterTest methodsFor: 'accessing' stamp: 'DamienCassou 2/12/2016 13:26'!level3HeaderBegin	^ self shouldBeImplemented! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 09:34'!listItemWith1	^ '1'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 09:42'!monospaceFoo	^ '==foo=='! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 09:33'!orderedListBegin	^ '#'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:17'!packageNamesUnderTest	^ #('Pillar-ExporterPillar')! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 09:53'!paragraphFoo	^ 'foo'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:03'!preformattedFooBegin	^ '='! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:03'!preformattedTextFoo	^ 'foo'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:06'!rawText	^ '*foo>http://bar.com* ''italic'''! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 5/20/2015 17:33'!referenceToFigurePierLogo	^ '*@pierLogo*'! !!PRPillarWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:39'!resultWithRefWithAnchorWithSeparateOutputFiles	^ 'ref.pillar@foo'! !!PRPillarWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/20/2015 18:08'!resultWithRefWithAnchorWithoutSeparateOutputFiles	^ self resultWithRefWithAnchorWithSeparateOutputFiles! !!PRPillarWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:40'!resultWithRefWithoutAnchorWithSeparateOutputFiles	^ 'ref.pillar'! !!PRPillarWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 10:48'!resultWithRefWithoutAnchorWithoutSeparateOutputFiles	^ self resultWithRefWithoutAnchorWithSeparateOutputFiles ! !!PRPillarWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:40'!resultWithoutAliasWithRefWithAnchorWithoutSeparateOutputFiles	^ 'ref.pillar@foo'! !!PRPillarWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:21'!resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles	^ '@foo'! !!PRPillarWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:40'!resultWithoutAliasWithoutRefWithAnchorWithoutSeparateOutputFiles	^ self resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles ! !!PRPillarWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 11:12'!resultWithoutRefWithAnchorWithSeparateOutputFiles	^ '@foo'! !!PRPillarWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:40'!resultWithoutRefWithAnchorWithoutSeparateOutputFiles	^ self resultWithoutRefWithAnchorWithSeparateOutputFiles ! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:15'!scriptAnchorForMyScript	^ 'label=myScript'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:16'!scriptWithCaptionBegin	^ '[[['! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:10'!scriptWithoutCaptionBegin	^ '[[['! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:14'!strikethroughFoo	^ '--foo--'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 09:26'!subscriptFoo	^ '@@foo@@'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 09:26'!superscriptFoo	^ '^^foo^^'! !!PRPillarWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/12/2016 14:04'!supportSyntaxHighlighting	^ false! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:17'!tableBegin	^ '|'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:17'!tableCellWithFoo	^ '|foo'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:19'!tableCellWithHeadingFoo	^ '|!!foo'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:17'!tableRow	^ '|'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 09:36'!termItemWithFoo	^ ';foo'! !!PRPillarWriterTest methodsFor: 'tests' stamp: 'YannDubois 5/2/2016 14:55'!testAnnotation	| item |	item := PRMockAnnotation		parameters:			(SmallDictionary new				add: 'value' -> 'Foo';				add: 'number' -> '5';				yourself).	self assertWriting: item includesText: '${mock:value=Foo|number=5}$'! !!PRPillarWriterTest methodsFor: 'tests' stamp: 'DamienCassou 3/5/2014 17:49'!testCommentedLineNotVisibleInOutput	"in Pillar output, we really want our comments back"! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 9/6/2015 13:18'!testFigureWithoutLabelAndWithoutCaptionAreExportedWithoutEnvironment	self skip: 'no figure environment in pillar'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 10:17'!underlineFoo	^ '__foo__'! !!PRPillarWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/20/2014 09:27'!unorderedListBegin	^ '-'! !"Pillar-Tests-ExporterPillar"!!PRLaTeXWriterTest class methodsFor: 'testing' stamp: 'DamienCassou 10/8/2013 10:56'!isAbstract	^ false! !!PRLaTeXWriterTest methodsFor: 'private' stamp: 'DamienCassou 10/8/2013 11:19'!actualClass	^ PRLaTeXWriter! !!PRLaTeXWriterTest methodsFor: 'private' stamp: 'DamienCassou 9/24/2015 11:16'!annotationBegin: annotationString	^ '\begin{' , annotationString , '}'.	! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 15:07'!boldFoo	^ '\textbf{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 5/3/2016 15:54'!citationRepresentation	^'\cite{hello}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 14:40'!dataItemWithBar	^ ' bar'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 14:43'!definitionListBegin	^ '\begin{description}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 4/26/2014 18:14'!emailToFoo	^ '\href{mailto:foo@bar.com'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 1/9/2014 16:23'!figureAnchorForPierLogo	^ '\label{pierLogo}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/21/2013 11:59'!figureBegin	^ '\begin{figure}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/3/2016 16:25'!footnoteBar	^ '\footnote{Bar}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 3/5/2014 18:31'!horizontalRule	^ '\rule{\textwidth}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 14:55'!italicFoo	^ '\textit{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/21/2013 07:49'!level1HeaderBegin	^ '\part{'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 1/7/2014 14:17'!level1HeaderWithFoo	^ '\part{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 1/7/2014 15:01'!level2HeaderBegin	^ '\chapter{'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/21/2013 07:50'!level3HeaderBegin	^ '\section{'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/8/2013 13:20'!listItemWith1	^ '\item 1'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 9/17/2015 14:52'!monospaceFoo	^ '\code{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 14:31'!orderedListBegin	^ '\begin{enumerate}'! !!PRLaTeXWriterTest methodsFor: 'accessing' stamp: 'DamienCassou 1/15/2014 16:47'!packageNamesUnderTest	^ #('Pillar-ExporterLaTeX')! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 12/9/2013 13:29'!paragraphFoo	| newLine |	newLine := self configuration newLine.	^ 'foo', newLine! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 15:59'!preformattedFooBegin	^ '\begin{verbatim}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 15:54'!preformattedTextFoo	^ 'foo'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/20/2013 17:46'!rawText	^ '\textbf{\textit{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/22/2013 18:21'!referenceToFigurePierLogo	^ '\ref{pierLogo}'! !!PRLaTeXWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/20/2015 17:58'!resultWithRefWithAnchorWithSeparateOutputFiles	^ ''! !!PRLaTeXWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/20/2015 18:07'!resultWithRefWithAnchorWithoutSeparateOutputFiles	^ '\hyperref[foo]'! !!PRLaTeXWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 10:39'!resultWithRefWithoutAnchorWithSeparateOutputFiles	^ ''! !!PRLaTeXWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 10:46'!resultWithRefWithoutAnchorWithoutSeparateOutputFiles	^ ''! !!PRLaTeXWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 13:54'!resultWithoutAliasWithRefWithAnchorWithoutSeparateOutputFiles	^ '\ref{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:21'!resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles	^ '\ref{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:25'!resultWithoutAliasWithoutRefWithAnchorWithoutSeparateOutputFiles	^ '\ref{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 11:12'!resultWithoutRefWithAnchorWithSeparateOutputFiles	^ '\hyperref[foo]'! !!PRLaTeXWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 11:16'!resultWithoutRefWithAnchorWithoutSeparateOutputFiles	^ '\hyperref[foo]'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 9/17/2015 16:46'!scriptAnchorForMyScript	^ 'label=myScript'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 9/17/2015 16:45'!scriptWithCaptionBegin	^ '\begin{listing}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 9/17/2015 16:46'!scriptWithoutCaptionBegin	^ '\begin{listing}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 14:57'!strikethroughFoo	^ '\sout{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 3/22/2014 15:32'!subscriptFoo	^ '\textsubscript{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 3/22/2014 15:31'!superscriptFoo	^ '\textsuperscript{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/20/2013 16:21'!tableBegin	^ '\begin{tabular}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/20/2013 16:22'!tableCellWithFoo	^ 'foo'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/20/2013 16:22'!tableCellWithHeadingFoo	^ '\textbf{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/20/2013 16:21'!tableRow	^ '\\'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 14:40'!termItemWithFoo	^ '\item[foo]'! !!PRLaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testAnchor	| item |	item := PRAnchor new name: 'foo'.	self assertWriting: item includesText: '\label{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 5/3/2016 15:53'!testExportCitation	| item |	item := PRDocument new		add: (PRCitation ref: 'hello');		yourself.	self		assertWriting: item		includesText: self citationRepresentation.! !!PRLaTeXWriterTest methodsFor: 'tests-internalLinks' stamp: 'DamienCassou 3/16/2016 18:02'!testExternalLinkWithCaptionShouldPrintUrlAsFootnote	| link |	link := self addText: 'Pharo' to: (PRExternalLink reference: 'http://www.pharo.org').	self assertWriting: link includesText: '\href{http://www.pharo.org}{Pharo}\footnote{\url{http://www.pharo.org}}'! !!PRLaTeXWriterTest methodsFor: 'tests-internalLinks' stamp: 'DamienCassou 3/17/2016 10:58'!testExternalLinkWithCaptionShouldProtectUrlInFootnotes	| link |	link := self addText: 'Launcher' to: (PRExternalLink reference: 'http://www.smalltalkhub.com/#!!/~Pharo/PharoLauncher').	self assertWriting: link includesText: '\footnote{\url{http://www.smalltalkhub.com/\#!!/~Pharo/PharoLauncher}}'! !!PRLaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 9/24/2015 13:31'!testFigureCaptionWithNonTextChildren	| item |	item := PRFigure new		reference: 'file://picture.png';		add: (self addText: 'foo' to: PRBoldFormat new);		yourself.	self assertWriting: item includesText: self boldFoo! !!PRLaTeXWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 9/8/2015 18:43'!testFigureLabelNotEscaped	| item |	item := PRFigure new		reference: 'file://picture.png';		label: 'a_b';		yourself.	self assertWriting: item includesText: 'a_b'! !!PRLaTeXWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 10:59'!testInternalLinkWithAliasWithReferenceWithoutAnchorWithoutSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: 'ref')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	self should: [ resultString := self write: item ] raise: PRLinkWarning.	[  resultString := self write: item ] on: PRLinkWarning do: [:w | w resume ].	self resultWithRefWithoutAnchorWithoutSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithoutAnchorWithoutSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRLaTeXWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 11:25'!testInternalLinkWithoutAliasWithRefWithAncorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: 'ref@foo');		yourself.	self should: [ resultString := self writeWithSeparateOutputFiles: item ] raise: PRLinkWarning.	[ resultString := self writeWithSeparateOutputFiles: item ]		on: PRLinkWarning		do: [ :w | w resume ].	self resultWithRefWithAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithAnchorWithSeparateOutputFiles) ]! !!PRLaTeXWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:11'!testInternalLinkWithoutAliasWithReferenceWithoutAnchorWithSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add: (PRInternalLink reference: 'ref');		yourself.	self should: [ resultString := self writeWithSeparateOutputFiles: item ] raise: PRLinkWarning.	[ resultString := self writeWithSeparateOutputFiles: item ]		on: PRLinkWarning		do: [ :w | w resume ].	self resultWithRefWithoutAnchorWithSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithoutAnchorWithSeparateOutputFiles) ]! !!PRLaTeXWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:16'!testInternalLinkWithoutAliasWithReferenceWithoutAnchorWithoutSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: 'ref')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	self should: [ resultString := self write: item ] raise: PRLinkWarning.	[ resultString := self write: item ]		on: PRLinkWarning		do: [ :w | w resume ].	self resultWithRefWithoutAnchorWithoutSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithoutAnchorWithoutSeparateOutputFiles) ]! !!PRLaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testLinksWithBadCharactersInCaption	| item url caption |	url := 'http://www.pharo.org'.	caption := 'bad chars #_'.	item := PRExternalLink new		reference: url;		add: (PRText content: caption);		yourself.	self assertWriting: item includesText: 'bad chars \#\_'! !!PRLaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testLinksWithEitherHrefOrUrl	| item url caption |	url := 'http://www.pharo.org#foo'.	caption := 'some caption'.	item := PRExternalLink new reference: url.	self assertWriting: item includesText: '\url{' , url , '}'.	item := PRExternalLink new		reference: url;		add: (PRText content: caption);		yourself.	self assertWriting: item includesText: '\href{' , url , '}{' , caption , '}'! !!PRLaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 5/11/2016 15:37'!testPreformattedExportsToUnprotectedVerbatim	"Special characters in a Pillar preformattted group should not be protected by backslashes because they are exported in a verbatim LaTeX environment."	| item |	item := PRPreformatted with: (PRText content: '[[[').	self		assertWriting: item		includesText: self preformattedFooBegin , self configuration newLine , '[[[' , self configuration newLine! !!PRLaTeXWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 5/20/2015 17:32'!testReferencesToSectionsAreNotEscaped	|item|	item := PRInternalLink reference: '@a_section_somewhere'.	self assertWriting: item includesText: 'a_section_somewhere'! !!PRLaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/29/2016 16:48'!testScriptWithCorrectNewLines	| item |	item := (PRScript content: 'foo')		label: 'myScript';		caption: 'a caption';		yourself.	self		assertWriting: item		includesText:			self configuration newLine , 'foo' , self configuration newLine , '\end{'! !!PRLaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 9/24/2015 11:07'!testStrictLineBreaksInAnnotatedParagraphs	| item lineBreak |	item := self		addText: 'Blah'		to:			(PRAnnotatedParagraph new				annotation: 'note';				yourself).	lineBreak := self configuration newLine.	self assertWriting: item includesText: '\begin{note}' , lineBreak , 'Blah' , lineBreak , '\end{note}' , lineBreak! !!PRLaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testTableWith2CellsInARow	| item |	item := super testTableWith2CellsInARow.	self assertWriting: item includesText: 'foo & foo \\'	! !!PRLaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 10/15/2015 11:40'!testTablesHaveSeparatingLines	| text |	text := '|!!Syntax |!!What it represents|startPoint|a variable name'.	self assertWriting: (self parser parse: text) includesTexts: { 'toprule' . 'midrule' . 'bottomrule' }! !!PRLaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 10/15/2015 11:40'!testThereIsABlankLineBetweenTextAndTable	| text nLine |	nLine := Smalltalk os lineEnding.	text := 'This is a table:| foo| bar'.	self		assertWriting: (self parser parse: text)		includesText: 'This is a table:' , nLine , nLine , '\begin{tab'! !!PRLaTeXWriterTest methodsFor: 'tests-internalLinks' stamp: 'DamienCassou 3/17/2016 11:08'!testUrlsAreProtected	| writer |	writer := self createWriterOn: String new.	self assert: (writer protectUrl: '#') equals: '\#'.	self assert: (writer protectUrl: '~') equals: '~'.	self assert: (writer protectUrl: '&') equals: '&'.	self assert: (writer protectUrl: '%') equals: '\%'.	self assert: (writer protectUrl: '\') equals: '\\'.	self assert: (writer protectUrl: '\~#%') equals: '\\~\#\%'.! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 14:57'!underlineFoo	^ '\uline{foo}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 14:31'!unorderedListBegin	^ '\begin{itemize}'! !!PRLaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/21/2014 17:40'!widthFor50percents	^ '0.5'! !!PRSBALaTeXWriterTest methodsFor: 'private' stamp: 'DamienCassou 2/29/2016 11:29'!actualClass	^ PRSBALaTeXWriter! !!PRSBALaTeXWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 3/2/2016 14:00'!monospaceFoo	^ '\textcode{foo}'! !!PRSBALaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/29/2016 16:07'!testFloatingScriptWithNoLanguageGeneratePlain	| script |	script := (PRScript content: 'foo')		caption: 'a caption';		yourself.	self assertWriting: script includesText: '{plain}'! !!PRSBALaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/29/2016 16:50'!testInFlowScriptWithCorrectNewLines	| item |	item := PRScript content: 'foo'.	self		assertWriting: item		includesText:			self configuration newLine , 'foo' , self configuration newLine , '\end{'! !!PRSBALaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/29/2016 16:05'!testInFlowScriptWithNoLanguageGeneratePlain	| script |	script := PRScript content: 'foo'.	self assertWriting: script includesTexts: #('\begin{displaycode}{plain}' 'foo')! !!PRSBALaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/29/2016 16:47'!testScript	"ignore as we have much more explicit tests in this class"! !!PRSBALaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/29/2016 16:18'!testScriptWithBothLabelAndCaption	| script |	script := (PRScript content: 'foo')					label: 'myScript';					caption: 'a caption';					language: PRHTMLScriptLanguage default;					yourself.	self assertWriting: script includesTexts: #('\begin{listing}[float, label=myScript]{html}{a caption}' 'foo')! !!PRSBALaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/29/2016 15:25'!testScriptWithCaptionAndNotLabel	| script |	script := (PRScript content: 'foo')					caption: 'a caption';					language: PRHTMLScriptLanguage default;					yourself.	self assertWriting: script includesTexts: #('\begin{listing}[float]{html}{a caption}' 'foo')! !!PRSBALaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/29/2016 15:26'!testScriptWithCaptionAndNotLabelAndShortCaption	| script |	script := (PRScript content: 'foo')					caption: 'a caption';					shortCaption: 'short';					language: PRHTMLScriptLanguage default;					yourself.	self assertWriting: script includesTexts: #('\begin{listing}[float, list text={short}]{html}{a caption}' 'foo')! !!PRSBALaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/29/2016 16:39'!testScriptWithLabelAndNotCaption	| script |	script := (PRScript content: 'foo')					label: 'myScript';					language: PRHTMLScriptLanguage default;					yourself.	self assertWriting: script includesTexts: #('\begin{listing}[float, label=myScript]{html}{}' 'foo')! !!PRSBALaTeXWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/29/2016 15:24'!testScriptWithNeitherCaptionNorLabel	| script |	script := (PRScript content: 'foo')					language: PRHTMLScriptLanguage default;					yourself.	self assertWriting: script includesTexts: #('\begin{displaycode}{html}' 'foo')! !"Pillar-Tests-ExporterLaTeX"!!Trait method!actualClass	^ self explicitRequirement! !!Trait method!slideRepresentation	^ self explicitRequirement! !!Trait method!testslideWithLabel	"self debug: #testExportSlideTitle"	| item |	item := PRDocument new		add:				((PRSlide titled: 'Slide title')						label: 'Foo';						yourself);		yourself.	self assertWriting: item includesTexts: {(self representationOfAnchor)}! !!Trait method!testRenderStructureAsSlide	| item |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'Foo');						yourself);		add: (PRSlide titled: 'Slide');		yourself.	self configuration renderStructureAsSlide: true.	self assertWriting: item includesTexts: {(self headerInSlide)}.	self configuration renderStructureAsSlide: false.	self deny: [ (self write: item) includesSubstring: self headerInSlide ]! !!Trait method!testTitleOfSlide	"self debug: #testExportSlideTitle"	| item |	item := PRDocument new		add: (PRSlide titled: 'Slide title');		yourself.	self		assertWriting: item		includesTexts: self slideTitle.! !!Trait method!representationOfAnchor	"I return a string which reprensent an anchor in the slider format."	^ self explicitRequirement! !!Trait method!endSlideTag	^ self explicitRequirement! !!Trait method!headerInSlide	"I return one string that define a header rendering in a slide."	^ self explicitRequirement! !!Trait method!testExport2SlidesCloseAllFrames	"self debug: #testExportSlideTitle"	| item resultString index |	item := PRDocument new		add: (PRSlide titled: 'Slide 1');		add: (PRSlide titled: 'Slide 2');		yourself.	resultString := self write: item.	index := resultString findString: self endSlideTag startingAt: 0.	self assert: index > 0.	index := resultString findString: self endSlideTag startingAt: index + 1.	self assert: index > 0! !!Trait method!testExport1SimpleSlide	"self debug: #testExportSlideTitle"	| item |	item := PRDocument new		add: (PRSlide titled: 'Slide title');		add: (PRText content: 'Presentation text');		yourself.	self		assertWriting: item		includesTexts: self slideRepresentation.! !!Trait method!slideTitle	"I return a collection with an explicite rendering of a slide title."	^ self explicitRequirement! !!PRBeamerWriterTest methodsFor: 'private' stamp: 'DamienCassou 4/2/2015 09:39' prior: 35837567!actualClass	^ PRBeamerWriter! !!PRBeamerWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/4/2015 18:24' prior: 35838785!endSlideTag	^ '\end{frame}'! !!PRBeamerWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 9/6/2015 13:14'!figureBegin	self skip: 'Beamer does not use figure environments because we typically don''t need a caption or label to reference'.	^ ''! !!PRBeamerWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/5/2015 15:48' prior: 35838843!headerInSlide	"I return one string that define a header rendering in a slide."	^ '\huge{'! !!PRBeamerWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 6/21/2016 13:32'!level1HeaderWithFoo	^ '\section{foo}'! !!PRBeamerWriterTest methodsFor: 'accessing' stamp: 'DamienCassou 4/2/2015 09:40'!packageNamesUnderTest	^ #('Pillar-ExporterBeamer')! !!PRBeamerWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/5/2015 17:24' prior: 35838645!representationOfAnchor	"I return a string which reprensent an anchor in the slider format."	^ '\label{'! !!PRBeamerWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 6/5/2015 17:19'!resultWithRefWithAnchorWithoutSeparateOutputFiles	^ '\hyperlink{foo}'! !!PRBeamerWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 6/5/2015 17:19'!resultWithoutRefWithAnchorWithSeparateOutputFiles	^ '\hyperlink{foo}'! !!PRBeamerWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 6/5/2015 17:20'!resultWithoutRefWithAnchorWithoutSeparateOutputFiles	^ '\hyperlink{foo}'! !!PRBeamerWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/4/2015 18:22' prior: 35837625!slideRepresentation	^ {'\begin{frame}'.	'\frametitle{Slide title}'.	'Presentation text'.	'\end{frame}'}! !!PRBeamerWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/5/2015 16:12' prior: 35839703!slideTitle	"I return a collection with an explicite rendering of a slide title."	^ {'\frametitle{'.	'}'}! !!PRBeamerWriterTest methodsFor: 'tests' stamp: 'DamienCassou 9/24/2015 13:36'!testFigureCaptionWithNonTextChildren	"Ignore as we don't generate caption/label for figures"! !!PRBeamerWriterTest methodsFor: 'tests' stamp: 'DamienCassou 6/25/2015 09:48'!testFigureLabelGenerateAnchor	"Ignore as we don't generate caption/label for figures"! !!PRBeamerWriterTest methodsFor: 'tests' stamp: 'DamienCassou 6/25/2015 09:48'!testFigureLabelNotEscaped	"Ignore as we don't generate caption/label for figures"! !!PRBeamerWriterTest methodsFor: 'tests' stamp: 'DamienCassou 6/25/2015 09:47'!testFiguresHaveACaption	"Ignore as we don't generate caption/label for figures"! !!PRBeamerWriterTest methodsFor: 'tests' stamp: 'DamienCassou 10/15/2015 11:39'!testFrameWithInvalidOption	| wiki |	wiki := '${frame:title=Foo|option=bar}$'.	self should: [ self parser parse: wiki ] raise: PRError! !!PRBeamerWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/3/2015 17:58'!testFrameWithOption	"For now the option are not activated."	"	| item |	item := PRDocument new		add: (PRSlideTitleAnnotation parameters: (PRParameterParser parse: 'title=Slide title|option=plain') yourself);		add: (PRText content: 'Presentation text');		yourself.	self		assertWriting: item		includesTexts:			{'\begin{frame}[plain]'.			'\frametitle{Slide title}'.			'Presentation text'.			'\end{frame}'}"	! !!PRBeamerWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/3/2015 17:58'!testFrameWithoutOption	| item |	item := PRDocument new		add: (PRSlide titled: 'Slide title');		add: (PRText content: 'Presentation text');		yourself.	self		assertWriting: item		includesTexts:			{'\begin{frame}[fragile]'.			'\frametitle{Slide title}'.			'Presentation text'.			'\end{frame}'}! !!PRBeamerWriterTest methodsFor: 'tests' stamp: 'DamienCassou 4/25/2016 16:45'!testScriptDefaultLanguage	"Ignore as we don't generate a language attribute"! !!PRBeamerWriterTest methodsFor: 'tests' stamp: 'DamienCassou 4/25/2016 16:46'!testScriptLabelGenerateAnchor	"Ignore as we don't generate anchors"! !!PRBeamerWriterTest methodsFor: 'tests' stamp: 'DamienCassou 4/25/2016 16:46'!testScriptsHaveACaption	"Ignore as we don't generate captions"! !"Pillar-Tests-ExporterBeamer"!!PRHTMLWriterTest class methodsFor: 'testing' stamp: 'DamienCassou 10/8/2013 10:56'!isAbstract	^ false! !!PRHTMLWriterTest methodsFor: 'private' stamp: 'DamienCassou 10/8/2013 11:19'!actualClass	^ PRHTMLWriter! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'BenComan 6/2/2014 22:14'!annotationBegin: annotationString	^'<p class="' , annotationString, '">' ! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 15:11'!boldFoo	^ '<strong>foo</strong>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 14:41'!dataItemWithBar	^ '<dd>bar</dd>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 14:38'!definitionListBegin	^ '<dl>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 4/26/2014 18:18'!emailToFoo	^ '<a href="mailto:foo@bar.com">'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/4/2015 13:44'!figureAnchorForPierLogo	^ '<a id="pierLogo">'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 9/6/2015 11:10'!figureBegin	^ '<figure>'! !!PRHTMLWriterTest methodsFor: 'as yet unclassified' stamp: 'YannDubois 5/4/2016 11:19'!footnoteBar	^ '<sup><a href="#footnote1">[1]</a></sup>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 3/5/2014 18:30'!horizontalRule	^ '<hr>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 14:45'!italicFoo	^ '<em>foo</em>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/21/2013 07:47'!level1HeaderBegin	^ '<h1>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 1/7/2014 14:18'!level1HeaderWithFoo	^ '<h1>foo</h1>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 1/7/2014 15:01'!level2HeaderBegin	^ '<h2>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/21/2013 07:47'!level3HeaderBegin	^ '<h3>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 14:43'!listItemWith1	^ '<li>1</li>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 13:54'!monospaceFoo	^ '<code>foo</code>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/8/2013 13:48'!orderedListBegin	^ '<ol>'! !!PRHTMLWriterTest methodsFor: 'accessing' stamp: 'DamienCassou 1/15/2014 16:47'!packageNamesUnderTest	^ #('Pillar-ExporterHTML')! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/4/2015 13:44'!paragraphFoo	^ '<p>' , Smalltalk os lineEnding , 'foo' , Smalltalk os lineEnding , '</p>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 15:56'!preformattedFooBegin	^ '<pre>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 15:56'!preformattedTextFoo	^ 'foo'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/20/2013 17:39'!rawText	^ '<img>'! !!PRHTMLWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:39'!resultWithRefWithAnchorWithSeparateOutputFiles	^ 'href="ref.html#foo"'! !!PRHTMLWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/20/2015 18:09'!resultWithRefWithAnchorWithoutSeparateOutputFiles	^ 'href="#foo"'! !!PRHTMLWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:39'!resultWithRefWithoutAnchorWithSeparateOutputFiles	^ 'href="ref.html"'! !!PRHTMLWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 10:46'!resultWithRefWithoutAnchorWithoutSeparateOutputFiles	^ ''! !!PRHTMLWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 11:31'!resultWithoutAliasWithRefWithAnchorWithoutSeparateOutputFiles	^ 'href="#foo"'! !!PRHTMLWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:21'!resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles	^ 'href="#foo"'! !!PRHTMLWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:25'!resultWithoutAliasWithoutRefWithAnchorWithoutSeparateOutputFiles	^ 'href="#foo"'! !!PRHTMLWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 11:12'!resultWithoutRefWithAnchorWithSeparateOutputFiles	^ 'href="#foo"'! !!PRHTMLWriterTest methodsFor: 'requirement-InternalLinks' stamp: 'CyrilFerlicot 5/21/2015 11:16'!resultWithoutRefWithAnchorWithoutSeparateOutputFiles	^ 'href="#foo"'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/4/2015 13:45'!scriptAnchorForMyScript	^ '<a id="myScript">'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 1/9/2014 09:10'!scriptWithCaptionBegin	^ '<pre><code'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 1/9/2014 09:10'!scriptWithoutCaptionBegin	^ '<pre><code'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 13:56'!strikethroughFoo	^ '<s>foo</s>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 13:57'!subscriptFoo	^ '<sub>foo</sub>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 13:57'!superscriptFoo	^ '<sup>foo</sup>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/20/2013 16:18'!tableBegin	^ '<table'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/20/2013 15:45'!tableCellWithFoo	^ '<td>foo</td>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/20/2013 16:02'!tableCellWithHeadingFoo	^ '<th>foo</th>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 11/20/2013 15:45'!tableRow	^ '<tr>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 14:41'!termItemWithFoo	^ '<dt>foo</dt>'! !!PRHTMLWriterTest methodsFor: 'tests' stamp: 'DamienCassou 2/20/2014 08:52'!testAnchor	| item |	item := PRAnchor new name: 'foo'.	self assertWriting: item includesText: 'id="foo"'! !!PRHTMLWriterTest methodsFor: 'tests' stamp: 'CyrilFerlicot 6/4/2015 13:43'!testExportingIsolatedRaw	"The idea is that you don''t want the <p> when using a Raw that potentially displays a <div>, because this is not HTML compliant"	| item |	item := PRDocument new		add:				(PRParagraph new						add: (PRRaw content: '<div>foo</div>');						yourself);		yourself.	self assert: (self write: item) equals: '<div>foo</div>'! !!PRHTMLWriterTest methodsFor: 'tests' stamp: 'YannDubois 5/4/2016 16:02'!testFootnoteAtEnd	| item |	item := PRFootnote new note: 'foo'.	self assertWriting: item includesText: '<sup id="footnote1">[1] foo</sup>'! !!PRHTMLWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 10:59'!testInternalLinkWithAliasWithReferenceWithoutAnchorWithoutSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: 'ref')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	self should: [ resultString := self write: item ] raise: PRLinkWarning.	[  resultString := self write: item ] on: PRLinkWarning do: [:w | w resume ].	self resultWithRefWithoutAnchorWithoutSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithoutAnchorWithoutSeparateOutputFiles) ].	self assert: (resultString includesSubstring: 'Alias')! !!PRHTMLWriterTest methodsFor: 'tests-internalLinks' stamp: 'CyrilFerlicot 5/21/2015 14:16'!testInternalLinkWithoutAliasWithReferenceWithoutAnchorWithoutSeparateOutputFiles	| item resultString |	item := PRParagraph new		add: (PRAnchor named: 'foo');		add:				((PRInternalLink reference: 'ref')						addAll: {(PRText content: 'Alias')};						yourself);		yourself.	self should: [ resultString := self write: item ] raise: PRLinkWarning.	[ resultString := self write: item ]		on: PRLinkWarning		do: [ :w | w resume ].	self resultWithRefWithoutAnchorWithoutSeparateOutputFiles = ''		ifFalse: [ self assert: (resultString includesSubstring: self resultWithRefWithoutAnchorWithoutSeparateOutputFiles) ]! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/14/2013 13:59'!underlineFoo	^ '<u>foo</u>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 10/9/2013 14:31'!unorderedListBegin	^ '<ul>'! !!PRHTMLWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 2/21/2014 17:42'!widthFor50percents	^ '50%'! !"Pillar-Tests-ExporterHTML"!!PRGithubMarkdownWriterTest methodsFor: 'private' stamp: 'YannDubois 5/31/2016 14:51'!actualClass	^ PRGithubMarkdownWriter ! !!PRGithubMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/31/2016 14:52'!scriptWithCaptionBegin	^ '```'! !!PRGithubMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/31/2016 14:52'!scriptWithoutCaptionBegin	^ '```'! !!PRGithubMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/31/2016 14:52'!supportSyntaxHighlighting	^ true! !!PRGithubMarkdownWriterTest methodsFor: 'as yet unclassified' stamp: 'YannDubois 5/31/2016 15:11'!tableBegin	^ '| '! !!PRGithubMarkdownWriterTest methodsFor: 'as yet unclassified' stamp: 'YannDubois 5/31/2016 15:12'!tableCellWithFoo	^ '| foo'! !!PRGithubMarkdownWriterTest methodsFor: 'as yet unclassified' stamp: 'YannDubois 5/31/2016 15:12'!tableCellWithHeadingFoo	^ '| foo'! !!PRGithubMarkdownWriterTest methodsFor: 'as yet unclassified' stamp: 'YannDubois 5/31/2016 15:12'!tableRow	^ '| '! !!PRGithubMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/31/2016 15:05'!underlineFoo	^ 'foo'! !!PRMarkdownWriterTest methodsFor: 'private' stamp: 'YannDubois 5/30/2016 10:16'!actualClass	^ PRMarkdownWriter! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 13:42'!boldFoo	^ '**foo**'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 16:56'!figureAnchorForPierLogo	^ '[pierLogo]'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 16:56'!figureBegin	^ '!!['! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 10:55'!horizontalRule	^ '***'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 13:42'!italicFoo	^ '*foo*'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 10:15'!level1HeaderBegin	^ '#'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 10:15'!level1HeaderWithFoo	^ '#foo'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 10:15'!level2HeaderBegin	^ '##'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 10:15'!level3HeaderBegin	^ '###'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 6/2/2016 10:49'!listItemWith1	^ '1'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 16:56'!monospaceFoo	^ '`foo`'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 6/3/2016 09:16'!orderedListBegin	^ '1. '! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 16:54'!packageNamesUnderTest	^ #('Pillar-ExporterMarkdown')! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 13:57'!paragraphFoo	^ 'foo'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 11:24'!resultWithRefWithAnchorWithSeparateOutputFiles	^ '(ref.html#foo)'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 11:24'!resultWithRefWithAnchorWithoutSeparateOutputFiles	^ '(#foo)'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 11:24'!resultWithRefWithoutAnchorWithSeparateOutputFiles	^ '(ref.html)'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 11:25'!resultWithoutAliasWithRefWithAnchorWithoutSeparateOutputFiles	^ '(#foo)'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 11:25'!resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles	^ '(#foo)'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 11:25'!resultWithoutAliasWithoutRefWithAnchorWithoutSeparateOutputFiles	^ '(#foo)'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 11:25'!resultWithoutRefWithAnchorWithSeparateOutputFiles	^ '(#foo)'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/30/2016 11:26'!resultWithoutRefWithAnchorWithoutSeparateOutputFiles	^ '(#foo)'! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/31/2016 10:46'!scriptWithCaptionBegin	^ '    '! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/31/2016 10:46'!scriptWithoutCaptionBegin	^ '    '! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/31/2016 14:15'!supportSyntaxHighlighting	^ false! !!PRMarkdownWriterTest methodsFor: 'tests' stamp: 'YannDubois 5/31/2016 10:18'!testFigureWithoutLabelAndWithoutCaptionAreExportedWithoutEnvironment	self skip "Figures are no environnement in Markdown"! !!PRMarkdownWriterTest methodsFor: 'tests' stamp: 'YannDubois 6/3/2016 09:19'!testNestingList	| item expected |	item := PRUnorderedList new		add:			(PRListItem new				add:					(PROrderedList new						add:							(PRListItem new								add: (PRText content: self listItemWith1);								yourself);						yourself);				yourself);		yourself.	expected := '' writeStream << '- ' << self configuration newLine << '  ' << self orderedListBegin		<< self listItemWith1.	self assert: (self write: item) includesSubstring: expected contents! !!PRMarkdownWriterTest methodsFor: 'tests' stamp: 'YannDubois 6/3/2016 09:16'!testNestingListWith2Item	| item expected |	item := PRUnorderedList new		add:			(PRListItem new				add:					(PROrderedList new						add:							(PRListItem new								add: (PRText content: self listItemWith1);								yourself);						yourself);				yourself);		add:			(PRListItem new				add: (PRText content: self listItemWith1);				yourself);		yourself.	expected := '' writeStream << self unorderedListBegin << self configuration newLine << '  '		<< self orderedListBegin << self listItemWith1 << self configuration newLine		<< self unorderedListBegin << self listItemWith1.	self assert: (self write: item) includesSubstring: expected contents! !!PRMarkdownWriterTest methodsFor: 'tests' stamp: 'YannDubois 6/3/2016 09:18'!testNestingListWith2ItemWith2SubItem	| item expected |	item := PRUnorderedList new		add:			(PRListItem new				add:					(PROrderedList new						add:							(PRListItem new								add: (PRText content: self listItemWith1);								add:									(PROrderedList new										add:											(PRListItem new												add: (PRText content: self listItemWith1);												yourself);										yourself);								yourself);						yourself);				yourself);		add:			(PRListItem new				add: (PRText content: self listItemWith1);				yourself);		yourself.	expected := '' writeStream << self unorderedListBegin << self configuration newLine << '  '		<< self orderedListBegin << self listItemWith1 << self configuration newLine << '    ' << self orderedListBegin		<< self listItemWith1 << self configuration newLine << self unorderedListBegin << self listItemWith1.	self assert: (self write: item) includesSubstring: expected contents! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 6/3/2016 09:16'!unorderedListBegin	^ '- '! !!PRMarkdownWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/31/2016 10:11'!widthFor50percents	^ ''! !"Pillar-Tests-ExporterMarkdown"!!Trait method!actualClass	^ self explicitRequirement! !!Trait method!slideRepresentation	^ self explicitRequirement! !!Trait method!testslideWithLabel	"self debug: #testExportSlideTitle"	| item |	item := PRDocument new		add:				((PRSlide titled: 'Slide title')						label: 'Foo';						yourself);		yourself.	self assertWriting: item includesTexts: {(self representationOfAnchor)}! !!Trait method!testRenderStructureAsSlide	| item |	item := PRDocument new		add:				(PRHeader new						level: 1;						add: (PRText content: 'Foo');						yourself);		add: (PRSlide titled: 'Slide');		yourself.	self configuration renderStructureAsSlide: true.	self assertWriting: item includesTexts: {(self headerInSlide)}.	self configuration renderStructureAsSlide: false.	self deny: [ (self write: item) includesSubstring: self headerInSlide ]! !!Trait method!testTitleOfSlide	"self debug: #testExportSlideTitle"	| item |	item := PRDocument new		add: (PRSlide titled: 'Slide title');		yourself.	self		assertWriting: item		includesTexts: self slideTitle.! !!Trait method!representationOfAnchor	"I return a string which reprensent an anchor in the slider format."	^ self explicitRequirement! !!Trait method!endSlideTag	^ self explicitRequirement! !!Trait method!headerInSlide	"I return one string that define a header rendering in a slide."	^ self explicitRequirement! !!Trait method!testExport2SlidesCloseAllFrames	"self debug: #testExportSlideTitle"	| item resultString index |	item := PRDocument new		add: (PRSlide titled: 'Slide 1');		add: (PRSlide titled: 'Slide 2');		yourself.	resultString := self write: item.	index := resultString findString: self endSlideTag startingAt: 0.	self assert: index > 0.	index := resultString findString: self endSlideTag startingAt: index + 1.	self assert: index > 0! !!Trait method!testExport1SimpleSlide	"self debug: #testExportSlideTitle"	| item |	item := PRDocument new		add: (PRSlide titled: 'Slide title');		add: (PRText content: 'Presentation text');		yourself.	self		assertWriting: item		includesTexts: self slideRepresentation.! !!Trait method!slideTitle	"I return a collection with an explicite rendering of a slide title."	^ self explicitRequirement! !!PRDeckJSWriterTest methodsFor: 'private' stamp: 'CyrilFerlicot 6/4/2015 17:46' prior: 35860067!actualClass	^ PRDeckJSWriter! !!PRDeckJSWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/5/2015 16:25' prior: 35861285!endSlideTag	^ '</div>'! !!PRDeckJSWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/5/2015 16:25' prior: 35861343!headerInSlide	"I return one string that define a header rendering in a slide."	^ '<h1>'! !!PRDeckJSWriterTest methodsFor: 'accessing' stamp: 'CyrilFerlicot 6/4/2015 17:47'!packageNamesUnderTest	^ #('Pillar-ExporterDeckJS')! !!PRDeckJSWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/5/2015 17:26' prior: 35861145!representationOfAnchor	"I return a string which reprensent an anchor in the slider format."	^ '<a id="'! !!PRDeckJSWriterTest methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 6/8/2015 16:09'!resultWithRefWithAnchorWithSeparateOutputFiles	^ '#slide-0'! !!PRDeckJSWriterTest methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 6/8/2015 16:10'!resultWithRefWithAnchorWithoutSeparateOutputFiles	^ '#slide-0'! !!PRDeckJSWriterTest methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 6/8/2015 16:11'!resultWithoutAliasWithRefWithAnchorWithoutSeparateOutputFiles	^ '#slide-0'! !!PRDeckJSWriterTest methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 6/8/2015 16:11'!resultWithoutAliasWithoutRefWithAnchorWithSeparateOutputFiles	^ '#slide-0'! !!PRDeckJSWriterTest methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 6/8/2015 16:11'!resultWithoutAliasWithoutRefWithAnchorWithoutSeparateOutputFiles	^ '#slide-0'! !!PRDeckJSWriterTest methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 6/8/2015 16:10'!resultWithoutRefWithAnchorWithSeparateOutputFiles	^ '#slide-0'! !!PRDeckJSWriterTest methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 6/8/2015 16:10'!resultWithoutRefWithAnchorWithoutSeparateOutputFiles	^ '#slide-0'! !!PRDeckJSWriterTest methodsFor: 'requirements' stamp: 'CyrilFerlicot 6/5/2015 16:25' prior: 35860125!slideRepresentation	^ {'<div'.	'class'.	'slide'.	'</div>'}! !!PRDeckJSWriterTest methodsFor: 'requirements' stamp: 'DamienCassou 6/23/2015 17:32' prior: 35862203!slideTitle	"I return a collection with an explicite rendering of a slide title."	^ {'<h2>'.	'Slide title'.	'</h2>'}! !!PRDeckJSWriterTest methodsFor: 'as yet unclassified' stamp: 'CyrilFerlicot 6/8/2015 15:52'!testAnchor	"Anchors define by the user in deck.js doesn't work so we don't need to render them."	| item |	item := PRAnchor new name: 'foo'.	self deny: ((self write: item) includesSubstring: 'id="foo"')! !"Pillar-Tests-ExporterDeckJS"!!PREPubNavigationMenuWriterTest class methodsFor: 'testing' stamp: 'ThibaultAroing 5/26/2016 14:43'!isAbstract	^false! !!PREPubNavigationMenuWriterTest methodsFor: 'private' stamp: 'ThibaultAroing 5/26/2016 14:42'!actualClass	^PREPubNavigationMenuWriter ! !!PREPubNavigationMenuWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 6/6/2016 09:34'!level1HeaderWithFoo	^'<li><a href="chapter.xhtml#foo">foo'! !!PREPubNavigationMenuWriterTest methodsFor: 'requirements' stamp: 'ThibaultAroing 5/26/2016 15:10'!packageNamesUnderTest	^ #('Pillar-ExporterEPub')! !!PREPubNavigationMenuWriterTest methodsFor: 'tests' stamp: 'ThibaultArloing 6/6/2016 09:34'!testHeadersAreNumbered	self skip: 'Headers are not numbered in navigation menu'! !!PREPubNavigationMenuWriterTest methodsFor: 'tests' stamp: 'ThibaultArloing 6/6/2016 09:34'!testSubHeadersAreNumbered	self skip: 'Headers are not numbered in navigation menu'! !!PREPubTocMenuWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 6/6/2016 09:35'!actualClass	^PREPubTocMenuWriter ! !!PREPubTocMenuWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 6/6/2016 09:37'!level1HeaderWithFoo	^'<navLabel><text>foo</text></navLabel>'! !!PREPubTocMenuWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 6/6/2016 10:21'!packageNamesUnderTest	^ #('Pillar-ExporterEPub')! !!PREPubTocMenuWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 6/6/2016 09:38'!testHeadersAreNumbered	self skip: 'Headers are not numbered in toc menu'! !!PREPubTocMenuWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 6/6/2016 09:39'!testSubHeadersAreNumbered	self skip: 'Headers are not numbered in toc menu'! !!PREPubXHTMLWriterTest methodsFor: 'private' stamp: 'ThibaultAroing 5/26/2016 14:43'!actualClass	^PREPubXHTMLWriter ! !!PREPubXHTMLWriterTest methodsFor: 'requirements' stamp: 'ThibaultAroing 5/26/2016 14:43'!level1HeaderWithFoo	^ '<div id="foo"><h1>foo</h1>'! !!PREPubMenuJustHeaderTransformerTest methodsFor: 'private' stamp: 'ThibaultArloing 6/2/2016 11:13'!actualClass	^ PREPubMenuJustHeaderTransformer! !!PREPubMenuJustHeaderTransformerTest methodsFor: 'private' stamp: 'ThibaultArloing 6/2/2016 11:11'!actualWriterClass	^ PREPubTocMenuWriter! !!PREPubMenuJustHeaderTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:03'!testKeepHeaderWithOneHeader	| input expected |	input := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'foo');				yourself).	expected := PRDocument new		add:			(PRSection new				add:					(PRHeader new						level: 1;						add: (PRText content: 'foo');						yourself)).	self		assert:			(self				executePhase: input				with:					(self configuration						outputType: self actualWriterClass;						yourself))		equals: expected! !!PREPubMenuJustHeaderTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:04'!testKeepHeaderWithParagraph	| input expected |	input := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'foo');				yourself);		add: (PRParagraph new add: (PRText content: 'bar'));		yourself.	expected := PRDocument new		add:			(PRSection new				add:					(PRHeader new						level: 1;						add: (PRText content: 'foo');						yourself)).	self		assert:			(self				executePhase: input				with:					(self configuration						outputType: self actualWriterClass;						yourself))		equals: expected! !!PREPubMenuJustHeaderTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:04'!testKeepHeaderWithParagraph2	| input expected |	input := PRDocument new		add: (PRParagraph new add: (PRText content: 'bar'));		add:			(PRHeader new				level: 1;				add: (PRText content: 'foo');				yourself);		yourself.	expected := PRDocument new		add:			(PRSection new				add:					(PRHeader new						level: 1;						add: (PRText content: 'foo');						yourself)).	self		assert:			(self				executePhase: input				with:					(self configuration						outputType: self actualWriterClass;						yourself))		equals: expected! !!PREPubMenuJustHeaderTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:05'!testKeepHeaderWithScript	| input expected |	input := PRDocument new		add: (PRScript content: 'hello');		add:			(PRHeader new				level: 1;				add: (PRText content: 'foo');				yourself);		yourself.	expected := PRDocument new		add:			(PRSection new				add:					(PRHeader new						level: 1;						add: (PRText content: 'foo');						yourself)).	self		assert:			(self				executePhase: input				with:					(self configuration						outputType: self actualWriterClass;						yourself))		equals: expected! !!PREPubMenuJustHeaderTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:05'!testTransformWith2Headers	| input expected |	input := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Bar') yourself);		add: (PRParagraph with: (PRText content: 'Foo') yourself);		add:			(PRHeader new				level: 2;				add: (PRText content: 'Bar2') yourself);		add: (PRParagraph with: (PRText content: 'Foo2') yourself);		yourself.	expected := PRDocument new		add:			(PRSection new				add:					(PRHeader new						level: 1;						add: (PRText content: 'Bar') yourself);				add:					(PRSection new						add:							(PRHeader new								level: 2;								add: (PRText content: 'Bar2') yourself))) yourself.	self		assert:			(self				executePhase: input				with:					(self configuration						outputType: self actualWriterClass;						yourself))		equals: expected! !!PREPubMenuJustHeaderTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:06'!testTransformWith3Headers	| input expected |	input := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Bar') yourself);		add: (PRParagraph with: (PRText content: 'Foo') yourself);		add:			(PRHeader new				level: 2;				add: (PRText content: 'Bar2') yourself);		yourself;		add:			(PRHeader new				level: 2;				add: (PRText content: 'Bar2b') yourself);		add: (PRParagraph with: (PRText content: 'Foo2') yourself);		yourself.	expected := PRDocument new		add:			(PRSection new				add:					(PRHeader new						level: 1;						add: (PRText content: 'Bar') yourself);				add:					(PRSection new						add:							(PRHeader new								level: 2;								add: (PRText content: 'Bar2') yourself));				add:					(PRSection new						add:							(PRHeader new								level: 2;								add: (PRText content: 'Bar2b')))) yourself.	self		assert:			(self				executePhase: input				with:					(self configuration						outputType: self actualWriterClass;						yourself))		equals: expected! !!PREPubMenuJustHeaderTransformerTest methodsFor: 'tests' stamp: 'DamienCassou 6/20/2016 14:06'!testTransformWithOneSection	| input expected |	input := PRDocument new		add:			(PRHeader new				level: 1;				add: (PRText content: 'Bar') yourself);		add: (PRParagraph with: (PRText content: 'Foo!!') yourself);		yourself.	expected := PRDocument new		add:			(PRSection new				add:					(PRHeader new						level: 1;						add: (PRText content: 'Bar') yourself);				yourself) yourself.	self		assert:			(self				executePhase: input				with:					(self configuration						outputType: self actualWriterClass;						yourself))		equals: expected! !"Pillar-Tests-ExporterEPub"!!PRAsciiDocWriterTest methodsFor: 'private' stamp: 'ThibaultArloing 1/29/2016 14:55'!actualClass	^ PRAsciiDocWriter! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 1/29/2016 15:03'!boldFoo	^ '*foo*'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 2/5/2016 17:10'!dataItemWithBar	^ ':: bar'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 2/5/2016 16:30'!definitionListBegin	^''! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 2/5/2016 14:14'!emailToFoo	^'foo@bar.com'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 3/4/2016 15:35'!figureAnchorForPierLogo	^ '[[pierLogo]]'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 3/4/2016 13:43'!figureBegin	^ 'image::'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'YannDubois 5/3/2016 17:02'!footnoteBar	^ 'footnote:[Bar]'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'YannDubois 2/12/2016 14:38'!horizontalRule	^ ''''''''! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 1/29/2016 16:40'!italicFoo	^ '''foo'''! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'YannDubois 3/7/2016 11:01'!level1HeaderWithFoo	^ '= foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 2/5/2016 16:09'!listItemWith1	^'1'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 1/29/2016 16:47'!monospaceFoo	^ '+foo+'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 2/5/2016 16:10'!orderedListBegin	^ '. '! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'YannDubois 2/12/2016 16:15'!packageNamesUnderTest	^ #('Pillar-ExporterAsciiDoc')! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 2/5/2016 13:58'!paragraphFoo	^'foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'YannDubois 2/12/2016 15:12'!preformattedFooBegin	^ ' '! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'YannDubois 2/12/2016 15:15'!preformattedTextFoo	^ 'foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'YannDubois 2/12/2016 15:47'!rawText	^ '[underline]''*foo*'''! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 3/4/2016 15:33'!referenceToFigurePierLogo	^ '<<pierLogo>>'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 2/26/2016 16:48'!resultForCaution	^ 'CAUTION:'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 2/26/2016 16:49'!resultForImportant	^ 'IMPORTANT:'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 2/26/2016 16:49'!resultForNotRecognizedPatterns	^ ''! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 2/26/2016 16:48'!resultForNote	^ 'NOTE:'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 2/26/2016 16:48'!resultForTip	^ 'TIP:'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 2/26/2016 16:49'!resultForWarning	^ 'WARNING:'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 2/26/2016 15:55'!resultWithRefWithAnchorWithoutSeparateOutputFiles	^ '<<foo'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 2/26/2016 15:20'!resultWithRefWithoutAnchorWithoutSeparateOutputFiles	^ ''! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 2/26/2016 15:21'!resultWithoutAliasWithRefWithAnchorWithoutSeparateOutputFiles	^ '<<foo>>'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 2/26/2016 15:21'!resultWithoutAliasWithoutRefWithAnchorWithoutSeparateOutputFiles	^ '<<foo>>'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 2/26/2016 15:55'!resultWithoutRefWithAnchorWithoutSeparateOutputFiles	^ '<<foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 2/26/2016 14:45'!scriptAnchorForMyScript	^ '[[myScript]]'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'YannDubois 2/12/2016 17:29'!scriptWithCaptionBegin	^'----'		"TODO: Test does not run"! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'YannDubois 2/12/2016 17:27'!scriptWithoutCaptionBegin	^'----'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 1/29/2016 17:00'!strikethroughFoo	^ '[line-through]foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'YannDubois 2/12/2016 15:00'!subscriptFoo	^ '~foo~'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'YannDubois 2/12/2016 15:00'!superscriptFoo	^ '^foo^'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'YannDubois 2/12/2016 16:46'!tableBegin	^ '|==='! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'YannDubois 2/12/2016 16:46'!tableCellWithFoo	^ '|foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'YannDubois 2/12/2016 16:47'!tableCellWithHeadingFoo	^'|foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'YannDubois 2/12/2016 16:46'!tableRow	^''! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 2/5/2016 17:10'!termItemWithFoo	^'foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 4/6/2016 09:48'!testAnnotation	| note tip warning caution important nonRecognized text |	text := PRText content: 'foo'.	note := PRAnnotatedParagraph new		annotation: 'note';		add: text.	tip := PRAnnotatedParagraph new		annotation: 'tip';		add: text.	warning := PRAnnotatedParagraph new		annotation: 'warning';		add: text.	caution := PRAnnotatedParagraph new		annotation: 'caution';		add: text.	important := PRAnnotatedParagraph new		annotation: 'todo';		add: text.	nonRecognized := PRAnnotatedParagraph new		annotation: 'toto';		add: text.	self assertWriting: note includesText: self resultForNote.	self assertWriting: tip includesText: self resultForTip.	self assertWriting: warning includesText: self resultForWarning.	self assertWriting: caution includesText: self resultForCaution.	self assertWriting: important includesText: self resultForImportant.	self assert: (self write: nonRecognized) trimRight equals: (self resultForNotRecognizedPatterns, text text).! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 3/4/2016 15:46'!testFigureWithoutLabelAndWithoutCaptionAreExportedWithoutEnvironment	self skip: 'no figure environment in asciidoc'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 2/26/2016 15:06'!testInternalLinkWithAliasWithRefWithAncorWithSeparateOutputFiles	self flag: 'TODO: check if this is important after large refactoring'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 2/26/2016 15:14'!testInternalLinkWithAliasWithReferenceWithoutAnchorWithSeparateOutputFiles	self flag: 'TODO: check if this is important after large refactoring'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 2/26/2016 15:57'!testInternalLinkWithAliasWithReferenceWithoutAnchorWithoutSeparateOutputFiles	self flag: 'TODO: With alias but without anchor, we don''t understand'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 2/26/2016 15:13'!testInternalLinkWithAliasWithoutReferenceWithAnchorWithSeparateOutputFiles	self flag: 'TODO: check if this is important after large refactoring'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 2/26/2016 15:14'!testInternalLinkWithoutAliasWithRefWithAncorWithSeparateOutputFiles	self flag: 'TODO: check if this is important after large refactoring'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 2/26/2016 15:15'!testInternalLinkWithoutAliasWithReferenceWithoutAnchorWithSeparateOutputFiles	self flag: 'TODO: check if this is important after large refactoring'! !!PRAsciiDocWriterTest methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 2/26/2016 15:15'!testInternalLinkWithoutAliasWithoutReferenceWithAnchorWithSeparateOutputFiles	self flag: 'TODO: check if this is important after large refactoring'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 1/29/2016 17:15'!underlineFoo	^ '[underline]foo'! !!PRAsciiDocWriterTest methodsFor: 'requirements' stamp: 'ThibaultArloing 2/5/2016 16:10'!unorderedListBegin	^ '* '! !"Pillar-Tests-ExporterAsciiDoc"!!PRPillarGrammarTest methodsFor: 'accessing' stamp: 'CyrilFerlicot 8/12/2015 15:20'!parserClass	^ PRPillarGrammar! !!PRPillarGrammarTest methodsFor: 'tests - Reference' stamp: 'DamienCassou 10/5/2015 11:15'!testAliasFigure	self parse: 'Alias>' rule: #figureAlias! !!PRPillarGrammarTest methodsFor: 'tests - Reference' stamp: 'DamienCassou 10/5/2015 11:16'!testAliasFigureEscape	self parse: 'Alias\>>' rule: #figureAlias! !!PRPillarGrammarTest methodsFor: 'tests - Reference' stamp: 'DamienCassou 10/5/2015 11:16'!testAliasLink	self parse: 'Alias>' rule: #linkAlias! !!PRPillarGrammarTest methodsFor: 'tests - Reference' stamp: 'DamienCassou 10/5/2015 11:16'!testAliasLinkEscape	self parse: 'Alias\>>' rule: #linkAlias! !!PRPillarGrammarTest methodsFor: 'tests - Anchor' stamp: 'CyrilFerlicot 8/12/2015 15:20'!testAnchor	self parse: '@test' rule: #anchor! !!PRPillarGrammarTest methodsFor: 'tests - Anchor' stamp: 'CyrilFerlicot 8/12/2015 15:21'!testAnchorAreTrimed	self parse: '@  test  ' rule: #anchor! !!PRPillarGrammarTest methodsFor: 'tests - Anchor' stamp: 'CyrilFerlicot 8/12/2015 15:22'!testAnchorWithNewLine	self parse: '@foo' rule: #elementWithNewline! !!PRPillarGrammarTest methodsFor: 'tests - Anchor' stamp: 'CyrilFerlicot 8/12/2015 15:23'!testAnchorWithSpaceInside	self parse: '@foo bar' rule: #anchor! !!PRPillarGrammarTest methodsFor: 'tests - Paragraph' stamp: 'CyrilFerlicot 8/12/2015 17:06'!testAnnotatedParagraph	self parse: '@@foo Bar' rule: #annotatedParagraph! !!PRPillarGrammarTest methodsFor: 'tests - Paragraph' stamp: 'CyrilFerlicot 8/12/2015 17:07'!testAnnotatedParagraphEmpty	self parse: '@@foo' rule: #annotatedParagraph! !!PRPillarGrammarTest methodsFor: 'tests - Paragraph' stamp: 'CyrilFerlicot 8/12/2015 17:08'!testAnnotatedParagraphEmptyWithNewLine	self parse: '@@foo' rule: #elementWithNewline! !!PRPillarGrammarTest methodsFor: 'tests - Annotation' stamp: 'CyrilFerlicot 8/12/2015 15:27'!testAnnotation	self parse: '${inputFile:value=Foo}$' rule: #annotation! !!PRPillarGrammarTest methodsFor: 'tests - Annotation' stamp: 'CyrilFerlicot 8/12/2015 15:27'!testAnnotationAreTrimedAtTheRight	self parse: '${inputFile:value=Foo}$  ' rule: #annotation! !!PRPillarGrammarTest methodsFor: 'tests - Annotation' stamp: 'CyrilFerlicot 9/3/2015 23:56'!testAnnotationParameter	self parse: 'value=foo' rule: #parameterUntilEndAnnotation! !!PRPillarGrammarTest methodsFor: 'tests - Annotation' stamp: 'CyrilFerlicot 9/3/2015 23:59'!testAnnotationParameters	self parse: ':foo=bar|timo=leon' rule: #annotationParameters! !!PRPillarGrammarTest methodsFor: 'tests - Annotation' stamp: 'CyrilFerlicot 9/3/2015 23:59'!testAnnotationParameters2	self parse: 'foo=bar|timo=leon' rule: #parametersUntilEndAnnotation! !!PRPillarGrammarTest methodsFor: 'tests - Annotation' stamp: 'CyrilFerlicot 9/3/2015 23:55'!testAnnotationTag	self parse: 'mock' rule: #annotationTag! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:31'!testBoldFormat	self parse: '""Foo""' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:33'!testBoldFormatEmpty	self parse: '""""' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:36'!testBoldFormatWithEscaped	self parse: '""\"\"""' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:04'!testCommentedLine	self parse: '%some text' rule: #commentedLine! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:04'!testCommentedLineWithNewline	self parse: '%some text' rule: #elementWithNewline! !!PRPillarGrammarTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:34'!testDefinitionList	self		parse:			';Foo:Bar'		rule: #definitionList! !!PRPillarGrammarTest methodsFor: 'tests - Paragraph' stamp: 'CyrilFerlicot 8/12/2015 17:08'!testEmptyParagraph	self		parse:			''		rule: #emptyParagraph! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:04'!testEscapedCharacter	self parse: '\*' rule: #escapedCharacter! !!PRPillarGrammarTest methodsFor: 'tests - Reference' stamp: 'DamienCassou 10/5/2015 11:13'!testFigureFollowedByLinkWithAlias	self parse: '+file://TeapotWelcome.png+*Go>http://localhost*' rule: #paragraph! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 9/10/2015 03:01'!testFormatWithLink	self parse: '""*foo*""' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:41'!testHeaderEmpty	self parse: '!!' rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:41'!testHeaderLevel1	self parse: '!!Foo' rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:41'!testHeaderLevel2	self parse: '!!!!Foo' rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:41'!testHeaderLevel3	self parse: '!!!!!!Foo' rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:41'!testHeaderLevel4	self parse: '!!!!!!!!Foo' rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:41'!testHeaderLevel5	self parse: '!!!!!!!!!!Foo' rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:42'!testHeaderLevel6	self parse: '!!!!!!!!!!!!Foo' rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:45'!testHeaderWithFormat	self parse: '!!""Foo""' rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:45'!testHeaderWithFormatAndText	self parse: '!!""Foo"" bar' rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:42'!testHeaderWithNewLine	self parse: '!!Foo' rule: #elementWithNewline! !!PRPillarGrammarTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:42'!testHeaderWithWithLink	self parse: '!! Foo *Link*' rule: #header! !!PRPillarGrammarTest methodsFor: 'tests - HorizontalRule' stamp: 'CyrilFerlicot 8/12/2015 16:06'!testHorizontalRule	self parse: '_' rule: #horizontalRule! !!PRPillarGrammarTest methodsFor: 'tests - HorizontalRule' stamp: 'CyrilFerlicot 8/12/2015 16:07'!testHorizontalRuleFollowByNewLine	self parse: '_' rule: #elementWithNewline! !!PRPillarGrammarTest methodsFor: 'tests - HorizontalRule' stamp: 'CyrilFerlicot 8/12/2015 16:07'!testHorizontalRuleTrimRight	self parse: '_  ' rule: #horizontalRule! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:32'!testItalicFormat	self parse: '''''Foo''''' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:34'!testItalicFormatEmpty	self parse: '''''''''' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:36'!testItalicFormatWithEscaped	self parse: '''''\''\''''''' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Document' stamp: 'CyrilFerlicot 8/12/2015 17:04'!testLineEnd	self parse: '' rule: #lineEnd! !!PRPillarGrammarTest methodsFor: 'tests - Document' stamp: 'CyrilFerlicot 8/12/2015 17:04'!testLineEndwithNewline	self parse: String lf rule: #lineEnd! !!PRPillarGrammarTest methodsFor: 'tests - Reference' stamp: 'DamienCassou 10/3/2015 07:16'!testLinkFollowedByFigureWithAlias	self parse: '*http://localhost*+Go>file://TeapotWelcome.png+' rule: #paragraph! !!PRPillarGrammarTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/18/2015 14:28'!testListMulti	self		parse:			'-1--2---3--4--5--6-7-##8'		rule: #list! !!PRPillarGrammarTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:53'!testListWithComment	self		parse:			'#Foo%Comment#Bar'		rule: #list! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:32'!testMonospaceFormat	self parse: '==Foo==' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:34'!testMonospaceFormatEmpty	self parse: '====' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:37'!testMonospaceFormatWithEscaped	self parse: '==\=\===' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Document' stamp: 'CyrilFerlicot 8/12/2015 17:02'!testNewline	self parse: Smalltalk os lineEnding rule: #newline! !!PRPillarGrammarTest methodsFor: 'tests - Document' stamp: 'CyrilFerlicot 8/12/2015 17:02'!testNewlineCR	self parse: String cr rule: #newline! !!PRPillarGrammarTest methodsFor: 'tests - Document' stamp: 'CyrilFerlicot 8/12/2015 17:03'!testNewlineCRLF	self parse: String crlf rule: #newline! !!PRPillarGrammarTest methodsFor: 'tests - Document' stamp: 'CyrilFerlicot 8/12/2015 17:03'!testNewlineLF	self parse: String lf rule: #newline! !!PRPillarGrammarTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:36'!testOrderedList	self parse: '#Foo' rule: #orderedList! !!PRPillarGrammarTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:53'!testOrderedListEmpty	self parse: '#' rule: #orderedList! !!PRPillarGrammarTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:53'!testOrderedListMulti	self		parse:			'#1##2###3##4##5##6#7###8'		rule: #orderedList! !!PRPillarGrammarTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:54'!testOrderedListWithSubList	self		parse:			'#Foo##Bar'		rule: #orderedList! !!PRPillarGrammarTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:59'!testOrderedListWithTwoItems	self		parse:			'#Foo#Bar'		rule: #orderedList! !!PRPillarGrammarTest methodsFor: 'tests - Paragraph' stamp: 'CyrilFerlicot 8/12/2015 17:08'!testParagraph	self parse: 'This is a text' rule: #paragraph! !!PRPillarGrammarTest methodsFor: 'tests - Paragraph' stamp: 'CyrilFerlicot 8/12/2015 17:08'!testParagraphWithFormat	self parse: 'Foo ""Bar""' rule: #paragraph! !!PRPillarGrammarTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 9/9/2015 02:59'!testParameterFigure	self parse: 'value=foo' rule: #parameterUntilEndFigure! !!PRPillarGrammarTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 9/9/2015 17:18'!testParameterLink	self parse: 'value=foo' rule: #parameterUntilEndLink! !!PRPillarGrammarTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 9/9/2015 02:57'!testParametersFigure	self parse: '|foo=bar|timo=leon' rule: #parametersFigure! !!PRPillarGrammarTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 9/9/2015 17:18'!testParametersLink	self parse: '|foo=bar|timo=leon' rule: #parametersLink! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:04'!testPreformatedLine	self parse: '= Foo' rule: #preformatedLine! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:06'!testPreformatedText	self parse: '= Foo' rule: #preformatedText! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:05'!testPreformatedTextEmpty	self parse: '= ' rule: #preformatedText! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:05'!testPreformatedTextWithMultiLines	self		parse:			'= Foo= Bar'		rule: #preformatedText! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:05'!testPreformatedTextWithNewline	self parse: '= Foo' rule: #preformatedText! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:06'!testPreformatedTextWithSpaces	self parse: '=    Foo' rule: #preformatedText! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:06'!testPreformatedTextWithTab	self parse: '= 	Foo' rule: #preformatedText! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 9/9/2015 20:21'!testRaw	self parse: '{{{mock:foo}}}' rule: #raw! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:06'!testRawEmpty	self parse: '{{{}}}' rule: #raw! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:06'!testRawHTML	self parse: '{{{html:foo}}}' rule: #raw! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 9/9/2015 20:32'!testRawInvalid	self parse: '{{{invalid:foo}}}' rule: #raw! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 9/9/2015 20:32'!testRawMultiLines	self parse: '{{{foobar}}}' rule: #raw! !!PRPillarGrammarTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 8/13/2015 14:12'!testReference	self parse: '*foo>@bar*' rule: #reference! !!PRPillarGrammarTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 9/9/2015 01:59'!testReferenceFigure	self parse: 'file://foo.png' rule: #referenceFigure! !!PRPillarGrammarTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 9/9/2015 02:01'!testReferenceFigureEscape	self parse: 'file://foo\+.png' rule: #referenceFigure! !!PRPillarGrammarTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 9/9/2015 17:07'!testReferenceLink	self parse: 'file://foo.png' rule: #referenceLink! !!PRPillarGrammarTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 9/9/2015 17:07'!testReferenceLinkEscape	self parse: 'file://foo\*.png' rule: #referenceLink! !!PRPillarGrammarTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 8/12/2015 17:15'!testScript	self		parse:			'[[[foo]]]'		rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 9/3/2015 05:09'!testScriptParameter	self parse: 'value=foo' rule: #parameterUntilNewline! !!PRPillarGrammarTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 9/3/2015 05:09'!testScriptParameterEscape	self parse: 'value\==foo' rule: #parameterUntilNewline! !!PRPillarGrammarTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 9/3/2015 04:15'!testScriptParameterNil	self		parse:			'[[[foobar]]]'		rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 9/3/2015 05:10'!testScriptParameterValue	self parse: '=foo' rule: #parameterValueUntilNewline! !!PRPillarGrammarTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 9/3/2015 04:15'!testScriptParameterWithNoValues	self		parse:			'[[[foo=bar]]]'		rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 9/3/2015 05:10'!testScriptParameterWithoutValue	self parse: 'foo' rule: #parameterUntilNewline! !!PRPillarGrammarTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 8/21/2015 16:08'!testScriptParameters	self parse: 'value=foo' rule: #scriptParameters! !!PRPillarGrammarTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 8/21/2015 17:01'!testScriptParametersEscape	self parse: 'value=foo\||bar' rule: #scriptParameters! !!PRPillarGrammarTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 8/21/2015 16:08'!testScriptParametersMultiple	self parse: 'value=foo|bar' rule: #scriptParameters! !!PRPillarGrammarTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 8/12/2015 17:15'!testScriptWithLanguage	self		parse:			'[[[language=smalltalkfoo]]]'		rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 8/12/2015 17:17'!testScriptWithNewLine	self		parse:			'[[[foo]]]'		rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 9/10/2015 02:51'!testScriptWithSpaceAtTheEnd	self		parse:			'[[[foo]]]  '		rule: #script! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:32'!testStrikethroughFormat	self parse: '--Foo--' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:34'!testStrikethroughFormatEmpty	self parse: '----' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:37'!testStrikethroughFormatWithEscaped	self parse: '--\-\---' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:33'!testSubscriptFormat	self parse: '@@Foo@@' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:34'!testSubscriptFormatEmpty	self parse: '@@@@' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:37'!testSubscriptFormatWithEscaped	self parse: '@@\@\@@@' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:33'!testSuperscriptFormat	self parse: '^^Foo^^' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:34'!testSuperscriptFormatEmpty	self parse: '^^^^' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:37'!testSuperscriptFormatWithEscaped	self parse: '^^\^\^^^' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:20'!testTable	self		parse:			'|!! Foo |!! Bar| Foo2 | Bar2'		rule: #table! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:21'!testTableAlignMarkup	self parse: '}' rule: #tableAlignMarkup! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:21'!testTableCell	self parse: '|Foo' rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:21'!testTableCellAreTrimed	self parse: '|   Foo   ' rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:21'!testTableCellCenter	self parse: '||Foo' rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:21'!testTableCellHeader	self parse: '|!!Foo' rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:22'!testTableCellHeaderCenter	self parse: '|!!|Foo' rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:22'!testTableCellHeaderCenter2	self parse: '||!!Foo' rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:22'!testTableCellHeaderLeft	self parse: '|!!{Foo' rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:22'!testTableCellHeaderLeft2	self parse: '|{!!Foo' rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:22'!testTableCellHeaderRight	self parse: '|!!}Foo' rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:22'!testTableCellHeaderRight2	self parse: '|}!!Foo' rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:29'!testTableCellLeft	self parse: '|{Foo' rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:29'!testTableCellRight	self parse: '|}Foo' rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:22'!testTableCellWithFormat	self parse: '| ''''Foo'''' ' rule: #tableCell! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:22'!testTableCenterMarkup	self parse: '|' rule: #tableCenterMarkup! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:22'!testTableHeadingMarkup	self parse: '!!' rule: #tableHeadingMarkup! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:23'!testTableLeftMarkup	self parse: '{' rule: #tableLeftMarkup! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:23'!testTableMarkups	self parse: '|' rule: #tableMarkups! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:23'!testTableMarkupsCenter	self parse: '||' rule: #tableMarkups! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:23'!testTableMarkupsHeading	self parse: '|!!' rule: #tableMarkups! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:23'!testTableMarkupsHeadingAndCenter	self parse: '|!!|' rule: #tableMarkups! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:23'!testTableMarkupsHeadingAndCenter2	self parse: '||!!' rule: #tableMarkups! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:23'!testTableRightMarkup	self parse: '}' rule: #tableRightMarkup! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:23'!testTableRow	self parse: '| Foo | Bar' rule: #tableRow! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:23'!testTableRowWithEmptyCells	self parse: '|  | ' rule: #tableRow! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:38'!testTableRowWithHeading	self parse: '|!! Foo |!! Bar' rule: #tableRow! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:25'!testTableWithComment	self flag: #todo	"We need to add that later."	"self		parse:			'|Foo%Comment|Bar'		rule: #table"! !!PRPillarGrammarTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:23'!testTableWithNewLine	self		parse:			'|!! Foo |!! Bar| Foo2 | Bar2'		rule: #table! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:07'!testText	self parse: 'Foo' rule: #text! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:07'!testTextWithEscapeAtBeginning	self parse: '\*Foo' rule: #text! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:07'!testTextWithEscapeInTheMiddle	self parse: 'Foo \* Bar' rule: #text! !!PRPillarGrammarTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:07'!testTextWithMultiEscape	self parse: '\*Foo\*' rule: #text! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:33'!testUnderlineFormat	self parse: '__Foo__' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:34'!testUnderlineFormatEmpty	self parse: '____' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:37'!testUnderlineFormatWithEscaped	self parse: '__\_\___' rule: #format! !!PRPillarGrammarTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:54'!testUnorderedList	self parse: '-Foo' rule: #unorderedList! !!PRPillarGrammarTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:54'!testUnorderedListEmpty	self parse: '-' rule: #unorderedList! !!PRPillarGrammarTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:55'!testUnorderedListMulti	self		parse:			'-1--2---3--4--5--6-7---8'		rule: #unorderedList! !!PRPillarGrammarTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:55'!testUnorderedListWithSubList	self		parse:			'-Foo--Bar'		rule: #unorderedList! !!PRPillarGrammarTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:55'!testUnorderedListWithTwoItems	self		parse:			'-Foo-Bar'		rule: #unorderedList! !!PRPillarParserTest methodsFor: 'accessing' stamp: 'CyrilFerlicot 8/12/2015 15:20'!parserClass	^ PRPillarParser! !!PRPillarParserTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 9/9/2015 01:57'!testAliasFigure	super testAliasFigure.	self assert: result equals: { PRText content: 'Alias' }! !!PRPillarParserTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 9/9/2015 01:57'!testAliasFigureEscape	super testAliasFigureEscape.	self assert: result equals: { PRText content: 'Alias>' }! !!PRPillarParserTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 9/9/2015 16:58'!testAliasLink	super testAliasLink.	self assert: result equals: { PRText content: 'Alias' }! !!PRPillarParserTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 9/9/2015 16:59'!testAliasLinkEscape	super testAliasLinkEscape.	self assert: result equals: { PRText content: 'Alias>' }! !!PRPillarParserTest methodsFor: 'tests - Anchor' stamp: 'CyrilFerlicot 8/12/2015 15:20'!testAnchor	super testAnchor.	self assert: result equals: (PRAnchor named: 'test')! !!PRPillarParserTest methodsFor: 'tests - Anchor' stamp: 'CyrilFerlicot 8/12/2015 15:21'!testAnchorAreTrimed	super testAnchorAreTrimed.	self assert: result equals: (PRAnchor named: 'test')! !!PRPillarParserTest methodsFor: 'tests - Anchor' stamp: 'CyrilFerlicot 8/12/2015 15:23'!testAnchorWithNewLine	super testAnchorWithNewLine.	self assert: result equals: (PRAnchor named: 'foo')! !!PRPillarParserTest methodsFor: 'tests - Anchor' stamp: 'CyrilFerlicot 8/12/2015 15:23'!testAnchorWithSpaceInside	super testAnchorWithSpaceInside.	self assert: result equals: (PRAnchor named: 'foo bar')! !!PRPillarParserTest methodsFor: 'tests - Paragraph' stamp: 'CyrilFerlicot 8/12/2015 17:08'!testAnnotatedParagraph	super testAnnotatedParagraph.	self assert: result equals: (PRAnnotatedParagraph withAll: {PRText content: 'Bar'} annotation: 'foo')! !!PRPillarParserTest methodsFor: 'tests - Paragraph' stamp: 'CyrilFerlicot 8/12/2015 17:09'!testAnnotatedParagraphEmpty	super testAnnotatedParagraphEmpty.	self		assert: result		equals:			(PRAnnotatedParagraph new				annotation: 'foo';				yourself)! !!PRPillarParserTest methodsFor: 'tests - Paragraph' stamp: 'CyrilFerlicot 8/12/2015 17:09'!testAnnotatedParagraphEmptyWithNewLine	super testAnnotatedParagraphEmptyWithNewLine.	self		assert: result		equals:			(PRAnnotatedParagraph new				annotation: 'foo';				yourself)! !!PRPillarParserTest methodsFor: 'tests - Annotation' stamp: 'YannDubois 5/2/2016 14:21'!testAnnotation	super testAnnotation.	self		assert: result		equals: (PRInputFileAnnotation parameters: 						((SmallDictionary new						at: 'value' put: 'Foo';						yourself)))! !!PRPillarParserTest methodsFor: 'tests - Annotation' stamp: 'YannDubois 5/2/2016 14:21'!testAnnotationAreTrimedAtTheRight	super testAnnotationAreTrimedAtTheRight.	self		assert: result		equals:			(PRInputFileAnnotation				parameters:					(SmallDictionary new						at: 'value' put: 'Foo';						yourself))! !!PRPillarParserTest methodsFor: 'tests - Annotation' stamp: 'CyrilFerlicot 9/3/2015 23:57'!testAnnotationParameter	super testAnnotationParameter.	self assert: result equals: #('value' 'foo')! !!PRPillarParserTest methodsFor: 'tests - Annotation' stamp: 'YannDubois 5/2/2016 14:22'!testAnnotationParameters	| expected |	super testAnnotationParameters.	expected := SmallDictionary new.	expected at: 'foo' put: 'bar'.	expected at: 'timo' put: 'leon'.	self assert: result equals:  expected! !!PRPillarParserTest methodsFor: 'tests - Annotation' stamp: 'YannDubois 5/2/2016 14:36'!testAnnotationParameters2	| expected |	super testAnnotationParameters.	expected := SmallDictionary new.	expected at: 'foo' put: 'bar'.	expected at: 'timo' put: 'leon'.	self assert: result equals:  expected! !!PRPillarParserTest methodsFor: 'tests - Annotation' stamp: 'CyrilFerlicot 9/3/2015 23:55'!testAnnotationTag	super testAnnotationTag.	self assert: result equals: PRMockAnnotation! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:38'!testBoldFormat	super testBoldFormat.	self assert: result equals: (PRBoldFormat with: (PRText content: 'Foo'))! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:38'!testBoldFormatEmpty	super testBoldFormatEmpty.	self assert: result equals: PRBoldFormat new! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:38'!testBoldFormatWithEscaped	super testBoldFormatWithEscaped.	self assert: result equals: (PRBoldFormat with: (PRText content: '""'))! !!PRPillarParserTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:14'!testCommentedLine	super testCommentedLine.	self assert: result equals: (PRCommentedLine content: 'some text')! !!PRPillarParserTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 8/13/2015 10:14'!testCommentedLineWithNewline	super testCommentedLineWithNewline.	self assert: result equals: (PRCommentedLine content: 'some text')! !!PRPillarParserTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:48'!testDefinitionList	super testDefinitionList.	self		assert: result		equals:			(PRDefinitionList				withAll:					{(PRTermItem with: (PRText content: 'Foo')).					(PRDataItem with: (PRText content: 'Bar'))})! !!PRPillarParserTest methodsFor: 'tests - Paragraph' stamp: 'CyrilFerlicot 8/12/2015 17:09'!testEmptyParagraph	super testEmptyParagraph.	self assert: result equals: PREmptyParagraph new! !!PRPillarParserTest methodsFor: 'tests - Reference' stamp: 'DamienCassou 10/5/2015 11:27'!testFigureFollowedByLinkWithAlias	| paragraph |	super testFigureFollowedByLinkWithAlias.	paragraph := PRParagraph withAll: { 		PRFigure reference: 'file://TeapotWelcome.png'.		(PRExternalLink reference: 'http://localhost')			add: (PRText content: 'Go');			yourself	 }.	self assert: result equals: paragraph! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 9/10/2015 03:01'!testFormatWithLink	super testFormatWithLink.	self assert: result equals: (PRBoldFormat with: (PRInternalLink reference: 'foo'))! !!PRPillarParserTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:44'!testHeaderEmpty	super testHeaderEmpty.	self assert: result equals: (PRHeader withAll: Array new level: 1)! !!PRPillarParserTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:44'!testHeaderLevel1	super testHeaderLevel1.	self assert: result equals: (PRHeader withAll: {PRText content: 'Foo'} level: 1)! !!PRPillarParserTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:44'!testHeaderLevel2	super testHeaderLevel2.	self assert: result equals: (PRHeader withAll: {PRText content: 'Foo'} level: 2)! !!PRPillarParserTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:44'!testHeaderLevel3	super testHeaderLevel3.	self assert: result equals: (PRHeader withAll: {PRText content: 'Foo'} level: 3)! !!PRPillarParserTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:44'!testHeaderLevel4	super testHeaderLevel4.	self assert: result equals: (PRHeader withAll: {PRText content: 'Foo'} level: 4)! !!PRPillarParserTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:44'!testHeaderLevel5	super testHeaderLevel5.	self assert: result equals: (PRHeader withAll: {PRText content: 'Foo'} level: 5)! !!PRPillarParserTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:44'!testHeaderLevel6	super testHeaderLevel6.	self assert: result equals: (PRHeader withAll: {PRText content: 'Foo'} level: 6)! !!PRPillarParserTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:44'!testHeaderWithFormat	super testHeaderWithFormat.	self assert: result equals: (PRHeader withAll: {PRBoldFormat with: (PRText content: 'Foo')} level: 1)! !!PRPillarParserTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:45'!testHeaderWithFormatAndText	super testHeaderWithFormatAndText.	self		assert: result		equals:			(PRHeader				withAll:					{PRBoldFormat with: (PRText content: 'Foo').					PRText content: ' bar'}				level: 1)! !!PRPillarParserTest methodsFor: 'tests - Header' stamp: 'CyrilFerlicot 8/12/2015 15:45'!testHeaderWithNewLine	super testHeaderWithNewLine.	self assert: result equals: (PRHeader withAll: {PRText content: 'Foo'} level: 1)! !!PRPillarParserTest methodsFor: 'tests - HorizontalRule' stamp: 'CyrilFerlicot 8/12/2015 16:08'!testHorizontalRule	super testHorizontalRule.	self assert: result equals: PRHorizontalRule new! !!PRPillarParserTest methodsFor: 'tests - HorizontalRule' stamp: 'CyrilFerlicot 8/12/2015 16:08'!testHorizontalRuleFollowByNewLine	super testHorizontalRuleFollowByNewLine.	self assert: result equals: PRHorizontalRule new! !!PRPillarParserTest methodsFor: 'tests - HorizontalRule' stamp: 'CyrilFerlicot 8/12/2015 16:08'!testHorizontalRuleTrimRight	super testHorizontalRuleTrimRight.	self assert: result equals: PRHorizontalRule new! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:38'!testItalicFormat	super testItalicFormat.	self assert: result equals: (PRItalicFormat with: (PRText content: 'Foo'))! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:38'!testItalicFormatEmpty	super testItalicFormatEmpty.	self assert: result equals: PRItalicFormat new! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:38'!testItalicFormatWithEscaped	super testItalicFormatWithEscaped.	self assert: result equals: (PRItalicFormat with: (PRText content: ''''''))! !!PRPillarParserTest methodsFor: 'tests - Reference' stamp: 'DamienCassou 10/5/2015 10:06'!testLinkFollowedByFigureWithAlias	| paragraph |	super testLinkFollowedByFigureWithAlias.	paragraph := PRParagraph withAll: { 		PRExternalLink reference: 'http://localhost'.		(PRFigure reference: 'file://TeapotWelcome.png')			add: (PRText content: 'Go');			yourself	 }.	self assert: result equals: paragraph! !!PRPillarParserTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/18/2015 14:29'!testListMulti	super testListMulti.	self		assert: result		equals:			(PRUnorderedList				withAll:					{(PRListItem						withAll:							{(PRText content: '1').							(PRUnorderedList								withAll:									{(PRListItem										withAll:											{(PRText content: '2').											(PRUnorderedList with: (PRListItem with: (PRText content: '3')))}).									(PRListItem with: (PRText content: '4')).									(PRListItem with: (PRText content: '5')).									(PRListItem with: (PRText content: '6'))})}).					(PRListItem						withAll:							{(PRText content: '7').							(PROrderedList with: (PRListItem with: (PROrderedList with: (PRListItem with: (PRText content: '8')))))})})! !!PRPillarParserTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:51'!testListWithComment	super testListWithComment.	self		assert: result		equals:			(PROrderedList				withAll:					{PRListItem						withAll:							{PRText content: 'Foo'.							PRCommentedLine content: 'Comment'}.					PRListItem with: (PRText content: 'Bar')})! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:38'!testMonospaceFormat	super testMonospaceFormat.	self assert: result equals: (PRMonospaceFormat with: (PRText content: 'Foo'))! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:38'!testMonospaceFormatEmpty	super testMonospaceFormatEmpty.	self assert: result equals: PRMonospaceFormat new! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:38'!testMonospaceFormatWithEscaped	super testMonospaceFormatWithEscaped.	self assert: result equals: (PRMonospaceFormat with: (PRText content: '=='))! !!PRPillarParserTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:36'!testOrderedList	super testOrderedList.	self assert: result equals: (PROrderedList with: (PRListItem with: (PRText content: 'Foo')))! !!PRPillarParserTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:55'!testOrderedListEmpty	super testOrderedListEmpty.	self assert: result equals: (PROrderedList with: PRListItem new)! !!PRPillarParserTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 16:56'!testOrderedListMulti	super testOrderedListMulti.	self		assert: result		equals:			(PROrderedList				withAll:					{(PRListItem						withAll:							{(PRText content: '1').							(PROrderedList								withAll:									{(PRListItem										withAll:											{(PRText content: '2').											(PROrderedList with: (PRListItem with: (PRText content: '3')))}).									(PRListItem with: (PRText content: '4')).									(PRListItem with: (PRText content: '5')).									(PRListItem with: (PRText content: '6'))})}).					(PRListItem						withAll:							{(PRText content: '7').							(PROrderedList with: (PRListItem with: (PROrderedList with: (PRListItem with: (PRText content: '8')))))})})! !!PRPillarParserTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 17:00'!testOrderedListWithSubList	super testOrderedListWithSubList.	self		assert: result		equals:			(PROrderedList				with:					(PRListItem						withAll:							{PRText content: 'Foo'.							PROrderedList with: (PRListItem with: (PRText content: 'Bar'))}))! !!PRPillarParserTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 17:01'!testOrderedListWithTwoItems	super testOrderedListWithTwoItems.	self		assert: result		equals:			(PROrderedList				withAll:					{(PRListItem with: (PRText content: 'Foo')).					(PRListItem with: (PRText content: 'Bar'))})! !!PRPillarParserTest methodsFor: 'tests - Paragraph' stamp: 'CyrilFerlicot 8/12/2015 17:09'!testParagraph	super testParagraph.	self assert: result equals: (PRParagraph new add: (PRText content: 'This is a text'))! !!PRPillarParserTest methodsFor: 'tests - Paragraph' stamp: 'CyrilFerlicot 8/12/2015 17:09'!testParagraphWithFormat	super testParagraphWithFormat.	self		assert: result		equals:			(PRParagraph				withAll:					{(PRText content: 'Foo ').					(PRBoldFormat with: (PRText content: 'Bar'))})! !!PRPillarParserTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 9/9/2015 20:20'!testRaw	super testRaw.	self assert: result equals: (PRRaw content: 'foo' type: 'mock' )! !!PRPillarParserTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 9/9/2015 20:30'!testRawEmpty	super testRawEmpty.	self assert: result equals: (PRRaw content: '')! !!PRPillarParserTest methodsFor: 'tests - Text' stamp: 'CyrilFerlicot 9/9/2015 20:31'!testRawMultiLines	super testRawMultiLines.	self assert: result equals: (PRRaw content: 'foobar')! !!PRPillarParserTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 8/13/2015 14:12'!testReference	super testReference.	self		assert: result		equals:			(PRInternalLink new				add: (PRText content: 'foo');				anchor: 'bar';				yourself)! !!PRPillarParserTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 9/9/2015 02:02'!testReferenceFigure	super testReferenceFigure.	self assert: result equals: 'file://foo.png'! !!PRPillarParserTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 9/9/2015 02:02'!testReferenceFigureEscape	super testReferenceFigureEscape.	self assert: result equals: 'file://foo+.png'! !!PRPillarParserTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 9/9/2015 17:08'!testReferenceLink	super testReferenceLink.	self assert: result equals: 'file://foo.png'! !!PRPillarParserTest methodsFor: 'tests - Reference' stamp: 'CyrilFerlicot 9/9/2015 17:08'!testReferenceLinkEscape	super testReferenceLinkEscape.	self assert: result equals: 'file://foo*.png'! !!PRPillarParserTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 8/12/2015 17:17'!testScript	super testScript.	self assert: result equals: (PRScript content: 'foo')! !!PRPillarParserTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 9/3/2015 05:11'!testScriptParameter	super testScriptParameter.	self assert: result equals: #('value' 'foo')! !!PRPillarParserTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 9/3/2015 05:11'!testScriptParameterEscape	super testScriptParameterEscape.	self assert: result equals: #('value=' 'foo')! !!PRPillarParserTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 8/31/2015 21:33'!testScriptParameterNil	| script |	super testScriptParameterNil.	script := PRScript content: 'bar'.	script parameters at: 'foo' put: nil.	self assert: result equals: script! !!PRPillarParserTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 8/22/2015 18:33'!testScriptParameterValue	super testScriptParameterValue.	self assert: result equals: 'foo'! !!PRPillarParserTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 8/31/2015 21:33'!testScriptParameterWithNoValues	| script |	super testScriptParameterWithNoValues.	script := PRScript content: 'bar'.	script parameters at: 'foo' put: ''.	self assert: result equals: script! !!PRPillarParserTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 9/3/2015 05:11'!testScriptParameterWithoutValue	super testScriptParameterWithoutValue.	self assert: result equals: #('foo'  nil)! !!PRPillarParserTest methodsFor: 'tests - Script' stamp: 'YannDubois 5/2/2016 14:37'!testScriptParameters	super testScriptParameters.	self		assert: result		equals:			(SmallDictionary new				at: 'value' put: 'foo';				yourself)! !!PRPillarParserTest methodsFor: 'tests - Script' stamp: 'YannDubois 5/2/2016 14:37'!testScriptParametersEscape	super testScriptParametersEscape.	self		assert: result		equals:			(SmallDictionary new				at: 'value' put: 'foo|';				at: 'bar' put: nil;				yourself)! !!PRPillarParserTest methodsFor: 'tests - Script' stamp: 'YannDubois 5/2/2016 14:20'!testScriptParametersMultiple	super testScriptParametersMultiple.	self		assert: result		equals:			(SmallDictionary new				at: 'value' put: 'foo';				at: 'bar' put: nil;				yourself)! !!PRPillarParserTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 8/12/2015 17:17'!testScriptWithLanguage	super testScriptWithLanguage.	self		assert: result		equals:			((PRScript content: 'foo')				language: PRSmalltalkScriptLanguage default;				yourself)! !!PRPillarParserTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 8/12/2015 17:17'!testScriptWithNewLine	super testScriptWithNewLine.	self assert: result equals: (PRScript content: 'foo')! !!PRPillarParserTest methodsFor: 'tests - Script' stamp: 'CyrilFerlicot 9/10/2015 02:51'!testScriptWithSpaceAtTheEnd	super testScriptWithSpaceAtTheEnd.	self assert: result equals: (PRScript content: 'foo')! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:38'!testStrikethroughFormat	super testStrikethroughFormat.	self assert: result equals: (PRStrikethroughFormat with: (PRText content: 'Foo'))! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:39'!testStrikethroughFormatEmpty	super testStrikethroughFormatEmpty.	self assert: result equals: PRStrikethroughFormat new! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:39'!testStrikethroughFormatWithEscaped	super testStrikethroughFormatWithEscaped.	self assert: result equals: (PRStrikethroughFormat with: (PRText content: '--'))! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:39'!testSubscriptFormat	super testSubscriptFormat.	self assert: result equals: (PRSubscriptFormat with: (PRText content: 'Foo'))! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:39'!testSubscriptFormatEmpty	super testSubscriptFormatEmpty.	self assert: result equals: PRSubscriptFormat new! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:39'!testSubscriptFormatWithEscaped	super testSubscriptFormatWithEscaped.	self assert: result equals: (PRSubscriptFormat with: (PRText content: '@@'))! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:39'!testSuperscriptFormat	super testSuperscriptFormat.	self assert: result equals: (PRSuperscriptFormat with: (PRText content: 'Foo'))! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:39'!testSuperscriptFormatEmpty	super testSuperscriptFormatEmpty.	self assert: result equals: PRSuperscriptFormat new! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:39'!testSuperscriptFormatWithEscaped	super testSuperscriptFormatWithEscaped.	self assert: result equals: (PRSuperscriptFormat with: (PRText content: '^^'))! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:26'!testTable	super testTable.	self		assert: result		equals:			(PRTable new				add:						(PRTableRow new								add: (PRTableCell align: nil heading: true withAll: {PRText content: 'Foo'});								add: (PRTableCell align: nil heading: true withAll: {PRText content: 'Bar'});								yourself);				add:						(PRTableRow new								add: (PRTableCell align: nil heading: false withAll: {PRText content: 'Foo2'});								add: (PRTableCell align: nil heading: false withAll: {PRText content: 'Bar2'});								yourself);				yourself)! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:27'!testTableAlignMarkup	super testTableAlignMarkup.	self assert: result equals: #right! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:27'!testTableCell	super testTableCell.	self assert: result equals: (PRTableCell align: nil heading: false withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:27'!testTableCellAreTrimed	super testTableCellAreTrimed.	self assert: result equals: (PRTableCell align: nil heading: false withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:27'!testTableCellCenter	super testTableCellCenter.	self assert: result equals: (PRTableCell align: #center heading: false withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:27'!testTableCellHeader	super testTableCellHeader.	self assert: result equals: (PRTableCell align: nil heading: true withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:27'!testTableCellHeaderCenter	super testTableCellHeaderCenter.	self assert: result equals: (PRTableCell align: #center heading: true withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:27'!testTableCellHeaderCenter2	super testTableCellHeaderCenter2.	self assert: result equals: (PRTableCell align: #center heading: true withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:27'!testTableCellHeaderLeft	super testTableCellHeaderLeft.	self assert: result equals: (PRTableCell align: #left heading: true withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:27'!testTableCellHeaderLeft2	super testTableCellHeaderLeft2.	self assert: result equals: (PRTableCell align: #left heading: true withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:27'!testTableCellHeaderRight	super testTableCellHeaderRight.	self assert: result equals: (PRTableCell align: #right heading: true withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:27'!testTableCellHeaderRight2	super testTableCellHeaderRight2.	self assert: result equals: (PRTableCell align: #right heading: true withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:27'!testTableCellLeft	super testTableCellLeft.	self assert: result equals: (PRTableCell align: #left heading: false withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:27'!testTableCellRight	super testTableCellRight.	self assert: result equals: (PRTableCell align: #right heading: false withAll: {PRText content: 'Foo'})! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:27'!testTableCellWithFormat	super testTableCellWithFormat.	self		assert: result		equals: (PRTableCell align: nil heading: false withAll: {PRItalicFormat with: (PRText content: 'Foo')})! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:28'!testTableCenterMarkup	super testTableCenterMarkup.	self assert: result equals: #center! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:28'!testTableHeadingMarkup	super testTableHeadingMarkup.	self assert: result equals: true! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:28'!testTableLeftMarkup	super testTableLeftMarkup.	self assert: result equals: #left! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:28'!testTableMarkups	super testTableMarkups.	self		assert: result		equals:			{nil.			false}! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:28'!testTableMarkupsCenter	super testTableMarkupsCenter.	self		assert: result		equals:			{#center.			false}! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:28'!testTableMarkupsHeading	super testTableMarkupsHeading.	self		assert: result		equals:			{nil.			true}! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:28'!testTableMarkupsHeadingAndCenter	super testTableMarkupsHeadingAndCenter.	self		assert: result		equals:			{#center.			true}! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:28'!testTableMarkupsHeadingAndCenter2	super testTableMarkupsHeadingAndCenter2.	self		assert: result		equals:			{#center.			true}! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:28'!testTableRightMarkup	super testTableRightMarkup.	self assert: result equals: #right! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:28'!testTableRow	super testTableRow.	self		assert: result		equals:			(PRTableRow new				add: (PRTableCell align: nil heading: false withAll: {PRText content: 'Foo'});				add: (PRTableCell align: nil heading: false withAll: {PRText content: 'Bar'});				yourself)! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:28'!testTableRowWithEmptyCells	super testTableRowWithEmptyCells.	self		assert: result		equals:			(PRTableRow new				add: PRTableCell new;				add: PRTableCell new;				yourself)! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:28'!testTableRowWithHeading	super testTableRowWithHeading.	self		assert: result		equals:			(PRTableRow new				add: (PRTableCell align: nil heading: true withAll: {PRText content: 'Foo'});				add: (PRTableCell align: nil heading: true withAll: {PRText content: 'Bar'});				yourself)! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:39'!testTableWithComment	super testTableWithComment.	self flag: #todo	"See super."	"self		assert: result		equals:			(PRTable				withAll:					{PRTableRow						with:							(PRTableCell								align: nil								heading: false								withAll:									{PRText content: 'Foo'.									PRCommentedLine content: 'Comment'}).					PRTableRow with: (PRTableCell align: nil heading: false withAll: {PRText content: 'Bar'})})"! !!PRPillarParserTest methodsFor: 'tests - Table' stamp: 'CyrilFerlicot 8/12/2015 17:29'!testTableWithNewLine	super testTableWithNewLine.	self		assert: result		equals:			(PRTable new				add:						(PRTableRow new								add: (PRTableCell align: nil heading: true withAll: {PRText content: 'Foo'});								add: (PRTableCell align: nil heading: true withAll: {PRText content: 'Bar'});								yourself);				add:						(PRTableRow new								add: (PRTableCell align: nil heading: false withAll: {PRText content: 'Foo2'});								add: (PRTableCell align: nil heading: false withAll: {PRText content: 'Bar2'});								yourself);				yourself)! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:39'!testUnderlineFormat	super testUnderlineFormat.	self assert: result equals: (PRUnderlineFormat with: (PRText content: 'Foo'))! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:39'!testUnderlineFormatEmpty	super testUnderlineFormatEmpty.	self assert: result equals: PRUnderlineFormat new! !!PRPillarParserTest methodsFor: 'tests - Format' stamp: 'CyrilFerlicot 8/12/2015 15:39'!testUnderlineFormatWithEscaped	super testUnderlineFormatWithEscaped.	self assert: result equals: (PRUnderlineFormat with: (PRText content: '__'))! !!PRPillarParserTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 17:01'!testUnorderedList	super testUnorderedList.	self		assert: result		equals: (PRUnorderedList with: (PRListItem with: (PRText content: 'Foo')))! !!PRPillarParserTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 17:01'!testUnorderedListEmpty	super testUnorderedListEmpty.	self assert: result equals: (PRUnorderedList with: PRListItem new)! !!PRPillarParserTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 17:01'!testUnorderedListMulti	super testUnorderedListMulti.	self		assert: result		equals:			(PRUnorderedList				withAll:					{(PRListItem						withAll:							{(PRText content: '1').							(PRUnorderedList								withAll:									{(PRListItem										withAll:											{(PRText content: '2').											(PRUnorderedList with: (PRListItem with: (PRText content: '3')))}).									(PRListItem with: (PRText content: '4')).									(PRListItem with: (PRText content: '5')).									(PRListItem with: (PRText content: '6'))})}).					(PRListItem						withAll:							{(PRText content: '7').							(PRUnorderedList								with:									(PRListItem with: (PRUnorderedList with: (PRListItem with: (PRText content: '8')))))})})! !!PRPillarParserTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 17:00'!testUnorderedListWithSubList	super testUnorderedListWithSubList.	self		assert: result		equals:			(PRUnorderedList				with:					(PRListItem						withAll:							{(PRText content: 'Foo').							(PRUnorderedList with: (PRListItem with: (PRText content: 'Bar')))}))! !!PRPillarParserTest methodsFor: 'tests - List' stamp: 'CyrilFerlicot 8/12/2015 17:00'!testUnorderedListWithTwoItems	super testUnorderedListWithTwoItems.	self		assert: result		equals:			(PRUnorderedList				withAll:					{(PRListItem with: (PRText content: 'Foo')).					(PRListItem with: (PRText content: 'Bar'))})! !"Pillar-Tests-PetitPillar"!----QUIT----2016-11-30T00:44:15.686155+01:00 Pillar.image priorSource: 317223!!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!priority	^ 90! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!key	^ #mock! !!PRMockPhase class methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!pipelineKey	^ #transform! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!start: anInput	^ super start: (anInput add: (PRText content: 'Bar'); yourself)! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!visitDocumentGroup: aGroup			aGroup add: (PRText content: 'Timoleon')! !!PRMockPhase methodsFor: 'as yet unclassified' stamp: 'hudson 11/30/2016 00:44'!transformerMock: aCollection			<pillarTransformer: 100 key: 'mock' documentation:'mock transformer'>! !!ConfigurationOfMustache class methodsFor: 'development support' stamp: 'NorbertHartl 9/30/2013 10:05'!DevelopmentSupport"See the methods in the 'development support' category on the class-side of MetacelloBaseConfiguration. Decide what development support methods you would like to use and copy them the the class-side of your configuration."	<apiDocumentation>! !!ConfigurationOfMustache class methodsFor: 'private' stamp: 'NorbertHartl 9/30/2013 10:05'!baseConfigurationClassIfAbsent: aBlock	^Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			self ensureMetacelloBaseConfiguration.			Smalltalk at: #MetacelloBaseConfiguration ifAbsent: aBlock ].! !!ConfigurationOfMustache class methodsFor: 'private' stamp: 'NorbertHartl 9/30/2013 10:05'!ensureMetacello	(self baseConfigurationClassIfAbsent: []) ensureMetacello! !!ConfigurationOfMustache class methodsFor: 'private' stamp: 'NorbertHartl 9/30/2013 10:05'!ensureMetacelloBaseConfiguration	Smalltalk		at: #MetacelloBaseConfiguration		ifAbsent: [ 			| repository version |			repository := MCHttpRepository location: 'http://seaside.gemstone.com/ss/metacello' user: '' password: ''.			repository				versionReaderForFileNamed: 'Metacello-Base-DaleHenrichs.2.mcz'				do: [ :reader | 					version := reader version.					version load.					version workingCopy repositoryGroup addRepository: repository ] ]! !!ConfigurationOfMustache class methodsFor: 'metacello tool support' stamp: 'NorbertHartl 9/30/2013 10:05'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfMustache class methodsFor: 'loading' stamp: 'NorbertHartl 9/30/2013 10:05'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfMustache class methodsFor: 'loading' stamp: 'NorbertHartl 9/30/2013 10:05'!loadBleedingEdge	"Load the latest versions of the mcz files defined for this project. It is not likely that the #bleedingEdge has been tested."	"self loadBleedingEdge"	<apiDocumentation>	^(self project version: #bleedingEdge) load! !!ConfigurationOfMustache class methodsFor: 'loading' stamp: 'NorbertHartl 9/30/2013 10:05'!loadDevelopment	"Load the #development version defined for this platform. The #development version will change over time and is not expected to be stable."	"self loadDevelopment"	<apiDocumentation>	^(self project version: #development) load! !!ConfigurationOfMustache class methodsFor: 'accessing' stamp: 'NorbertHartl 9/30/2013 10:05'!project	^self new project! !!ConfigurationOfMustache class methodsFor: 'development support' stamp: 'NorbertHartl 9/30/2013 10:05'!validate	"Check the configuration for Errors, Critical Warnings, and Warnings (see class comment for MetacelloMCVersionValidator for more information). 	Errors identify specification issues that will result in unexpected behaviour when you load the configuration. 	Critical Warnings identify specification issues that may result in unexpected behavior when you load the configuration.	Warnings identify specification issues that are technically correct, but are worth take a look at."	"self validate"	<apiDocumentation>	self ensureMetacello.	^ ((Smalltalk at: #MetacelloToolBox) validateConfiguration: self debug: #() recurse: false) explore! !!ConfigurationOfMustache methodsFor: 'baselines' stamp: 'NorbertHartl 12/23/2014 15:16'!baseline01: spec	<version: '0.1-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/NorbertHartl/Mustache/main'.		spec 			package: 'Mustache-Core';			package: 'Mustache-Tests' with: [				spec requires: #('Mustache-Core' ). ].		spec 			group: 'default' with: #('Core' 'Tests' );			group: 'Core' with: #('Mustache-Core' );			group: 'Tests' with: #('Mustache-Tests' ). ].! !!ConfigurationOfMustache methodsFor: 'baselines' stamp: 'ThibaultArloing 4/20/2016 10:21'!baseline02: spec	<version: '0.2-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec repository: 'http://smalltalkhub.com/mc/NorbertHartl/Mustache/main'.		spec project: 'JSON' with: [				spec					className: #ConfigurationOfJSON;					versionString: #'stable';					loads: #('default' );					repository: 'http://smalltalkhub.com/mc/PharoExtras/JSON/main/' ].		spec 			package: 'Mustache-Core';			package: 'Mustache-Tests' with: [				spec requires: #('Mustache-Core' ). ];			package: #'Mustache-Cli' with: [				spec requires: #('JSON' ). ].		spec 			group: 'Core' with: #('Mustache-Core' );			group: 'Tests' with: #('Mustache-Tests' );			group: 'default' with: #('Core' 'Tests' #'Mustache-Cli' ). ].! !!ConfigurationOfMustache methodsFor: 'symbolic versions' stamp: 'ThibaultArloing 4/20/2016 09:17'!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: '0.2-baseline'.! !!ConfigurationOfMustache methodsFor: 'accessing' stamp: 'NorbertHartl 9/30/2013 10:05'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		(self class baseConfigurationClassIfAbsent: []) ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project loadType: #linear. "change to #atomic if desired"		project ]! !!ConfigurationOfMustache methodsFor: 'symbolic versions' stamp: 'NorbertHartl 10/26/2016 15:37'!stable: spec	<symbolicVersion: #'stable'>	spec for: #'common' version: '0.73'.! !!ConfigurationOfMustache methodsFor: 'versions' stamp: 'NorbertHartl 10/3/2013 21:38'!version043: spec	<version: '0.43' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: '0.42 : last preparations for releasing0.43 : release on smalltalkhub'.		spec author: 'NorbertHartl'.		spec timestamp: '10/3/2013 21:38'.		spec 			package: 'Mustache-Core' with: 'Mustache-Core-NorbertHartl.15';			package: 'Mustache-Tests' with: 'Mustache-Tests-NorbertHartl.6'. ].! !!ConfigurationOfMustache methodsFor: 'versions' stamp: 'NorbertHartl 10/3/2013 21:50'!version044: spec	<version: '0.44' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: '0.43 : release on smalltalkhub0.44 : comments added and code critics'.		spec author: 'NorbertHartl'.		spec timestamp: '10/3/2013 21:50'.		spec 			package: 'Mustache-Core' with: 'Mustache-Core-NorbertHartl.16';			package: 'Mustache-Tests' with: 'Mustache-Tests-NorbertHartl.6'. ].! !!ConfigurationOfMustache methodsFor: 'versions' stamp: 'DamienCassou 11/27/2013 18:14'!version045: spec	<version: '0.45' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '0.45 : comments added and code critics'.		spec author: 'NorbertHartl'.		spec timestamp: '10/3/2013 21:50'.		spec 			package: 'Mustache-Core' with: 'Mustache-Core-NorbertHartl.16';			package: 'Mustache-Tests' with: 'Mustache-Tests-NorbertHartl.6'. ].! !!ConfigurationOfMustache methodsFor: 'versions' stamp: 'DamienCassou 11/27/2013 18:15'!version046: spec	<version: '0.46' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '0.46 : Provide AbstractFileReference>>asMustacheTemplate and AbstractFileReference>>mustacheTemplateDuring:'.		spec author: 'DamienCassou'.		spec timestamp: '27/11/2013 18:14'.		spec 			package: 'Mustache-Core' with: 'Mustache-Core-DamienCassou.17';			package: 'Mustache-Tests' with: 'Mustache-Tests-DamienCassou.7'. ].! !!ConfigurationOfMustache methodsFor: 'versions' stamp: 'DamienCassou 11/27/2013 18:23'!version047: spec	<version: '0.47' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '0.47 : Previous didn''t load in Pharo 2.0'.		spec author: 'DamienCassou'.		spec timestamp: '27/11/2013 18:23'.		spec 			package: 'Mustache-Core' with: 'Mustache-Core-DamienCassou.18';			package: 'Mustache-Tests' with: 'Mustache-Tests-DamienCassou.7'. ].! !!ConfigurationOfMustache methodsFor: 'versions' stamp: 'DamienCassou 11/27/2013 18:32'!version048: spec	<version: '0.48' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: '0.48 : Fix for Pharo 2.0'.		spec author: 'DamienCassou'.		spec timestamp: '27/11/2013 18:31'.		spec 			package: 'Mustache-Core' with: 'Mustache-Core-DamienCassou.19';			package: 'Mustache-Tests' with: 'Mustache-Tests-DamienCassou.7'. ].! !!ConfigurationOfMustache methodsFor: 'versions' stamp: 'NorbertHartl 2/25/2014 16:17'!version049: spec	<version: '0.49' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: ''.		spec author: 'NorbertHartl'.		spec timestamp: '2/25/2014 16:16'.		spec 			package: 'Mustache-Core' with: 'Mustache-Core-NorbertHartl.20';			package: 'Mustache-Tests' with: 'Mustache-Tests-NorbertHartl.8'. ].! !!ConfigurationOfMustache methodsFor: 'versions' stamp: 'NorbertHartl 2/25/2014 16:38'!version050: spec	<version: '0.50' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'Old change delimiter test was testing the broken behavior correct'.		spec author: 'NorbertHartl'.		spec timestamp: '2/25/2014 16:38'.		spec 			package: 'Mustache-Core' with: 'Mustache-Core-NorbertHartl.20';			package: 'Mustache-Tests' with: 'Mustache-Tests-NorbertHartl.9'. ].! !!ConfigurationOfMustache methodsFor: 'versions' stamp: 'NorbertHartl 4/18/2014 23:46'!version060: spec         <version: '0.60' imports: #('0.1-baseline')>        spec for: #common do: [                spec blessing: #release.			spec package: 'Mustache-Core' with: 'Mustache-Core-NorbertHartl.23'.			spec package: 'Mustache-Tests' with: 'Mustache-Tests-NorbertHartl.12'.                ].! !!ConfigurationOfMustache methodsFor: 'versions' stamp: 'NorbertHartl 11/7/2014 10:39'!version070: spec         <version: '0.70' imports: #('0.1-baseline')>        spec for: #common do: [                spec blessing: #release.			spec package: 'Mustache-Core' with: 'Mustache-Core-NorbertHartl.25'.			spec package: 'Mustache-Tests' with: 'Mustache-Tests-NorbertHartl.15'.                ].! !!ConfigurationOfMustache methodsFor: 'versions' stamp: 'NorbertHartl 12/23/2014 15:16'!version071: spec	<version: '0.71' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.71'.		spec author: 'NorbertHartl'.		spec timestamp: '12/23/2014 15:16'.		spec 			package: 'Mustache-Core' with: 'Mustache-Core-NorbertHartl.26';			package: 'Mustache-Tests' with: 'Mustache-Tests-NorbertHartl.15'. ].! !!ConfigurationOfMustache methodsFor: 'versions' stamp: 'NorbertHartl 9/19/2015 16:23'!version072: spec	<version: '0.72' imports: #('0.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'Added support for dot (.) selectors. Sections and values can use dot to select current object in context. This supports e.g. using collections containing plain strings'.		spec author: 'NorbertHartl'.		spec timestamp: '9/19/2015 16:21'.		spec 			package: 'Mustache-Core' with: 'Mustache-Core-NorbertHartl.31';			package: 'Mustache-Tests' with: 'Mustache-Tests-NorbertHartl.16'. ].! !!ConfigurationOfMustache methodsFor: 'versions' stamp: 'NorbertHartl 10/26/2016 15:38'!version073: spec	<version: '0.73' imports: #('0.2-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 0.73 fixed bug when string is context and evaluation is using dot'.		spec author: 'NorbertHartl'.		spec timestamp: '10/26/2016 15:37'.		spec project: 'JSON' with: '1.2'.		spec 			package: 'Mustache-Core' with: 'Mustache-Core-NorbertHartl.32';			package: 'Mustache-Tests' with: 'Mustache-Tests-NorbertHartl.17';			package: #'Mustache-Cli' with: 'Mustache-Cli-ThibaultArloing.5'. ].! !"ConfigurationOfMustache"!!MustacheParser commentStamp: '<historical>' prior: 0!A MustacheParser is the internally used parser that is used my MustacheTemplate to compile a template string into a template structure!!MustachePart commentStamp: '<historical>' prior: 0!A MustachePart is the base class for all entities that are parsed from a template string. The structure is held internally by MustacheTemplate to render a string from a template.For public access have a look at MustacheTemplate!!MustacheTemplate commentStamp: '<historical>' prior: 0!A MustacheTemplate is the main class to interact when dealing with mustache templates.A MustacheTemplate can be created from a string containing mustache template markup either withMustacheTemplate on: aStringoraString asMustacheTemplate To fill out a template just provide a context object and doaMustacheTemplate value: aContextObject Nested templates can be used be providing a dictionary with keys as the names used in the master template and values being individual mustache templates!!MustacheWriteVisitor commentStamp: '<historical>' prior: 0!A MustacheWriteVisitor is the main visitor produces a final string from a template and a context object. It is used by MustacheTemplate!!AbstractFileReference methodsFor: '*mustache-core' stamp: 'DamienCassou 11/27/2013 18:28'!asMustacheTemplate	^ MustacheTemplate on: self readStream contents asString! !!AbstractFileReference methodsFor: '*mustache-core' stamp: 'DamienCassou 11/27/2013 18:21'!mustacheTemplateDuring: aBlock	^ self		readStreamDo: [ :input | | input2 |			"The following are here because of case #12259: 'FileSystem memory reads/writes using a binary stream by default'."			input2 := input.			(self fileSystem store isKindOf: MemoryStore)				ifTrue: [ input2 := input2 contents asString readStream ].			aBlock value: (MustacheTemplate on: input2) ]! !!False methodsFor: '*mustache-core' stamp: 'NorbertHartl 10/1/2013 14:11'!mustacheDo: aBlock inverted: aBoolean	aBoolean ifTrue:  [ aBlock value: nil ]! !!UndefinedObject methodsFor: '*mustache-core' stamp: 'NorbertHartl 10/1/2013 14:32'!mustacheDo: aBlock inverted: aBoolean 	aBoolean mustacheDo: aBlock! !!HashedCollection methodsFor: '*mustache-core' stamp: 'NorbertHartl 4/18/2014 17:52'!mustacheDo: aBlock	aBlock value: self! !!HashedCollection methodsFor: '*mustache-core' stamp: 'NorbertHartl 4/18/2014 17:52'!mustacheDo: aBlock inverted: aBoolean	aBoolean ifFalse: [ aBlock cull: self ]! !!True methodsFor: '*mustache-core' stamp: 'NorbertHartl 10/1/2013 14:11'!mustacheDo: aBlock inverted: aBoolean	aBoolean ifFalse:  [ aBlock value: nil ]! !!MustacheParser class methodsFor: 'instance creation' stamp: 'NorbertHartl 9/28/2013 00:57'!on: aStringOrStream 	^ self new		stream: aStringOrStream readStream ! !!MustacheParser methodsFor: 'accessing' stamp: 'NorbertHartl 9/28/2013 22:21'!addPart: aMustachePart	stack top addPart: aMustachePart	! !!MustacheParser methodsFor: 'accessing' stamp: 'NorbertHartl 1/25/2015 10:30'!buildDelimiterExtensions	^ Dictionary new		at: $# put: [ self startSection: MustacheSection ];		at: $/ put: [ self endSection ];		at: ${ put: [ self readDefaultUnescapedToken ];		at: $& put: [ self readUnescapedToken  ];		at: $!! put: [ self readComment ];		at: $^ put: [ self startSection: MustacheInvertedSection ];		at: $= put: [ self readChangeDelimiter ];		at: $> put: [ self readPartial ];		yourself! !!MustacheParser methodsFor: 'generating' stamp: 'NorbertHartl 10/2/2013 09:58'!compile	|  sequenceStart |	sequenceStart := [ 		self readStringChunk.		[ self readTag. sequenceStart ] ].	self readUpToEndUsing: sequenceStart ! !!MustacheParser methodsFor: 'as yet unclassified' stamp: 'NorbertHartl 12/23/2014 15:01'!compileTemplate: aTemplate	self push: aTemplate.	self compile! !!MustacheParser methodsFor: 'reading' stamp: 'NorbertHartl 9/27/2013 22:48'!consumeWhiteSpace	[ stream atEnd not and: [ stream peek isSeparator ] ] whileTrue: [ 		stream next ]! !!MustacheParser methodsFor: 'accessing' stamp: 'NorbertHartl 9/27/2013 23:01'!defaultEndDelimiter	^ '}}'! !!MustacheParser methodsFor: 'accessing' stamp: 'NorbertHartl 9/27/2013 22:11'!defaultStartDelimiter	^ '{{'! !!MustacheParser methodsFor: 'accessing' stamp: 'NorbertHartl 1/25/2015 10:30'!delimiterExtensions	^ delimiterExtensions ifNil: [ 		delimiterExtensions := self buildDelimiterExtensions ]! !!MustacheParser methodsFor: 'accessing' stamp: 'NorbertHartl 9/27/2013 23:02'!endDelimiter	^ endDelimiter ifNil: [ 		endDelimiter := self defaultEndDelimiter  ]! !!MustacheParser methodsFor: 'accessing' stamp: 'NorbertHartl 9/28/2013 23:16'!endDelimiter: aString	endDelimiter := aString! !!MustacheParser methodsFor: 'reading' stamp: 'NorbertHartl 9/30/2013 11:01'!endSection	| token |	token := self readToken.	(stack top selector = token) ifFalse: [ 		Error signal: 'end section does not match ', stack top selector asString ].	stack pop! !!MustacheParser methodsFor: 'initialize-release' stamp: 'NorbertHartl 9/28/2013 01:01'!initialize 	super initialize.	stack := Stack new! !!MustacheParser methodsFor: 'testing' stamp: 'NorbertHartl 9/27/2013 22:35'!isDelimiterExtension: aCharacter	^ self delimiterExtensions keys includes: aCharacter! !!MustacheParser methodsFor: 'accessing' stamp: 'NorbertHartl 9/28/2013 00:59'!push: aTemplate 	stack push: aTemplate ! !!MustacheParser methodsFor: 'reading' stamp: 'NorbertHartl 2/25/2014 16:06'!readChangeDelimiter	self startDelimiter: (String streamContents: [ :s| 		[ stream peek isSeparator ] whileFalse: [ 			s nextPut: stream next ]]).	self consumeWhiteSpace.	self endDelimiter: (stream upToAll: self endDelimiter) allButLast! !!MustacheParser methodsFor: 'reading' stamp: 'NorbertHartl 10/2/2013 10:12'!readComment	"just read and forget"	self readToken! !!MustacheParser methodsFor: 'reading' stamp: 'NorbertHartl 10/2/2013 09:33'!readDefaultTag	self readHtmlEscapedToken! !!MustacheParser methodsFor: 'reading' stamp: 'NorbertHartl 9/28/2013 22:17'!readDefaultUnescapedToken	self readUnescapedToken.	(stream next = $}) ifFalse: [ 		Error signal: $} asString, ' character expected' ].! !!MustacheParser methodsFor: 'reading' stamp: 'NorbertHartl 10/2/2013 09:32'!readExtendedTag	 ^ (self delimiterExtensions at: stream next) value! !!MustacheParser methodsFor: 'reading' stamp: 'NorbertHartl 9/29/2013 17:29'!readHtmlEscapedToken	self addPart: (MustacheHtmlEscapedToken token: self readToken)! !!MustacheParser methodsFor: 'reading' stamp: 'NorbertHartl 10/2/2013 10:13'!readPartial	self addPart: (MustachePartial name: self readToken)! !!MustacheParser methodsFor: 'reading' stamp: 'NorbertHartl 9/28/2013 23:38'!readStringChunk	(stream upToAll: self startDelimiter) ifNotNil: [:chunk|		self addPart: (MustacheStringChunk string: chunk) ].! !!MustacheParser methodsFor: 'reading' stamp: 'NorbertHartl 10/2/2013 09:33'!readTag	(self isDelimiterExtension: stream peek)		ifTrue: [  self readExtendedTag  ]		ifFalse: [  self readDefaultTag  ]! !!MustacheParser methodsFor: 'reading' stamp: 'NorbertHartl 9/28/2013 23:07'!readToken	^ (stream upToAll: self endDelimiter) trimBoth! !!MustacheParser methodsFor: 'reading' stamp: 'NorbertHartl 9/28/2013 22:23'!readUnescapedToken	self addPart: (MustacheToken token: self readToken)! !!MustacheParser methodsFor: 'reading' stamp: 'NorbertHartl 10/2/2013 09:49'!readUpToEndUsing: aBlock	| nextRead |	nextRead := aBlock.	[ stream atEnd ] whileFalse: [  		 nextRead := nextRead value ]! !!MustacheParser methodsFor: 'accessing' stamp: 'NorbertHartl 9/27/2013 22:11'!startDelimiter	^ startDelimiter ifNil: [		startDelimiter := self defaultStartDelimiter ]! !!MustacheParser methodsFor: 'accessing' stamp: 'NorbertHartl 9/28/2013 23:17'!startDelimiter: aString	startDelimiter := aString! !!MustacheParser methodsFor: 'reading' stamp: 'NorbertHartl 10/3/2013 20:14'!startSection: aSectionClass	| section |	section := aSectionClass selector: self readToken.	self addPart: section. 	stack push: section	! !!MustacheParser methodsFor: 'accessing' stamp: 'NorbertHartl 9/28/2013 00:58'!stream: aStream 	stream := aStream! !!MustacheCompositePart methodsFor: 'adding' stamp: 'NorbertHartl 9/27/2013 23:54'!addPart: aMustachePart	parts add: aMustachePart ! !!MustacheCompositePart methodsFor: 'initialize-release' stamp: 'NorbertHartl 9/27/2013 23:54'!initialize 	super initialize.	parts := OrderedCollection new.! !!MustacheCompositePart methodsFor: 'accessing' stamp: 'NorbertHartl 9/29/2013 16:52'!parts	^ parts! !!MustacheInvertedSection methodsFor: 'testing' stamp: 'NorbertHartl 10/1/2013 14:25'!isInverted	^ true! !!MustacheSection class methodsFor: 'instance creation' stamp: 'NorbertHartl 9/28/2013 00:05'!selector: aString 	^ self new		selector: aString! !!MustacheSection methodsFor: 'visiting' stamp: 'NorbertHartl 9/29/2013 16:56'!accept: aVisitor 	aVisitor visitSection: self! !!MustacheSection methodsFor: 'testing' stamp: 'NorbertHartl 10/1/2013 14:24'!isInverted	^ false! !!MustacheSection methodsFor: 'accessing' stamp: 'NorbertHartl 9/30/2013 10:44'!lookupInContext: anObject	^ self lookup: selector inContext: anObject! !!MustacheSection methodsFor: 'resolving' stamp: 'NorbertHartl 10/1/2013 14:25'!mustacheDo: aBlock inContext: aContext 	aContext mustacheDo: aBlock inverted: self isInverted! !!MustacheSection methodsFor: 'accessing' stamp: 'NorbertHartl 9/30/2013 11:01'!selector	^ selector! !!MustacheSection methodsFor: 'accessing' stamp: 'NorbertHartl 9/28/2013 00:05'!selector: aString 	selector := aString! !!MustacheSection methodsFor: 'accessing' stamp: 'NorbertHartl 4/18/2014 18:47'!valueInContext: anObject	^ self lookupInContext: anObject! !!MustacheTemplate class methodsFor: 'instance creation' stamp: 'NorbertHartl 12/23/2014 14:56'!on: aStringOrStream 	^ self new		compile: aStringOrStream readStream;		yourself! !!MustacheTemplate methodsFor: 'visiting' stamp: 'NorbertHartl 9/29/2013 16:50'!accept: aVisitor 	aVisitor visitTemplate: self! !!MustacheTemplate methodsFor: 'resolving' stamp: 'NorbertHartl 12/23/2014 15:01'!compile: aStream 	(self parserClass on: aStream)		compileTemplate: self			! !!MustacheTemplate methodsFor: 'accessing' stamp: 'NorbertHartl 12/23/2014 15:01'!parserClass	^ MustacheParser ! !!MustacheTemplate methodsFor: 'resolving' stamp: 'NorbertHartl 10/2/2013 10:19'!value: anObject 	| visitor |	visitor := MustacheWriteVisitor new		context: anObject.	self accept: visitor.	^ visitor string! !!MustacheTemplate methodsFor: 'resolving' stamp: 'NorbertHartl 10/2/2013 10:19'!value: anObject partials: aDictionary	| visitor |	visitor := MustacheWriteVisitor new		partials: aDictionary;		context: anObject.	self accept: visitor.	^ visitor string! !!MustachePart methodsFor: 'resolving' stamp: 'NorbertHartl 9/30/2013 10:41'!lookup: aToken inContext: anObject	^ anObject mustacheLookup: aToken! !!MustachePartial class methodsFor: 'instance creation' stamp: 'NorbertHartl 10/2/2013 10:14'!name: aString 	^ self new		name: aString! !!MustachePartial methodsFor: 'visiting' stamp: 'NorbertHartl 10/2/2013 10:15'!accept: aVisitor 	aVisitor visitPartial: self ! !!MustachePartial methodsFor: 'accessing' stamp: 'NorbertHartl 10/2/2013 10:16'!name	^ name! !!MustachePartial methodsFor: 'accessing' stamp: 'NorbertHartl 10/2/2013 10:14'!name: aString 	name := aString! !!MustacheStringChunk class methodsFor: 'instance creation' stamp: 'NorbertHartl 9/27/2013 22:29'!string: aString 	^ self new		string: aString! !!MustacheStringChunk methodsFor: 'visiting' stamp: 'NorbertHartl 9/29/2013 16:54'!accept: aVisitor 	aVisitor visitStringChunk: self! !!MustacheStringChunk methodsFor: 'accessing' stamp: 'NorbertHartl 9/29/2013 17:01'!string	^ string! !!MustacheStringChunk methodsFor: 'accessing' stamp: 'NorbertHartl 9/27/2013 22:30'!string: aString 	string := aString! !!MustacheHtmlEscapedToken methodsFor: 'visiting' stamp: 'NorbertHartl 9/29/2013 16:55'!accept: aVisitor 	aVisitor visitHtmlEscapedToken: self ! !!MustacheHtmlEscapedToken methodsFor: 'resolving' stamp: 'NorbertHartl 9/30/2013 10:38'!valueInContext: anObject	^ (super valueInContext: anObject) asHTMLString ! !!MustacheToken class methodsFor: 'instance creation' stamp: 'NorbertHartl 9/28/2013 22:14'!token: aString 	^ self new		token: aString! !!MustacheToken methodsFor: 'visting' stamp: 'NorbertHartl 9/29/2013 17:31'!accept: aVisitor 	aVisitor visitToken: self! !!MustacheToken methodsFor: 'resolving' stamp: 'NorbertHartl 9/30/2013 10:41'!lookupInContext: anObject	^ self lookup: token inContext: anObject! !!MustacheToken methodsFor: 'accessing' stamp: 'NorbertHartl 9/28/2013 22:03'!token: aString 	token := aString! !!MustacheToken methodsFor: 'resolving' stamp: 'NorbertHartl 9/30/2013 10:46'!valueInContext: anObject	"lookup to token, perfrom value on it in case we have a block and 	finally convert it to string"	^ (self lookupInContext: anObject) 		ifNotNil: [ :object | object value asString ]		ifNil: [ '' ]! !!MustacheVisitor methodsFor: 'accessing' stamp: 'NorbertHartl 10/2/2013 10:38'!partialAt: aString 	| template |	partials ifNil: [ Error signal: 'template has no partials' ].	template := partials at: aString.	template isString ifTrue: [ 		template := MustacheTemplate on: template.		partials at: aString put: template ].	^ template! !!MustacheVisitor methodsFor: 'accessing' stamp: 'NorbertHartl 10/2/2013 10:10'!partials: aDictionary	partials := aDictionary! !!MustacheVisitor methodsFor: 'visiting' stamp: 'NorbertHartl 9/29/2013 16:54'!visit: aMustachePart	aMustachePart accept: self! !!MustacheVisitor methodsFor: 'visiting' stamp: 'NorbertHartl 9/29/2013 16:52'!visitAll: aCollection 	aCollection do: [ :each |		self visit: each ]! !!MustacheVisitor methodsFor: 'visiting' stamp: 'NorbertHartl 9/29/2013 16:51'!visitCompositePart: aCompositePart	self visitAll: aCompositePart parts! !!MustacheVisitor methodsFor: 'visiting' stamp: 'NorbertHartl 9/29/2013 16:56'!visitHtmlEscapedToken: aMustacheHTMLEscapedToken 	! !!MustacheVisitor methodsFor: 'visiting' stamp: 'NorbertHartl 10/2/2013 10:15'!visitPartial: aMustachePartial 	self visit: (self partialAt: aMustachePartial name)! !!MustacheVisitor methodsFor: 'visiting' stamp: 'NorbertHartl 9/29/2013 16:57'!visitSection: aMustacheSection 	self visitCompositePart: aMustacheSection ! !!MustacheVisitor methodsFor: 'visiting' stamp: 'NorbertHartl 9/29/2013 16:55'!visitStringChunk: aMustacheStringChunk 	! !!MustacheVisitor methodsFor: 'visiting' stamp: 'NorbertHartl 9/29/2013 16:50'!visitTemplate: aMustacheTemplate 	self visitCompositePart: aMustacheTemplate ! !!MustacheVisitor methodsFor: 'visiting' stamp: 'NorbertHartl 9/29/2013 16:58'!visitToken: aMustacheToken	self visitHtmlEscapedToken: aMustacheToken  	! !!MustacheWriteVisitor methodsFor: 'accessing' stamp: 'NorbertHartl 9/29/2013 17:32'!addString: aString	aString ifNotEmpty: [ 		strings add: aString ]! !!MustacheWriteVisitor methodsFor: 'accessing' stamp: 'NorbertHartl 9/29/2013 17:05'!context: anObject	context := anObject! !!MustacheWriteVisitor methodsFor: 'initialize-release' stamp: 'NorbertHartl 9/29/2013 17:36'!initialize 	super initialize.	strings := OrderedCollection new: 50.! !!MustacheWriteVisitor methodsFor: 'rendering' stamp: 'NorbertHartl 4/18/2014 19:24'!renderSection: aSection withBlock: aBlock	"generate a render continuation block and hand it over to block	in the template. Return value will be a string that add as a whole	to the local string stack"	self addString: (aBlock value: [ 		self class new 			context: context;			visitCompositePart: aSection;			string ]) ! !!MustacheWriteVisitor methodsFor: 'rendering' stamp: 'NorbertHartl 4/18/2014 19:26'!renderSection: aSection withObject: anObject	aSection 		mustacheDo: [:item|			"if we are in collection context the lookup context			is shifted to the actual element of the collection"			item notNil ifTrue: [  context := item ].			self visitCompositePart: aSection ]		inContext: anObject! !!MustacheWriteVisitor methodsFor: 'accessing' stamp: 'NorbertHartl 4/18/2014 17:56'!string	^ strings		ifNotEmpty: [   			String 				new: ( strings sum: #size ) 				streamContents: [ :stream|					strings do: [ :string| 					stream nextPutAll: string ] ] ]		ifEmpty: [ '' ]! !!MustacheWriteVisitor methodsFor: 'visiting' stamp: 'NorbertHartl 9/30/2013 10:37'!visitHtmlEscapedToken: aToken	self addString: (aToken valueInContext: context)! !!MustacheWriteVisitor methodsFor: 'visiting' stamp: 'NorbertHartl 4/18/2014 19:27'!visitSection: aSection 	 | oldContext value |	oldContext := context.	value := aSection valueInContext: context.	[ value isClosure 		ifTrue: [ self renderSection: aSection withBlock: value ]		ifFalse: [ self renderSection: aSection withObject: value ]]			ensure: [ context := oldContext ]! !!MustacheWriteVisitor methodsFor: 'visiting' stamp: 'NorbertHartl 9/29/2013 17:33'!visitStringChunk: aStringChunk	self addString: aStringChunk string! !!Object methodsFor: '*mustache-core' stamp: 'DamienCassou 6/4/2014 16:34'!mustacheDefaultWhenLookupFails	^ nil! !!Object methodsFor: '*mustache-core' stamp: 'NorbertHartl 10/1/2013 14:36'!mustacheDo: aBlock	self mustacheDo: aBlock inverted: false! !!Object methodsFor: '*mustache-core' stamp: 'NorbertHartl 10/1/2013 14:13'!mustacheDo: aBlock inverted: aBoolean	aBoolean ifFalse:  [ aBlock cull: self ]! !!Object methodsFor: '*mustache-core' stamp: 'NorbertHartl 9/18/2015 18:58'!mustacheLookup: aString	(aString = '.') ifTrue: [ ^ self ].	^ (self respondsTo: aString asSymbol) 		ifTrue: [ self perform: aString asSymbol ]		ifFalse: [  self mustacheLookupComplex: aString ]! !!Object methodsFor: '*mustache-core' stamp: 'NorbertHartl 11/7/2014 10:26'!mustacheLookupComplex: aString	| stream firstPart |	stream := aString readStream.	firstPart := stream upTo: $. .	^ stream atEnd		ifTrue: [ self mustacheDefaultWhenLookupFails ]		ifFalse: [ (self mustacheLookup: firstPart) mustacheLookup: stream upToEnd ]! !!String methodsFor: '*mustache-core' stamp: 'NorbertHartl 10/2/2013 10:44'!asMustacheTemplate	^ MustacheTemplate on: self ! !!String methodsFor: '*mustache-core' stamp: 'NorbertHartl 10/26/2016 15:31'!mustacheDo: aBlock inverted: aBoolean	"as strings are collections we need to prevent it from iterating	over all of the characters. Invoke the block with self instead"	aBoolean		ifTrue: [ self notEmpty mustacheDo: aBlock inverted: aBoolean ]		ifFalse: [ aBlock value: self ]! !!Collection methodsFor: '*mustache-core' stamp: 'NorbertHartl 9/28/2013 00:40'!mustacheDo: aBlock	self do: aBlock! !!Collection methodsFor: '*mustache-core' stamp: 'NorbertHartl 10/1/2013 14:23'!mustacheDo: aBlock inverted: aBoolean	aBoolean		ifTrue: [ self notEmpty mustacheDo: aBlock inverted: aBoolean ]		ifFalse: [ self do: aBlock ]! !!Dictionary methodsFor: '*mustache-core' stamp: 'NorbertHartl 9/18/2015 19:29'!mustacheLookup: aString	(aString = '.') ifTrue: [ ^ self ].	^ self at: aString ifAbsent: [ self mustacheLookupComplex: aString ]! !"Mustache-Core"!!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 4/18/2014 19:30'!testBlockSection	| template result |	template := MustacheTemplate on: '{{#wrapped}} {{name}} is awesome {{/wrapped}}'.	result := template value: { 		'name' -> 'Willy'.		'wrapped' -> [ :render | '<b>',  render value, '</b>' ]  } asDictionary  .	self assert: result = '<b> Willy is awesome </b>'.	! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 4/18/2014 19:28'!testBlockValue	| template result |	template := MustacheTemplate on: 'This is a test for {{ name }}.'.	result := template value: { 'name' -> [ 'blockcontent' ] } asDictionary .	self assert: result = 'This is a test for blockcontent.'.	! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 2/25/2014 16:36'!testChangeDelimiter	| template result |	template := MustacheTemplate on: 'This is a test for {{ name }} {{=<% %>=}} and something that uses <% delimiter %> delimiter. And change it back to <%={{ }}=%>{{back}}.'.	result := template value: { 		'name' -> 'simpletoken' . 		'delimiter' -> 'another' . 		'back' -> 'normal' } asDictionary .	self assert: result = 'This is a test for simpletoken  and something that uses another delimiter. And change it back to normal.'. ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:30'!testComment	| template result |	template := MustacheTemplate on: 'This is a test for {{!! ignore me }}.'.	result := template value: { 'name' -> 'simpletoken' } asDictionary .	self assert: result = 'This is a test for .' 	! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 10/1/2013 14:29'!testContextDo	| called block |	called := 0.	block := [ :el |called := called + 1 ].		false mustacheDo:  block inverted: false.	self assert: called = 0.		called := 0.	true mustacheDo:  block inverted: false.	self assert: called = 1.		called := 0.	nil mustacheDo:  block inverted: false.	self assert: called = 0.		called := 0.	Object new mustacheDo:  block inverted: false.	self assert: called = 1.		called := 0.	#() mustacheDo:  block inverted: false.	self assert: called = 0.		called := 0.	#(1 2 3) mustacheDo:  block inverted: false.	self assert: called = 3.! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 10/1/2013 14:27'!testContextDoInverted	| called block |	called := 0.	block := [ :el |called := called + 1 ].		false mustacheDo:  block inverted: true.	self assert: called = 1.		called := 0.	true mustacheDo:  block inverted: true.	self assert: called = 0.		called := 0.	nil mustacheDo:  block inverted: true.	self assert: called = 1.		called := 0.	Object new mustacheDo:  block inverted: true.	self assert: called = 0.		called := 0.	#() mustacheDo:  block inverted: true.	self assert: called = 1.		called := 0.	#(1 2 3) mustacheDo:  block inverted: true.	self assert: called = 0.! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:31'!testDefaultUnescapedToken	| template result |	template := MustacheTemplate on: 'This is a test for {{{ name }}}.'.	result := template value: { 'name' -> '&' } asDictionary .	self assert: result = 'This is a test for &.'.	! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 4/18/2014 17:57'!testDictionaryInDictionary	| template result |	template := MustacheTemplate on: '{{#person?}} Hi {{name}}!! {{/person?}}' .	result := template 		value: { 'person?' -> 			{ 'name' -> 'Jon' } asDictionary  } asDictionary.	self assert: result = ' Hi Jon!! ' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/18/2015 19:08'!testDotToken	| template result |	template := MustacheTemplate on: '{{ . }}'.	result := template value: #a.	self assert: result = 'a' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/18/2015 19:33'!testDotTokenWithDictionary	| template result |	template := MustacheTemplate on: '{{ . }}'.	result := template value: {		'foo' -> 'bar' } asDictionary.	self assert: result = 'a Dictionary(''foo''-&gt;''bar'' )' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:31'!testHTMLEscapedToken	| template result |	template := MustacheTemplate on: 'This is a test for {{ name }}.'.	result := template value: { 'name' -> '&' } asDictionary .	self assert: result = 'This is a test for &amp;.'.	! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 4/18/2014 18:09'!testHTMLMenuExample	| template result |	template := MustacheTemplate on: '<ul>	{{#entries}}<li class="menuEntry{{#active}} active{{/active}}">{{label}}</li>	{{/entries}}</ul>' .	result := template 		value: { 'entries' -> {   			{ 'label' -> 'first' } asDictionary. 			{ 'label' -> 'second' . 'active' -> true } asDictionary.			{ 'label' -> 'third' } asDictionary } } asDictionary.	self assert: result = '<ul>	<li class="menuEntry">first</li>	<li class="menuEntry active">second</li>	<li class="menuEntry">third</li>	</ul>' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:31'!testInvertedSectionWithEmptyListContext	| template result |	template := MustacheTemplate on: 'list{{^ list }} is {{/ list}}displayed'.	result := template value: { 		'list' -> { }	} asDictionary.	self assert: result = 'list is displayed' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:31'!testInvertedSectionWithFalseContext	| template result |	template := MustacheTemplate on: 'list{{^ list }} is {{/ list}}displayed'.	result := template value: { 		'list' -> false	} asDictionary.	self assert: result = 'list is displayed' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:31'!testInvertedSectionWithNonEmptyListContext	| template result |	template := MustacheTemplate on: 'list{{^ list }} is {{/ list}}displayed'.	result := template value: { 		'list' -> { 1 }	} asDictionary.	self assert: result = 'listdisplayed' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:31'!testInvertedSectionWithTrueContext	| template result |	template := MustacheTemplate on: 'list{{^ list }} is {{/ list}}displayed'.	result := template value: { 		'list' -> false	} asDictionary.	self assert: result = 'list is displayed' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:31'!testMultipleTokens	| template result |	template := MustacheTemplate on: '1 = {{ one }}, 2 = {{ two }}, and so on'.	result := template value: { 'one' -> 1 . 'two' -> 2 } asDictionary .	self assert: result = '1 = 1, 2 = 2, and so on' 	! !!MustacheTests methodsFor: 'tests' stamp: 'DamienCassou 6/4/2014 16:11'!testObject	| template result |	template := MustacheTemplate on: '{{#stream}}Class: {{class}}, Position: {{position}}, Next: {{next}}, Position: {{position}}{{/stream}}' .	result := template 		value: { 'stream' -> 'Hello' readStream } asDictionary.	self assert: result = 'Class: ReadStream, Position: 0, Next: H, Position: 1' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 11/7/2014 10:27'!testObjectNoSection	| template result |	template := MustacheTemplate on: 'Class: {{stream.class}}, Position: {{stream.position}}, Next: {{stream.next}}, Position: {{stream.position}}' .	result := template 		value: { 'stream' -> 'Hello' readStream } asDictionary.	self assert: result = 'Class: ReadStream, Position: 0, Next: H, Position: 1' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 11/7/2014 10:27'!testObjectNoSectionBreakingDemeterLaw	| template result |	template := MustacheTemplate on: '{{stream.class.name.first.lowercase}}' .	result := template 		value: { 'stream' -> 'Hello' readStream } asDictionary.	self assert: result = 'r' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 10/2/2013 10:44'!testPartialAsString	| template result |	template := 'This is a test for {{> partial }} .' asMustacheTemplate.	result := template 		value: { 'name' -> 'partial template' } asDictionary		partials: { 'partial' ->  '{{name}} rendering' } asDictionary.	self assert: result = 'This is a test for partial template rendering .'! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 10/2/2013 10:34'!testPartialListContext	| template result |	template := MustacheTemplate on: 'We can have a lists ({{# list}} [ {{> partial }} ] {{/ list}}) .'.	result := template 		value: { 'list' -> {			{ 'name' -> 'first list' } asDictionary.			{ 'name' -> 'last list' } asDictionary  } } asDictionary		partials: (Dictionary new			at: 'partial' put: (MustacheTemplate on: 'including {{name}} item');			yourself) .	self assert: result = 'We can have a lists ( [ including first list item ]  [ including last list item ] ) .' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 10/2/2013 10:23'!testPartialObjectContext	| template result |	template := MustacheTemplate on: 'This is a test for {{> partial }} .'.	result := template 		value: { 'name' -> 'partial template' } asDictionary		partials: (Dictionary new			at: 'partial' put: (MustacheTemplate on: '{{name}} rendering');			yourself) .	self assert: result = 'This is a test for partial template rendering .'! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/18/2015 19:07'!testSectionWithDotAsToken	| template result |	template := MustacheTemplate on: '{{# list }}{{ . }}{{/ list}}'.	result := template value: { 		'list' -> #( a b c )	} asDictionary.	self assert: result = 'abc' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:31'!testSectionWithEmptyListContext	| template result |	template := MustacheTemplate on: 'list {{# list }}{{  label }} {{/ list}}trailer'.	result := template value: { 		'list' -> {  		}} asDictionary.	self assert: result = 'list trailer' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:31'!testSectionWithFalseContext	| template result |	template := MustacheTemplate on: 'list{{# list }} is {{/ list}}displayed'.	result := template value: { 		'list' -> false	} asDictionary.	self assert: result = 'listdisplayed' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:31'!testSectionWithNonEmptyListContext	| template result |	template := MustacheTemplate on: 'list {{# list }}{{  label }} {{/ list}}trailer'.	result := template value: { 		'list' -> {  			{ 'label' -> 'has 2' } asDictionary.			{ 'label' -> 'elements'} asDictionary 		}} asDictionary.	self assert: result = 'list has 2 elements trailer' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 10/26/2016 15:30'!testSectionWithStringContextUsingDot	| template result |	template := MustacheTemplate on: '{{#list}}before {{.}} after{{/list}}'.	result := template value: { 		'list' -> 'list'	} asDictionary.	self assert: result = 'before list after' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:31'!testSectionWithTrueContext	| template result |	template := MustacheTemplate on: 'list{{# list }} is {{/ list}}displayed'.	result := template value: { 		'list' -> true	} asDictionary.	self assert: result = 'list is displayed' ! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 2/25/2014 16:09'!testSetDelimiter	| template result |	template := MustacheTemplate on: '* {{default_tags}} {{=<% %>=}} * <%erb_style_tags%> <%={{ }}=%> * {{default_tags_again}} *'.	result := template value: (Array with: 'default_tags' -> '1' with: 'erb_style_tags' -> '2' with: 'default_tags_again' -> '3') asDictionary .	self assert: result = '* 1  * 2  * 3 *'.! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:31'!testSingleToken	| template result |	template := MustacheTemplate on: 'This is a test for {{ name }}.'.	result := template value: { 'name' -> 'simpletoken' } asDictionary .	self assert: result = 'This is a test for simpletoken.' 	! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:31'!testSingleTokenBegin	| template result |	template := MustacheTemplate on: '{{ name }} test it is.'.	result := template value: { 'name' -> 'simpletoken' } asDictionary .	self assert: result = 'simpletoken test it is.' 	! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:31'!testSingleTokenEnd	| template result |	template := MustacheTemplate on: 'test for {{ name }}'.	result := template value: { 'name' -> 'simpletoken' } asDictionary .	self assert: result = 'test for simpletoken' 	! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:31'!testSingleTokenNoneExisting	| template result |	template := MustacheTemplate on: 'This is a test for {{ name }}.'.	result := template value: { 'noname' -> 'simpletoken' } asDictionary .	self assert: result = 'This is a test for .' 	! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:31'!testSingleTokenUndefinedValue	| template result |	template := MustacheTemplate on: 'This is a test for {{ name }}.'.	result := template value: { 'name' -> nil } asDictionary .	self assert: result = 'This is a test for .' 	! !!MustacheTests methodsFor: 'tests' stamp: 'DamienCassou 11/27/2013 17:53'!testTemplateFromFile	| file template result |	file := FileSystem memory root / 'file'.	file writeStreamDo: [ :stream | stream nextPutAll: '12{{i}}4' ].	template := file asMustacheTemplate.	result := template value: { 'i' -> '3' } asDictionary .	self assert: result asString equals: '1234' ! !!MustacheTests methodsFor: 'tests' stamp: 'DamienCassou 11/27/2013 17:53'!testTemplateFromFileWithBlock	| file result |	file := FileSystem memory root / 'file'.	file writeStreamDo: [ :stream | stream nextPutAll: '12{{i}}4' ].	file mustacheTemplateDuring: [ :template | result := template value: {('i' -> '3')} asDictionary ].	self assert: result asString equals: '1234'! !!MustacheTests methodsFor: 'tests' stamp: 'NorbertHartl 9/30/2013 10:32'!testUnescapedToken	| template result |	template := MustacheTemplate on: 'This is a test for {{& name }}.'.	result := template value: { 'name' -> '&' } asDictionary .	self assert: result = 'This is a test for &.'.	! !"Mustache-Tests"!!MustacheCommandLineHandler commentStamp: 'YannDubois 4/20/2016 12:29' prior: 0!I am the top level command line handler for Mustache.My keyword is "mustache-pharo".Options:	--data 				a json file	--template			a template for mustache	[--partials]			template files	[--baseDirectory] 		a directory where files can be found!!MustacheCommandLineHandler class methodsFor: 'as yet unclassified' stamp: 'ThibaultArloing 4/25/2016 14:21'!commandName	^'mustache'! !!MustacheCommandLineHandler methodsFor: 'activation' stamp: 'YannDubois 4/20/2016 16:48'!activate	| result template json partials |	self activateHelp		ifTrue: [ ^ self ].	self		optionAt: 'baseDirectory'		ifPresent: [ :dir | baseDirectory := dir asFileReference ].	json := (self baseDirectory resolve: self jsonDataOption) contents.	template := (self baseDirectory resolve: self templateOption) contents.	partials := self partialsToDictionary: self partialsOption.	result := (MustacheTemplate on: template)		value: (Json readFrom: json readStream)		partials: partials.	self stdout nextPutAll: result.	self stdout flush.	self exitSuccess! !!MustacheCommandLineHandler methodsFor: 'activation' stamp: 'ThibaultArloing 4/18/2016 15:50'!baseDirectory	^ baseDirectory ifNil: [ FileSystem workingDirectory ]! !!MustacheCommandLineHandler methodsFor: 'accessing' stamp: 'YannDubois 4/20/2016 12:36'!errorFileNotFound: aString	self help.	self exitFailure: 'The file ', aString, ' was not found'.! !!MustacheCommandLineHandler methodsFor: 'accessing' stamp: 'YannDubois 4/20/2016 12:36'!errorNeed: aString	self help.	self exitFailure: 'You need to define ', aString.! !!MustacheCommandLineHandler methodsFor: 'accessing' stamp: 'ThibaultArloing 4/19/2016 10:47'!jsonDataOption	^ self optionAt: 'data' ifAbsent: [ self errorNeed: 'data' ]! !!MustacheCommandLineHandler methodsFor: 'accessing' stamp: 'YannDubois 4/20/2016 17:14'!partialsOption	^ self optionAt: 'partials' ifAbsent: [ '' ].! !!MustacheCommandLineHandler methodsFor: 'private' stamp: 'YannDubois 4/20/2016 17:17'!partialsToDictionary: aString	| fileNames file partials name |	self flag: #TODO.	"Change this to have partials file name with space"	partials := Dictionary new.	fileNames := aString substrings: ' '.	fileNames		replace: [ :each | 			file := (self baseDirectory resolve: each). 			file exists				ifTrue: [ 					name := (each substrings: '.') first. 					partials add: name -> file contents ]				ifFalse: [ self errorFileNotFound: each ] ].	^ partials ! !!MustacheCommandLineHandler methodsFor: 'accessing' stamp: 'ThibaultArloing 4/19/2016 10:47'!templateOption	^ self optionAt: 'template' ifAbsent: [ self errorNeed: 'template' ]! !"Mustache-Cli"!----QUIT----2016-11-30T00:44:23.065074+01:00 Pillar.image priorSource: 2382023!----QUIT----2016-11-30T00:44:25.876096+01:00 Pillar.image priorSource: 2467018!----QUIT----2016-11-30T00:44:26.462107+01:00 Pillar.image priorSource: 2467099!----QUIT----2016-11-30T00:44:27.083883+01:00 Pillar.image priorSource: 2467180!----QUIT----2016-11-30T00:44:27.758213+01:00 Pillar.image priorSource: 2467261!----QUIT----2016-11-30T00:44:28.341622+01:00 Pillar.image priorSource: 2467342!----QUIT----2016-11-30T07:55:18.218723+01:00 Pharo.image priorSource: 2467423!----QUIT----2016-11-30T07:55:18.741681+01:00 Pharo.image priorSource: 2467504!----QUIT/NOSAVE----2016-12-06T07:09:57.619921+01:00 Pharo.image priorSource: 2467584!----SNAPSHOT----2016-12-06T07:12:29.900829+01:00 PharoPP2.image priorSource: 2467584!!BaselineOfPetitParser2 methodsFor: 'baselines' stamp: ' 12/6/2016 07:12:30'!baseline: spec	<baseline>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'PetitParser2'.		spec repository: 'github://kursjan/petitparser2:master'.		spec 			package: 'PetitParser2';			package: 'PetitParser2-Tests' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-Backtracking' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-Backtracking-Tests' with: [ spec requires: #('PetitParser2-Validation' 'PetitParser2-Tests') ];			package: 'PetitParser2-Validation' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-Validation-Tests' with: [ spec requires: #('PetitParser2-Validation' 'PetitParser2-Tests') ];			package: 'PetitParser2-Benchmarks' with: [ spec requires: #('PetitParser2' 'PetitParser2-Validation') ];			package: 'PetitParser2-Smalltalk' with: [ spec requires: #('PetitParser2' 'PetitParser2-Benchmarks') ];			package: 'PetitParser2-Smalltalk-Tests' with: [ spec requires: #('PetitParser2-Smalltalk' 'PetitParser2-Tests') ];			package: 'PetitParser2-Html' with: [ spec requires: #('PetitParser2' 'PetitParser2-Benchmarks') ];			package: 'PetitParser2-Html-Tests' with: [ spec requires: #('PetitParser2-Html' 'PetitParser2-Tests') ];			package: 'PetitParser2-CSV' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-JSON' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-MSE' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-ManifestMf' with: [spec requires: #('PetitParser2') ].		spec project: 'Glamour' with: [			spec				versionString: #'development';				className: 'ConfigurationOfGlamour';				repository: 'http://www.smalltalkhub.com/mc/Moose/Glamour/main' ].					spec project: 'Roassal2' with: [				spec					versionString: #'development';					className: #ConfigurationOfRoassal2;					repository: 'http://www.smalltalkhub.com/mc/ObjectProfile/Roassal2/main' ].		spec project: 'GToolkit' with: [				spec					className: #ConfigurationOfGToolkit;					versionString: #'development';					repository: 'http://www.smalltalkhub.com/mc/Moose/GToolkit/main' ].		spec 			package: 'PetitParser2-GUI' with: [ spec requires: #('Glamour' 'Roassal2' 'PetitParser2') ];			package: 'PetitParser2-GUI-Tests' with: [ spec requires: #('PetitParser2-GUI') ];			package: 'PetitParser2-Benchmarks-GUI' with: [ spec requires: #('PetitParser2-Benchmarks') ].					spec group: 'PetitParser2-Headless' with: #(												'PetitParser2' 											'PetitParser2-Tests' 											'PetitParser2-Smalltalk' 											'PetitParser2-Smalltalk-Tests' 											'PetitParser2-Html' 											'PetitParser2-Html-Tests' 											'PetitParser2-Validation'											'PetitParser2-Validation-Tests'											'PetitParser2-Benchmarks'											).																	spec group: 'PetitParser2-IDE' with: #( 											'PetitParser2-Headless'											'PetitParser2-GUI').			spec group: 'Tests' with: #(											'PetitParser2-Tests'											'PetitParser2-Smalltalk-Tests' 											'PetitParser2-Html-Tests' 											'PetitParser2-Validation-Tests').	] ! !"BaselineOfPetitParser2"!!PP2RecordingDebuggingStrategy commentStamp: 'JanKurs 11/19/2016 16:53' prior: 0!todo: Refactor to two strategies:- profiling- debugging!!PP2AsyncStream commentStamp: 'JanKurs 11/27/2016 17:17' prior: 0!TODO: Find a better name for this.I represent a stream which is filled by some other input that comes  asynchronously.E.g. keyboard  keyboard source can queue the characters that can be read by parser.!!PP2BufferStream commentStamp: 'JanKurs 9/3/2016 12:08' prior: 0!Suppose very minimal stream with the following interface:- atEnd- nextI can adapt this stream and provide the PP2SStream interface thanks to the buffer.Note: I index everything from 0 and not from 1. The reason being the modulo arithmetics that works better when indexed from 0.!!PP2Context commentStamp: 'JanKurs 9/3/2016 11:50' prior: 0!Expects a PP2Stream interface!!PP2Node commentStamp: 'JanKurs 9/6/2016 13:58' prior: 0!Base class for all the nodes of PP2!!PP2AdaptableNode commentStamp: 'JanKurs 9/6/2016 13:58' prior: 0!Purpose of this node is to refer to a piece of grammar, that changes dynamically, during parsing. The node is essential to run optimization analyses properly. If no optimizations are done, this node is completely useless.!!PP2HtmlHeaderGrammar commentStamp: 'JanKurs 11/28/2016 07:50' prior: 0!I am a parser that can extract an HTML headers from an html file.Run PP2HtmlHeaderGrammar exampleto see, how to extract  the header without downloading the whole file. The example starts a  ZincClient in streaming mode and utilizes PP2 capabilities to work on streams. It reads the stream up until the end of a header or until start of a body.!!PP2NodeVisitor commentStamp: 'JanKurs 9/6/2016 14:04' prior: 0!Defines base interface for PP2Node visitors.!!PP2NoopVisitor commentStamp: 'JanKurs 9/6/2016 14:06' prior: 0!Traverses all PP2Nodes, takes care about recursive sub-structures.!!PP2ContextChangesVisitor commentStamp: 'JanKurs 11/5/2016 19:41' prior: 0!return if a given node does not change a context, pushes, pops, or does some other changes (e.g. push in a loop).!!PP2IsNullableVisitor commentStamp: 'JanKurs 9/30/2016 19:04' prior: 0!I return true, if parser ALWAYS accepts epsilon without a failure, i.e it cannot fail.		- I do not chache the result- I do allow to everride the behaviour by setting the #isNullable  property!!PP2CharacterStream commentStamp: 'JanKurs 11/27/2016 17:36' prior: 0!I am an adapter from stream of bytes (stream instance varaible) to stream of characters. I use encoder (instance variable) to translate these bytes into characters.!!ManifestPetitParser commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PP2InMemoryContext commentStamp: 'JanKurs 10/9/2016 12:39' prior: 0!Optimized version of PP2Context. When input fits into the memory, PP2InMemoryContext can be used, providing slightly better perfomance.!!PP2ReparseException commentStamp: 'JanKurs 10/9/2016 12:36' prior: 0!Raised when reparse fails, for some reason!!PP2ReadKeysExample commentStamp: 'JanKurs 11/28/2016 07:37' prior: 0!I show how to parse a keyboard input stream. The parser is extremely simple, it detect occurences of 'petit' in the input stream and shows a notifiaction.Start with:PP2ReadKeysExample example!!PP2ReadKeysMorph commentStamp: 'JanKurs 10/11/2016 11:29' prior: 0!Open me, try typing and check the transcript. I will be happy when you enter 'petit'.This is a demonstration of PP2AsyncStream and capabilities of PP2 to work on streams that are not completely in memory.!!TPP2AnalysisCache methodsFor: 'hooks' stamp: '12/5/2016 22:12:51'!afterAccept: ctx result: result	ctx node propertyAt: self propertySymbol ifAbsentPut: result! !!TPP2AnalysisCache methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!doPass: node	| children child |	self visit: node.	children := node allNodes.		[child := children detect: [ :e | (e hasProperty: self propertySymbol) not ] 							ifNone: [ nil ] ] whileNotNil: [ 				self visit: child	]! !!TPP2AnalysisCache methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!propertySymbol	self explicitRequirement! !!TPP2Context methodsFor: 'reparsing' stamp: '12/5/2016 22:12:51'!applyChange: change	change updateContext: self.	change updateTokens: self returnValue.	change updateParser: self parser! !!TPP2Context methodsFor: 'debugging' stamp: '12/5/2016 22:12:51'!currentDebugResult	^ self globalAt: #debugResult ifAbsentPut: [ PP2DebugResult new context: self; yourself ]! !!TPP2Context methodsFor: 'debugging' stamp: '12/5/2016 22:12:51'!currentDebugResult: anObject	self globalAt: #debugResult put: anObject ! !!TPP2Context methodsFor: 'debugging' stamp: '12/5/2016 22:12:51'!debugResult	^ self globalAt: #debugResult ifAbsentPut: [ 		self restore: self startMemento.		self parser enableDebug parseWithContext: self.		self currentDebugResult	]! !!TPP2Context methodsFor: 'context' stamp: '12/5/2016 22:12:51'!defaultStack	^ self stackNamed: #defaultStack! !!TPP2Context methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isRecording	^ false! !!TPP2Context methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parsedValue	"to provide some compatibility with PPToken"	^ self returnValue! !!TPP2Context methodsFor: 'requirements' stamp: '12/5/2016 22:12:51'!position	self explicitRequirement! !!TPP2Context methodsFor: 'requirements' stamp: '12/5/2016 22:12:51'!returnValue	self explicitRequirement! !!TPP2Context methodsFor: 'requirements' stamp: '12/5/2016 22:12:51'!returnValue: anObject	self explicitRequirement! !!TPP2Context methodsFor: 'requirements' stamp: '12/5/2016 22:12:51'!setAsStartState	self startMemento: self remember! !!TPP2Context methodsFor: 'context' stamp: '12/5/2016 22:12:51'!stackNamed: identifier	^ self propertyAt: identifier ifAbsentPut: [ PP2Stack new ]! !!TPP2Context methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!start	^ self startMemento position! !!TPP2Context methodsFor: 'requirements' stamp: '12/5/2016 22:12:51'!startMemento	self explicitRequirement! !!TPP2Context methodsFor: 'requirements' stamp: '12/5/2016 22:12:51'!startMemento: contextMemento	self explicitRequirement! !!TPP2Context methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stop	^ self position! !!TPP2Context methodsFor: 'seas' stamp: '12/5/2016 22:12:51'!waterPosition	^ self globalAt: #waterPosition ifAbsent: -1! !!TPP2Context methodsFor: 'seas' stamp: '12/5/2016 22:12:51'!waterPosition: anInteger	self globalAt: #waterPosition put: anInteger! !!TPP2Debuggable methodsFor: 'debugging' stamp: '12/5/2016 22:12:51'!debugResult	self explicitRequirement! !!TPP2Globals methodsFor: 'accessing - globals' stamp: '12/5/2016 22:12:51'!globalAt: aKey	"Answer the global property value associated with aKey."		^ self globalAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!TPP2Globals methodsFor: 'accessing - globals' stamp: '12/5/2016 22:12:51'!globalAt: aKey ifAbsent: aBlock	"Answer the global property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ self globals isNil		ifTrue: [ aBlock value ]		ifFalse: [ self globals at: aKey ifAbsent: aBlock ]! !!TPP2Globals methodsFor: 'accessing - globals' stamp: '12/5/2016 22:12:51'!globalAt: aKey ifAbsentPut: aBlock	"Answer the global property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self globalAt: aKey ifAbsent: [ self globalAt: aKey put: aBlock value ]! !!TPP2Globals methodsFor: 'accessing - globals' stamp: '12/5/2016 22:12:51'!globalAt: aKey put: anObject	"Set the global property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (self globals ifNil: [ self globals: (IdentityDictionary new: 1) ])		at: aKey put: anObject! !!TPP2Globals methodsFor: 'accessing - globals' stamp: '12/5/2016 22:12:51'!globals	self explicitRequirement! !!TPP2Globals methodsFor: 'accessing - globals' stamp: '12/5/2016 22:12:51'!hasGlobal: aKey	"Test if the global property aKey is present."		^ self globals notNil and: [ self globals includesKey: aKey ]! !!TPP2Globals methodsFor: 'accessing - globals' stamp: '12/5/2016 22:12:51'!removeGlobal: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeGlobal: aKey ifAbsent: [ self error: 'Property not found' ]! !!TPP2Globals methodsFor: 'accessing - globals' stamp: '12/5/2016 22:12:51'!removeGlobal: aKey ifAbsent: aBlock	"Remove the global property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	self globals isNil ifTrue: [ ^ aBlock value ].	answer := self globals removeKey: aKey ifAbsent: aBlock.	self globals isEmpty ifTrue: [ self globals: nil ].	^ answer! !!TPP2NullProfiling methodsFor: 'profiling' stamp: '12/5/2016 22:12:51'!cacheHit: context! !!TPP2NullProfiling methodsFor: 'profiling' stamp: '12/5/2016 22:12:51'!invocation! !!TPP2Properties methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!hasProperty: aKey	"Test if the property aKey is present."		^ self properties notNil and: [ self properties includesKey: aKey ]! !!TPP2Properties methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!properties	self explicitRequirement! !!TPP2Properties methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!properties: newProperties	self explicitRequirement! !!TPP2Properties methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!propertiesCopy	self properties isNil ifTrue: [ ^ nil ].	^ self properties collect: #copy! !!TPP2Properties methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!TPP2Properties methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ self properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ self properties at: aKey ifAbsent: aBlock ]! !!TPP2Properties methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!TPP2Properties methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (self properties ifNil: [ self properties: (IdentityDictionary new: 1) ])		at: aKey put: anObject! !!TPP2Properties methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]! !!TPP2Properties methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	self properties isNil ifTrue: [ ^ aBlock value ].	answer := self properties removeKey: aKey ifAbsent: aBlock.	self properties isEmpty ifTrue: [ self properties: nil ].	^ answer! !!TPP2RecordingCache methodsFor: 'recording' stamp: '12/5/2016 22:12:51'!cacheHit: context	self hits: self hits + 1.	context cacheHit.! !!TPP2RecordingCache methodsFor: 'accessing - statistics' stamp: '12/5/2016 22:12:51'!hitRatio	^ self hits / (self invocations max: 1) asFloat! !!TPP2RecordingCache methodsFor: 'recording' stamp: '12/5/2016 22:12:51'!hits	self explicitRequirement! !!TPP2RecordingCache methodsFor: 'recording' stamp: '12/5/2016 22:12:51'!hits: anInteger	self explicitRequirement! !!TPP2RecordingCache methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.	self resetCounters.! !!TPP2RecordingCache methodsFor: 'recording' stamp: '12/5/2016 22:12:51'!invocation	self invocations: self invocations + 1! !!TPP2RecordingCache methodsFor: 'recording' stamp: '12/5/2016 22:12:51'!invocations	self explicitRequirement! !!TPP2RecordingCache methodsFor: 'recording' stamp: '12/5/2016 22:12:51'!invocations: anInteger	self explicitRequirement! !!TPP2RecordingCache methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isRecording	^ true! !!TPP2RecordingCache methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!recording	^ self! !!TPP2RecordingCache methodsFor: 'recording' stamp: '12/5/2016 22:12:51'!resetCounters	self invocations: 0.	self hits: 0.! !!Object methodsFor: '*PetitParser2' stamp: '12/5/2016 22:12:51'!asArray	^ Array with: self! !!Object methodsFor: '*PetitParser2' stamp: '12/5/2016 22:12:51'!asMapArgument	^ Array with: self! !!Object methodsFor: '*PetitParser2' stamp: '12/5/2016 22:12:51'!isPetit2Failure	^ false! !!Object methodsFor: '*PetitParser2' stamp: '12/5/2016 22:12:51'!isPetit2Parser	^ false! !!Object methodsFor: '*PetitParser2' stamp: '12/5/2016 22:12:51'!isPetit2Success	^ true! !!Object methodsFor: '*PetitParser2' stamp: '12/5/2016 22:12:51'!isToken	^ false! !!Object methodsFor: '*PetitParser2' stamp: '12/5/2016 22:12:51'!nodesDo: aBlock	"nothing to do"! !!PP2AbstractStrategy methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!cache	^ PP2Cache on: self! !!PP2AbstractStrategy methodsFor: 'analysis' stamp: '12/5/2016 22:12:51'!includesCache	^ self allChildren anySatisfy: [ :s | s isCache ]! !!PP2AbstractStrategy methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isCache	^ false! !!PP2AbstractStrategy methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isDebugging	^ false! !!PP2AbstractStrategy methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isMemoized	^ false! !!PP2AbstractStrategy methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isRecording	^ false! !!PP2AbstractStrategy methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isReparsable	^ false! !!PP2AbstractStrategy methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!memoize	^ PP2Packrat on: self! !!PP2AbstractStrategy methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!parsingGuard: classification	^ (PP2ParsingGuard on: self)		classification: classification;		retval: (PP2Failure message: 'Early failure, no first set character found')		yourself! !!PP2AbstractStrategy methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!recognizer	^ self! !!PP2AbstractStrategy methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!recording	^ self! !!PP2AbstractStrategy methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!reparsable	^ PP2Reparsable on: self! !!PP2AbstractStrategy methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!trimmingCache	^ PP2TrimmingCache on: self! !!PP2AbstractStrategy methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!withoutDebugStrategy	^ self! !!PP2Action methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| retval |	^ (retval := node child parseOn: aPP2Context) isPetit2Success		ifTrue: [ node block value: retval  ]		ifFalse: [ retval ]! !!PP2Adaptable methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	^ node child parseOn: context! !!PP2And methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| memento retval |	memento := self remember: context.	retval := node child parseOn: context.	self restore: context from: memento. 		^ retval isPetit2Success 		ifTrue: [	retval ]		ifFalse: [ PP2Failure message: retval message context: context  ]! !!PP2AndLiteralObject methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initializeFor: aNode	super initializeFor: aNode.	literal := aNode child literal! !!PP2AndLiteralObject methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	^ (context peek == literal )		ifTrue: [ literal ] 		ifFalse: [ PP2Failure message: 'literal expected' context: context ]! !!PP2AndPredicateObject methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!initializeFor: aNode	super initializeFor: aNode.	predicate := aNode child predicate! !!PP2AndPredicateObject methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!parseOn: context	| peek |	peek := context peek.	^ (peek isNil not and: [ predicate value: peek ])		ifTrue: [ peek ] 		ifFalse: [ PP2Failure message: 'predicate expected' context: context ]! !!PP2Choice methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| retval |		1 to: node children size do: [ :index |		(retval := (node childAt: index) parseOn: aPP2Context) isPetit2Success ifTrue: [ ^ retval ] 	].		^ retval! !!PP2Delegate methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	^ node child parseOn: aPP2Context! !!PP2End methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| memento retval |	memento := aPP2Context remember.	retval := node child parseOn: aPP2Context.		^ aPP2Context atEnd ifTrue: [ 		retval 	] ifFalse: [		| failure | 		failure := PP2Failure message: 'end of input expected' context: aPP2Context. 		aPP2Context restore: memento. 		^ failure	]! !!PP2EndOfInput methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!initializeFor: aPP2Node	super initializeFor: aPP2Node.		failure := PP2Failure message: 'end of input expected'! !!PP2EndOfInput methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	^ context atEnd ifTrue: [ nil ] ifFalse: [ failure context: context ]! !!PP2Epsilon methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	^ nil! !!PP2Failing methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	^ PP2Failure message: 'failure' context: aPP2Context! !!PP2Flatten methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| retval start |	start := aPP2Context position.	^ (retval := node child parseOn: aPP2Context) isPetit2Success ifTrue: [ 		aPP2Context copyFrom: start + 1 to: aPP2Context position	] ifFalse: [ 		retval	]! !!PP2Fragment methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| startMemento returnValue |	startMemento := context remember.	(returnValue := node child parseOn: context) isPetit2Failure ifTrue: [ ^ returnValue ].	^ context copy 		returnValue: returnValue;		startMemento: startMemento;		parser: node;		yourself! !!PP2LiteralObject methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!initializeFor: aPP2Node	super initializeFor: aPP2Node! !!PP2LiteralObject methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| literal |	literal := node literal.		^ (aPP2Context nextFor: literal)		ifTrue: [ literal ]		ifFalse: [ PP2Failure message: node message context: aPP2Context ]		! !!PP2LiteralSequence methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| position |	position := aPP2Context rememberPosition.	(node literal = (aPP2Context next: node size)) ifTrue: [  		^ node literal	].	aPP2Context restorePosition: position.	^ PP2Failure message: 'literal not found' context: aPP2Context! !!PP2Mapping methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| retval |	^ (retval := node child parseOn: aPP2Context) isPetit2Success		ifTrue: [ node block valueWithArguments: retval asMapArgument ]		ifFalse: [ retval ]! !!PP2MappingOfThree methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!parseOn: context	| retval |	^ (retval := node child parseOn: context) isPetit2Success		ifTrue: [ node block value: (retval at: 1) value: (retval at: 2) value: (retval at: 3)  ]		ifFalse: [ retval ]! !!PP2MappingOfTwo methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| retval |	^ (retval := node child parseOn: context) isPetit2Success		ifTrue: [ node block value: (retval at: 1) value: (retval at: 2)  ]		ifFalse: [ retval ]! !!PP2Match methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| retval stackTop memento stack |	memento := self remember: context.	retval := node child parseOn: context.	retval isPetit2Failure ifTrue: [ ^ retval ].	stack := context stackNamed: node stackId.		^ (stack isEmpty not and: [(stackTop :=  stack top) = retval]) ifTrue: [  		retval	] ifFalse: [ 		self restore: context from: memento.		PP2Failure message: ('context stack value: "', stackTop asString, 								   '" does not match ', retval asString)					  context: context	]! !!PP2NewLine methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!initializeFor: aPP2Node	super initializeFor: aPP2Node.	failure := PP2Failure message: 'new line expected'! !!PP2NewLine methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!parseOn: context	context atEnd ifTrue: [ ^ failure ].		(context uncheckedPeek == Character lf) ifTrue: [ 		context shift.		^ String lf	].	(context uncheckedPeek == Character cr) ifTrue: [  		context shift.		(context peek == Character lf) ifTrue: [ 			context shift.			^ String crlf.		].		^ String cr	].	^ failure! !!PP2NonEpsilon methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!parseOn: context	| start memento retval |	memento := self remember: context.	start := context position.	retval := node child parseOn: context.	(retval isPetit2Success and: [ context position = start ]) ifTrue: [ 		self restore: context from: memento.		^ PP2Failure message: 'epsilon parse not allowed' context: context	].	^ retval! !!PP2Not methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| memento retval |	memento := aPP2Context remember.	retval := node child parseOn: aPP2Context.		aPP2Context restore: memento.	^ retval isPetit2Failure 		ifTrue: [ nil ]		ifFalse: [ PP2Failure message: 'Child was not expected to pass' context: aPP2Context  ]! !!PP2NotLiteralObject methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initializeFor: aNode	super initializeFor: aNode.	literal := aNode child literal! !!PP2NotLiteralObject methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	^ (context peek == literal )		ifFalse: [ nil ] 		ifTrue: [ PP2Failure message: 'literal expected' context: context ]! !!PP2NotPredicateObject methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!initializeFor: aNode	super initializeFor: aNode.	predicate := aNode child predicate! !!PP2NotPredicateObject methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!parseOn: context	| peek |	peek := context peek.	^ (peek isNil not and: [ predicate value: peek ])		ifFalse: [ nil ] 		ifTrue: [ PP2Failure message: 'predicate not expected' context: context ]! !!PP2Optional methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| memento retval |	memento := aPP2Context remember.		^ (retval := node child parseOn: aPP2Context) isPetit2Success		ifTrue: [ retval ]		ifFalse: [ aPP2Context restore: memento. nil ]! !!PP2Optional methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!parsingGuard: classification	^ (super parsingGuard: classification)		retval: nil		yourself! !!PP2OptionalLiteralObject methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initializeFor: aPP2Node	super initializeFor: aPP2Node.	character := node child literal! !!PP2OptionalLiteralObject methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	^ (aPP2Context peek == character) ifTrue: [ 		aPP2Context uncheckedNext 	] ifFalse: [  		nil	]! !!PP2Pluggable methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	^ node block value: aPP2Context! !!PP2Pop methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!parseOn: context	| retval |	retval := node child parseOn: context.		retval isPetit2Failure ifFalse: [  		(context stackNamed: node stackId) pop	].	^ retval! !!PP2Plus methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!bypass: aChild to: target	self assert: aChild == child.		child := target! !!PP2Plus methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!child	^ child! !!PP2Plus methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initializeFor: aNode	super initializeFor: aNode.	child := aNode child! !!PP2Plus methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| elements retval |		(retval := child parseOn: aPP2Context) isPetit2Failure ifTrue: [		^ retval	].	elements := OrderedCollection with: retval.		(node max - 1) timesRepeat: [	 	(retval := child parseOn: aPP2Context) isPetit2Failure ifTrue: [ 			^ elements 		].		elements addLast: retval 	].	^ elements! !!PP2Plus methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!recognizer	^ PP2PlusRecognizer on: self node! !!PP2PlusPredicateObject methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initializeFor: aPP2Node	super initializeFor: aPP2Node.		predicate := node child predicate.	failure := PP2Failure message: 'predicate not found'! !!PP2PlusPredicateObject methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| elements |		(aPP2Context atEnd not and: [predicate value: aPP2Context uncheckedPeek]) ifFalse: [ 		^ failure	].	elements := OrderedCollection with: aPP2Context uncheckedNext.		[aPP2Context atEnd not and: [ predicate value: aPP2Context uncheckedPeek ]] whileTrue: [  		elements addLast: aPP2Context uncheckedNext	].	^ elements! !!PP2PlusRecognizer methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| retval |			(retval := node child parseOn: aPP2Context) isPetit2Failure ifTrue: [		^ retval	].	(node max - 1) timesRepeat: [	 	(retval := node child parseOn: aPP2Context) isPetit2Failure ifTrue: [ 			^ self 		].	].! !!PP2PossesiveRepeating methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| memento elements retval |	elements := OrderedCollection new.	memento := context remember.		[ elements size < node min ] whileTrue: [		(retval := node child parseOn: context) isPetit2Failure ifTrue: [			context restore: memento.			^ retval		].		elements addLast: retval 	].		[ elements size < node max ] whileTrue: [	 	(retval := node child parseOn: context) isPetit2Failure ifTrue: [ 			^ elements 		].		elements addLast: retval 	].	^ elements! !!PP2Star methodsFor: 'transformations' stamp: '12/5/2016 22:12:51'!bypass: aChild to: target	self assert: aChild == child.		child := target! !!PP2Star methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!child	^ child! !!PP2Star methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!initializeFor: aNode	super initializeFor: aNode.	child := aNode child! !!PP2Star methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| elements retval |	elements := OrderedCollection new.		node max timesRepeat: [		(retval := child parseOn: aPP2Context) isPetit2Failure ifTrue: [			^ elements		].		elements addLast: retval 	].		^ elements! !!PP2Star methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!parsingGuard: classification	^ (super parsingGuard: classification)		retval: #();		yourself! !!PP2StarPredicateObject methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!initializeFor: aPP2Node	super initializeFor: aPP2Node.	predicate := node child predicate! !!PP2StarPredicateObject methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| collection |	collection := OrderedCollection new.		[aPP2Context atEnd not and: [ predicate value: aPP2Context uncheckedPeek ]] whileTrue: [  		collection addLast: aPP2Context uncheckedNext	].	^ collection	! !!PP2StarPredicateObject methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!recognizer	^ PP2StarPredicateObjectRecognizer on: self node! !!PP2StarPredicateObjectRecognizer methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!initializeFor: aPP2Node	super initializeFor: aPP2Node.	predicate := node child predicate! !!PP2StarPredicateObjectRecognizer methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	[aPP2Context atEnd not and: [ predicate value: aPP2Context uncheckedPeek ]] whileTrue: [  		aPP2Context shift	].	^ #()	! !!PP2PredicateObject methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	^ (aPP2Context atEnd not and: [ node predicate value: aPP2Context uncheckedPeek ])		ifFalse: [ PP2Failure message: node predicateMessage context: aPP2Context  ]		ifTrue: [ aPP2Context uncheckedNext ]! !!PP2PredicateObject methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!recognizer	^ PP2PredicateObjectRecognizer on: self node! !!PP2PredicateObjectRecognizer methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	^ (aPP2Context atEnd not and: [ node predicate value: aPP2Context uncheckedPeek ])		ifFalse: [ PP2Failure message: node predicateMessage context: aPP2Context  ]		ifTrue: [ aPP2Context shift ]! !!PP2PredicateSequence methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| retval position |	position := aPP2Context rememberPosition.	retval := aPP2Context next: node size.		^ (retval isNil not and: [ node predicate value: retval ]) 		ifTrue: [ retval ]		ifFalse: [ 			aPP2Context restorePosition: position.			PP2Failure message: node predicateMessage context: aPP2Context 		]! !!PP2Push methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| retval |	retval := (node child parseOn: context).	retval isPetit2Failure ifTrue: [ ^ retval ].		(context stackNamed: node stackId) push: retval.	^ retval! !!PP2Sea methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!memoize	^ PP2MemoizedSea on: self! !!PP2Sea methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| awr bwr ir memento |	memento := self remember: context.	node reset: context.		(bwr := node beforeWater parseOn: context) isPetit2Failure ifTrue: [		^ bwr	].	(ir := node island parseOn: context) isPetit2Failure ifTrue: [  		self restore: context from: memento.		^ PP2Failure message: 'island not found' context: context	].	(awr := node afterWater parseOn: context) isPetit2Failure ifTrue: [  		self restore: context from: memento.		^  PP2Failure message: 'boundary not found' context: context	].	^ Array with: bwr with: ir with: awr! !!PP2Sequence methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| retval elements memento |	memento := self remember: context.	elements := Array new: node children size.		1 to: elements size do: [ :index |		retval := (node childAt: index) parseOn: context.		retval isPetit2Failure ifTrue: [ 			self restore: context from: memento. 			^ retval		].		elements at: index put: retval 	].		^ elements! !!PP2SequenceOfThree methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initializeFor: aPP2SequenceNode	super initializeFor: aPP2SequenceNode.		firstChild := aPP2SequenceNode firstChild.	secondChild := aPP2SequenceNode secondChild.	thirdChild := aPP2SequenceNode thirdChild.! !!PP2SequenceOfThree methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| retval elements memento |	memento := self remember: context.	(retval := firstChild parseOn: context) isPetit2Failure ifTrue: [ 		^ retval	].	elements := Array new: 3.	elements at: 1 put: retval.		(retval := secondChild parseOn: context) isPetit2Failure ifTrue: [ 		self restore: context from: memento.		^ retval	].	elements at: 2 put: retval.	(retval := thirdChild parseOn: context) isPetit2Failure ifTrue: [ 		self restore: context from: memento.		^ retval	].	elements at: 3 put: retval.		^ elements! !!PP2SequenceOfTwo methodsFor: 'transformation' stamp: '12/5/2016 22:12:51'!bypass: child to: target	firstChild == child ifTrue: [ firstChild := target ].	secondChild == child ifTrue: [ secondChild := target ]! !!PP2SequenceOfTwo methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!firstChild	^ firstChild! !!PP2SequenceOfTwo methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initializeFor: aPP2SequenceNode	super initializeFor: aPP2SequenceNode.		firstChild := aPP2SequenceNode firstChild.	secondChild := aPP2SequenceNode secondChild.! !!PP2SequenceOfTwo methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| retval elements memento |	memento := self remember: context.	(retval := firstChild parseOn: context) isPetit2Failure ifTrue: [ 		^ retval	].	elements := Array new: 2.	elements at: 1 put: retval.		(retval := secondChild parseOn: context) isPetit2Failure ifTrue: [ 		self restore: context from: memento.		^ retval	].	elements at: 2 put: retval.	^ elements! !!PP2SequenceOfTwo methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!recognizer	^ PP2SequenceOfTwoRecognizer on: self node! !!PP2SequenceOfTwo methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!secondChild	^ secondChild! !!PP2SequenceOfTwoRecognizer methodsFor: 'transformation' stamp: '12/5/2016 22:12:51'!bypass: child to: target	firstChild == child ifTrue: [ firstChild := target ].	secondChild == child ifTrue: [ secondChild := target ]! !!PP2SequenceOfTwoRecognizer methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!firstChild	^ firstChild! !!PP2SequenceOfTwoRecognizer methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initializeFor: aPP2SequenceNode	super initializeFor: aPP2SequenceNode.		firstChild := aPP2SequenceNode firstChild.	secondChild := aPP2SequenceNode secondChild.! !!PP2SequenceOfTwoRecognizer methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| retval memento |	memento := self remember: context.	(retval := firstChild parseOn: context) isPetit2Failure ifTrue: [ 		^ retval	].	(retval := secondChild parseOn: context) isPetit2Failure ifTrue: [ 		self restore: context from: memento.		^ retval	].! !!PP2SequenceOfTwoRecognizer methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!secondChild	^ secondChild! !!PP2Strategy class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!new	^ self error: 'Use "#on: aPP2Node" instead'! !!PP2Strategy class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!on: aPP2Node	^ self basicNew initializeFor:	aPP2Node! !!PP2Strategy methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!allChildren	^ OrderedCollection with: self! !!PP2Strategy methodsFor: 'transformation' stamp: '12/5/2016 22:12:51'!bypass: aPP2Node to: target	"nothing to do really"! !!PP2Strategy methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initializeFor: aPP2Node	node := aPP2Node! !!PP2Strategy methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!node	^ node! !!PP2Strategy methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!node: anObject	node := anObject! !!PP2Strategy methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	self subclassResponsibility ! !!PP2Strategy methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!remember: context	^ node memoizationStrategy remember: context! !!PP2Strategy methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restore: context from: memento	node memoizationStrategy restore: context from: memento! !!PP2TokenStrategy methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| start retval |	start := aPP2Context position.	(retval := node child parseOn: aPP2Context) isPetit2Failure ifTrue: [ ^ retval ].	^ aPP2Context newToken: (node tokenClass) from: start! !!PP2Trimming methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	| position retval |	position := aPP2Context position.	node trimmer parseOn: aPP2Context.		(retval := node child parseOn: aPP2Context) isPetit2Failure ifTrue: [ 		aPP2Context restorePosition: position.		^ retval	].		node trimmer parseOn: aPP2Context.	^ retval! !!PP2TrimmingLiteralObjectToken methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!initializeFor: aNode	| token |	super initializeFor: aNode.		token := aNode child.	literal := token childSkipDelegate literal.	failure := PP2Failure message: 'literal expected'! !!PP2TrimmingLiteralObjectToken methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!literal	^ literal! !!PP2TrimmingLiteralObjectToken methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!parseOn: context	| position retval |	position := context rememberPosition.	trimmer parseOn: context.		(context nextFor: literal) ifTrue: [		retval := context newToken: tokenClass from: context position - 1	] ifFalse: [  		context restorePosition: position.		^ failure	].		trimmer parseOn: context.	^ retval! !!PP2TrimmingToken methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!initializeFor: aNode	super initializeFor: aNode.		tokenClass := aNode child tokenClass.	tokenChild := aNode child child.	trimmer := aNode trimmer.! !!PP2TrimmingToken methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| position retval start |	position := context rememberPosition.	trimmer parseOn: context.	start := context position.	(retval := tokenChild parseOn: context) isPetit2Failure ifTrue: [ 		context restorePosition: position.		^ retval	].	retval := context newToken: tokenClass from: start.	trimmer parseOn: context.	^ retval! !!PP2TrimmingToken methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!tokenChild	^ tokenChild! !!PP2TrimmingToken methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!tokenChild: anObject	tokenChild := anObject! !!PP2TrimmingToken methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!tokenClass	^ tokenClass! !!PP2TrimmingToken methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!tokenClass: anObject	tokenClass := anObject! !!PP2TrimmingToken methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!trimmer	^ trimmer! !!PP2TrimmingToken methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!trimmer: anObject	trimmer := anObject! !!PP2Water methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initializeFor: aPP2Node	super initializeFor: aPP2Node! !!PP2Water methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| result contents memento startWaterPosition |	memento := self remember: context.	startWaterPosition := context waterPosition.	contents := OrderedCollection new.		"Recursive Water case"	(context waterPosition = context position) ifTrue: [  ^ '' ].		[		context waterPosition: context position.		(node boundary parseOn: context) isPetit2Failure 	] whileTrue: [  		(result := node waterToken parseOn: context) isPetit2Failure ifTrue: [  			self restore: context from: memento.			context waterPosition: startWaterPosition.			^ PP2Failure message: 'water boundary not found' context: context.		].		contents add: result.	].	context waterPosition: startWaterPosition.	^ contents! !!PP2Wrapping methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	^ node block value: aPP2Context value: [ node child parseOn: aPP2Context ]! !!PP2Cache methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!cache	^ self! !!PP2Cache methodsFor: 'profiling' stamp: '12/5/2016 22:12:51'!cacheHit: context	"profiling not implemented"! !!PP2Cache methodsFor: 'profiling' stamp: '12/5/2016 22:12:51'!invocation	"profiling not implemented"! !!PP2Cache methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isCache	^ true! !!PP2Cache methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| start |	self invocation.	(context position == position) ifTrue: [ 		self cacheHit: context.		context position: endPosition.		^ retval	].	start := context position.	retval := strategy parseOn: context.	position := start.	endPosition := context position.		^ retval! !!PP2Cache methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!reset	position := -1! !!PP2RecordingCache methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!hits	^ hits! !!PP2RecordingCache methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!hits: anInteger	hits := anInteger! !!PP2RecordingCache methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.	self resetCounters.! !!PP2RecordingCache methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!invocations	^ invocations ! !!PP2RecordingCache methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!invocations: anInteger	invocations := anInteger! !!PP2DebuggingStrategy class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!on: aPP2Strategy	^ self new initializeFor: aPP2Strategy! !!PP2DebuggingStrategy methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!cache	strategy := strategy cache! !!PP2DebuggingStrategy methodsFor: 'caching' stamp: '12/5/2016 22:12:51'!cacheIfNeeded: result debugResult: debugResult		(strategy includesCache and: [ (resultCache includesKey: result) and: [ (debugResult allResults size = 1 )]]) ifTrue:[		debugResult children add: (PP2DebugResultLink on: (resultCache at: result))	] ifFalse: [ 		resultCache at: result put: debugResult.	]! !!PP2DebuggingStrategy methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!debug	^ self! !!PP2DebuggingStrategy methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	resultCache := IdentityDictionary new.! !!PP2DebuggingStrategy methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isDebugging	^ true! !!PP2DebuggingStrategy methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| parentDebugResult debugResult result |	parentDebugResult := context currentDebugResult.		debugResult := PP2DebugResult new		parser: self node;		start: context position + 1;		parent: parentDebugResult;		yourself.		parentDebugResult children add: debugResult.			context currentDebugResult: debugResult.	result := strategy parseOn: context.	self cacheIfNeeded: result debugResult: debugResult.	context currentDebugResult: parentDebugResult.		debugResult 		stop: context position;		result: result.		^ result! !!PP2DebuggingStrategy methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!parsingGuard: classification	strategy := strategy parsingGuard: classification! !!PP2DebuggingStrategy methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!recording	^ PP2RecordingDebuggingStrategy on: strategy ! !!PP2DebuggingStrategy methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!reparsable	strategy := strategy reparsable! !!PP2DebuggingStrategy methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!withoutDebugStrategy	^ strategy withoutDebugStrategy! !!PP2RecordingDebuggingStrategy methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isRecording	^ true! !!PP2RecordingDebuggingStrategy methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| result entry |	self node hasName ifTrue: [ context namedInvoked 	] ifFalse: [ context invoked ].	entry := context eventsTrace last.	entry start: context eventsTrace entriesCount.		result := super parseOn: context.		entry stop: context eventsTrace entriesCount.	entry debugResult: context lastDebugResult.	"JK: I don't like this reference from debugResult to entry..."	context lastDebugResult invocationEntry: entry.		^ result! !!PP2RecordingDebuggingStrategy methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!recording	^ self! !!PP2MemoizedSea methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!cache	^ self! !!PP2MemoizedSea methodsFor: 'profiling' stamp: '12/5/2016 22:12:51'!cacheHit: context! !!PP2MemoizedSea methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.	"	Would be nice to call this, but there is some mess in initializations.	This would be called before underlying strategy knows, what is its node :(		self reset	"! !!PP2MemoizedSea methodsFor: 'profiling' stamp: '12/5/2016 22:12:51'!invocation! !!PP2MemoizedSea methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isCache	^ true! !!PP2MemoizedSea methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isMemoized	^ true! !!PP2MemoizedSea methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!memoize	^ self! !!PP2MemoizedSea methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| contextMemento returnValue |	self invocation.	contextMemento := self remember: context.	buffer at: contextMemento ifPresent: [:memento |		self cacheHit: context.		self restore: context from: memento contextMemento.		^ memento returnValue	].	returnValue := strategy parseOn: context.	(context waterPosition == context position) ifFalse: [  		| result |		result := PP2Memento new 			returnValue: returnValue;			contextMemento: (self remember: context);			yourself.		buffer at: contextMemento put: result	].	^ returnValue! !!PP2MemoizedSea methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!recording	^ PP2RecordingMemoizedSea on: strategy! !!PP2MemoizedSea methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!remember: context	^ memoizationStrategy remember: context! !!PP2MemoizedSea methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!reset	self node isContextSensitive ifTrue: [  		memoizationStrategy := PP2CSMemoization new.		buffer := Dictionary new.	] ifFalse: [  		memoizationStrategy := PP2CFMemoization new.		buffer := IdentityDictionary new	]! !!PP2MemoizedSea methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restore: context from: memento	^ memoizationStrategy restore: context from: memento! !!PP2RecordingMemoizedSea methodsFor: 'profiling' stamp: '12/5/2016 22:12:51'!hits	^ hits! !!PP2RecordingMemoizedSea methodsFor: 'profiling' stamp: '12/5/2016 22:12:51'!hits: anInteger	hits := anInteger! !!PP2RecordingMemoizedSea methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.	self resetCounters.! !!PP2RecordingMemoizedSea methodsFor: 'profiling' stamp: '12/5/2016 22:12:51'!invocations	^ invocations! !!PP2RecordingMemoizedSea methodsFor: 'profiling' stamp: '12/5/2016 22:12:51'!invocations: anInteger	invocations := anInteger! !!PP2Packrat methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!buffer	^ buffer! !!PP2Packrat methodsFor: 'profiling' stamp: '12/5/2016 22:12:51'!cacheHit: context! !!PP2Packrat methodsFor: 'profiling' stamp: '12/5/2016 22:12:51'!invocation! !!PP2Packrat methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isCache	^ true! !!PP2Packrat methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isMemoized	^ true! !!PP2Packrat methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!memoize	^ self! !!PP2Packrat methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| contextMemento returnValue result |	self invocation.	contextMemento := self remember: context.	buffer at: contextMemento ifPresent: [:memento |		self cacheHit: context.		self restore: context from: memento contextMemento.		^ memento returnValue	].	returnValue := strategy parseOn: context.	result := PP2Memento new 		returnValue: returnValue;		contextMemento: (self remember: context);		yourself.	buffer at: contextMemento put: result.	^ returnValue! !!PP2Packrat methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!recording	^ PP2RecordingPackrat on: strategy! !!PP2Packrat methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!remember: context	^ memoizationStrategy remember: context! !!PP2Packrat methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!reset	self node isContextSensitive ifTrue: [  		memoizationStrategy := PP2CSMemoization new.		buffer := Dictionary new	] ifFalse: [  		memoizationStrategy := PP2CFMemoization new.		buffer := IdentityDictionary new	]! !!PP2Packrat methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restore: context from: memento	^ memoizationStrategy restore: context from: memento! !!PP2RecordingPackrat methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!hits	^ hits! !!PP2RecordingPackrat methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!hits: anObject	hits := anObject! !!PP2RecordingPackrat methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.	self resetCounters.! !!PP2RecordingPackrat methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!invocations	^ invocations! !!PP2RecordingPackrat methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!invocations: anObject	invocations := anObject! !!PP2ParsingGuard methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!classification	^ classification ! !!PP2ParsingGuard methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!classification: anArray	"I am experimenting with smaller classification, but not 100% sure this improves performance"	classification := (anArray copyFrom: 1 to: 128)! !!PP2ParsingGuard methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| intValue |	context atEnd ifTrue: [ ^ retval ].	intValue := context uncheckedPeek asInteger.	(intValue between: 0 and: 128) ifFalse: [  		^ strategy parseOn: context	].		(classification at: intValue) ifFalse: [ 		^ retval	].	^ strategy parseOn: context! !!PP2ParsingGuard methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!parsingGuard: anArray	self assert: classification = (anArray copyFrom: 1 to: classification size).	^ self! !!PP2ParsingGuard methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!retval	^ retval ! !!PP2ParsingGuard methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!retval: anObject	retval := anObject! !!PP2RecordingStrategy methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| result entry lastDebugResult |	self node hasName ifTrue: [ context namedInvoked 	] ifFalse: [ context invoked ].	entry := context eventsTrace last.	entry start: context eventsTrace entriesCount.		result := strategy parseOn: context.		entry stop: context eventsTrace entriesCount.	(lastDebugResult := context lastDebugResult) isNil ifFalse: [ 		entry debugResult: lastDebugResult.		lastDebugResult invocationEntry: entry.	].	^ result! !!PP2Reparsable methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!buffer	^ buffer! !!PP2Reparsable methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!buffer: anObject	buffer := anObject! !!PP2Reparsable methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!cache	^ self! !!PP2Reparsable methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!displayName	^ super displayName, '#', self identityHash asString! !!PP2Reparsable methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.		self reset! !!PP2Reparsable methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isCache	^ true! !!PP2Reparsable methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isReparsable	^ true! !!PP2Reparsable methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| memento mementoPromise |	Halt if: [ Sensor shiftPressed  ].		mementoPromise := buffer at: context position ifAbsentPut: [ 		PP2MementoPromise new			position: context position;			buffer: buffer;			yourself	].	memento := mementoPromise resolveFor: strategy in: context.	context restore: memento contextMemento.	^ memento returnValue		"		The code might be a bit of magic, because it handles 'reparses':			1) In case of the first parse, a MementoPromise is crated and immediately resolved.			2) In case of a reparse after a change in input, an PP2InputChange puts a mementoPromise 				to the buffer with a limit. If parser during the resolve does not fit the limit, an				exception is raised and reparse fails.	"	! !!PP2Reparsable methodsFor: 'copying' stamp: '12/5/2016 22:12:51'!postCopy	super postCopy.		buffer := buffer copy.! !!PP2Reparsable methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!reparsable	^ self! !!PP2Reparsable methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!reset	buffer := IdentityDictionary new! !!PP2RecordingTrimmingCache methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!hits	^ hits ! !!PP2RecordingTrimmingCache methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!hits: anInteger	hits := anInteger! !!PP2RecordingTrimmingCache methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!invocations	^ invocations ! !!PP2RecordingTrimmingCache methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!invocations: anInteger	invocations := anInteger! !!PP2TrimmingCache methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!cache	"I already cache trimming, no need to add another layer of caches"	^ self! !!PP2TrimmingCache methodsFor: 'profiling' stamp: '12/5/2016 22:12:51'!cacheHit: context! !!PP2TrimmingCache methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initializeFor: aPP2Strategy	super initializeFor: aPP2Strategy.		failure := PP2Failure message: 'no more whitespace'! !!PP2TrimmingCache methodsFor: 'profiling' stamp: '12/5/2016 22:12:51'!invocation! !!PP2TrimmingCache methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isCache	^ true! !!PP2TrimmingCache methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: context	| retval |	self invocation.	(context position == lastTrimming) ifTrue: [ 		self cacheHit: context.		^ failure 	].	retval := strategy parseOn: context.	lastTrimming := context position.	^ retval! !!PP2TrimmingCache methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!reset	lastTrimming := nil! !!PP2TrimmingCache methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!trimmingCache	^ self! !!PP2WrappingStrategy class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!on: aPP2Strategy	^ self new initializeFor: aPP2Strategy! !!PP2WrappingStrategy methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!allChildren	^ (strategy allChildren) 		addFirst: self;		yourself! !!PP2WrappingStrategy methodsFor: 'transformation' stamp: '12/5/2016 22:12:51'!bypass: aChild to: target	strategy bypass: aChild to: target! !!PP2WrappingStrategy methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!changeStrategy: newStrategy	self halt: 'JK: delete?'.	strategy := newStrategy! !!PP2WrappingStrategy methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initializeFor: aPP2Strategy	strategy := aPP2Strategy.		self assert: aPP2Strategy class ~= self class! !!PP2WrappingStrategy methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isCache	^ false! !!PP2WrappingStrategy methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!node	^ strategy node! !!PP2WrappingStrategy methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!node: anObject	^ strategy node: anObject! !!PP2WrappingStrategy methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	^ strategy parseOn: aPP2Context! !!PP2WrappingStrategy methodsFor: 'copying' stamp: '12/5/2016 22:12:51'!postCopy	super postCopy.		strategy := strategy copy.! !!PP2WrappingStrategy methodsFor: 'conversion' stamp: '12/5/2016 22:12:51'!recognizer	strategy := strategy recognizer! !!PP2WrappingStrategy methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!remember: context	^ self node memoizationStrategy remember: context! !!PP2WrappingStrategy methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restore: context from: memento	^ self node memoizationStrategy restore: context from: memento! !!PP2WrappingStrategy methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!strategy	^ strategy! !!PP2WrappingStrategy methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!strategy: newStrategy	strategy := newStrategy! !!PP2AsyncStream methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asPetit2Stream	^ PP2BufferStream on: self! !!PP2AsyncStream methodsFor: 'minimal interface' stamp: '12/5/2016 22:12:51'!atEnd	^ queue isEmpty and: closed! !!PP2AsyncStream methodsFor: 'initialize-release' stamp: '12/5/2016 22:12:51'!close	closed := true.	"I need to queue some character at the end, because next is waiting for an input"	queue addLast: (Character codePoint: 4).! !!PP2AsyncStream methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.		closed := false.	queue := OrderedCollection new.	! !!PP2AsyncStream methodsFor: 'minimal interface' stamp: '12/5/2016 22:12:51'!next	| delay |	delay := Delay forMilliseconds: 50.		[ queue isEmpty] whileTrue: [ delay wait  ].	^  queue removeFirst! !!PP2AsyncStream methodsFor: 'events' stamp: '12/5/2016 22:12:51'!queueChar: aCharacter	closed ifFalse: [  queue addLast: aCharacter ]! !!PP2BufferStream class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!new	"for compatibility reasons"	^ self basicNew		initialize! !!PP2BufferStream class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!on: stream	^ self on: stream bufferSize: 1024! !!PP2BufferStream class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!on: stream bufferSize: bufferSize	^ (self basicNew)		initializeForSize: bufferSize;		stream: stream;		yourself! !!PP2BufferStream methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asPetit2Context	^ PP2Context on: self! !!PP2BufferStream methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asPetit2Stream	^ self! !!PP2BufferStream methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asPetitStream	^ stream asPetitStream! !!PP2BufferStream methodsFor: 'context interface' stamp: '12/5/2016 22:12:51'!atEnd: readPosition	self upToPosition: readPosition.		^ (readPosition >= position) and: [ stream atEnd ]! !!PP2BufferStream methodsFor: 'context interface' stamp: '12/5/2016 22:12:51'!atPosition: readPosition	(readPosition == position) ifTrue: [ 		^ self last.	].	(readPosition > position) ifTrue: [ 		self upToPosition: readPosition.		(readPosition > position) ifTrue: [ SubscriptOutOfBounds signal ].		^ self last	].	"backtrack case"	(position - readPosition >= bufferSize) ifTrue: [ 		SubscriptOutOfBounds signalFor: readPosition.	].	^ buffer at: ((readPosition - 1) % bufferSize) + 1.! !!PP2BufferStream methodsFor: 'accessing - private' stamp: '12/5/2016 22:12:51'!buffer	^ buffer ! !!PP2BufferStream methodsFor: 'accessing - private' stamp: '12/5/2016 22:12:51'!bufferSize	^ bufferSize! !!PP2BufferStream methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!contents	"Not sure, what is the best think to return..."	^ buffer contents copyFrom: 1 to: position! !!PP2BufferStream methodsFor: 'context interface' stamp: '12/5/2016 22:12:51'!copyFrom: start to: stop	"start - end should be in range <0, size)"	| bufferStart bufferStop |		(stop - start >= bufferSize ) ifTrue: [ 		"range bigger than buffer"		SubscriptOutOfBounds signalFor: start.	].	(position - start >= bufferSize) ifTrue: [ 		"buffer not big enough"		SubscriptOutOfBounds signalFor: start.	].	self upToPosition: stop.		(position < stop) ifTrue: [ 		SubscriptOutOfBounds signalFor: stop.	].	bufferStart := ((start - 1) % bufferSize) + 1.	bufferStop := ((stop -1) % bufferSize) + 1.		(bufferStart <= bufferStop) ifTrue: [ 		^ buffer copyFrom: bufferStart to: bufferStop	] ifFalse: [		| retval |		retval := ByteString new: stop - start + 1. 		0 to: stop - start do: [ :index |			retval at: (index + 1) put: (buffer at: ((start - 1 + index) % bufferSize) + 1)		].		^ retval	]! !!PP2BufferStream methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	self initializeForSize: 1024! !!PP2BufferStream methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initializeForSize: size	"nothing to do"	bufferSize := size.	buffer := ByteString new: bufferSize.	position := 0.! !!PP2BufferStream methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isBuffered	^ true! !!PP2BufferStream methodsFor: 'private' stamp: '12/5/2016 22:12:51'!last	^ buffer at: ((position - 1) % bufferSize) + 1! !!PP2BufferStream methodsFor: 'context interface' stamp: '12/5/2016 22:12:51'!newToken: tokenClass from: start to: stop	| collection |	collection := self copyFrom: start to: stop.		^ tokenClass 		on: collection 		start:  1		stop: 	(stop - start + 1)! !!PP2BufferStream methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!printOn: writeStream position: currentPosition	"TODO: show the position as well"	stream contents printOn: writeStream! !!PP2BufferStream methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!reset	! !!PP2BufferStream methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stream: aStream	stream := aStream! !!PP2BufferStream methodsFor: 'private' stamp: '12/5/2016 22:12:51'!uncheckedNext	| bufferIndex |	bufferIndex := (position % bufferSize) + 1.	position := position + 1.		buffer at: bufferIndex put: stream next.	^ buffer at: bufferIndex! !!PP2BufferStream methodsFor: 'private' stamp: '12/5/2016 22:12:51'!upToPosition: readPosition	[position < (readPosition) and: [ stream atEnd not ]] whileTrue: [  		self uncheckedNext	]! !!PP2CcChange methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isContextChange	^ true! !!PP2CcChange methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isNotContextChange	^ true! !!PP2CcChange methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isUnknownChange	^ true! !!PP2CcDoesNotChange methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!isContextChange	^ false! !!PP2CcDoesNotChange methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!isNotContextChange	^ true! !!PP2CcPop methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isContextChange	^ true! !!PP2CcPop methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isContextPop	^ true! !!PP2CcPush methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!isContextChange	^ true! !!PP2CcPush methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!isContextPush	^ true! !!PP2CcResult class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!change	^ PP2CcChange instance! !!PP2CcResult class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!instance	Instance isNil ifTrue: [  		Instance := self new	].	^ Instance! !!PP2CcResult class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!noChange	^ PP2CcDoesNotChange instance! !!PP2CcResult class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!pop	^ PP2CcPop instance! !!PP2CcResult class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!push	^ PP2CcPush instance! !!PP2CcResult methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isContextChange	self subclassResponsibility ! !!PP2CcResult methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isContextPop	^ false! !!PP2CcResult methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isContextPush	^ false! !!PP2CcResult methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isNotContextChange	^ self isContextChange not! !!PP2CcResult methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isUnknownChange	^ false! !!PP2CharSetPredicate class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!any	^ self on: [ :e | true ]! !!PP2CharSetPredicate class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!empty	^ self on: [ :e | false ]! !!PP2CharSetPredicate class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!on: aBlock	^ self basicNew initializeOn: aBlock! !!PP2CharSetPredicate methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asCharSetPredicate	^ self! !!PP2CharSetPredicate methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!classification	^ classification! !!PP2CharSetPredicate methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initializeOn: aBlock	block := aBlock.	classification := Array new: 255.	1 to: classification size do: [ :index |		classification at: index put: (block			value: (Character codePoint: index)) ]! !!PP2CharSetPredicate methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isUnknown	^ false! !!PP2CharSetPredicate methodsFor: 'evaluating' stamp: '12/5/2016 22:12:51'!value: aCharacter	| index |	index := aCharacter asInteger.	index == 0	ifTrue: [ ^ block value: aCharacter ].	index > 255	ifTrue: [ ^ block value: aCharacter ].			^ classification at: index! !!PP2Context class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!on: stream	^ self on: stream position: 0! !!PP2Context class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!on: stream position: position	^ self new 		stream: stream;		position: position;		yourself! !!PP2Context methodsFor: 'reparsing' stamp: '12/5/2016 22:12:51'!adoptString: newString	stream adoptString: newString! !!PP2Context methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asPositionableStream	^ (ReadStream on: stream collection)		position: position;		yourself! !!PP2Context methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asReparsableContext	^ self collection asReparsableContext! !!PP2Context methodsFor: 'stream mimicry' stamp: '12/5/2016 22:12:51'!atEnd	^ stream atEnd: position! !!PP2Context methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!contents	^ stream contents! !!PP2Context methodsFor: 'copying' stamp: '12/5/2016 22:12:51'!copyFrom: start to: end	^ stream copyFrom: start to: end! !!PP2Context methodsFor: 'accessing-globals' stamp: '12/5/2016 22:12:51'!globals	^ globals! !!PP2Context methodsFor: 'accessing-globals' stamp: '12/5/2016 22:12:51'!globals: anObject	^ globals := anObject! !!PP2Context methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize! !!PP2Context methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isPetit2Context	^ true! !!PP2Context methodsFor: 'tokenization' stamp: '12/5/2016 22:12:51'!newToken: tokenClass from: start	^ stream newToken: tokenClass from: start + 1 to: position! !!PP2Context methodsFor: 'stream mimicry' stamp: '12/5/2016 22:12:51'!next	^ (stream atEnd: position) not ifTrue: [ 		position := position + 1.		stream atPosition: position	] ifFalse: [  		nil	]! !!PP2Context methodsFor: 'stream mimicry' stamp: '12/5/2016 22:12:51'!next: size	^ ((stream atEnd: position + size - 1) not) ifTrue: [ 		stream copyFrom: (position + 1) to: (position := position + size)	] ifFalse: [ 		nil	]! !!PP2Context methodsFor: 'stream mimicry' stamp: '12/5/2016 22:12:51'!nextFor: aCharacter	^ (stream atEnd: position) not ifTrue: [ 		position := position + 1.		^ ((stream atPosition: position) == aCharacter )			ifTrue: [ true ]			ifFalse:[ position := position - 1 . false ].	] ifFalse: [  		false	]! !!PP2Context methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parser	^ parser! !!PP2Context methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parser: aPP2Parser	parser := aPP2Parser ! !!PP2Context methodsFor: 'stream mimicry' stamp: '12/5/2016 22:12:51'!peek	^ (stream atEnd: position) not ifTrue: [ 		stream atPosition: position + 1	]! !!PP2Context methodsFor: 'stream mimicry' stamp: '12/5/2016 22:12:51'!peekFor: anObject 	"Answer false and do not move over the next element if it is not equal to 	the argument, anObject, or if the receiver is at the end. Answer true 	and increment the position for accessing elements, if the next element is 	equal to anObject."	| nextObject |	self atEnd ifTrue: [^false].	nextObject := self next.	"peek for matching element"	anObject = nextObject ifTrue: [^true].	"gobble it if found"	position := position - 1.	^false! !!PP2Context methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position	^ position! !!PP2Context methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position: anInteger	position := anInteger! !!PP2Context methodsFor: 'copying' stamp: '12/5/2016 22:12:51'!postCopy	super postCopy.	globals := globals copy.	! !!PP2Context methodsFor: 'printing' stamp: '12/5/2016 22:12:51'!printOn: aStream	super printOn: aStream.	aStream nextPut: $:.	aStream nextPut: $ .	stream printOn: aStream! !!PP2Context methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!properties	^ properties! !!PP2Context methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!properties: newProperties	^ properties := newProperties! !!PP2Context methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!remember	^ PP2ContextMemento new		stream: stream;		position: position;		properties: self propertiesCopy;		yourself.! !!PP2Context methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!rememberPosition	^ position! !!PP2Context methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!reset	globals := nil! !!PP2Context methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restore: contextMemento	position := contextMemento position.	properties := contextMemento propertiesCopy.! !!PP2Context methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restorePosition: anInteger	position := anInteger! !!PP2Context methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!returnValue	^ returnValue! !!PP2Context methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!returnValue: anObject	returnValue := anObject! !!PP2Context methodsFor: 'stream extras' stamp: '12/5/2016 22:12:51'!shift	position := position + 1! !!PP2Context methodsFor: 'requirements' stamp: '12/5/2016 22:12:51'!startMemento	^ startMemento! !!PP2Context methodsFor: 'requirements' stamp: '12/5/2016 22:12:51'!startMemento: anObject	startMemento := anObject! !!PP2Context methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stream	^ stream! !!PP2Context methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stream: aStream	stream := aStream! !!PP2Context methodsFor: 'stream extras' stamp: '12/5/2016 22:12:51'!uncheckedNext	position := position + 1.	^ stream atPosition: position! !!PP2Context methodsFor: 'stream extras' stamp: '12/5/2016 22:12:51'!uncheckedPeek	^ stream atPosition: position + 1! !!PP2Context methodsFor: 'stream mimicry' stamp: '12/5/2016 22:12:51'!upTo: character	| start |	start := position := position + 1.		[ 		(stream atEnd: position) ifTrue: [  			^ stream copyFrom: start to: position			].		(stream atPosition: position) = character			] whileFalse: [ position := position + 1 ].	^ stream copyFrom: start to: position ! !!PP2Context methodsFor: 'stream mimicry' stamp: '12/5/2016 22:12:51'!upToEnd	| start |	start := position.		[ stream atEnd: position ] whileFalse: [ position := position + 1 ].	^ stream copyFrom: start + 1 to: position! !!PP2Context methodsFor: 'evaluating' stamp: '12/5/2016 22:12:51'!value	^ returnValue! !!PP2ContextMemento methodsFor: 'arithmetic' stamp: '12/5/2016 22:12:51'!+ anInteger	^ (self copy)		position: position + anInteger;		yourself! !!PP2ContextMemento methodsFor: 'arithmetic' stamp: '12/5/2016 22:12:51'!- anInteger	^ (self copy)		position: position - anInteger;		yourself! !!PP2ContextMemento methodsFor: 'comparison' stamp: '12/5/2016 22:12:51'!= anotherMemento	self class == anotherMemento class ifFalse: [ ^ false ].		self position == anotherMemento position ifFalse: [ ^ false ].	self stream == anotherMemento stream ifFalse: [ ^ false ].		^ self properties = anotherMemento properties! !!PP2ContextMemento methodsFor: 'comparison' stamp: '12/5/2016 22:12:51'!hash	^ self position hash! !!PP2ContextMemento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position	^ position! !!PP2ContextMemento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position: anObject	position := anObject! !!PP2ContextMemento methodsFor: 'copying' stamp: '12/5/2016 22:12:51'!postCopy	properties := properties copy! !!PP2ContextMemento methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!properties	^ properties! !!PP2ContextMemento methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!properties: newProperties	^ properties := newProperties! !!PP2ContextMemento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stream	^ stream! !!PP2ContextMemento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stream: anObject	stream := anObject! !!PP2DebugResult methodsFor: 'analysis' stamp: '12/5/2016 22:12:51'!allResults	^ allChildren ifNil: [  		| collection |		collection := IdentitySet new.		self allResultsTo: collection.		allChildren := collection		]! !!PP2DebugResult methodsFor: 'analysis' stamp: '12/5/2016 22:12:51'!allResultsTo: set	set add: self.	self children do: [ :child | child allResultsTo: set ].! !!PP2DebugResult methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asEventsMorph	invocationEntry isNil ifTrue: [ ^ Morph new ].		^ (self findContext eventsTrace)		selection: invocationEntry;		eventsMorph! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!children	^ children! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!children: anObject	children := anObject! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!contents	^ self findContextContents! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!context		^ context! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!context: anObject		context := anObject! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!debugResult	^ self! !!PP2DebugResult methodsFor: 'analysis' stamp: '12/5/2016 22:12:51'!events	| ctx |	ctx := self findContext.	(ctx isNil or: [ ctx isRecording not ]) ifTrue: [ ^ #() ].		^ result isPetit2Success ifTrue: [ 		ctx filterFrom: self start to: self stop.	] ifFalse: [ 		ctx filterFrom: self start to: self start + 1.	]! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!findContext		context ifNil: [ ^ parent ifNotNil: [ parent findContext ] ].	^ context! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!findContextContents	^ (self findContext ifNotNil: [ :s | s contents ]) ifNil: [ '' ]! !!PP2DebugResult methodsFor: 'printing' stamp: '12/5/2016 22:12:51'!formattedText	self result isPetit2Failure ifTrue: [ 		^ Text string: self printString attribute: TextColor gray 	].		(self isBiggestChild) ifTrue: [  		^ Text string: self printString attribute: (TextColor new color: Color red muchDarker)	].		^ self printString! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!furthestPosition	^ furthestPosition! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!furthestPosition: anObject	furthestPosition := anObject! !!PP2DebugResult methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!hasEvents	^ eventsTrace isNil not! !!PP2DebugResult methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize 	children := OrderedCollection new! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!invocationEntry	self flag: 'JK: I don''t like the cyclic dependency between debug result and profiling info. Is there a better architecture for this?'.		^ invocationEntry! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!invocationEntry: entry	invocationEntry := entry! !!PP2DebugResult methodsFor: 'printing' stamp: '12/5/2016 22:12:51'!isBiggestChild	parent isNil ifTrue: [ ^ false ].	^ (parent children sort: [ :c1 :c2 | c1 allResults size > c2 allResults size ]) first == self! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parent	^ parent! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parent: anObject	parent := anObject! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parser	^ parser! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parser: anObject	parser := anObject! !!PP2DebugResult methodsFor: 'printing' stamp: '12/5/2016 22:12:51'!printOn: aStream 	self parser ifNil: [ ^ super printOn: aStream ].	aStream 		nextPutAll: self parser displayName;		nextPutAll: '[';		nextPutAll: self parser withoutDebugStrategy displayName;	"first ones are the debugging ones, skip them"		nextPutAll: ']';		nextPutAll: '(';		nextPutAll: self allResults size asString;"		nextPutAll: ':';		nextPutAll: self events size asString;"		nextPutAll: ')';		nextPutAll: ' - ';   		nextPutAll: (self result printStringLimitedTo: 50).! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!result	^ result! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!result: anObject	result := anObject! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!start	^ start! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!start: anObject	start := anObject! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!startEvent	^ startEvent! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!startEvent: anObject	startEvent := anObject! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!startStopInterval	(start isNil or: [stop isNil]) ifTrue: [ ^ 1 to: 0 ].		^ start to: stop ! !!PP2DebugResult methodsFor: 'analysis' stamp: '12/5/2016 22:12:51'!steps	^ self allResults size! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stop	^ stop! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stop: anObject	stop := anObject! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stopEvent	^ stopEvent! !!PP2DebugResult methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stopEvent: anObject	stopEvent := anObject! !!PP2DebugResultLink class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!on: aPP2DebugResult	^ (self new)		reference: aPP2DebugResult;		yourself! !!PP2DebugResultLink methodsFor: 'analysis' stamp: '12/5/2016 22:12:51'!allResults	^ #()! !!PP2DebugResultLink methodsFor: 'analysis' stamp: '12/5/2016 22:12:51'!allResultsTo: aSet	^ aSet! !!PP2DebugResultLink methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asEventsMorph	^ reference asEventsMorph! !!PP2DebugResultLink methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!children	^ Array with: reference ! !!PP2DebugResultLink methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!contents	^ reference contents! !!PP2DebugResultLink methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!debugResult	^ self! !!PP2DebugResultLink methodsFor: 'printing' stamp: '12/5/2016 22:12:51'!formattedText	^ Text string: self printString attribute: (TextColor new color: Color blue muchDarker)! !!PP2DebugResultLink methodsFor: 'printing' stamp: '12/5/2016 22:12:51'!printOn: aStream 	super printOn: aStream.	aStream nextPutAll: ': reference'! !!PP2DebugResultLink methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!reference	^ reference! !!PP2DebugResultLink methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!reference: anObject	reference := anObject! !!PP2DebugResultLink methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!startStopInterval	^ reference startStopInterval! !!PP2EventRecord methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!event	^ event! !!PP2EventRecord methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!event: anObject	event := anObject! !!PP2EventRecord methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isInvocation	^ false! !!PP2EventRecord methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!node	^ strategy node! !!PP2EventRecord methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position	^ position! !!PP2EventRecord methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position: anObject	position := anObject! !!PP2EventRecord methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!strategy	^ strategy! !!PP2EventRecord methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!strategy: anObject	strategy := anObject! !!PP2InvocationRecord methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!debugResult	^ debugResult! !!PP2InvocationRecord methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!debugResult: anObject	debugResult := anObject! !!PP2InvocationRecord methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isInvocation	^ true! !!PP2InvocationRecord methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!start	^ start! !!PP2InvocationRecord methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!start: anObject	start := anObject! !!PP2InvocationRecord methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stop	^ stop! !!PP2InvocationRecord methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stop: anObject	stop := anObject! !!PP2EventsTrace methodsFor: 'adding' stamp: '12/5/2016 22:12:51'!addLast: aPP2ProfilingEvent	entries addLast: aPP2ProfilingEvent ! !!PP2EventsTrace methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!colorForEvent: event	| eventSet |	event == #namedInvoked ifTrue: [ ^ Color green muchDarker ].		colors isNil ifTrue: [ 		eventSet := (entries collect: #event) asIdentitySet asArray.		colors := RTMultiLinearColorForIdentity new objects: eventSet.	].	^ colors 	rtValue: event! !!PP2EventsTrace methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!entries	^ entries! !!PP2EventsTrace methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!entries: aCollection	entries := aCollection! !!PP2EventsTrace methodsFor: 'enumerating' stamp: '12/5/2016 22:12:51'!entriesCollect: aBlock	^ entries collect: aBlock! !!PP2EventsTrace methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!entriesCount	^ entries size! !!PP2EventsTrace methodsFor: 'enumerating' stamp: '12/5/2016 22:12:51'!entriesDo: aBlock	^ entries do: aBlock! !!PP2EventsTrace methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!entryAt: index	^ entries at: index! !!PP2EventsTrace methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!eventsMorph"	^ self eventsMorph: #(#uncheckedNext #uncheckedPeek #peek #next)"	^ self eventsMorph: #(#namedInvoked)! !!PP2EventsTrace methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!eventsMorph: eventArray	| limit width height canvas morph heightIndex highlightStart highlightStop highlightColor |	limit := self limit: eventArray.	width  := (entries collect: #position) max min: 4096.	height := limit min: 65535.	canvas := FormCanvas extent: width @ height.	morph := canvas form asMorph.	heightIndex := 0.	fEntries := OrderedCollection new.		highlightStart := Stack with: SmallInteger maxVal.	highlightStop := Stack with: SmallInteger maxVal.	highlightColor := Color red muchLighter muchLighter.		self interval do: [ :index |		| entry |		entry := entries at: index.		(eventArray isNil or: [eventArray includes: entry event]) ifTrue: [ 			fEntries addLast: entry.			heightIndex := heightIndex + 1.						(entry isInvocation and: [ 			(entry node == self selectionNode) and: [ 			(entry position == self selectionPosition) and: [ 			(entry ~= self selection) ] ] ] ) ifTrue: [  				highlightStart push: entry start.				highlightStop push: entry stop.				highlightColor := highlightColor darker.			].			index > highlightStop top ifTrue: [ 				highlightColor := highlightColor lighter.				highlightStop pop. 				highlightStart pop 			].			(highlightStart top <= index and: [ highlightStop top >= index]) ifTrue: [  				canvas line: 1 @ heightIndex to: width @ heightIndex color: highlightColor			].			(self selectionStart <= index and: [ self selectionStop >= index]) ifTrue: [  				| color |				color := Color yellow muchLighter.				canvas line: 1 @ heightIndex to: width @ heightIndex color: color			].			canvas form 				colorAt: entry position @ heightIndex 				put: (self colorForEvent: entry event).		]	].	morph := canvas form asMorph.	morph on: #mouseMove		send: #mouseDown:with:		to: self.			^ morph! !!PP2EventsTrace methodsFor: 'private' stamp: '12/5/2016 22:12:51'!filterEvents: eventsCollection	fEntries := OrderedCollection new.	self halt: 'obsolete?'.		self interval do: [ :index | | e |		e := self entries at: index.		(eventsCollection isNil or: [ eventsCollection includes: e event]) ifTrue: [			fEntries add: e.		]	].		^ fEntries! !!PP2EventsTrace methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.		entries := OrderedCollection new! !!PP2EventsTrace methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!interval"		(start isNil not and: [stop isNil not]) ifTrue: [ 		^ (start to: stop)	]."	^ 1 to: entries size.! !!PP2EventsTrace methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!last	^ entries last! !!PP2EventsTrace methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!limit: eventsCollection	| limit |		eventsCollection isNil ifTrue: [ ^ entries size ].	limit := 0.			self interval do: [ :index | | e |		e := self entries at: index.		(eventsCollection includes: e event) ifTrue: [			limit := limit + 1		]	].		^ limit! !!PP2EventsTrace methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!mouseDown: anEvent with: aMorph	| location msg entry |	location := anEvent position.	(location  y < fEntries size and: [ location y > 0 ]) ifTrue: [ 		entry := fEntries at: location y.		msg := (entry position asString, ':', entry event, ': ', entry node asString).		aMorph showBalloon: msg.		Transcript cr; show: msg.	]! !!PP2EventsTrace methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!selection	^ selection! !!PP2EventsTrace methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!selection: invocationEntry	selection := invocationEntry! !!PP2EventsTrace methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!selectionNode	^ selection isNil ifFalse: [ selection node ] ifTrue: [ nil  ]! !!PP2EventsTrace methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!selectionPosition	^ selection isNil ifFalse: [ selection position ] ifTrue: [ SmallInteger maxVal  ]! !!PP2EventsTrace methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!selectionStart	^ selection isNil ifFalse: [ selection start ] ifTrue: [ SmallInteger maxVal  ]! !!PP2EventsTrace methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!selectionStop	^ selection isNil ifFalse: [ selection stop ] ifTrue: [ SmallInteger minVal  ]! !!PP2EventsTrace methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!strategies	^ entries collect: #strategy! !!PP2Failure class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!message: aString	^ (self new )		message: aString;		position: 0		! !!PP2Failure class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!message: aString context: aPP2Context	^ self basicNew message: aString position: aPP2Context position! !!PP2Failure methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!context: aPP2Context	self flag: 'TODO FIX: so far use #setContext: as a setter'.	position := aPP2Context position! !!PP2Failure methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!furthestPosition	^ context furthestPosition! !!PP2Failure methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isPetit2Failure	^ true! !!PP2Failure methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isPetit2Success	^ false! !!PP2Failure methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!message	^ message! !!PP2Failure methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!message: anObject	message := anObject! !!PP2Failure methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!message: aString position: anInteger	message := aString.	position := anInteger! !!PP2Failure methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parser	^ context parser! !!PP2Failure methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position	^ position! !!PP2Failure methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position: anObject	position := anObject! !!PP2Failure methodsFor: 'printing' stamp: '12/5/2016 22:12:51'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ': '.	self message printOn: aStream ! !!PP2Failure methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!returnValue	^ self! !!PP2Failure methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!setContext: aPP2Context	context := aPP2Context! !!PP2DeleteCharacter methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!changeAfterRange: highIndex	^ position > (highIndex + 1)! !!PP2DeleteCharacter methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!changeBeforeRange: lowIndex	^ position  < lowIndex! !!PP2DeleteCharacter methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!changeBetween: lowIndex and: highIndex	^ position >= lowIndex and: [ (position - 1) <= highIndex ]! !!PP2DeleteCharacter methodsFor: 'private - updates' stamp: '12/5/2016 22:12:51'!updateBuffer: buffer	| newBuffer|	newBuffer := IdentityDictionary new.		buffer associationsDo: [ :assoc |		| key memento  lowIndex highIndex contextMemento |		key := assoc key.		memento := assoc value.				lowIndex := (assoc key + 1).		highIndex := assoc value furthestPosition.		contextMemento := assoc value contextMemento.		(self changeAfterRange: highIndex) ifTrue: [ newBuffer at: key put: memento ].		(self changeBetween: lowIndex and: highIndex) ifTrue: [ 			newBuffer at: key put: (PP2MementoPromise new				contextMemento: contextMemento - 1;				furthestPosition: highIndex - 1;				buffer: newBuffer;				position: key;				yourself)		].		(self changeBeforeRange: lowIndex) ifTrue: [ 			memento contextMemento: contextMemento - 1.			newBuffer at: key - 1 put: memento 		].	].	^ newBuffer! !!PP2DeleteCharacter methodsFor: 'private - updates' stamp: '12/5/2016 22:12:51'!updateToken: token	(self changeBeforeRange: token start) ifTrue: [ 		token start: token start - 1.		token stop: token stop - 1.		token collection: input	]! !!PP2InputChange class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!on: input at: position	^ self new		position: position;		input: input;		yourself! !!PP2InputChange methodsFor: 'enumerating' stamp: '12/5/2016 22:12:51'!deepSelectTokens: node into: aSet	node isToken ifTrue: [ aSet add: node ].		node nodesDo: [ :child | self deepSelectTokens: child into: aSet	]	! !!PP2InputChange methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!input	^ input! !!PP2InputChange methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!input: anObject	input := anObject! !!PP2InputChange methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position	^ position! !!PP2InputChange methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position: anObject	position := anObject! !!PP2InputChange methodsFor: 'private - updates' stamp: '12/5/2016 22:12:51'!updateBuffer: buffer	self subclassResponsibility! !!PP2InputChange methodsFor: 'updates' stamp: '12/5/2016 22:12:51'!updateContext: context	context adoptString: input! !!PP2InputChange methodsFor: 'updates' stamp: '12/5/2016 22:12:51'!updateParser: node	node ifNil: [ ^ self ].	node allReparsables do: [ :reparsable |		reparsable buffer: (self updateBuffer: reparsable buffer).	]! !!PP2InputChange methodsFor: 'private - updates' stamp: '12/5/2016 22:12:51'!updateToken: token	self subclassResponsibility! !!PP2InputChange methodsFor: 'updates' stamp: '12/5/2016 22:12:51'!updateTokens: node	| set |	"make sure you update every token only once ;-)"	set := IdentitySet new.	self deepSelectTokens: node into: set.		set do: [ :token | self updateToken: token ].	! !!PP2InsertCharacter methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!changeAfterRange: highIndex	^ position > (highIndex + 1)! !!PP2InsertCharacter methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!changeBeforeRange: lowIndex	^ position < lowIndex! !!PP2InsertCharacter methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!changeBetween: lowIndex and: highIndex	^ (position >= lowIndex) and: [ position <= (highIndex + 1) ]! !!PP2InsertCharacter methodsFor: 'private - updates' stamp: '12/5/2016 22:12:51'!updateBuffer: buffer	| newBuffer |	newBuffer := IdentityDictionary new.	buffer associationsDo: [ :assoc |		| key lowIndex highIndex memento contextMemento |		"for some reason, key has indexing from zero"		memento := assoc value.		key := assoc key.		lowIndex := (assoc key + 1).		highIndex := assoc value furthestPosition.		contextMemento := assoc value contextMemento.		(self changeAfterRange: highIndex) ifTrue: [ newBuffer at: key put: memento ].		(self changeBetween: lowIndex and: highIndex) ifTrue: [ 			newBuffer at: key put: (PP2MementoPromise new				contextMemento: contextMemento + 1;				furthestPosition: highIndex +1;				position: key;				buffer: newBuffer;				yourself)		].		(self changeBeforeRange: lowIndex) ifTrue: [ 			memento contextMemento: contextMemento + 1.			newBuffer at: (key + 1) put: memento 		].	].	^ newBuffer! !!PP2InsertCharacter methodsFor: 'private - updates' stamp: '12/5/2016 22:12:51'!updateToken: token	(self changeBeforeRange: token start) ifTrue: [ 		token start: token start + 1.		token stop: token stop + 1.		token collection: input	]! !!PP2Memento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!contextMemento	^ contextMemento! !!PP2Memento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!contextMemento: anObject	contextMemento := anObject! !!PP2Memento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!furthestPosition	^ furthestPosition! !!PP2Memento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!furthestPosition: anObject	furthestPosition := anObject! !!PP2Memento methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isPromise	^ false! !!PP2Memento methodsFor: 'resolving' stamp: '12/5/2016 22:12:51'!resolveFor: parser in: context	^ self! !!PP2Memento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!returnValue	^ returnValue! !!PP2Memento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!returnValue: anObject	returnValue := anObject! !!PP2MementoPromise methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!buffer	^ buffer! !!PP2MementoPromise methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!buffer: anObject	buffer := anObject! !!PP2MementoPromise methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!contextMemento	^ contextMemento! !!PP2MementoPromise methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!contextMemento: anObject	contextMemento := anObject! !!PP2MementoPromise methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!furthestPosition	^ furthestPosition! !!PP2MementoPromise methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!furthestPosition: anObject	furthestPosition := anObject! !!PP2MementoPromise methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isPromise	^ true! !!PP2MementoPromise methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parser	^ parser! !!PP2MementoPromise methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parser: anObject	parser := anObject! !!PP2MementoPromise methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position	^ position! !!PP2MementoPromise methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position: anObject	position := anObject! !!PP2MementoPromise methodsFor: 'resolving' stamp: '12/5/2016 22:12:51'!resolveFor: parser in: context	| memento |	memento := PP2Memento new		returnValue: (parser parseOn: context);		contextMemento: context remember;		furthestPosition: context furthestPosition;		yourself.	(contextMemento isNotNil and: [ memento contextMemento position ~= contextMemento position ]) ifTrue: [ 		PP2ReparseException signal: 'reparse consumed more or less characters than expected'	].			^ buffer at: position put: memento.	! !!PP2CFMemoization methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isContextFree	^ true! !!PP2CFMemoization methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!remember: context	^ context rememberPosition ! !!PP2CFMemoization methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restore: context from: memento	context restorePosition: memento! !!PP2CSMemoization methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isContextFree	^ false! !!PP2CSMemoization methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!remember: context	^ context remember ! !!PP2CSMemoization methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restore: context from: memento	context restore: memento! !!PP2Memoization methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!remember: context	self subclassResponsibility ! !!PP2Memoization methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restore: context from: memento	self subclassResponsibility ! !!PP2PopMemoization methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!remember: context	"TODO JK: make it working with other than default stacks"	^ PP2PopMemento new 		position: context rememberPosition;		stackSize: context defaultStack size;		stackTop: context defaultStack top;		yourself	! !!PP2PopMemoization methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restore: context from: memento	context restorePosition: memento position.	context defaultStack size < memento stackSize ifTrue: [ 			context defaultStack push: memento stackTop.	]! !!PP2PushMemoization methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!remember: context	"TODO JK: make it working with other than default stacks"	^ PP2PushMemento new 		position: context rememberPosition;		stackSize: context defaultStack size;		yourself	! !!PP2PushMemoization methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restore: context from: memento	context restorePosition: memento position.	context defaultStack size > memento stackSize ifTrue: [ 			context defaultStack pop	]! !!PP2AdaptableNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: visitor	^ visitor visitAdaptable: self! !!PP2AdaptableNode methodsFor: 'transforming' stamp: '12/5/2016 22:12:51'!changeChild: newChild	child := newChild! !!PP2AdaptableNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!child	^ child! !!PP2AdaptableNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!children	^ child isNil ifTrue: [ Array new ] ifFalse: [ Array with: child ]! !!PP2AdaptableNode methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isAdaptable	^ true! !!PP2AdaptableNode methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isFirstSetTerminal	^ false! !!PP2AdaptableNode methodsFor: 'transforming' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Delegate on: self! !!PP2AbstractActionNode class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!on: node block: aBlock	^ self new		child: node;		block: aBlock;		yourself! !!PP2AbstractActionNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!block	"Answer the action block of the receiver."	^ block! !!PP2AbstractActionNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!block: anObject	block := anObject! !!PP2AbstractActionNode methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localEquals: anotherNode	(super localEquals: anotherNode) ifFalse: [ ^ false ].		^ (self block printString = anotherNode block printString)! !!PP2AbstractActionNode methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localHash	^ super localHash bitXor: block printString hash! !!PP2AbstractActionNode methodsFor: 'parsing - private' stamp: '12/5/2016 22:12:51'!parseOn: context	^ strategy parseOn: context ! !!PP2ActionNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitAction: self! !!PP2ActionNode methodsFor: 'parsing - private' stamp: '12/5/2016 22:12:51'!parseOld: aPP2Context	| context |	^ (context := child parseWithContext:  aPP2Context) isPetit2Failure		ifFalse: [ context setValue: (block value: context value) ]		ifTrue: [ context ]! !!PP2ActionNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Action on: self! !!PP2MappingNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitMapping: self! !!PP2MappingNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Mapping on: self! !!PP2WrappingNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitWrapping: self! !!PP2WrappingNode methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!doesFunctionalChanges	^ self propertyAt: #functionalChanges! !!PP2WrappingNode methodsFor: 'analysis - first' stamp: '12/5/2016 22:12:51'!firstCharSet	^ self doesFunctionalChanges ifTrue: [ 		PP2UnknownCharSetPredicate instance	] ifFalse: [  		child firstCharSet	]! !!PP2WrappingNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!functionalChanges: aBoolean	self propertyAt: #functionalChanges put: aBoolean! !!PP2WrappingNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.	self functionalChanges: true.! !!PP2WrappingNode methodsFor: 'analysis - first' stamp: '12/5/2016 22:12:51'!isFirstSetTerminal	"lets be conservative here"	self doesFunctionalChanges ifTrue: [  		^ true	].	^ false! !!PP2WrappingNode methodsFor: 'parsing - private' stamp: '12/5/2016 22:12:51'!parseOn: context	^ strategy parseOn: context! !!PP2WrappingNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Wrapping on: self! !!PP2AndNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitAnd: self! !!PP2AndNode methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!and	^ self! !!PP2AndNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2And on: self! !!PP2AdaptableGrammar methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!body	^ PP2AdaptableNode new! !!PP2AdaptableGrammar methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!content	^ element star! !!PP2AdaptableGrammar methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!element	^ head, body! !!PP2AdaptableGrammar methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!head	"I set the body parser dynamically; based on the result of the head"	^ #digit asPParser plus flatten 		==> [ :_number |		body changeChild: (#any asPParser times: _number asNumber) flatten	]! !!PP2AdaptableGrammar methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!start	^ content! !!PP2CompositeNode class methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!ignoredNames	"Answer a collection of instance-variables that should not be automatically initialized with productions, but that are used internal to the composite parser."	^ PP2CompositeNode allInstVarNames! !!PP2CompositeNode class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!new	"Answer a new parser starting at the default start symbol."	^ self newStartingAt: self startSymbol! !!PP2CompositeNode class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!newStartingAt: aSymbol	"Answer a new parser starting at aSymbol."	^ self basicNew		initializeStartingAt: aSymbol;		yourself! !!PP2CompositeNode class methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parse: anObject	^ self parse: anObject startingAt: self startSymbol! !!PP2CompositeNode class methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parse: anObject onError: aBlock	^ self parse: anObject startingAt: self startSymbol onError: aBlock! !!PP2CompositeNode class methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parse: anObject startingAt: aSymbol	^ (self newStartingAt: aSymbol) parse: anObject! !!PP2CompositeNode class methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parse: anObject startingAt: aSymbol onError: aBlock	^ (self newStartingAt: aSymbol) parse: anObject onError: aBlock! !!PP2CompositeNode class methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!startSymbol	"Answer the method that represents the default start symbol."	^ #start! !!PP2CompositeNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: visitor	^ visitor visitComposite: self! !!PP2CompositeNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initializeStartingAt: aSymbol	| parser |	self initialize.	self productionNames keysAndValuesDo: [ :key :value |		self instVarAt: key put: (PP2DelegateNode named: value) 	].	self productionNames keysAndValuesDo: [ :key :value |		parser := self perform: value.		self assert: parser ~= self description: 'you probably forgot to return the parser in "', value, '"'.		(self instVarAt: key) child: parser 	].	child := (self perform: aSymbol)! !!PP2CompositeNode methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isProduction	^ false! !!PP2CompositeNode methodsFor: 'querying' stamp: '12/5/2016 22:12:51'!productionAt: aSymbol	"Answer the production named aSymbol."		^ self productionAt: aSymbol ifAbsent: [ nil ]! !!PP2CompositeNode methodsFor: 'querying' stamp: '12/5/2016 22:12:51'!productionAt: aSymbol ifAbsent: aBlock	"Answer the production named aSymbol, if there is no such production answer the result of evaluating aBlock."		(self class ignoredNames includes: aSymbol asString)		ifTrue: [ ^ aBlock value ].	(self class startSymbol = aSymbol)		ifTrue: [ ^ child ].	^ self instVarAt: (self class allInstVarNames		indexOf: aSymbol asString		ifAbsent: [ ^ aBlock value ])! !!PP2CompositeNode methodsFor: 'querying' stamp: '12/5/2016 22:12:51'!productionNames	"Answer a dictionary of slot indexes and production names."		| productionNames ignoredNames |	productionNames := Dictionary new.	ignoredNames := self class ignoredNames		collect: [ :each | each asSymbol ].	self class allInstVarNames keysAndValuesDo: [ :key :value |		(ignoredNames includes: value asSymbol)			ifFalse: [ productionNames at: key put: value asSymbol ] ].	^ productionNames! !!PP2CompositeNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!start	"Answer the production to start this parser with."		self subclassResponsibility! !!PP2ExpressionGrammar methodsFor: 'grammar' stamp: '12/5/2016 22:12:51'!addition	^ primary, $+ asPParser trim, terms! !!PP2ExpressionGrammar methodsFor: 'grammar' stamp: '12/5/2016 22:12:51'!closeBracket	^ $) asPParser! !!PP2ExpressionGrammar methodsFor: 'grammar' stamp: '12/5/2016 22:12:51'!multiplication	^ primary, $* asPParser trim, terms! !!PP2ExpressionGrammar methodsFor: 'grammar' stamp: '12/5/2016 22:12:51'!number	^ ($- asPParser optional , #digit asPParser plus , ($. asPParser, #digit asPParser plus) optional) flatten! !!PP2ExpressionGrammar methodsFor: 'grammar' stamp: '12/5/2016 22:12:51'!openBracket	^ $( asPParser! !!PP2ExpressionGrammar methodsFor: 'grammar' stamp: '12/5/2016 22:12:51'!parentheses	^ openBracket trim , terms , closeBracket trim! !!PP2ExpressionGrammar methodsFor: 'grammar' stamp: '12/5/2016 22:12:51'!primary	^ number / parentheses! !!PP2ExpressionGrammar methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!start	^ terms end! !!PP2ExpressionGrammar methodsFor: 'grammar' stamp: '12/5/2016 22:12:51'!terms	^ addition / multiplication / primary! !!PP2ExpressionParser methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!number	^ super number ==> #asNumber! !!PP2HtmlHeaderGrammar class methodsFor: 'example' stamp: '12/5/2016 22:12:51'!example	| byteStream stream |	byteStream := ZnClient new 		url: 'http://pharo.org';  		streaming: true;  		get.	stream := PP2CharacterStream on: byteStream encoder: ZnUTF8Encoder new.	^ PP2HtmlHeaderGrammar new optimize parse: stream! !!PP2HtmlHeaderGrammar methodsFor: 'rules' stamp: '12/5/2016 22:12:51'!bodyStart	^ '<body' asPParser! !!PP2HtmlHeaderGrammar methodsFor: 'rules' stamp: '12/5/2016 22:12:51'!header	^ '<head>' asPParser, #any asPParser starLazy, '</head>' asPParser		map: [ :_begin :_content :_end |		(_content inject: (WriteStream on: '') into: [ :stream :char | stream nextPut: char. stream ]) 			contents	]! !!PP2HtmlHeaderGrammar methodsFor: 'rules' stamp: '12/5/2016 22:12:51'!headerStart	^ '<head' asPParser! !!PP2HtmlHeaderGrammar methodsFor: 'rules' stamp: '12/5/2016 22:12:51'!htmlFragment	^ (#any asPParser starLazy: (headerStart / bodyStart)), header ==> #second! !!PP2HtmlHeaderGrammar methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!start	^ htmlFragment! !!PP2CsNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: visitor	self subclassResponsibility ! !!PP2CsNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	self subclassResponsibility ! !!PP2CsNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stackId	^ stackId ifNil: [ #defaultStack ] ifNotNil: [ stackId ]! !!PP2CsNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stackId: id	^ stackId := id! !!PP2MatchNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: visitor	^ visitor visitMatch: self! !!PP2MatchNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Match on: self! !!PP2PopNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: visitor	^ visitor visitPop: self! !!PP2PopNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Pop on: self! !!PP2PushNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: visitor	^ visitor visitPush: self! !!PP2PushNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Push on: self! !!PP2DelegateNode class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!on: node	^ self new child: node! !!PP2DelegateNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitDelegate: self! !!PP2DelegateNode methodsFor: 'transforming' stamp: '12/5/2016 22:12:51'!changeChild: newChild	self assert: child isAdaptable.	child changeChild: newChild.! !!PP2DelegateNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!child	^ child! !!PP2DelegateNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!child: newChild	child := newChild! !!PP2DelegateNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!childSkipDelegate	^ child isJustDelegate ifTrue: [  child child ] ifFalse: [	^ child ]! !!PP2DelegateNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!children	^ Array with: child! !!PP2DelegateNode methodsFor: 'optimizations - caching' stamp: '12/5/2016 22:12:51'!isCacheForbidden	self isJustDelegate ifFalse: [  		^ super isCacheForbidden 	].	^ super isCacheForbidden or: [ self child isCacheForbidden  ]! !!PP2DelegateNode methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isDelegate	self class == PP2DelegateNode ! !!PP2DelegateNode methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isJustDelegate	^ self class == PP2DelegateNode ! !!PP2DelegateNode methodsFor: 'parsing - private' stamp: '12/5/2016 22:12:51'!parseOn: context	^ strategy parseOn: context ! !!PP2DelegateNode methodsFor: 'transforming' stamp: '12/5/2016 22:12:51'!replace: node with: anotherNode	child == node ifTrue: [ child := anotherNode ]! !!PP2DelegateNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Delegate on: self! !!PP2EndNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitEnd: self! !!PP2EndNode methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!end	^ self! !!PP2EndNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2End on: self! !!PP2FlattenNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitFlatten: self! !!PP2FlattenNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Flatten on: self! !!PP2FragmentNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitFragment: self! !!PP2FragmentNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Fragment on: self! !!PP2NonEpsilonNode methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!accept: visitor	^ visitor visitNonEpsilon: self! !!PP2NonEpsilonNode methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2NonEpsilon on: self! !!PP2NotNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitNot: self! !!PP2NotNode methodsFor: 'analysis - first' stamp: '12/5/2016 22:12:51'!firstCharSet	^ PP2UnknownCharSetPredicate instance! !!PP2NotNode methodsFor: 'analysis - first' stamp: '12/5/2016 22:12:51'!isFirstSetTerminal	^ true! !!PP2NotNode methodsFor: 'parsing - private' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	^ strategy parseOn: aPP2Context ! !!PP2NotNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Not on: self! !!PP2OptionalNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitOptional: self! !!PP2OptionalNode methodsFor: 'parsing - private' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	^ strategy parseOn: aPP2Context ! !!PP2OptionalNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Optional on: self! !!PP2PossesiveRepeatingNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitPossesiveRepeating: self! !!PP2PossesiveRepeatingNode methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!hash	^ super hash bitXor: (min hash bitXor: max hash)! !!PP2PossesiveRepeatingNode methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localEquals: anotherNode	(super localEquals: anotherNode) ifFalse: [ ^ false ].		self min = anotherNode min ifFalse: [ ^ false ].	self max = anotherNode max ifFalse: [ ^ false ].	^ true! !!PP2PossesiveRepeatingNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2PossesiveRepeating on: self! !!PP2RepeatingNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitRepeating: self! !!PP2RepeatingNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.	min := 0.	max := SmallInteger maxVal.! !!PP2RepeatingNode methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isRepeating	^ true! !!PP2RepeatingNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!max	^ max! !!PP2RepeatingNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!max: anObject	max := anObject! !!PP2RepeatingNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!min	^ min! !!PP2RepeatingNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!min: anObject	min := anObject! !!PP2TokenNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitToken: self! !!PP2TokenNode methodsFor: 'private' stamp: '12/5/2016 22:12:51'!defaultTokenClass	^ PP2Token! !!PP2TokenNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.	tokenClass := self defaultTokenClass! !!PP2TokenNode methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isToken	^ true! !!PP2TokenNode methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localEquals: anotherNode	(super localEquals: anotherNode) ifFalse: [ ^ false ].	^ self tokenClass == anotherNode tokenClass! !!PP2TokenNode methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localHash	^ super localHash bitXor: tokenClass hash! !!PP2TokenNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2TokenStrategy on: self! !!PP2TokenNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!tokenClass	^ tokenClass! !!PP2TokenNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!tokenClass: anObject	tokenClass := anObject! !!PP2TrimmingNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitTrimming: self! !!PP2TrimmingNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!children	^ Array with: trimmer with: child! !!PP2TrimmingNode methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isTrimming	^ true! !!PP2TrimmingNode methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isTrimmingToken	^ self child isToken! !!PP2TrimmingNode methodsFor: 'parsing - private' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	^ strategy parseOn: aPP2Context ! !!PP2TrimmingNode methodsFor: 'transforming' stamp: '12/5/2016 22:12:51'!replace: node with: anotherNode	node == child ifTrue: [ child := anotherNode ].	node == trimmer ifTrue: [ trimmer := anotherNode ].! !!PP2TrimmingNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Trimming on: self! !!PP2TrimmingNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!trimmer	^ trimmer ! !!PP2TrimmingNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!trimmer: aPP2arser	trimmer := aPP2arser! !!PP2EndOfInputNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitEndOfInput: self! !!PP2EndOfInputNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!firstCharSet	^ PP2CharSetPredicate empty! !!PP2EndOfInputNode methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isEOI	^ true	! !!PP2EndOfInputNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2EndOfInput on: self! !!PP2EpsilonNode class methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!instance	instance isNil ifTrue: [ 		instance := PP2EpsilonNode basicNew initialize	].	instance resetStrategies.	^ instance! !!PP2EpsilonNode class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!new	^ self instance! !!PP2EpsilonNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitEpsilon: self! !!PP2EpsilonNode methodsFor: 'analysis - first' stamp: '12/5/2016 22:12:51'!firstCharSet	^ PP2CharSetPredicate any! !!PP2EpsilonNode methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isEpsilon	^ true! !!PP2EpsilonNode methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!nonEpsilon	^	#failure asPParser! !!PP2EpsilonNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Epsilon on: self! !!PP2FailingNode class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!instance	instance isNil ifTrue: [ 		instance := PP2FailingNode message: 'failing'	].	^ instance! !!PP2FailingNode class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!message: aString	^ self new message: aString! !!PP2FailingNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitFailing: self! !!PP2FailingNode methodsFor: 'analysis' stamp: '12/5/2016 22:12:51'!firstCharSet	^ PP2CharSetPredicate empty! !!PP2FailingNode methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localEquals: anotherNode	(super localEquals: anotherNode) ifFalse: [ ^ false ].		^ self message = anotherNode message! !!PP2FailingNode methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localHash	^ super localHash bitXor: message hash! !!PP2FailingNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!message	^ message! !!PP2FailingNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!message: anObject	message := anObject! !!PP2FailingNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Failing on: self! !!PP2ChoiceNode methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!/ aRule 	^ self copyWith: aRule! !!PP2ChoiceNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitChoice: self! !!PP2ChoiceNode methodsFor: 'parsing - private' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	^ strategy parseOn: aPP2Context ! !!PP2ChoiceNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Choice on: self! !!PP2ListNode class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!with: aParser	^ self withAll: (Array with: aParser)! !!PP2ListNode class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!with: aFirstParser with: aSecondParser	^ self withAll: (Array with: aFirstParser with: aSecondParser)! !!PP2ListNode class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!withAll: aCollection	^ self new		children: aCollection;		yourself! !!PP2ListNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ self subclassResponsibility! !!PP2ListNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!children	^ children! !!PP2ListNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!children: aCollection	^ children := aCollection! !!PP2ListNode methodsFor: 'copying' stamp: '12/5/2016 22:12:51'!copyWith: aParser	^ self species withAll: (children copyWith: aParser)! !!PP2ListNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!firstChild	^ self children at: 1! !!PP2ListNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.	self children: #()! !!PP2ListNode methodsFor: 'copying' stamp: '12/5/2016 22:12:51'!postCopy	super postCopy.	children := children copy! !!PP2ListNode methodsFor: 'transforming' stamp: '12/5/2016 22:12:51'!replace: child with: anotherChild	children keysAndValuesDo: [ :index :e |		e == child ifTrue: [ children at: index put: anotherChild ] 	]! !!PP2ListNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!secondChild	^ self children at: 2! !!PP2ListNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!thirdChild	^ self children at: 3! !!PP2SequenceNode methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!, aRule	^ self copyWith: aRule! !!PP2SequenceNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitSequence: self! !!PP2SequenceNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!children: newChildren	super children: newChildren! !!PP2SequenceNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Sequence on: self! !!PP2LiteralNode class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!on: literal	^ self on: literal message: 'literal ', literal printString, ' expected'! !!PP2LiteralNode class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!on: literal message: message	^ self new		literal: literal;		message: message;		yourself! !!PP2LiteralNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitLiteral: self! !!PP2LiteralNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!literal	^ literal! !!PP2LiteralNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!literal: anObject	literal := anObject! !!PP2LiteralNode methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localEquals: anotherNode	(super localEquals: anotherNode) ifFalse: [ ^ false ].		self literal = anotherNode literal ifFalse: [ ^ false ].	self message = anotherNode message ifFalse: [ ^ false ].		^ true! !!PP2LiteralNode methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localHash	^ super localHash bitXor: (self literal hash bitXor: self message hash)! !!PP2LiteralNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!message	^ message! !!PP2LiteralNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!message: anObject	message := anObject! !!PP2LiteralNode methodsFor: 'printing' stamp: '12/5/2016 22:12:51'!printOn: aStream	aStream nextPut: $'.	aStream nextPutAll: literal asString.	aStream nextPut: $'.		aStream nextPut: $(.	aStream nextPutAll: self displayName.	aStream nextPut: $).		! !!PP2LiteralObjectNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitLiteralObject: self! !!PP2LiteralObjectNode methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PP2PredicateObjectNode on: [ :value | literal sameAs: value ] message: message! !!PP2LiteralObjectNode methodsFor: 'analysis - first' stamp: '12/5/2016 22:12:51'!firstCharSet	^ PP2CharSetPredicate on: [ :e | e = literal ]! !!PP2LiteralObjectNode methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!negate	^ (PP2PredicateObjectNode expect: literal message: message) negate! !!PP2LiteralObjectNode methodsFor: 'parsing - private' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	^ strategy parseOn: aPP2Context ! !!PP2LiteralObjectNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2LiteralObject on: self! !!PP2LiteralSequenceNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitLiteralSequence: self! !!PP2LiteralSequenceNode methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PP2PredicateSequenceNode 		on: [ :value | literal sameAs: value ] 		message: message		size: literal size! !!PP2LiteralSequenceNode methodsFor: 'analysis - first' stamp: '12/5/2016 22:12:51'!firstCharSet	^ (literal = '') ifTrue: [ 		PP2CharSetPredicate any	] ifFalse: [ 		PP2CharSetPredicate on: [ :e | self literal first = e ]	]! !!PP2LiteralSequenceNode methodsFor: 'parsing - private' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	^ strategy parseOn: aPP2Context ! !!PP2LiteralSequenceNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2LiteralSequence  on: self! !!PP2LiteralSequenceNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!size	^ literal size! !!PP2NewLineNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: visitor	^ visitor visitStartOfLine: self! !!PP2NewLineNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!firstCharSet	^ PP2CharSetPredicate on: [ :e | e = Character cr or: [ e = Character lf ] ]! !!PP2NewLineNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2NewLine on: self! !!PP2Node class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!named: aString	^ self new name: aString! !!PP2Node class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!new	"for compatibility reasons with Smalltalk/X"	^ self basicNew 		initialize! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!, anotherParser	^ PP2SequenceNode with: self with: anotherParser! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!/ aParser 	"Answer a new parser that parses the receiver, if the receiver fails try with aParser (ordered-choice)."		^ PP2ChoiceNode with: self with: aParser! !!PP2Node methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!= anotherNode	^ self equals: anotherNode visitedSet: IdentitySet new		"			Note: should not be really overriden by children, try to 				override #equals:, unless you know what you are doing, 				of course :)	"! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!==> aBlock	"Answer a new parser that performs aBlock as action handler on success."	^ PP2ActionNode on: self block: aBlock! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!>==> aBlock	"		Make sure that the block does not perform any functional changes, otherwise all the optimizations break.			Use #>=> if you need to do functional changes.	"	^ (PP2WrappingNode on: self block: aBlock)		functionalChanges: false;		yourself! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!>=> aBlock	"Answer a new parser that performs aBlock as action handler on success."	^ PP2WrappingNode on: self block: aBlock! !!PP2Node methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2ParserVisitor	self subclassResponsibility ! !!PP2Node methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!addParent: value	self parents add: value! !!PP2Node methodsFor: 'optimizations - warnings' stamp: '12/5/2016 22:12:51'!addWarning: warning	self warnings add: warning.		"Transcript crShow: warning"! !!PP2Node methodsFor: 'optimizations - caching' stamp: '12/5/2016 22:12:51'!allCaches	^ self propertyAt: #allCaches ifAbsent: [		self collectCaches	]! !!PP2Node methodsFor: 'enumerating' stamp: '12/5/2016 22:12:51'!allNodes"	^ PP2ChildrenVisitor new visit: self"	"faster version than visitor:"	| result |	result := OrderedCollection new.	self allNodesDo: [ :parser | result addLast: parser ].	^ result! !!PP2Node methodsFor: 'enumerating' stamp: '12/5/2016 22:12:51'!allNodesDo: aBlock	^ self allNodesDo: aBlock seen: IdentitySet new! !!PP2Node methodsFor: 'enumerating' stamp: '12/5/2016 22:12:51'!allNodesDo: aBlock seen: aSet	"		Iterate over all the parse nodes of the receiver, do not visit the ones contained in aSet.	"	(aSet includes: self) ifTrue: [ ^ self ].	aSet add: self.		aBlock value: self.	self children do: [ :each | each allNodesDo: aBlock seen: aSet ]! !!PP2Node methodsFor: 'reparsing' stamp: '12/5/2016 22:12:51'!allReparsables	^ self propertyAt: #allReparsables ifAbsentPut: [		self collectReparsables	]! !!PP2Node methodsFor: 'optimizations - warnings' stamp: '12/5/2016 22:12:51'!allWarnings	| warnings |	warnings := Dictionary new.	self allNodesDo: [ :node | 		node warnings do: [ :w | warnings at: node put: w ]	].	^ warnings! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!and	^ PP2AndNode on: self! !!PP2Node methodsFor: 'reparsing' stamp: '12/5/2016 22:12:51'!applyChange: change	change updateParser: self! !!PP2Node methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asPParser	^ self! !!PP2Node methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!changeStrategy: aPP2Strategy	"		Contrary to the #strategy:, I do not assert the identity equivalence of the node.		This means you can you the same strategy with multiple nodes, as long as the nodes		are equivalent (i.e. nodeOne = node2)	"	self assert: (aPP2Strategy node = self).	strategy := aPP2Strategy! !!PP2Node methodsFor: 'reparsing' stamp: '12/5/2016 22:12:51'!checkPromises	self allReparsables do: [ :reparsable | 		(reparsable buffer values anySatisfy: [ :e | e isPromise ]) ifTrue: [  			PP2ReparseException signal: 'Some of the promises were not resolved'		]	]! !!PP2Node methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!childAt: index	^ self children at: index! !!PP2Node methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!children	^ #()! !!PP2Node methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!childrenEqual: anotherNode visitedSet: visitedSet	"		Invokes the comparison function on all children, while passing the visited		set to avoid infinite loops.	"	self children size = anotherNode children size ifFalse: [ ^ false ].		self children with: anotherNode children do: [ :child :anotherChild |		(child equals: anotherChild visitedSet: visitedSet) ifFalse: [ ^ false ]	].	^ true! !!PP2Node methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!childrenHash: visitedSet	| hash |	hash := '' hash.	self children do: [ :child |		hash := hash bitXor: (child hash: visitedSet)	].	^ hash! !!PP2Node methodsFor: 'optimizations - caching' stamp: '12/5/2016 22:12:51'!collectCaches	| caches |	caches := IdentitySet new. 	self allNodesDo: [ :c | c strategies do: [ :s | s isCache ifTrue: [ caches add: s ] ] ].	^ caches asArray! !!PP2Node methodsFor: 'reparsing' stamp: '12/5/2016 22:12:51'!collectReparsables	| reparsables |	reparsables := IdentitySet new. 	self allNodesDo: [ :c | c strategies do: [ :s | s isReparsable ifTrue: [ reparsables add: s ] ] ].	^ reparsables asArray! !!PP2Node methodsFor: 'analysis - context' stamp: '12/5/2016 22:12:51'!contextChanges	^ self propertyAt: #contextChanges ifAbsent: [  		PP2ContextChangesVisitor new visit: self	]! !!PP2Node methodsFor: 'analysis - context' stamp: '12/5/2016 22:12:51'!contextChanges: aPP2CaResult	self assert: (aPP2CaResult isKindOf: PP2CcResult).	^ self propertyAt: #contextChanges put: aPP2CaResult! !!PP2Node methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!debug: input	^ self 		enableDebug enableRecording 		parse: input withContext: PP2RecordingContext new! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!def: node	"Redefine the receiver as the argument 'node'. This method is useful when defining recursive parsers: instantiate a PP2UnresolvedNode and later redefine it with another one."	^ self becomeForward: (node name: self name)! !!PP2Node methodsFor: 'operators - convenience' stamp: '12/5/2016 22:12:51'!delimitedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated and possibly ended by aParser."		^ (self separatedBy: aParser) , (aParser optional) ==> [ :node |		node second isNil			ifTrue: [ node first ]			ifFalse: [ node first copyWith: node second ] ]! !!PP2Node methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!deoptimize	self isOptimized ifFalse: [ ^ self ].	self allNodesDo: [ :node | node resetStrategies ].	self unsetOptimized.! !!PP2Node methodsFor: 'copying' stamp: '12/5/2016 22:12:51'!duplicate	^ self transform: [ :node | node copy ]! !!PP2Node methodsFor: 'debugging' stamp: '12/5/2016 22:12:51'!enableDebug	self allNodesDo: [ :child | child strategy: child strategy debug ]! !!PP2Node methodsFor: 'debugging' stamp: '12/5/2016 22:12:51'!enableRecording	| parent |	self allNodesDo: [ :node | 		parent := node.		node strategies do: [ :s | 			parent := self switchToRecording: s parent: parent.		]	].	"The caches has been changed to their recording equivalents, the info needs to be updated"	self refreshCaches.! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!end	^ PP2EndNode on: self! !!PP2Node methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!equals: anotherNode visitedSet: visitedSet	self == anotherNode ifTrue: [ ^ true ].		"		Manages visited set in order to avoid inifinite loops, I don't see much reasons to		override this method.	"	(visitedSet includes: self) ifTrue: [ ^ true ].	(visitedSet add: self).	(self localEquals: anotherNode) ifFalse: [ ^ false ].		(self childrenEqual: anotherNode visitedSet: visitedSet) ifFalse: [ ^ false ].		^ true! !!PP2Node methodsFor: 'analysis - first' stamp: '12/5/2016 22:12:51'!firstProductionSet	^ self propertyAt: #firstProductionSet ifAbsent: [		PP2FirstSetVisitor productionSet visit: self	]! !!PP2Node methodsFor: 'analysis - first' stamp: '12/5/2016 22:12:51'!firstSeasOrTerminalsSet	^ self propertyAt: #firstSeasOrTerminals ifAbsent: [		PP2FirstSetVisitor seasOrTerminalsSet visit: self	]! !!PP2Node methodsFor: 'analysis - first' stamp: '12/5/2016 22:12:51'!firstSet	^ self propertyAt: #firstSet ifAbsent: [		PP2FirstSetVisitor firstSet visit: self	]! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!flatten	^ PP2FlattenNode on: self! !!PP2Node methodsFor: 'optimizations - caching' stamp: '12/5/2016 22:12:51'!forbidCache	^ self propertyAt: #cacheAllowed put: false! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!fragment	^ PP2FragmentNode on: self! !!PP2Node methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!hasName	^ self name isNil not! !!PP2Node methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!hash	^ self hash: IdentitySet new! !!PP2Node methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!hash: visitedSet	"		Manages visited set in order to avoid inifinite loops, I don't see much reasons to		override this method.	"	(visitedSet includes: self) ifTrue: [ ^ '' hash ].	(visitedSet add: self).	^ self localHash bitXor: (self childrenHash: visitedSet)! !!PP2Node methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	self resetStrategies! !!PP2Node methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isAdaptable	^ false! !!PP2Node methodsFor: 'optimizations - caching' stamp: '12/5/2016 22:12:51'!isCacheForbidden	(self hasProperty: #cacheAllowed) ifTrue: [ 		^ (self propertyAt: #cacheAllowed) not	].	^ false! !!PP2Node methodsFor: 'analysis - context' stamp: '12/5/2016 22:12:51'!isContextFree	^ self isContextSensitive not! !!PP2Node methodsFor: 'analysis - context' stamp: '12/5/2016 22:12:51'!isContextSensitive	^ self propertyAt: #isContextSensitive ifAbsent: [  		PP2ContextSensitivityVisitor new visit: self	]! !!PP2Node methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isDebugging	^ self strategies anySatisfy: [ :s | s isDebugging ]! !!PP2Node methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isEOI	^ false! !!PP2Node methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isEpsilon	^ false! !!PP2Node methodsFor: 'analysis - first' stamp: '12/5/2016 22:12:51'!isFirstSetTerminal	^ self isTerminal! !!PP2Node methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isJustDelegate	^ false! !!PP2Node methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isMemoized	^ self strategies anySatisfy: [ :s | s isMemoized ]! !!PP2Node methodsFor: 'analysis - abstract simulation' stamp: '12/5/2016 22:12:51'!isNullable	"		I return true, if parser ALWAYS can accept epsilon and I NEVER fail.				Use #acceptsEpsilon if it can accept epsilon, but it can fail as well.	"	^ self propertyAt: #isNullable ifAbsent: [ 		PP2IsNullableVisitor new visit: self	]! !!PP2Node methodsFor: 'analysis - abstract simulation' stamp: '12/5/2016 22:12:51'!isNullable: aBoolean	self propertyAt: #isNullable put: aBoolean! !!PP2Node methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!isOptimized	^ self propertyAt: #optimized ifAbsent: false! !!PP2Node methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isPetit2Parser	^ true! !!PP2Node methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isProduction	^ self name isNotNil! !!PP2Node methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isRepeating	^ false! !!PP2Node methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isSea	^ false! !!PP2Node methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isTerminal	^ self children isEmpty! !!PP2Node methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isToken	^ false! !!PP2Node methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isTrimming	^ false! !!PP2Node methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isTrimmingToken	^ false! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!islandInSea	^ self sea ==> #second! !!PP2Node methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localEquals: anotherNode	"		This method is supposed to be overriden by children	"	self == anotherNode ifTrue: [ ^ true ].	self class == anotherNode class ifFalse: [ ^ false ].		"		JK: properties? Most probably not, they can contain first/follow etc.		Cherrypick manually the ones you care about.	"	self name = anotherNode name ifFalse: [ ^ false ].	"JK: strategy? Probably not"	^ true! !!PP2Node methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localHash	"		This method is supposed to be overriden by children	"	^ self class hash bitXor: self name hash! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!map: block	^ PP2MappingNode on: self block: block! !!PP2Node methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!markNoRecognizer	((self hasProperty: #recognizer) and: [ self propertyAt: #recognizer ]) ifTrue: [  		self warnShouldNotBeShared. 	].	self propertyAt: #recognizer put: false! !!PP2Node methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!markRecognizer	((self hasProperty: #recognizer) and: [ (self propertyAt: #recognizer) not ]) ifTrue: [  		self warnShouldNotBeShared. 	].	self propertyAt: #recognizer ifAbsentPut: true! !!PP2Node methodsFor: 'operators - context' stamp: '12/5/2016 22:12:51'!match	^ PP2MatchNode on: self! !!PP2Node methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!matches: anObject	"Answer if anObject can be parsed by the receiver."		^ (self parseContext: anObject) isPetit2Failure not! !!PP2Node methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!memoizationStrategy	^ memoizationStrategy! !!PP2Node methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!memoizationStrategy: anObject	memoizationStrategy := anObject! !!PP2Node methodsFor: 'optimizations - caching' stamp: '12/5/2016 22:12:51'!memoize	self propertyAt: #memoize put: true! !!PP2Node methodsFor: 'operators - repeating' stamp: '12/5/2016 22:12:51'!min: aMinInteger max: aMaxInteger	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times."		^ self star 		min: aMinInteger; 		max: aMaxInteger;		yourself! !!PP2Node methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!name	"Answer the production name of the receiver."		^ self propertyAt: #name ifAbsent: [ nil ]! !!PP2Node methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!name: aString	self propertyAt: #name put: aString! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!negate	"Answer a new parser consumes any input token but the receiver."		^ self not , #any asPParser ==> #second! !!PP2Node methodsFor: 'analysis - next' stamp: '12/5/2016 22:12:51'!nextSetIn: root	^ root nextSets at: self! !!PP2Node methodsFor: 'analysis - next' stamp: '12/5/2016 22:12:51'!nextSets	^ self propertyAt: #nextSets ifAbsent: [  		(PP2NextSetsVisitor new )			visit: self;			nextSets.	]! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!nonEpsilon	^ PP2NonEpsilonNode on: self! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!not	^ PP2NotNode on: self! !!PP2Node methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!optimize	self isOptimized ifTrue: [ ^ self ].		PP2SeaOptimizationVisitor new doPass: self.		PP2SpecializingVisitor new doPass: self.	PP2ParentAnalysisVisitor new doPass: self.	PP2RecognizerVisitor new doPass: self.	PP2IsNullableCache new doPass: self.	PP2FirstSetCache new doPass: self.	 "		Should be called before CommonPrefix. Both do caching, but trimming is tailored to the		whitespace handling in PP2 and has more suitable cache.	"	PP2TrimmingCacheVisitor new doPass: self.	"Use packrat parsing"	PP2PackratVisitor new doPass: self.	"Cache the intermediate results for the Guard and Common Prefix visitors"	PP2AllNodesCache new doPass: self.	PP2FirstProductionSetCache new doPass: self.	PP2CommonPrefixVisitor new doPass: self.		PP2GuardVisitor new doPass: self.		PP2BypassVisitor new doPass: self.		PP2ReparsableVisitor new doPass: self.		"Inject CF memoizations when possible"	PP2ContextChangesCache new doPass: self.	PP2ContextSensitivityCache new doPass: self.	PP2ContextMemoizationVisitor new doPass: self.		self propertyAt: #allCaches put: self collectCaches.	self setOptimized.! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!optional	^ PP2OptionalNode on: self! !!PP2Node methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!parent: value	self parents add: value! !!PP2Node methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!parents	^ self propertyAt: #parents ifAbsentPut: [ OrderedCollection new ]! !!PP2Node methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parse: input	^ (self parseContext: input) returnValue! !!PP2Node methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parse: anObject onError: aBlock	"Parse anObject with the receiving parser and answer the parse-result or answer the result of evaluating aBlock. Depending on the number of arguments of the block it is simply evaluated, evaluated with the failure object, or evaluated with the error message and position."		| result |	result := self parse: anObject.	result isPetit2Success ifTrue: [ ^ result ].		(aBlock numArgs = 0) ifTrue: [ ^ aBlock value ].	(aBlock numArgs = 1) ifTrue: [ ^ aBlock value: result ].	^ aBlock value: result message value: result position! !!PP2Node methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parse: input withContext: startContext	^ self parseAdaptable: input withContext: startContext! !!PP2Node methodsFor: 'parsing - adaptable' stamp: '12/5/2016 22:12:51'!parseAdaptable: input	^ self parseAdaptableWithContext: input asPetit2Stream asPetit2Context! !!PP2Node methodsFor: 'parsing - adaptable' stamp: '12/5/2016 22:12:51'!parseAdaptable: input withContext: context	context stream: input asPetit2Stream.	context position: 0.	context parser: self.	^ self parseAdaptableWithContext: context	! !!PP2Node methodsFor: 'parsing - adaptable' stamp: '12/5/2016 22:12:51'!parseAdaptableWithContext: context	| returnValue |	context parser: self.	self resetCaches.		context startMemento: context remember.	returnValue := self parseOn: context.	^ returnValue isPetit2Success ifTrue: [ 		context returnValue: returnValue 	] ifFalse: [ 		returnValue 			setContext: context;			yourself 	]! !!PP2Node methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseContext: input	^ self parseAdaptable: input! !!PP2Node methodsFor: 'parsing - interpretation' stamp: '12/5/2016 22:12:51'!parseInterpreted: input	^ self parseInterpreted: input withContext: PP2Context new.! !!PP2Node methodsFor: 'parsing - interpretation' stamp: '12/5/2016 22:12:51'!parseInterpreted: input withContext: startContext	^ (PP2Interpret on: self) parse: input withContext: startContext! !!PP2Node methodsFor: 'parsing - adaptable' stamp: '12/5/2016 22:12:51'!parseOn: context	^ strategy parseOn: context ! !!PP2Node methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseWithContext: startContext	^ self parseAdaptableWithContext: startContext! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!plus	^ (PP2PossesiveRepeatingNode on: self)		min: 1;		yourself! !!PP2Node methodsFor: 'operators - context' stamp: '12/5/2016 22:12:51'!pop	^ PP2PopNode on: self! !!PP2Node methodsFor: 'copying' stamp: '12/5/2016 22:12:51'!postCopy	"JK: I am not sure, if this works properly for optimized version!!"	super postCopy.		properties := properties copy.	strategy := strategy copy.	strategy node: self! !!PP2Node methodsFor: 'printing' stamp: '12/5/2016 22:12:51'!printOn: aStream	super printOn: aStream.		self name isNil ifFalse: [ 		aStream nextPut: $(.		self name printOn: aStream.		aStream nextPut: $).	] ifTrue: [  		aStream nextPut: $#.		aStream nextPutAll: self identityHash asString	]! !!PP2Node methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!properties	^ properties! !!PP2Node methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!properties: anObject	^ properties := anObject ! !!PP2Node methodsFor: 'operators - context' stamp: '12/5/2016 22:12:51'!push	^ PP2PushNode on: self! !!PP2Node methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!recognizer	^ self propertyAt: #recognizer! !!PP2Node methodsFor: 'optimizations - caching' stamp: '12/5/2016 22:12:51'!refreshCaches	^ self propertyAt: #allCaches put: self collectCaches! !!PP2Node methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!reparsable	self propertyAt: #reparsable put: true! !!PP2Node methodsFor: 'parsing - adaptable' stamp: '12/5/2016 22:12:51'!reparseAdaptableWithContext: context	| reparsableContext returnValue |	[		reparsableContext := context asReparsableContext.		reparsableContext reset.		reparsableContext parser 			ifNil: [ self resetCaches. reparsableContext parser: self ] 			ifNotNil: [ self assert: reparsableContext parser == self. self resetNonReparsableCaches ].		reparsableContext restore: reparsableContext startMemento.		returnValue := self parseOn: reparsableContext.		self checkPromises.		^ returnValue isPetit2Success ifTrue: [ 			reparsableContext returnValue: returnValue 		] ifFalse: [ 			returnValue 				setContext: reparsableContext;				yourself 		]	] on: PP2ReparseException do: [ 		"reparse did not worked, do the full parse instead"		reparsableContext reset.		reparsableContext restore: reparsableContext startMemento.			^ self parseAdaptableWithContext: reparsableContext	]! !!PP2Node methodsFor: 'reparsing' stamp: '12/5/2016 22:12:51'!reparseWithContext: context	^ self reparseAdaptableWithContext: context! !!PP2Node methodsFor: 'transforming' stamp: '12/5/2016 22:12:51'!replace: node with: anotherNode	"Replace the references of the receiver pointing to aParser with anotherParser."! !!PP2Node methodsFor: 'optimizations - caching' stamp: '12/5/2016 22:12:51'!resetCaches	self isOptimized ifFalse: [ ^ self ].	self allCaches do: [ :cache | cache reset ].	! !!PP2Node methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetMemoizationStrategy	memoizationStrategy := PP2CSMemoization new! !!PP2Node methodsFor: 'optimizations - caching' stamp: '12/5/2016 22:12:51'!resetNonReparsableCaches	self isOptimized ifFalse: [ ^ self ].	self allCaches reject: [:e | e isReparsable ] thenDo: [ :cache | cache reset ].	! !!PP2Node methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategies	self resetStrategy.	self resetMemoizationStrategy.! !!PP2Node methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	self subclassResponsibility! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!sea	^ PP2SeaNode on: self! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!sea: waterToken	^ (PP2SeaNode on: self)		waterToken: waterToken;		yourself! !!PP2Node methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!selfSkipDelegate	^ self isJustDelegate ifTrue: [  self child ] ifFalse: [	^ self ]! !!PP2Node methodsFor: 'operators - convenience' stamp: '12/5/2016 22:12:51'!separatedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated by aParser."		^ (PP2SequenceNode with: self with: (PP2SequenceNode with: aParser with: self) star) ==> [ :nodes |		| result |		result := Array new: 2 * nodes second size + 1.		result at: 1 put: nodes first.		nodes second 			keysAndValuesDo: [ :index :pair | result replaceFrom: 2 * index to: 2 * index + 1 with: pair startingAt: 1 ].		result ]! !!PP2Node methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!setOptimized	^ self allNodesDo: [ :node | node propertyAt: #optimized put: true ]! !!PP2Node methodsFor: 'optimizations - caching' stamp: '12/5/2016 22:12:51'!shouldCache	^ self propertyAt: #cacheAllowed ifAbsent: [ ^ false ]! !!PP2Node methodsFor: 'optimizations - caching' stamp: '12/5/2016 22:12:51'!shouldMemoize	^ self propertyAt: #memoize ifAbsent: false! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!star	^ (PP2PossesiveRepeatingNode on: self)		min: 0;		yourself! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!starLazy	| sea |	sea := (#epsilon asPParser sea)		waterToken: self;		yourself.	^ (sea map: [:_before :_epsilon :_after | 			"return just before water, because island is nil and after water is empty"			_before		]) ! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!starLazy: predicate	^ (predicate not, self) star! !!PP2Node methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!strategies	^ strategy allChildren! !!PP2Node methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!strategy	^ strategy! !!PP2Node methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!strategy: aPP2Strategy	(strategy == aPP2Strategy) ifTrue: [ ^ self ].	self assert: aPP2Strategy node == self.	strategy := aPP2Strategy! !!PP2Node methodsFor: 'recording' stamp: '12/5/2016 22:12:51'!switchToRecording: toBeSwitched parent: nodeOrStrategy	| recordingStrategy |	recordingStrategy := toBeSwitched recording.	recordingStrategy == toBeSwitched ifTrue: [ ^ toBeSwitched ].	nodeOrStrategy strategy: recordingStrategy.	^ recordingStrategy ! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!times: anInteger	"Answer a new parser that parses the receiver exactly anInteger times."		^ (PP2PossesiveRepeatingNode on: self)		min: anInteger;		max: anInteger;		yourself! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!token	^ PP2TokenNode on: self! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!token: tokenClass	^ (PP2TokenNode on: self)		tokenClass: tokenClass;		yourself! !!PP2Node methodsFor: 'transforming' stamp: '12/5/2016 22:12:51'!transform: aBlock	^ self transform: aBlock suchThat: [ :node | true ]! !!PP2Node methodsFor: 'transforming' stamp: '12/5/2016 22:12:51'!transform: aBlock suchThat: predicate	^ PP2TransformVisitor new		block: aBlock;		predicate: predicate;		visit: self! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!trim	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trimSpaces! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!trim: aParser	"Answer a new parser that consumes and ignores aParser repeatedly before and after the receiving parser."		^ (PP2TrimmingNode on: self)		trimmer: aParser;		yourself! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!trimBlanks	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trim: #blank asPParser star! !!PP2Node methodsFor: 'trimming' stamp: '12/5/2016 22:12:51'!trimLeft	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trimSpacesLeft! !!PP2Node methodsFor: 'trimming' stamp: '12/5/2016 22:12:51'!trimRight	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trimSpacesRight! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!trimSpaces	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trim: #space asPParser star! !!PP2Node methodsFor: 'operators-mapping' stamp: '12/5/2016 22:12:51'!trimSpacesLeft	"Answer a new parser that consumes spaces before the receiving parser."		^ (#space asPParser star, self) ==> #second! !!PP2Node methodsFor: 'operators-mapping' stamp: '12/5/2016 22:12:51'!trimSpacesRight	"Answer a new parser that consumes spaces after the receiving parser."		^ (self, #space asPParser star) ==> #first! !!PP2Node methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!unsetOptimized	^ self allNodesDo: [ :node | node propertyAt: #optimized put: false ]! !!PP2Node methodsFor: 'optimizations - warnings' stamp: '12/5/2016 22:12:51'!warnActionInToken	"		(($a asParser2, $b asParser2) ==> [ :e | e second ] token) optimize	"	| warning |	warning := self displayName, ' is in token, there shouldnt be actions in tokens. but it might be necessary, I admit :('.		self addWarning: warning.! !!PP2Node methodsFor: 'optimizations - warnings' stamp: '12/5/2016 22:12:51'!warnDifferentTrimmer	"give user feedback about this issues"! !!PP2Node methodsFor: 'optimizations - warnings' stamp: '12/5/2016 22:12:51'!warnShouldNotBeShared	"give user feedback about this issues"	| warning |	warning := self displayName, ' should not be shared, because it cannot be optimized'.		self addWarning: warning.! !!PP2Node methodsFor: 'optimizations - warnings' stamp: '12/5/2016 22:12:51'!warnings	^ self propertyAt: #warnings ifAbsentPut: [ OrderedCollection new ]! !!PP2Node methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!withoutDebugStrategy	^ strategy withoutDebugStrategy! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!wrapped	^ PP2DelegateNode on: self! !!PP2Node methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!| aParser	"Answer a new parser that either parses the receiver or aParser. Fail if both pass or fail (exclusive choice, unordered choice)."	^ (self not , aParser) / (aParser not , self) ==> #second! !!PP2PluggableNode class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!on: block	^ self new		block: block;		yourself! !!PP2PluggableNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitPluggable: self! !!PP2PluggableNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!block	^ block! !!PP2PluggableNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!block: anObject	block := anObject! !!PP2PluggableNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!firstCharSet	^ PP2UnknownCharSetPredicate instance! !!PP2PluggableNode methodsFor: 'analysis - first' stamp: '12/5/2016 22:12:51'!isFirstSetTerminal	"lets be conservative here"	^ true! !!PP2PluggableNode methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localEquals: anotherNode	(super localEquals: anotherNode) ifFalse: [ ^ false ].		^ (self block printString = anotherNode block printString)! !!PP2PluggableNode methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localHash	^ super localHash bitXor: self block printString hash! !!PP2PluggableNode methodsFor: 'parsing - private' stamp: '12/5/2016 22:12:51'!parseOn: aPP2Context	^ strategy parseOn: aPP2Context ! !!PP2PluggableNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Pluggable on: self! !!PP2PredicateNode class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!on: predicate message: message	^ self new		predicate: predicate;		predicateMessage: message;		negated: [ :arg | (predicate value: arg) not ];		negatedMessage: 'no ', message;		yourself! !!PP2PredicateNode methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localEquals: anotherNode	(super localEquals: anotherNode) ifFalse: [ ^ false ].		self predicate printString = anotherNode predicate printString ifFalse: [ ^ false ].	self predicateMessage = anotherNode predicateMessage ifFalse: [ ^ false ].	^ true! !!PP2PredicateNode methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localHash	^ super localHash bitXor: (predicate printString hash bitXor: predicateMessage hash)! !!PP2PredicateNode methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!negate	"Answer a parser that is the negation of the receiving predicate parser."		^ (self class new)		predicate: negated;		predicateMessage: negatedMessage;		negated: predicate;		negatedMessage: predicateMessage! !!PP2PredicateNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!negated	^ negated! !!PP2PredicateNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!negated: anObject	negated := anObject! !!PP2PredicateNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!negatedMessage	^ negatedMessage! !!PP2PredicateNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!negatedMessage: anObject	negatedMessage := anObject! !!PP2PredicateNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!predicate	^ predicate! !!PP2PredicateNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!predicate: anObject	predicate := anObject! !!PP2PredicateNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!predicateMessage	^ predicateMessage! !!PP2PredicateNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!predicateMessage: anObject	predicateMessage := anObject! !!PP2PredicateObjectNode class methodsFor: 'factory-objects' stamp: '12/5/2016 22:12:51'!anyOf: aCollection	^ self new		predicate: [ :each | aCollection includes: each ];		predicateMessage: 'any of ' , aCollection printString , ' expected';		negated: [ :each | (aCollection includes: each) not ];		negatedMessage: 'none of ' , aCollection printString ,  'expected'! !!PP2PredicateObjectNode class methodsFor: 'factory-objects' stamp: '12/5/2016 22:12:51'!expect: anObject message: aString	^ (self new)		predicate: [ :each | each = anObject ];		predicateMessage: aString;		negated: [ :each | each ~= anObject ];		negatedMessage: 'no ' , aString! !!PP2PredicateObjectNode class methodsFor: 'factory-objects' stamp: '12/5/2016 22:12:51'!noneOf: aCollection	^ self new		predicate: [ :each | (aCollection includes: each) not ];		predicateMessage: 'none of ' , aCollection printString , ' expected';		negated: [ :each | (aCollection includes: each) ];		negatedMessage: 'any of ' , aCollection printString ,  'expected'! !!PP2PredicateObjectNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitPredicateObject: self! !!PP2PredicateObjectNode methodsFor: 'analysis - first' stamp: '12/5/2016 22:12:51'!firstCharSet	^ predicate asCharSetPredicate! !!PP2PredicateObjectNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!predicate: aPP2CharSetPredicateOrBlock	"Using char set predicate is a performance optimization"	predicate := aPP2CharSetPredicateOrBlock asCharSetPredicate! !!PP2PredicateObjectNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2PredicateObject on: self! !!PP2PredicateSequenceNode class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!on: predicate message: message size: size	^ (super on: predicate message: message)		size: size;		yourself! !!PP2PredicateSequenceNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitPredicateSequence: self! !!PP2PredicateSequenceNode methodsFor: 'analysis - first' stamp: '12/5/2016 22:12:51'!firstCharSet! !!PP2PredicateSequenceNode methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localEquals: anotherNode	(super localEquals: anotherNode) ifFalse: [ ^ false ].		^ self size = anotherNode size! !!PP2PredicateSequenceNode methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!localHash	^ super localHash bitXor: size hash! !!PP2PredicateSequenceNode methodsFor: 'operators' stamp: '12/5/2016 22:12:51'!negate	"Answer a parser that is the negation of the receiving predicate parser."		^ super negate		size: size;		yourself! !!PP2PredicateSequenceNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2PredicateSequence on: self! !!PP2PredicateSequenceNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!size	^ size! !!PP2PredicateSequenceNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!size: anObject	size := anObject! !!PP2SeaNode class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!on: island	^ (self new)		island: island;		yourself! !!PP2SeaNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: aPP2Visitor	^ aPP2Visitor visitSea: self! !!PP2SeaNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!afterWater	^ afterWater ! !!PP2SeaNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!beforeWater	^ beforeWater! !!PP2SeaNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!children	^ Array with: beforeWater with: island with: afterWater! !!PP2SeaNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.		beforeWater := PP2WaterNode new		waterToken: self waterToken;		yourself.	afterWater := PP2WaterNode new		waterToken: self waterToken;		yourself.! !!PP2SeaNode methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isMemoized	^ self strategies anySatisfy: [ :s | s isMemoized ]! !!PP2SeaNode methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isSea	^ true! !!PP2SeaNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!island	^ island! !!PP2SeaNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!island: anObject	island := anObject! !!PP2SeaNode methodsFor: 'private - operators' stamp: '12/5/2016 22:12:51'!nonEpsilon: node	^ node isNullable ifTrue: [ node nonEpsilon  ] ifFalse: [ node ]! !!PP2SeaNode methodsFor: 'transforming' stamp: '12/5/2016 22:12:51'!replace: node with: anotherNode	island == node ifTrue: [ island := anotherNode ].	beforeWater == node ifTrue: [ beforeWater := anotherNode ].	afterWater == node ifTrue: [ afterWater := anotherNode ]		! !!PP2SeaNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!reset: newContext	(root ~= newContext parser) ifTrue: [  		self updateForRoot: newContext parser	]! !!PP2SeaNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Sea on: self! !!PP2SeaNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!root: newRoot	root := newRoot! !!PP2SeaNode methodsFor: 'boundaries' stamp: '12/5/2016 22:12:51'!updateAfterWater: rootParser	| next |	self assert: rootParser isPetit2Parser.		next := self nextSetIn: rootParser.	afterWater boundaryElements: (OrderedCollection withAll: next)! !!PP2SeaNode methodsFor: 'boundaries' stamp: 'JanKurs 12/5/2016 22:17'!updateBeforeWater: rootParser	| next elements |	self assert: rootParser isPetit2Parser.	next := self nextSetIn: rootParser.	elements := OrderedCollection with: island.	elements addAll: next.	beforeWater	boundaryElements: elements.	! !!PP2SeaNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!updateForRoot: newRoot	root := newRoot.	self updateBeforeWater: root.	self updateAfterWater: root! !!PP2SeaNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!waterToken	^ self propertyAt: #waterToken ifAbsent: [  		#any asPParser 	]! !!PP2SeaNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!waterToken: waterToken	self propertyAt: #waterToken put: waterToken.		beforeWater waterToken: waterToken.	afterWater waterToken: waterToken.! !!PP2StartOfLineNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: visitor	^ visitor visitStartOfLine: self! !!PP2StartOfLineNode methodsFor: 'analysis - first' stamp: '12/5/2016 22:12:51'!firstCharSet	"	 Because the start of a line is not 'real' character in the input stream,	 I don't know if the peek character in a stream is in my first set.	"	^ PP2UnknownCharSetPredicate instance! !!PP2StartOfLineNode methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2StartOfLine on: self! !!PP2UnresolvedNode methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isUnresolved	^ true! !!PP2UnresolvedNode methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseOn: aStream	self error: self printString , ' need to be resolved before execution.'! !!PP2UnresolvedNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	"nothing to do here"! !!PP2WaterNode class methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!boundary: aPP2Node	^ (self new) 		boundary: aPP2Node;		yourself! !!PP2WaterNode methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!accept: visitor	^ visitor visitWater: self! !!PP2WaterNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!boundary	^ boundary! !!PP2WaterNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!boundary: anObject	self boundaryElements: anObject asCollection! !!PP2WaterNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!boundaryElements	^ boundary children collect: #child! !!PP2WaterNode methodsFor: 'accessing' stamp: 'JanKurs 12/5/2016 22:24'!boundaryElements: collectionOrElement	| elements |	elements := collectionOrElement isCollection ifTrue: [ collectionOrElement ] ifFalse: [ OrderedCollection with: collectionOrElement ].	"		#rejectXYZ are optimizations. 				This is kind of design issue, but I need to make seas at least a bit useable		in in non-optimized mode as well.	"	elements := elements collect: [:e | self rejectSeas: e ].	elements := elements collect: [:e | self rejectPossessive: e ].	elements := elements collect: [:e | self nonEpsilon: e ].	elements := elements collect: #and.			boundary := (PP2ChoiceNode withAll: elements).		self strategy isDebugging ifTrue: [ boundary enableDebug ]! !!PP2WaterNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!children	^ Array with: boundary with: waterToken ! !!PP2WaterNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.		waterToken := #any asPParser.	boundary := (PP2ChoiceNode with: PP2EndOfInputNode new and).! !!PP2WaterNode methodsFor: 'private' stamp: '12/5/2016 22:12:51'!nonEpsilon: node	^ node isNullable ifTrue: [ node nonEpsilon  ] ifFalse: [ node ]! !!PP2WaterNode methodsFor: 'private' stamp: '12/5/2016 22:12:51'!rejectPossessive: node	^ node selfSkipDelegate isRepeating ifTrue: [ node child  ] ifFalse: [ node ]! !!PP2WaterNode methodsFor: 'private' stamp: '12/5/2016 22:12:51'!rejectSeas: nodeOrDelegate	| node |	node := nodeOrDelegate selfSkipDelegate.		^ node isSea ifTrue: [ node island  ] ifFalse: [ node ]! !!PP2WaterNode methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!resetStrategy	strategy := PP2Water on: self! !!PP2WaterNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!waterToken	^ waterToken! !!PP2WaterNode methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!waterToken: anObject	waterToken := anObject! !!PP2NodeFactory class methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!instance	Instance isNil ifTrue: [  		Instance := PP2NodeFactory new	].	^ Instance! !!PP2NodeFactory class methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!reset	Instance := nil! !!PP2NodeFactory methodsFor: 'predicates' stamp: '12/5/2016 22:12:51'!any	^ PP2PredicateObjectNode new		predicate: [ :each | true ];		predicateMessage: 'input expected';		negated: [ :each | false ];		negatedMessage: 'no input expected';		yourself! !!PP2NodeFactory methodsFor: 'predicates' stamp: '12/5/2016 22:12:51'!blank	| collection |	collection := OrderedCollection with: Character space with: Character tab.	^ PP2PredicateObjectNode new 		predicate: (PP2CharSetPredicate on: [ :char | collection includes: char ]);		predicateMessage: 'blank expected';		negated: (PP2CharSetPredicate on: [:char | (collection includes: char) not ]);		negatedMessage: 'blank not expected';		yourself! !!PP2NodeFactory methodsFor: 'predicates' stamp: '12/5/2016 22:12:51'!digit	^ PP2PredicateObjectNode new		predicate: (PP2CharSetPredicate on: [ :char | char isDigit ]);		predicateMessage: 'digit expected';		negated: (PP2CharSetPredicate on: [ :char | char isDigit not ]);		negatedMessage: 'digit not expected';		yourself! !!PP2NodeFactory methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!eoi	^ PP2EndOfInputNode new! !!PP2NodeFactory methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!epsilon	^ PP2EpsilonNode instance! !!PP2NodeFactory methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!failure	^ PP2FailingNode new! !!PP2NodeFactory methodsFor: 'predicates' stamp: '12/5/2016 22:12:51'!hex	| hexBlock |	hexBlock := [ :char | (char between: $0 and: $9) 					or: [ (char between: $a and: $f) 					or: [ (char between: $A and: $F) ] ]  ].			^ PP2PredicateObjectNode new		predicate: (PP2CharSetPredicate on: hexBlock);		predicateMessage: 'hex digit expected';		negated: (PP2CharSetPredicate on: [:char | (hexBlock value: char) not]);		negatedMessage: 'hex digit not expected';		yourself! !!PP2NodeFactory methodsFor: 'predicates' stamp: '12/5/2016 22:12:51'!letter	^ PP2PredicateObjectNode new		predicate: (PP2CharSetPredicate on: [ :char | char isLetter ]);		predicateMessage: 'letter expected';		negated: (PP2CharSetPredicate on: [ :char | char isLetter not ]);		negatedMessage: 'letter not expected';		yourself! !!PP2NodeFactory methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!newline	^ PP2NewLineNode new! !!PP2NodeFactory methodsFor: 'context' stamp: '12/5/2016 22:12:51'!pop	^ nil asPParser pop! !!PP2NodeFactory methodsFor: 'predicates' stamp: '12/5/2016 22:12:51'!space	^ PP2PredicateObjectNode new 		predicate: (PP2CharSetPredicate on: [ :char | char isSeparator ]);		predicateMessage: 'separator expected';		negated: (PP2CharSetPredicate on: [ :char | char isSeparator not ]);		negatedMessage: 'separator not expected';		yourself! !!PP2NodeFactory methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!startOfLine	^ PP2StartOfLineNode new! !!PP2NodeFactory methodsFor: 'seas' stamp: '12/5/2016 22:12:51'!water	^ nil asPParser sea flatten! !!PP2NodeFactory methodsFor: 'predicates' stamp: '12/5/2016 22:12:51'!word	^ PP2PredicateObjectNode new		predicate: (PP2CharSetPredicate on: [ :char | char isAlphaNumeric ]);		predicateMessage: 'letter or digit expected';		negated: (PP2CharSetPredicate on: [ :char | char isAlphaNumeric not ]);		negatedMessage: 'letter or digit not expected';		yourself! !!PP2Interpret class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!on: aPP2Parser	^ (self basicNew)		initializeFor: aPP2Parser;		yourself! !!PP2Interpret methodsFor: 'visiting - helpers' stamp: '12/5/2016 22:12:51'!discardFailure	currentContext :=	currentContext success! !!PP2Interpret methodsFor: 'intializing' stamp: '12/5/2016 22:12:51'!initializeFor: aPP2Parser	rootParser := aPP2Parser! !!PP2Interpret methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parse: input	| startContext |	startContext := input asPetit2Context.	^ self parseWithContext: startContext! !!PP2Interpret methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parse: input withContext: startContext	startContext stream: input asPetit2Stream.	startContext position: 0.	startContext parser: rootParser.		^ self parseWithContext: startContext! !!PP2Interpret methodsFor: 'parsing' stamp: '12/5/2016 22:12:51'!parseWithContext: startContext	| retval |	currentContext := startContext.	retval := self visit: rootParser.		^ retval isPetit2Failure ifTrue: [ retval ] ifFalse: [ currentContext returnValue: retval; yourself ]		! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAction: parser	| retval |	^ (retval := self visit: parser child) isPetit2Failure 		ifTrue: [ ^ retval ]		ifFalse: [ ^ parser block value: retval ]! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAnd: parser	| retval memento |	memento := currentContext remember.		retval := self visit: parser child. 	currentContext restore: memento.		^ retval isPetit2Success		ifTrue: [ retval ]		ifFalse: [ PP2Failure message: retval message context: currentContext ]		! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitChoice: parser	| retval |		1 to: parser children size do: [ :index |		(retval := self visit: (parser childAt: index)) isPetit2Success ifTrue: [ ^ retval ] 	].		^ retval! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitComposite: node	^ self visit: node child! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitDelegate: parser	^ self visit: parser child! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEnd: parser	| memento retval |		memento := currentContext remember.	retval := self visit: parser child.	^ currentContext atEnd 		ifTrue: [ retval ] 		ifFalse: [ 			retval := PP2Failure message: 'end of input expected' context: currentContext.			currentContext restore: memento.			^ retval		]! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEpsilon: parser	^ nil! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitFailing: parser	^ PP2Failure message: parser message context: currentContext! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitFlatten: parser	| start result |	start := currentContext position.	(result := self visit: parser child) isPetit2Failure ifTrue: [ ^ result ].	^ currentContext copyFrom: start + 1 to: (currentContext position)! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitFragment: parser	| start retval |	start := currentContext remember.	(retval := self visit: parser child) isPetit2Failure ifTrue: [ ^ retval ].	^ currentContext copy 		returnValue: retval;		startMemento: start;		parser: parser;		yourself! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitLiteralObject: parser	^ (currentContext atEnd not and: [ parser literal = currentContext uncheckedPeek ])		ifFalse: [ PP2Failure message: parser message context: currentContext ]		ifTrue: [ currentContext uncheckedNext ]! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitLiteralSequence: parser	| memento retval |	memento := currentContext remember.	retval := currentContext next: parser size.	parser literal = retval ifTrue: [ ^ retval ].	currentContext restore: memento.	^ PP2Failure message: parser message context: currentContext! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitMapping: parser	| retval |	^ (retval := self visit: parser child) isPetit2Failure 		ifTrue: [ ^ retval ]		ifFalse: [ ^ parser block valueWithArguments: retval asOrderedCollection ]! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitNot: parser	| retval memento |	memento := currentContext remember.		retval := self visit: parser child.	currentContext restore: memento.		^ retval isPetit2Failure 		ifTrue: [ nil ]		ifFalse: [ PP2Failure message: 'I was not expected to pass' context: currentContext ]! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitOptional: parser	| retval memento |	memento := currentContext remember.		^ (retval := self visit: parser child) isPetit2Failure 		ifTrue: [ currentContext restore: memento. nil ]		ifFalse: [ retval ]! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPP2Node: aPP2Parser	self error: 'should not happen'! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPluggable: parser	^ parser block value: currentContext! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPossesiveRepeating: parser	| memento elements retval |	elements := OrderedCollection new.	memento := currentContext remember.		[ elements size < parser min ] whileTrue: [		(retval := self visit: parser child) isPetit2Failure ifTrue: [			currentContext restore: memento.			"^ PP2Failure message: 'not enough repetitions' context: currentContext."			^ retval		].		elements addLast: retval 	].		[ elements size < parser max ] whileTrue: [	 	(retval := self visit: parser child) isPetit2Failure ifTrue: [ 			^ elements 		].		elements addLast: retval 	].	^ elements! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPredicateObject: parser	^ (currentContext atEnd not and: [ parser predicate value: currentContext uncheckedPeek ])		ifFalse: [ PP2Failure message: parser predicateMessage context: currentContext  ]		ifTrue: [ currentContext uncheckedNext ]! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPredicateSequence: parser	| retval position |	position := currentContext position.	retval := currentContext next: parser size.		^ (retval isNil not and: [ parser predicate value: retval ]) 		ifTrue: [ retval ]		ifFalse: [ 			currentContext position: position.			PP2Failure message: parser predicateMessage context: currentContext 		]! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSequence: parser	| retval elements memento |	memento := currentContext remember.	elements := Array new: parser children size.		1 to: elements size do: [ :index |		retval := self visit: (parser childAt: index).		retval isPetit2Failure ifTrue: [ 			currentContext restore: memento. 			^ retval		].		elements at: index put: retval 	].		^ elements! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitToken: parser	| start token retval |	start := currentContext position.	(retval := self visit: parser child) isPetit2Failure ifTrue: [ ^ retval ].	token :=	currentContext newToken: (parser tokenClass) from: start.	^ token! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitTrimming: parser	| memento retval |	memento := currentContext remember.	self visit: parser trimmer.		(retval := self visit: parser child) isPetit2Failure ifTrue: [ 		currentContext restore: memento.		^ retval	].		self visit: parser trimmer.	^ retval! !!PP2Interpret methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitWrapping: parser	^ parser block value: currentContext value: [ self visit: parser child  ]! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visit: aPP2Parser	^ aPP2Parser accept: self! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAction: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAdaptable: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAnd: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitChoice: aPP2Parser	^ self visitPP2Node: aPP2Parser! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitComposite: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitDelegate: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEnd: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEndOfInput: node	^ self visitPP2Node: node	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEpsilon: node	^ self visitPP2Node: node	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitFailing: node	^ self visitPP2Node: node	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitFlatten: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitLiteralObject: aPP2Parser	^ self visitPP2Node: aPP2Parser! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitLiteralSequence: aPP2Parser	^ self visitPP2Node: aPP2Parser! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitMapping: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitMatch: node	^ self visitPP2Node: node! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitNonEpsilon: node	^ self visitPP2Node: node! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitNot: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitOptional: aPP2Parser	^ self visitPP2Node: aPP2Parser! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPP2Node: aPP2Node	"nothing to do here"	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPluggable: aPP2Parser	^ self visitPP2Node: aPP2Parser! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPop: node	^ self visitPP2Node: node! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPossesiveRepeating: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPredicateObject: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPredicateSequence: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPush: node	^ self visitPP2Node: node! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSea: node	^ self visitPP2Node: node! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSequence: aPP2Parser	^ self visitPP2Node: aPP2Parser! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitToken: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitTrimming: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitTrimmingToken: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitUnresolved: node	^ self visitPP2Node: node	! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitWater: node	^ self visitPP2Node: node! !!PP2NodeVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitWrapping: aPP2Parser	^ self visitPP2Node: aPP2Parser	! !!PP2AllNodesCache methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!afterAccept: ctx result: result	ctx node propertyAt: #allNodesSize ifAbsentPut: result size! !!PP2AllNodesCache methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!doPass: node	self visit: node! !!PP2AllNodesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!allNodes	^ closeSet collect: [ :ctx | ctx node ]! !!PP2AllNodesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!children	self halt: 'deprecated'.	^ closeSet collect: [ :ctx | ctx node ]! !!PP2AllNodesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPP2Node: node	| retval |	retval := IdentitySet new.	node children do: [ :child | 		retval addAll: (self visit: child)	].	retval add: node.		^ retval! !!PP2BypassVisitor methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!doPass: node	^ self visit: node! !!PP2BypassVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitComposite: node	self visit: node child.! !!PP2BypassVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPP2Node: node	| target |	node children do: [ :child | 		(child class == PP2DelegateNode and: [ child strategy class == PP2Delegate]) ifTrue: [  			target := child child.			node strategy bypass: child to: target		].		self visit: child.	]! !!PP2CommonPrefixVisitor methodsFor: 'caching' stamp: '12/5/2016 22:12:51'!cache: node	node isCacheForbidden ifTrue: [ ^ self ].	node contextChanges isContextChange ifTrue: [ ^ self ].	node isMemoized ifTrue: [ ^ self ].		node strategy: node strategy cache.! !!PP2CommonPrefixVisitor methodsFor: 'caching - choice' stamp: '12/5/2016 22:12:51'!cache: node production: production	| strategy |	node isCacheForbidden ifTrue: [ ^ self ].		strategy := production strategy cache.	node changeStrategy: strategy ! !!PP2CommonPrefixVisitor methodsFor: 'caching' stamp: '12/5/2016 22:12:51'!cacheIfMakesSense: node	(self cacheMakesSense: node) ifTrue: [  		self cache: node	]! !!PP2CommonPrefixVisitor methodsFor: 'support' stamp: '12/5/2016 22:12:51'!cacheMakesSense: production	| node target |	node := production isJustDelegate ifTrue: [ production child ] ifFalse: [ production ].	target := node.	"trimmers are already optimized, I care about the body"	node isTrimming ifTrue: [ target := node child ].	node isTrimmingToken ifTrue: [ target := node child child ].		^ (target propertyAt: #allNodesSize ifAbsentPut: [ node allNodes size ]) > 2! !!PP2CommonPrefixVisitor methodsFor: 'caching - choice' stamp: '12/5/2016 22:12:51'!cacheProductions: productions	| names |	names := productions collect: [:p | p name ].		"		Small magic alert: I take all the equivalent productions and set the same caching 		strategy for all production that occur in the first set of more than one alternives.	"	names do: [ :name |		| occurences production |		occurences := productions select: [ :p | p name = name ].		production := occurences first.				(occurences size > 1 and: [self cacheMakesSense: production ]) ifTrue: [ 			occurences do: [ :o |				"note that we are sharing the same strategy over multiple productions!!"				self cache: o production: production.			] 		]	].! !!PP2CommonPrefixVisitor methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!doPass: node	^ self visit: node	! !!PP2CommonPrefixVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitChoice: choice	| productions |	super visitChoice: choice.	productions := OrderedCollection new.	(choice children do: [ :c | productions addAll: c firstProductionSet ]).	self assert: (productions allSatisfy: [ :e | e isProduction ]).	self cacheProductions: productions! !!PP2CommonPrefixVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPP2Node: node	node shouldCache ifTrue: [ 		self cache: node	].	super visitPP2Node: node! !!PP2CommonPrefixVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSea: node	self visit: node island.		node isMemoized ifFalse: [ 		self cache: node island.		node beforeWater boundaryElements do: [ :e | self cache: e ].		node afterWater boundaryElements do: [ :e | self cache: e ].	]! !!PP2CommonPrefixVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSequence: sequence	| productions |	super visitSequence: sequence.	"First child is nullable, i.e. it cannot fail, the cache would be superfluous"	sequence firstChild isNullable ifFalse: [ ^ self ].	"so far only for the first two children"	productions := OrderedCollection new.	productions	addAll: (sequence firstChild firstProductionSet).	productions addAll: (sequence secondChild firstProductionSet).		self assert: (productions allSatisfy: [ :e | e isProduction ]).		self cacheProductions: productions! !!PP2ContextChangesCache methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!propertySymbol	^ #contextChanges! !!PP2ContextChangesVisitor methodsFor: 'loop control' stamp: '12/5/2016 22:12:51'!openedResultFor: context	^ PP2CcResult noChange ! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!sequenceResult: node	| childrenResult pushes pops |	childrenResult := node children collect: [ :child | self visit: child ].		(childrenResult noneSatisfy: [:result | result isContextChange ]) ifTrue: [  		^ PP2CcResult noChange	].	(childrenResult anySatisfy: [:result | result isUnknownChange ]) ifTrue: [  		^ PP2CcResult change	].	pushes := (node children select: [ :child | (self visit: child) isContextPush ]).	pops := (node children select: [ :child | (self visit: child) isContextPop ]).		pushes size > 1 ifTrue: [ ^ PP2CcResult change ].	pops size > 1 ifTrue: [ ^ PP2CcResult change ].		((pushes size = 1) and: [ pops size = 0 ]) ifTrue: [  ^ PP2CcResult push	].	((pops size = 1) and: [ pushes size = 0 ]) ifTrue: [ ^ PP2CcResult pop ].		(pushes size = 1 and: [ pops size = 1 ]) ifTrue: [ 		| pushIndex popIndex |		pushIndex := node children indexOf: pushes first.		popIndex := node children indexOf: pops first.				pushIndex < popIndex ifTrue: [ ^ PP2CcResult noChange  ] ifFalse: [ ^ PP2CcResult change ]	].	self error: 'should happen?'.! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAction: node	^ self visitDelegate: node! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAdaptable: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange change	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAnd: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitChoice: node	^ node propertyAt: #contextChanges ifAbsent: [ 		| results |		results := node children collect: [:child | self visit: child ].		results asSet size = 1 ifTrue: [ results anyOne ] ifFalse: [  			PP2CcChange change		]	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitComposite: node	^ self visitDelegate: node! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitDelegate: node	^ node propertyAt: #contextChanges ifAbsent: [ 		self visit: node child	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEnd: node	^ self visitDelegate: node! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEndOfInput: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEpsilon: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitFailing: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitFlatten: node	^ self visitDelegate: node! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitLiteralObject: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcResult noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitLiteralSequence: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitMapping: node	^ self visitDelegate: node! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitMatch: node	^ self visitDelegate: node! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitNonEpsilon: node	^ self visitDelegate: node! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitNot: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitOptional: node	^ node propertyAt: #contextChanges ifAbsent: [ 		| result |		result := self visit: node child.				result isContextChange ifTrue: [  			PP2CcResult change		] ifFalse: [  			PP2CcResult noChange 		]	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPP2Node: node	self error: 'should provide specific implementation, it is usually easy!!'! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPluggable: node	^ node propertyAt: #contextChanges ifAbsent: [ 		^ PP2CcChange change	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPop: node	^ node propertyAt: #contextChanges ifAbsent: [ 		(self visit: node child) isContextChange ifFalse: [			PP2CcChange pop		] ifTrue: [  			PP2CcChange change		]	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPossesiveRepeating: node	^ node propertyAt: #contextChanges ifAbsent: [ 		| result |		result := self visit: node child.				result isContextChange ifTrue: [  			PP2CcResult change		] ifFalse: [  			PP2CcResult noChange 		]	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPredicateObject: node	^ node propertyAt: #contextChanges ifAbsent: [ 		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPush: node	^ node propertyAt: #contextChanges ifAbsent: [ 		(self visit: node child) isContextChange ifFalse: [			PP2CcChange push		] ifTrue: [  			PP2CcChange change		]	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSea: node	^ node propertyAt: #contextChanges ifAbsent: [ 		"			These two asserts are probably not essential, but I cannot imagine the use case 			right now. If it is the case, the logic should be re-written.		"		self assert: (self visit: node beforeWater) isContextChange not.		self assert: (self visit: node afterWater) isContextChange not.		^ self visit: node island	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSequence: node	^ node propertyAt: #contextChanges ifAbsent: [ 		self sequenceResult: node	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitToken: node	^ self visitDelegate: node! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitTrimming: node	^ node propertyAt: #contextChanges ifAbsent: [ 		self assert: (self visit: node trimmer) isContextChange not.		self visit: node child	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitWater: node	^ node propertyAt: #contextChanges ifAbsent: [ 		self assert: (self visit: node waterToken) isContextChange not.		self assert: (self visit: node boundary) isContextChange not.		PP2CcChange noChange 	]! !!PP2ContextChangesVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitWrapping: node	^ node propertyAt: #contextChanges ifAbsent: [ 		^ PP2CcChange change	]! !!PP2ContextMemoizationVisitor methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!doPass: node	^ self visit: node	! !!PP2ContextMemoizationVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAnd: node	node child contextChanges isNotContextChange ifTrue: [ 		node memoizationStrategy: PP2CFMemoization new.		^ 	super visitAnd: node.	].	node child contextChanges isContextPop ifTrue: [ 		node memoizationStrategy: PP2PopMemoization new.		^ 	super visitAnd: node.	].	node child contextChanges isContextPush ifTrue: [ 		node memoizationStrategy: PP2PushMemoization new.		^ 	super visitAnd: node.	].	^ 	super visitAnd: node.! !!PP2ContextMemoizationVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitFlatten: node	node contextChanges isContextChange ifFalse: [ 		node memoizationStrategy: PP2CFMemoization new	].	super visitFlatten: node.	! !!PP2ContextMemoizationVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitMatch: node	node child contextChanges isNotContextChange ifTrue: [ 		node memoizationStrategy: PP2CFMemoization new	].	^ 	super visitWater: node! !!PP2ContextMemoizationVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitNonEpsilon: node	node child contextChanges isNotContextChange ifTrue: [ 		node memoizationStrategy: PP2CFMemoization new.		^ 	super visitAnd: node.	].	^ 	super visitAnd: node.! !!PP2ContextMemoizationVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSea: node	node contextChanges isContextChange ifFalse: [ 		node memoizationStrategy: PP2CFMemoization new	].	^ 	super visitSea: node! !!PP2ContextMemoizationVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSequence: node	(node children noneSatisfy: [:child | child contextChanges isContextChange ]) ifTrue: [ 		node memoizationStrategy: PP2CFMemoization new.		^ 	super visitSequence: node	].	node contextChanges isContextPop ifTrue: [ 		node memoizationStrategy: PP2PopMemoization new.		^ 	super visitSequence: node	].	node contextChanges isContextPush ifTrue: [ 		node memoizationStrategy: PP2PushMemoization new.		^ 	super visitSequence: node	].	((node children anySatisfy: [ :child | child contextChanges isContextChange  ]) and: [	  node contextChanges isNotContextChange ]) ifTrue: [ 			"JK: PUSH-POP case, can be handled by the PushMemoization, let me know if not :)"			node memoizationStrategy: PP2PushMemoization new.			^ 	super visitSequence: node	].	^ 	super visitSequence: node! !!PP2ContextMemoizationVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitWater: node	node waterToken contextChanges isContextChange ifFalse: [ 		node memoizationStrategy: PP2CFMemoization new	].	^ 	super visitWater: node! !!PP2ContextSensitivityCache methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!propertySymbol	^ #isContextSensitive! !!PP2ContextSensitivityVisitor methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!openedResultFor: context	^ false! !!PP2ContextSensitivityVisitor methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!sequenceResult: node	| pushes matches pushIndex matchIndices childrenResult |	childrenResult := node children collect: [ :child | child -> (self  visit: child) ].		pushes := node children select: [ :child | child contextChanges isContextPush ].	matches := childrenResult select: [ :assoc | assoc value ] thenCollect: #key.		matches isEmpty ifTrue: [ ^ false ].	pushes isEmpty ifTrue: [ ^ true ].	"probably can better here"	pushes size > 1 ifTrue: [ ^ true ].	"			JK: The idea here is, if there is a match after push, the result of the whole sequence 		does not depend on the stacks, because the match will be compared to the value from push.				E.g.  		self assert: (#letter asPParser push, #letter asPParser match) isContextFree	"		matchIndices := matches collect: [ :match | node children indexOf: match ].	pushIndex := node children indexOf: pushes anyOne.		^ matchIndices anySatisfy: [ :i | i < pushIndex ].! !!PP2ContextSensitivityVisitor methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!visitMatch: node	^ node propertyAt: #isContextSensitive ifAbsent: [ 		true	]! !!PP2ContextSensitivityVisitor methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!visitPP2Node: node	^ node propertyAt: #isContextSensitive ifAbsent: [ 		node children anySatisfy: [:child | self visit: child ]	]! !!PP2ContextSensitivityVisitor methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!visitSequence: node	^ node propertyAt: #isContextSensitive ifAbsent: [ 		super visitSequence: node.		self sequenceResult: node	]! !!PP2ContextSensitivityVisitor methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!visitTerminal: node	^ node propertyAt: #isContextSensitive ifAbsent: [ 		false	]! !!PP2FirstProductionSetCache methodsFor: 'hooks' stamp: '12/5/2016 22:12:51'!afterAccept: ctx result: result	ctx node propertyAt: #firstProductionSet ifAbsentPut: result! !!PP2FirstProductionSetCache methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!doPass: node	| allNodes child |	self visit: node.	allNodes := node allNodes.		[child := allNodes detect: [ :e | (e hasProperty: #firstProductionSet) not ] 							ifNone: [ nil ] ] whileNotNil: [ 				self visit: child	]! !!PP2FirstProductionSetCache methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.	predicateBlock := [ :e | e isProduction  ]! !!PP2FirstSetCache methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!propertySymbol	^ #firstSet! !!PP2FirstSetVisitor class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!firstSet	^ self on: [ :e | e isFirstSetTerminal ] on: [ :e | e isFirstSetTerminal ]! !!PP2FirstSetVisitor class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!new	^ self firstSet! !!PP2FirstSetVisitor class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!on: aBlock	^ self basicNew initialize 		terminalBlock: aBlock;		predicateBlock: aBlock;		yourself! !!PP2FirstSetVisitor class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!on: terminalBlock on: predicateBlock	^ self basicNew 		terminalBlock: terminalBlock;		predicateBlock: predicateBlock;		initialize;		yourself! !!PP2FirstSetVisitor class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!productionSet	^ self on: [ :e | e isFirstSetTerminal ] on: [ :e | e isProduction ]! !!PP2FirstSetVisitor class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!seasOrTerminalsSet	^ self 		on: [ :e | e isSea or: [ e isFirstSetTerminal ] ] 		on: [ :e | e isSea or: [ e isFirstSetTerminal ] ]! !!PP2FirstSetVisitor class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!tokenSet	^ self on: [ :e | e isToken or: [ e isFirstSetTerminal  ] ]! !!PP2FirstSetVisitor methodsFor: 'support' stamp: '12/5/2016 22:12:51'!addIfPossible: node to: collection	Halt if: [ node isKindOf: PP2CompositeNode  ].	(predicateBlock value: node) ifTrue: [ collection add: node ]! !!PP2FirstSetVisitor methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.		leftRecursionAllowed := false! !!PP2FirstSetVisitor methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isTerminal: node	^ terminalBlock value: node! !!PP2FirstSetVisitor methodsFor: 'loop control' stamp: '12/5/2016 22:12:51'!openedResultFor: context	leftRecursionAllowed ifTrue: [ 		^ super openedResultFor: context	].	"		JK: I am not 100% sure, but this should never happen. If this happens, the grammar		    contains an infinite loop.	"	self error: 'There seems to be a left recursive loop in your grammar!!'! !!PP2FirstSetVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!predicateBlock	^ predicateBlock! !!PP2FirstSetVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!predicateBlock: anObject	predicateBlock := anObject! !!PP2FirstSetVisitor methodsFor: 'support' stamp: '12/5/2016 22:12:51'!setWithPossible: node 	^ self setWithPossible: node withAll: #()! !!PP2FirstSetVisitor methodsFor: 'support' stamp: '12/5/2016 22:12:51'!setWithPossible: node withAll: aCollection	| set |	set := IdentitySet withAll: aCollection.		(predicateBlock value: node) ifTrue: [ 		set add: node	].	^ set! !!PP2FirstSetVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!terminalBlock	^ terminalBlock! !!PP2FirstSetVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!terminalBlock: aBlock	terminalBlock := aBlock! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAction: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAdaptable: node	| set |	set := (self setWithPossible: node).	"Node can be adpated to anything"	self addIfPossible: #any asPParser to: set.	"We don't know if Epsilon is possible or not so we rather add it"	self addIfPossible: PP2EpsilonNode instance to: set.		^ set! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAnd: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitChoice: node	| returnSet |	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].		returnSet := self setWithPossible: node.	node children do: [ :child | 		returnSet addAll: (self visit: child).	].	^ returnSet! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitComposite: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitDelegate: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	^ self setWithPossible: node withAll: (self visit: node child) ! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEnd: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEndOfInput: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	self warn: 'guess you have some issues with your terminal block'! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEpsilon: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	self warn: 'guess you have some issues with your terminal block'! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitFailing: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	self warn: 'guess you have some issues with your terminal block'! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitFlatten: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	^ self setWithPossible: node withAll: (self visit: node child) ! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitLiteralObject: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	self warn: 'guess you have some issues with your terminal block'! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitLiteralSequence: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	self warn: 'guess you have some issues with your terminal block'! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitMapping: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	^ self setWithPossible: node withAll: (self visit: node child) ! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitMatch: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitNonEpsilon: node	| set |	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	set := (self setWithPossible: node).	set addAll: (self visit: node child).	set remove: PP2EpsilonNode instance ifAbsent: nil.		^ set! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitNot: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitOptional: node	| set |	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	set := (self setWithPossible: node).	set addAll: (self visit: node child).	self addIfPossible: PP2EpsilonNode instance to: set.		^ set! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPP2Node: node	self error: 'should provide specific implementation'! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPluggable: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPop: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPossesiveRepeating: node	| set |	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	set := self setWithPossible: node withAll: (self visit: node child).	(node min = 0) ifTrue: [ 		self addIfPossible: PP2EpsilonNode instance to: set.	].	^ set! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPredicateObject: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	self warn: 'guess you have some issues with your terminal block'! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPush: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSea: node	| returnSet |	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	returnSet := (self setWithPossible: node).	returnSet addAll: (self visit: node beforeWater).	returnSet removeAllSuchThat: [ :e | e = #eoi asPParser ].	returnSet addAll: (self visit: node island).	node island isNullable ifTrue: [ 		returnSet addAll: (self visit: node afterWater).	].			^ returnSet reject: [ :e | e isEpsilon ] ! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSequence: node	| returnSet |	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	returnSet := self setWithPossible: node.	node children do: [ :child | 		returnSet addAll: (self visit: child).		child isNullable ifFalse: [ ^ returnSet reject: [ :e | e isEpsilon ] ]	].	self addIfPossible: PP2EpsilonNode instance to: returnSet.	^ returnSet! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitStartOfLine: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].		self warn: 'guess you have some issues with your terminal block'! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitToken: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitTrimming: node	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	^ (self setWithPossible: node) 		addAll: ((self visit: node trimmer) reject: [ :e | e isEpsilon ]);		addAll: (self visit: node child);		yourself! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitWater: node	| retval lrStatus |	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	lrStatus := leftRecursionAllowed.	leftRecursionAllowed := true.	retval := (self setWithPossible: node) 		addAll: (self visit: node waterToken);		addAll: (self visit: node boundary);		yourself.			leftRecursionAllowed := lrStatus.				^ retval! !!PP2FirstSetVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitWrapping: node	^ self visitDelegate: node! !!PP2FirstSetVisitor methodsFor: 'warnings' stamp: '12/5/2016 22:12:51'!warn: aMessage	Transcript crShow: aMessage.	self error: 'this should not really happen.'.! !!PP2GuardVisitor methodsFor: 'support' stamp: '12/5/2016 22:12:51'!classificationFor: node	| classification charSet firstSet |	classification := Array new: 255 withAll: false.	firstSet := node firstSet.	firstSet do: [ :first |  		charSet := first firstCharSet.				charSet isUnknown ifTrue: [ ^ anythingClassification  ].				charSet classification withIndexDo: [ :value :index |  			value ifTrue: [ classification at: index put: true ]		]	].	^ classification! !!PP2GuardVisitor methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!doPass: node	self visit: node! !!PP2GuardVisitor methodsFor: 'support' stamp: '12/5/2016 22:12:51'!guardOf: classification makesSenseFor: node	| size allNodesSize |	allNodesSize := node propertyAt: #allNodesSize ifAbsentPut: [ node allNodes size ].		"if there are too little children, the overhead of a guard is too high"	(allNodesSize < 4) ifTrue: [ ^ false ].	size := ((1 to: 255) 	collect: [ :index | classification at: index ]							  	thenSelect: [ :e | e ]) size.	"if guard passes for so many characters, it is probably(!!!!!!) better not to guard"	(size > 250) ifTrue: [ ^ false ].									"for small parsers"	(allNodesSize < 20 and: [size > 128 ]) ifTrue: [ ^ false ].			"It is already guarded"	(self isWellGuarded: classification) ifTrue: [ ^ false ].		^ true! !!PP2GuardVisitor methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.		anythingClassification := (Array new: 255 withAll: true).	guarded := Stack with: anythingClassification.	! !!PP2GuardVisitor methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isGuarded	^ guarded isEmpty! !!PP2GuardVisitor methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isWellGuarded: classification	| topClassification changes |	topClassification := guarded top.	changes := 0.		topClassification with: classification do: [ :topC :localC |		localC ifTrue: [ self assert: topC ].		"is single change enough?"				(topC and: localC not) ifTrue: [  			changes := changes + 1.		].		].	^ changes == 0	"		(DiffMorph 		from: (topClassification joinUsing: Character lf) 		to: (classification joinUsing: Character lf)) openInWindow	"! !!PP2GuardVisitor methodsFor: 'support' stamp: '12/5/2016 22:12:51'!visit: node guardedWith: classification	guarded push: classification.	self visit: node.	guarded pop.	! !!PP2GuardVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitChoice: node	| alternatives classification |	alternatives := node children.	alternatives do: [ :alternative | 		classification := self classificationFor: alternative.		(self guardOf: classification makesSenseFor: alternative) ifTrue: [  			alternative strategy: (alternative strategy parsingGuard: classification).			self visit: alternative guardedWith: classification		] ifFalse: [  			self visit: alternative		]	].! !!PP2GuardVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitDelegate: node	| classification |	(node children size = 1) ifFalse: [ ^ super visitDelegate: node ].		classification := self classificationFor: node.	(self guardOf: classification makesSenseFor: node) ifTrue: [  		node strategy: (node strategy parsingGuard: classification).		self visit: node child guardedWith: classification	] ifFalse: [  		self visit: node child	]! !!PP2GuardVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitOptional: node	| classification |	"we get classification for the child, because classification for myself contains contains only 'true'"	classification := self classificationFor: node child.	(self guardOf: classification makesSenseFor: node) ifTrue: [  		node strategy: (node strategy parsingGuard: classification).		self visit: node child guardedWith: classification	] ifFalse: [		self visit: node child	]! !!PP2GuardVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPossesiveRepeating: node	| classification |		classification := self classificationFor: node child.	(self guardOf: classification makesSenseFor: node) ifTrue: [ 		node strategy: (node strategy parsingGuard: classification).	].		"repetition is kind of sequence, so all but first are not really guarded"	self visitUnguarded: node child! !!PP2GuardVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSequence: node	self visit: node firstChild.		node children allButFirst do: [ :child |		self visitUnguarded: child.	].! !!PP2GuardVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitTrimming: node	| trimmerClassification topClassification childClassification |	trimmerClassification := self classificationFor: node trimmer.	childClassification := self classificationFor: node child. 	topClassification := guarded top copy.		1 to: 255 do: [ :index |		| topC trimC childC |		topC := topClassification at: index.		trimC := trimmerClassification at: index.		childC := childClassification at: index.				"child is not, but top is"		(childC not and: topC) ifTrue: [  			"actually, caused by trimmer"			trimC ifTrue: [ topClassification at: index put: false ]		]	].	"visit the child without the classification caused by trimmer"	self visit: node child guardedWith: topClassification! !!PP2GuardVisitor methodsFor: 'support' stamp: '12/5/2016 22:12:51'!visitUnguarded: node	^ self visit: node guardedWith: anythingClassification ! !!PP2IsNullableCache methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!propertySymbol	^ #isNullable! !!PP2IsNullableVisitor methodsFor: 'loop control' stamp: '12/5/2016 22:12:51'!openedResultFor: node	"		JK: I am not sure, but this should never happen. If this happens, the grammar 			 contains an infinite loop.						If you think I am wrong, you probably also know what to return (I don't).	"	self error: 'There seems to be a left recursive loop in your grammar!!'! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAction: node	^ node propertyAt: #isNullable ifAbsent: [ 		self visit: node child 	]! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAdaptable: node	^ node propertyAt: #isNullable ifAbsent: [ 		"Be conservative, we don't know for sure, so it is safer to report false"		false	]! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAnd: node	^ node propertyAt: #isNullable ifAbsent: [ 		self visit: node child 	]! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitChoice: node	^ node propertyAt: #isNullable ifAbsent: [ 		node children anySatisfy: [ :child | self visit: child  ]	]! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitComposite: node	^ node propertyAt: #isNullable ifAbsent: [ 		self visit: node child 	]! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitDelegate: node	^ node propertyAt: #isNullable ifAbsent: [ 		self visit: node child	]! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEnd: node	^ node propertyAt: #isNullable ifAbsent: [ 		self visit: node child	]! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEndOfInput: node	^ false! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEpsilon: node	^ true! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitFailing: node	^ false! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitFlatten: node	^ self visitDelegate: node! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitLiteralObject: node	^ false! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitLiteralSequence: node	^ node literal isEmpty! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitMapping: node	^ self visitDelegate: node! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitMatch: node	^ self visitDelegate: node! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitNonEpsilon: node	^ false! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitNot: node	^ node propertyAt: #isNullable ifAbsent: [ 		false	]! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitOptional: node	^ true! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPP2Node: node	self error: 'should provide specific implementation'! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPluggable: node	^ node propertyAt: #isNullable ifAbsent: [ 		"Be conservative, we dont know for sure, so it is safer to report true"		false	]! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPop: node	^ self visitDelegate: node! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPossesiveRepeating: node	^ node propertyAt: #isNullable ifAbsent: [ 		(node min == 0) ifTrue: [			true		] ifFalse: [ 			self visit: node child		]	]! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPredicateObject: node	^ false! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPush: node	^ self visitDelegate: node! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSea: node	^ self visit: node island! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSequence: node	^ node propertyAt: #isNullable ifAbsent: [ 		node children allSatisfy: [ :child | self visit: child  ]	]! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitStartOfLine: node	^ false! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitToken: node	^ self visitDelegate: node! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitTrimming: node	^ self visitDelegate: node! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitWater: node	^ self visit: node boundary! !!PP2IsNullableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitWrapping: node	^ node propertyAt: #isNullable ifAbsent: [ 		"Be conservative, we don't know for sure, so it is safer to report false"		node doesFunctionalChanges ifTrue: [ false ] ifFalse: [ 			self visit: node child.		]	]! !!PP2NextSetsVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!add: aPP2Node to: node	| nextSet |	nextSet := nextSets at: node ifAbsentPut: [ IdentitySet new ].	(nextSets at: node) add: aPP2Node! !!PP2NextSetsVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!addAll: aCollection to: node	| nextSet |	nextSet := nextSets at: node ifAbsentPut: [ IdentitySet new ].	(nextSets at: node) addAll: aCollection! !!PP2NextSetsVisitor methodsFor: 'caching' stamp: '12/5/2016 22:12:51'!context: node	^ PP2NextSetsContext new		node: node;		currentNext: currentNext;		yourself! !!PP2NextSetsVisitor methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.		eoi := PP2EndOfInputNode new.	nextSets := IdentityDictionary new.		"make sure the current next is immutable, otherwise you will have a non-deterministic behaviour"	currentNext := IdentitySet with: eoi.! !!PP2NextSetsVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!nextSetFor: node	^ nextSets at: node ifAbsentPut: [ IdentitySet new ]! !!PP2NextSetsVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!nextSets	^ nextSets! !!PP2NextSetsVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parentNextSet	self isRoot ifTrue: [  		^ IdentitySet with: eoi	].	^ nextSets at: self parentContext node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAction: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAdaptable: node	self addAll: currentNext to: node.	"should I visit children or not?"	! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAnd: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitChildrenOf: node	node children do: [ :child | self visit: child ]! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitChoice: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitComposite: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitDelegate: node	self addAll: currentNext to: node.	self visitChildrenOf: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEnd: node	self addAll: currentNext to: node.	"TODO JK: not sure if to add #eoi asPParser"	self visitChildrenOf: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEndOfInput: node	self addAll: currentNext to: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitEpsilon: node	self addAll: currentNext to: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitFailing: node	self addAll: currentNext to: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitFlatten: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitLiteralObject: node	self addAll: currentNext to: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitLiteralSequence: node	self addAll: currentNext to: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitMapping: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitMatch: node	^ self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitNonEpsilon: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitNot: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitOptional: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPP2Node: node	self error: 'should provide specific implementation'! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPop: node	^ self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: 'JanKurs 12/5/2016 22:16'!visitPossesiveRepeating: node	| oldNext |	self addAll: currentNext to: node.	oldNext := currentNext.	currentNext := IdentitySet with: node.	currentNext addAll: oldNext.		self visitChildrenOf: node.		currentNext := oldNext! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPredicateObject: node	self addAll: currentNext to: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPush: node	^ self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSea: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSequence: node	| oldNext |	self addAll: currentNext to: node.	oldNext := currentNext.			node children reversed do: [ :child |		self visit: child.		child isNullable ifFalse: [ currentNext := IdentitySet new ].		currentNext := currentNext copy add: child; yourself	].	currentNext := oldNext! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitToken: node	self visitDelegate: node! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitTrimming: node	self addAll: currentNext to: node.	self visit: node child! !!PP2NextSetsVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitWater: node	self addAll: currentNext to: node.	self visitChildrenOf: node! !!PP2NoopVisitor methodsFor: 'hooks' stamp: '12/5/2016 22:12:51'!afterAccept: context result: result! !!PP2NoopVisitor methodsFor: 'hooks' stamp: '12/5/2016 22:12:51'!beforeAccept: context! !!PP2NoopVisitor methodsFor: 'caching' stamp: '12/5/2016 22:12:51'!cacheResult: anObject for: context	cache at: context ifPresent: [ self error: 'already cached' ].		cache at: context put: anObject! !!PP2NoopVisitor methodsFor: 'caching' stamp: '12/5/2016 22:12:51'!cachedResultFor: context	^ cache at: context ! !!PP2NoopVisitor methodsFor: 'visiting - utilities' stamp: '12/5/2016 22:12:51'!close: context	self assert: (self isOpened: context).	self assert: (self isClosed: context) not.	self assert: (openStack top == context).		openSet remove: context.	openStack pop.	closeSet add: context.! !!PP2NoopVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!closedSet	^ closeSet ! !!PP2NoopVisitor methodsFor: 'caching' stamp: '12/5/2016 22:12:51'!context: node	^ PP2NoopContext new		node: node;		yourself! !!PP2NoopVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!currentContext	^ openStack top! !!PP2NoopVisitor methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	cache := Dictionary new.	openSet := Set new.	closeSet := Set new.		"to manage parents"	openStack := Stack with: self rootContext.! !!PP2NoopVisitor methodsFor: 'visiting - utilities' stamp: '12/5/2016 22:12:51'!isClosed: context	^ closeSet includes: context ! !!PP2NoopVisitor methodsFor: 'visiting - utilities' stamp: '12/5/2016 22:12:51'!isOpened: context	^ openSet includes: context ! !!PP2NoopVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!isRoot	"(rootContext : currentContext)"	^ openStack size = 2! !!PP2NoopVisitor methodsFor: 'visiting - utilities' stamp: '12/5/2016 22:12:51'!nodeClosed: aPP2Parser	"nothing to do"! !!PP2NoopVisitor methodsFor: 'visiting - utilities' stamp: '12/5/2016 22:12:51'!nodeOpened: aPP2Parser	"nothing to do"! !!PP2NoopVisitor methodsFor: 'visiting - utilities' stamp: '12/5/2016 22:12:51'!open: context	self assert: (self isOpened: context) not.	openSet add: context.	openStack push: context! !!PP2NoopVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!openSet	^ openSet! !!PP2NoopVisitor methodsFor: 'loop control' stamp: '12/5/2016 22:12:51'!openedResultFor: context	^ #()! !!PP2NoopVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parentContext			"(rootContext : ... : parentContext : currentContext)"	^ openStack at: 2! !!PP2NoopVisitor methodsFor: 'caching' stamp: '12/5/2016 22:12:51'!rootContext	^ PP2NoopContext new		node: nil;		yourself! !!PP2NoopVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visit: node	| result context |	context := self context: node.		(self isClosed: context) ifTrue: [ 		self nodeClosed: node.		^ self cachedResultFor: context	].	(self isOpened: context) ifTrue: [		self nodeOpened: node.		^ self openedResultFor: context	].	self open: context.	self beforeAccept: context.	result := node accept: self.	self afterAccept: context result: result.	self cacheResult: result for: context.	self close: context.	^ result! !!PP2NoopVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPP2Node: node	node children do: [ :child | self visit: child ]	! !!PP2PackratVisitor methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!doPass: node	^ self visit: node	! !!PP2PackratVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPP2Node: node	(node shouldMemoize) ifTrue: [  		(node contextChanges isContextChange) ifTrue: [  			node addWarning: 'cannot memoize a node that changes context!!'		] ifFalse: [ 			node strategy: node strategy memoize		]	].	^ super visitPP2Node: node! !!PP2ParentAnalysisVisitor methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!doPass: node	^ self visit: node	! !!PP2ParentAnalysisVisitor methodsFor: 'visiting - utilities' stamp: '12/5/2016 22:12:51'!nodeClosed: node	self assert: parent isNil not.		node addParent: parent! !!PP2ParentAnalysisVisitor methodsFor: 'visiting - utilities' stamp: '12/5/2016 22:12:51'!nodeOpened: node	self assert: parent isNil not.		node addParent: parent! !!PP2ParentAnalysisVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPP2Node: node	| tmpParent |	parent isNil ifFalse: [ node addParent: parent ].	tmpParent := parent.	parent := node.	super visitPP2Node: node.	parent := tmpParent.! !!PP2RecognizerVisitor methodsFor: 'support' stamp: '12/5/2016 22:12:51'!changeStrategies: node	node allNodesDo: [ :child | 		self assert: (child hasProperty: #recognizer).		child recognizer ifTrue: [  			child strategy: child strategy recognizer		]	]! !!PP2RecognizerVisitor methodsFor: 'caching' stamp: '12/5/2016 22:12:51'!context: node	^ PP2RecognizerContext new		node: node;		inToken: self inToken;		parent: self currentContext node;		yourself! !!PP2RecognizerVisitor methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!doPass: node	self visit: node.	self changeStrategies: node	! !!PP2RecognizerVisitor methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!inToken	^ inToken top! !!PP2RecognizerVisitor methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.		inToken := Stack with: false! !!PP2RecognizerVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!markNode: node	self inToken ifTrue: [  		node markRecognizer.	] ifFalse: [ 		node markNoRecognizer.	]! !!PP2RecognizerVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parentsFor: node	^ parents at: node ifAbsentPut: [ IdentitySet new ]! !!PP2RecognizerVisitor methodsFor: 'caching' stamp: '12/5/2016 22:12:51'!rootContext	^ PP2RecognizerContext new! !!PP2RecognizerVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAction: node	self inToken ifTrue: [  		node warnActionInToken.		inToken push: false.		super visitAction: node.		inToken pop.	] ifFalse: [ 		super visitAction: node	]! !!PP2RecognizerVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitFlatten: node	self markNode: node.	self visitRecognizer: node child! !!PP2RecognizerVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPP2Node: node	self markNode: node.		super visitPP2Node: node! !!PP2RecognizerVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitRecognizer: node	inToken push: true.	self visit: node.	inToken pop! !!PP2RecognizerVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitToken: node	self markNode: node.	self visitRecognizer: node child! !!PP2RecognizerVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitTrimming: node	self markNode: node.	self visitRecognizer: node trimmer.	self visit: node child.! !!PP2ReparsableVisitor methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!doPass: node	^ self visit: node! !!PP2ReparsableVisitor methodsFor: 'asserting' stamp: '12/5/2016 22:12:51'!shouldMemoize: node	^ node propertyAt: #reparsable ifAbsent: [ false ]! !!PP2ReparsableVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPP2Node: node	(self shouldMemoize: node) ifTrue: [  		node strategy: node strategy reparsable	].		^ super visitPP2Node: node! !!PP2SeaOptimizationVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!beforeAccept: context	self isRoot ifTrue: [ rootNode := context node ].! !!PP2SeaOptimizationVisitor methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!doPass: node	^ self visit: node	! !!PP2SeaOptimizationVisitor methodsFor: 'seas optimizations' stamp: '12/5/2016 22:12:51'!nextSet: node	^ rootNode nextSets at: node! !!PP2SeaOptimizationVisitor methodsFor: 'seas optimizations' stamp: '12/5/2016 22:12:51'!optimizedNextSet: node	| nextSet |	nextSet := self nextSet: node.	nextSet := self removeSeas: nextSet.	nextSet := self removeRepetitions: nextSet.	nextSet := Set withAll: nextSet.		^ nextSet! !!PP2SeaOptimizationVisitor methodsFor: 'seas optimizations' stamp: '12/5/2016 22:12:51'!removeRepetitions: nextSet	"		finds standalne seas and replaces them with islands.		This helps the performance, because seas are not nested	"	| newNextSet |	newNextSet := IdentitySet new.		nextSet do: [ :node | 		(node isRepeating and: [ node min <= 1 ]) ifTrue: [ 			newNextSet add: node child 		] ifFalse: [  			newNextSet add: node		]	].	^ newNextSet! !!PP2SeaOptimizationVisitor methodsFor: 'seas optimizations' stamp: '12/5/2016 22:12:51'!removeSeas: nextSet	"		finds standalne seas and replaces them with islands.		This helps the performance, because seas are not nested	"	| newNextSet |	newNextSet := IdentitySet new.		nextSet do: [ :node | 		| firstSet |		firstSet := node firstSeasOrTerminalsSet.		self seaCanBeRemoved: firstSet ifTrue:  [ :sea |			newNextSet add: sea island		] ifFalse: [  			newNextSet add: node		]	].	^ newNextSet! !!PP2SeaOptimizationVisitor methodsFor: 'seas optimizations' stamp: '12/5/2016 22:12:51'!seaCanBeRemoved: firstSet ifTrue: oneArgBlock ifFalse: aBlock	"Single sea"	(( firstSet size = 1) and: [ 		firstSet anyOne isSea 	]) ifTrue: [ ^ oneArgBlock value: firstSet anyOne ].		"sea / epsilon"	(((firstSet size = 2) and: [ 		firstSet contains: [ :n | n isSea ] ]) and: [ 		firstSet contains: [ :n | n isEpsilon 	]]) ifTrue: [ ^ oneArgBlock value: (firstSet detect: [ :n | n isSea ]) ].	"sea / #eoi"	(((firstSet size = 2) and: [ 		firstSet contains: [ :n | n isSea ] ]) and: [ 		firstSet contains: [ :n | n isEOI	]]) ifTrue: [ ^ oneArgBlock value: (firstSet detect: [ :n | n isSea ]) ].		^ aBlock value! !!PP2SeaOptimizationVisitor methodsFor: 'seas optimizations' stamp: '12/5/2016 22:12:51'!updateNode: node	| nextSet |	nextSet := self optimizedNextSet: node.		node beforeWater boundaryElements: (OrderedCollection with: node island withAll: nextSet).	node afterWater boundaryElements: (OrderedCollection withAll: nextSet).	node root: rootNode.! !!PP2SeaOptimizationVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSea: node	super visitSea: node.	self updateNode: node.			"memoize, if there are seas in water"	node afterWater allNodes select: [ :n | n isSea ] thenDo: [ :sea |		sea isContextFree ifTrue: [ 			sea strategy: sea strategy memoize		]	].	^ node! !!PP2SpecializingVisitor methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!doPass: node	^ self visit: node	! !!PP2SpecializingVisitor methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isAndLiteralObject: node 	self assert: (node isKindOf: PP2AndNode).	^ (node child isKindOf: PP2LiteralObjectNode) ! !!PP2SpecializingVisitor methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isAndPredicateObject: node 	self assert: (node isKindOf: PP2AndNode).	^ (node child isKindOf: PP2PredicateObjectNode) ! !!PP2SpecializingVisitor methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isMappingOfThree: node 	self assert: (node isKindOf: PP2MappingNode).	^ (node child children size = 3) ! !!PP2SpecializingVisitor methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isMappingOfTwo: node 	self assert: (node isKindOf: PP2MappingNode).	^ (node child children size = 2) ! !!PP2SpecializingVisitor methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isNotLiteralObject: node 	self assert: (node isKindOf: PP2NotNode).	^ (node child isKindOf: PP2LiteralObjectNode) ! !!PP2SpecializingVisitor methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isNotPredicateObject: node 	self assert: (node isKindOf: PP2NotNode).	^ (node child isKindOf: PP2PredicateObjectNode) ! !!PP2SpecializingVisitor methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isOptionalCharacter: node 	^ (node child isKindOf: PP2LiteralObjectNode) ! !!PP2SpecializingVisitor methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isPlus: node 	^ node min = 1! !!PP2SpecializingVisitor methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isPlusPredicateObject: node 	^ (node min = 1) and: [ 	  (node max = SmallInteger maxVal) and: [ 	  node child isKindOf: PP2PredicateObjectNode 	]]! !!PP2SpecializingVisitor methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isStar: node 	^ node min = 0! !!PP2SpecializingVisitor methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isStarPredicateObject: node 	^ (node min = 0) and: [ 	  (node max = SmallInteger maxVal) and: [ 	  node child isKindOf: PP2PredicateObjectNode 	]]! !!PP2SpecializingVisitor methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isTrimmingLiteralObjectToken: node 	self assert: (node isKindOf: PP2TrimmingNode).		(node child isKindOf: PP2TokenNode) ifFalse: [ ^ false ].	^ (node child childSkipDelegate isKindOf: PP2LiteralObjectNode) 		"		self new isTrimmingLiteralObjectToken: $a asPParser token trim.	"! !!PP2SpecializingVisitor methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isTrimmingToken: node 	self assert: (node isKindOf: PP2TrimmingNode).	^ node child isKindOf: PP2TokenNode		"		self new isTrimmingToken: 'foo' asPParser token trim.	"! !!PP2SpecializingVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAdaptable: node	"do not visit beyond this point"! !!PP2SpecializingVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitAnd: node	(self isAndLiteralObject: node) ifTrue: [  		node strategy: (PP2AndLiteralObject on: node)	].	(self isAndPredicateObject: node) ifTrue: [  		node strategy: (PP2AndPredicateObject on: node)	].	^ super visitOptional: node! !!PP2SpecializingVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitMapping: node	(self isMappingOfTwo: node) ifTrue: [  		node strategy: (PP2MappingOfTwo on: node)	].	(self isMappingOfThree: node) ifTrue: [  		node strategy: (PP2MappingOfThree on: node)	].	^ super visitMapping: node! !!PP2SpecializingVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitNot: node	(self isNotLiteralObject: node) ifTrue: [  		node strategy: (PP2NotLiteralObject on: node)	].	(self isNotPredicateObject: node) ifTrue: [  		node strategy: (PP2NotPredicateObject on: node)	].	^ super visitOptional: node! !!PP2SpecializingVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitOptional: node	(self isOptionalCharacter: node) ifTrue: [  		node strategy: (PP2OptionalLiteralObject on: node)	].	^ super visitOptional: node! !!PP2SpecializingVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPossesiveRepeating: node	(self isStar: node) ifTrue: [  		node strategy: (PP2Star on: node)	].	(self isStarPredicateObject: node) ifTrue: [  		node strategy: (PP2StarPredicateObject on: node)	].	(self isPlus: node) ifTrue: [  		node strategy: (PP2Plus on: node)	].	(self isPlusPredicateObject: node) ifTrue: [  		node strategy: (PP2PlusPredicateObject on: node)	].	^ super visitPossesiveRepeating: node! !!PP2SpecializingVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitSequence: node	(node children size = 2) ifTrue: [  		node strategy: (PP2SequenceOfTwo on: node)	].	(node children size = 3) ifTrue: [  		node strategy: (PP2SequenceOfThree on: node)	].	^ super visitSequence: node! !!PP2SpecializingVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitTrimming: node	(self isTrimmingToken: node) ifTrue: [  		node strategy: (PP2TrimmingToken on: node)	].	(self isTrimmingLiteralObjectToken: node) ifTrue: [  		node strategy: (PP2TrimmingLiteralObjectToken on: node)	].	^ super visitTrimming: node! !!PP2TransformVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!block	^ block! !!PP2TransformVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!block: anObject	block := anObject! !!PP2TransformVisitor methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.	predicate := [ :node | true ].	block := [ :node | node ].		mapping := IdentityDictionary new.! !!PP2TransformVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!initializeMapping: rootNode	| transformed |		rootNode allNodesDo: [ :node |		transformed := node copy. 		(predicate value: node) ifTrue: [  			transformed := block value: transformed		].		mapping at: node put: transformed.	]! !!PP2TransformVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!openedResultFor: context	"when visiting opened node, return the transformed value"	^ self transformed: context node! !!PP2TransformVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!predicate	^ predicate! !!PP2TransformVisitor methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!predicate: anObject	predicate := anObject! !!PP2TransformVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!transformed: node	^ mapping at: node ifAbsent: [ node ].	! !!PP2TransformVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitPP2Node: node	| transformed transformedChild |	self isRoot ifTrue: [ self initializeMapping: node ].			transformed := self transformed: node.	transformed children do: [ :child |		transformedChild := self visit: child.		transformed replace: child with: transformedChild.	].	^ transformed! !!PP2TrimmingCacheVisitor methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!doPass: node	self flag: 'should add a trimming guard for the equivalent trimmers'.	(self usingSameTrimmer: node) ifTrue: [ 		self visit: node.	] ifFalse: [  		node warnDifferentTrimmer.	]! !!PP2TrimmingCacheVisitor methodsFor: 'optimizations' stamp: '12/5/2016 22:12:51'!usingSameTrimmer: node	| trimmings trimmers |	trimmings := node allNodes select: [ :c | c isTrimming ].		trimmers := trimmings collect: [ :e | e trimmer ].	^ (Set withAll: trimmers) size = 1! !!PP2TrimmingCacheVisitor methodsFor: 'visiting' stamp: '12/5/2016 22:12:51'!visitTrimming: node	node trimmer strategy: node trimmer strategy trimmingCache.		super visitTrimming: node! !!PP2NextSetsContext methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!= anotherContext	super = anotherContext ifFalse: [ ^ false ].		(self currentNext size = anotherContext currentNext size) ifFalse: [ ^ false ].	self currentNext do: [ :value |		(anotherContext currentNext includes: value) ifFalse: [ ^ false ]	].	^ true! !!PP2NextSetsContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!currentNext	^ currentNext! !!PP2NextSetsContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!currentNext: anObject	self assert: [ anObject class == IdentitySet ] description: 'if not, override the #hash and #='.	currentNext := anObject! !!PP2NextSetsContext methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!hash	| hash |	hash := super hash.	currentNext size <= 10 ifTrue: [  		currentNext do: [ :e | e identityHash ].	].	^ hash bitXor: currentNext size hash! !!PP2NoopContext class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!with: node	^ (self new)		node: node;		yourself! !!PP2NoopContext methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!= anotherContext	self class == anotherContext class ifFalse: [ ^ false ].	self node == anotherContext node ifFalse: [ ^ false ].		^ self properties = anotherContext properties! !!PP2NoopContext methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!hash	^ self node identityHash bitXor: (self properties hash)! !!PP2NoopContext methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize! !!PP2NoopContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!node	^ node! !!PP2NoopContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!node: anObject	node := anObject! !!PP2NoopContext methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!properties	^ properties! !!PP2NoopContext methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!properties: anObject	^ properties := anObject ! !!PP2RecognizerContext methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!= anotherContext	super = anotherContext ifFalse: [ ^ false ]	.	(self inToken == anotherContext inToken) ifFalse: [ ^ false ].	(self parent == anotherContext parent) ifFalse: [ ^ false ].		^ true! !!PP2RecognizerContext methodsFor: 'comparing' stamp: '12/5/2016 22:12:51'!hash	^ super hash bitXor: (self inToken hash bitXor: self parent identityHash)! !!PP2RecognizerContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!inToken	^ inToken! !!PP2RecognizerContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!inToken: anObject	inToken := anObject! !!PP2RecognizerContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parent	^ parent! !!PP2RecognizerContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parent: anObject	parent := anObject! !!PP2PopMemento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position	^ position! !!PP2PopMemento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position: anObject	position := anObject! !!PP2PopMemento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stackSize	^ stackSize! !!PP2PopMemento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stackSize: anObject	stackSize := anObject! !!PP2PopMemento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stackTop	^ top! !!PP2PopMemento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stackTop: anObject	top := anObject! !!PP2PushMemento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position	^ position! !!PP2PushMemento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position: anObject	position := anObject! !!PP2PushMemento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stackSize	^ stackSize! !!PP2PushMemento methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stackSize: anObject	stackSize := anObject! !!PP2Stream class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!new	"for compatibility reasons"	^ self basicNew		initialize! !!PP2Stream class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!on: collection	^ self new		collection: collection;		yourself! !!PP2Stream methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!adoptString: newString	collection := newString! !!PP2Stream methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asPetit2Context	^ PP2InMemoryContext on: self	collection! !!PP2Stream methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asPetit2Stream	^ self! !!PP2Stream methodsFor: 'context interface' stamp: '12/5/2016 22:12:51'!atEnd: position	^ collection size <= position! !!PP2Stream methodsFor: 'context interface' stamp: '12/5/2016 22:12:51'!atPosition: position	^ collection at: position! !!PP2Stream methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!collection	^ collection! !!PP2Stream methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!collection: aCollection	collection := aCollection! !!PP2Stream methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!contents	^ collection copyFrom: 1 to: collection size! !!PP2Stream methodsFor: 'context interface' stamp: '12/5/2016 22:12:51'!copyFrom: start to: end	"start - end should be in range <1, collection size> "	^ collection copyFrom: start to: end! !!PP2Stream methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize! !!PP2Stream methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isBuffered	^ false! !!PP2Stream methodsFor: 'tokenization' stamp: '12/5/2016 22:12:51'!newToken: tokenClass from: start to: stop	^ tokenClass 		on: collection 		start:  start		stop: 	stop! !!PP2Stream methodsFor: 'printing' stamp: '12/5/2016 22:12:51'!printOn: writeStream position: position	writeStream		nextPutAll: (collection copyFrom: 1 to: position);		nextPutAll: '';		nextPutAll: (collection copyFrom: position + 1 to: collection size)! !!PP2Stream methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!reset	! !!PP2Token class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!on: collection start: start stop: stop	^ self new		collection: collection;		start: start;		stop: stop;		yourself! !!PP2Token methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!collection	^ collection! !!PP2Token methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!collection: anObject	collection := anObject! !!PP2Token methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isToken	^ true! !!PP2Token methodsFor: 'printing' stamp: '12/5/2016 22:12:51'!printOn: aStream	self value printOn: aStream.	aStream nextPut: $[.	start printOn: aStream.	aStream nextPut: $,.	stop printOn: aStream.	aStream nextPut: $].! !!PP2Token methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!properties	^ properties! !!PP2Token methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!properties: newProperties	^ properties := newProperties! !!PP2Token methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!start	^ start! !!PP2Token methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!start: anObject	start := anObject! !!PP2Token methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stop	^ stop! !!PP2Token methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stop: anObject	stop := anObject! !!PP2Token methodsFor: 'printing' stamp: '12/5/2016 22:12:51'!toString	^ self value, '[', start, ',', stop ,']'! !!PP2Token methodsFor: 'evaluating' stamp: '12/5/2016 22:12:51'!value	^ collection copyFrom: start to: stop! !!PP2UnknownCharSetPredicate class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!instance	instance isNil ifTrue: [ 		instance := PP2UnknownCharSetPredicate new	].	^ instance! !!PP2UnknownCharSetPredicate methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isUnknown	^ true! !!PP2UnknownCharSetPredicate methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!value: aCharacter	self error: 'I don''t know, sorry man :('! !!PP2CharacterStream class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!on: stream encoder: encoder	^ (self basicNew initialize)		stream: stream;		encoder: encoder;		yourself! !!PP2CharacterStream methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!atEnd	^ stream atEnd! !!PP2CharacterStream methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!encoder	^ encoder! !!PP2CharacterStream methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!encoder: anObject	encoder := anObject! !!PP2CharacterStream methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!next	^ (encoder nextCodePointFromStream: stream) asCharacter! !!PP2CharacterStream methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stream	^ stream! !!PP2CharacterStream methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stream: anObject	stream := anObject! !!Stream methodsFor: '*petitparser2' stamp: '12/5/2016 22:12:51'!asPetit2Context	^ self asPetit2Stream asPetit2Context ! !!Stream methodsFor: '*petitparser2' stamp: '12/5/2016 22:12:51'!asPetit2Stream	^ PP2BufferStream 		on: self 		bufferSize: 4*1024! !!Symbol methodsFor: '*PetitParser2' stamp: '12/5/2016 22:12:51'!asPParser	"Answer a predicate parser named after the receiving symbol. Possible symbols are the method selectors on the class-side of PPPredicateObjectParser."	^ PP2NodeFactory instance perform: self! !!UndefinedObject methodsFor: '*PetitParser2' stamp: '12/5/2016 22:12:51'!asPParser	^ PP2EpsilonNode new! !!UndefinedObject methodsFor: '*PetitParser2' stamp: '12/5/2016 22:12:51'!isSeparator	^ false! !!SequenceableCollection methodsFor: '*PetitParser2' stamp: '12/5/2016 22:12:51'!asMapArgument	^ self! !!SequenceableCollection methodsFor: '*petitparser2' stamp: '12/5/2016 22:12:51'!asPetit2Context	^ PP2InMemoryContext on: self position: 0! !!SequenceableCollection methodsFor: '*petitparser2' stamp: '12/5/2016 22:12:51'!asPetit2Stream	^ PP2Stream on: self	"^ PP2BufferStream on: (ReadStream on: self)"! !!SequenceableCollection methodsFor: '*petitparser2' stamp: '12/5/2016 22:12:51'!asReparsableContext	^ PP2ReparsableContext on: self position: 0! !!String methodsFor: '*petitparser2' stamp: '12/5/2016 22:12:51'!asMapArgument	^ Array with: self! !!String methodsFor: '*petitparser2' stamp: '12/5/2016 22:12:51'!asPParser	"Answer a parser that accepts the receiving string."	^ PP2LiteralSequenceNode on: self! !!ManifestPetitParser class methodsFor: 'code-critics' stamp: '12/5/2016 22:12:51'!ruleRBBadMessageRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#'PP2CompositeNode class' #newStartingAt: #true)) #'2016-10-24T14:28:46.455507+02:00') )! !!ManifestPetitParser class methodsFor: 'code-critics' stamp: '12/5/2016 22:12:51'!ruleRBEquivalentSuperclassMethodsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#PP2InMemoryContext #position #false)) #'2016-10-07T18:25:00.082204+02:00') )! !!ManifestPetitParser class methodsFor: 'code-critics' stamp: '12/5/2016 22:12:51'!ruleRBIfTrueReturnsRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#PP2RecognizerContext #= #false)) #'2016-09-13T08:14:53.299834+02:00') )! !!ManifestPetitParser class methodsFor: 'code-critics' stamp: '12/5/2016 22:12:51'!ruleRBInconsistentMethodClassificationRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#PP2InMemoryContext #position #false)) #'2016-10-07T18:25:03.188553+02:00') )! !!ManifestPetitParser class methodsFor: 'code-critics' stamp: '12/5/2016 22:12:51'!ruleRBTemporaryVariableCapitalizationRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#PP2AdaptableGrammar)) #'2016-09-03T17:12:25.309317+02:00') )! !!ManifestPetitParser class methodsFor: 'code-critics' stamp: '12/5/2016 22:12:51'!ruleRBUtilityMethodsRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#PP2SeaOptimizationVisitor)) #'2016-10-31T11:33:08.539255+01:00') #(#(#RGClassDefinition #(#PP2PushMemoization)) #'2016-11-06T14:33:18.377189+01:00') #(#(#RGClassDefinition #(#PP2PopMemoization)) #'2016-11-06T14:33:41.427177+01:00') )! !!PP2InMemoryContext class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!new	^ self basicNew initialize! !!PP2InMemoryContext class methodsFor: 'instance creation' stamp: '12/5/2016 22:12:51'!on: aCollection position: position	^ (self on: aCollection) 		position: position;		setAsStartState;		yourself.! !!PP2InMemoryContext methodsFor: 'reparsing' stamp: '12/5/2016 22:12:51'!adoptString: newString	collection := newString.	readLimit := newString size.	self assert: readLimit isNotNil.! !!PP2InMemoryContext methodsFor: 'reparsing' stamp: '12/5/2016 22:12:51'!applyChange: change	change updateContext: self.	change updateTokens: self returnValue.	change updateParser: self parser! !!PP2InMemoryContext methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asPetit2Context	^ self! !!PP2InMemoryContext methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asPositionableStream	^ self! !!PP2InMemoryContext methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asReparsableContext	^ (PP2ReparsableContext on: collection)! !!PP2InMemoryContext methodsFor: 'copying' stamp: '12/5/2016 22:12:51'!copyFrom: start to: end	"start - end should be in range <1, collection size> "	^ collection copyFrom: start to: end! !!PP2InMemoryContext methodsFor: 'accessing-globals' stamp: '12/5/2016 22:12:51'!globals	^ globals! !!PP2InMemoryContext methodsFor: 'accessing-globals' stamp: '12/5/2016 22:12:51'!globals: anObject	^ globals := anObject! !!PP2InMemoryContext methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.		self setAsStartState! !!PP2InMemoryContext methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isPetit2Context	^ true! !!PP2InMemoryContext methodsFor: 'tokenization' stamp: '12/5/2016 22:12:51'!newToken: tokenClass from: start	^ tokenClass 		on: collection		start: start + 1		stop: position! !!PP2InMemoryContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!next: anInteger 	| endPosition |	endPosition := position + anInteger.	^ (endPosition <= readLimit) ifTrue: [ 		collection copyFrom: position+1 to: (position := endPosition).		] ifFalse: [  		nil	]! !!PP2InMemoryContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!nextFor: aCharacter	position == readLimit ifTrue: [ ^ false ].	position := position + 1.	^ (collection at: position) == aCharacter 		ifTrue: [  true] 		ifFalse: [position := position - 1 . false ]! !!PP2InMemoryContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parser	^ parser! !!PP2InMemoryContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parser: anObject	parser := anObject! !!PP2InMemoryContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!peek	"An improved version of peek, that is slightly faster than the built in version."	^ self atEnd ifFalse: [ collection at: position + 1 ]! !!PP2InMemoryContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position	^ position ! !!PP2InMemoryContext methodsFor: 'copying' stamp: '12/5/2016 22:12:51'!postCopy	super postCopy.		globals := globals copy.! !!PP2InMemoryContext methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!properties	^ properties! !!PP2InMemoryContext methodsFor: 'accessing - properties' stamp: '12/5/2016 22:12:51'!properties: newProperties	^ properties := newProperties! !!PP2InMemoryContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!readLimit	^ readLimit! !!PP2InMemoryContext methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!remember	^ PP2ContextMemento new		stream: self;		position: position;		properties: self propertiesCopy;		yourself.! !!PP2InMemoryContext methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!rememberPosition	^ position! !!PP2InMemoryContext methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!reset	super reset.	globals := nil! !!PP2InMemoryContext methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restore: contextMemento	position := contextMemento position.	properties := contextMemento propertiesCopy.! !!PP2InMemoryContext methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restorePosition: anInteger	position := anInteger ! !!PP2InMemoryContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!returnValue	^ returnValue! !!PP2InMemoryContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!returnValue: anObject	returnValue := anObject! !!PP2InMemoryContext methodsFor: 'stream extras' stamp: '12/5/2016 22:12:51'!shift	position := position + 1! !!PP2InMemoryContext methodsFor: 'stream extras' stamp: '12/5/2016 22:12:51'!shift: integer	position := position + integer! !!PP2InMemoryContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!startMemento	^ startMemento! !!PP2InMemoryContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!startMemento: anObject	startMemento := anObject! !!PP2InMemoryContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stream	^ self! !!PP2InMemoryContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stream: aPP2Stream	collection := aPP2Stream collection.	readLimit := collection size.	position := 0! !!PP2InMemoryContext methodsFor: 'stream extras' stamp: '12/5/2016 22:12:51'!uncheckedNext	position := position + 1.	^ collection at: position! !!PP2InMemoryContext methodsFor: 'stream extras' stamp: '12/5/2016 22:12:51'!uncheckedPeek	^ collection at: position + 1! !!PP2InMemoryContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!upTo: character	"fast version using indexOf:"	| start end |	start := position+1.	end := collection indexOf: character startingAt: start ifAbsent: [ 0 ].	"not present--return rest of the collection"		(end = 0 or: [end > readLimit]) ifTrue: [ ^ self upToEnd ].	"skip to the end and return the data passed over"	position := end.	^ collection copyFrom: start to: end! !!PP2InMemoryContext methodsFor: 'evaluating' stamp: '12/5/2016 22:12:51'!value	^ returnValue! !!PP2RecordingContext class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!smalltalkParserExample	<gtExample>	<label: 'smalltalkParser profiling context'>		| inputs parser parsingContext |	inputs := PP2Sources current smalltalkSourcesProfiling.	parser := PP2SmalltalkParser new optimize.	parsingContext := PP2RecordingContext new.		inputs do: [ :input |		parser parse: input withContext: parsingContext	].	^ parsingContext! !!PP2RecordingContext methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asCacheReport	| table |	table := OrderedCollection new. 	parser allCaches do: [ :c | 		table add: (Array with: c with: c hitRatio with: c invocations).	].	^ table! !!PP2RecordingContext methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asEventsMorph	^ eventsTrace 		selection: nil;		eventsMorph! !!PP2RecordingContext methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asFrequencyTable	| bag total result |	bag := (eventsTrace entriesCollect: #strategy) asBag.	result := OrderedCollection new.	bag isEmpty ifTrue: [ ^ result ].	total := 100.0 / bag size.	bag sortedCounts 		do: [ :each | result addLast: (Array with: each value with: each key with: total * each key) ].	^ result! !!PP2RecordingContext methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asFrequencyTableForEvent: event	| bag total result filtered |		filtered := OrderedCollection new.	eventsTrace entriesDo: [ :e | 		event == e event ifTrue: [ filtered add: e strategy ]	].		bag := filtered asBag.	result := OrderedCollection new.	bag isEmpty ifTrue: [ ^ result ].	total := 100.0 / bag size.	bag sortedCounts 		do: [ :each | result addLast: (Array with: each value with: each key with: total * each key) ].	^ result! !!PP2RecordingContext methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asReportTable	| backtrackPerCharacter restoreCount rememberCount table lwRememberCount lwRestoreCount lwBacktrackPerCharacter |	rememberCount := (self countFor: #remember).	restoreCount := (self countFor: #restore).	backtrackPerCharacter := (restoreCount / (totalSize max: 1) asFloat).	lwRememberCount := (self countFor: #rememberPosition).	lwRestoreCount := (self countFor: #restorePosition).	lwBacktrackPerCharacter := (lwRestoreCount / (totalSize max: 1) asFloat).	table := OrderedCollection new. 	table add: (Array with: totalSize with: #'total stream size' with: totalSize).	table add: (Array with: backtrackPerCharacter with: #'backtrack per character' with: backtrackPerCharacter).	table add: (Array with: rememberCount with: #'remember count' with: rememberCount).	table add: (Array with: restoreCount with: #'restore count' with: restoreCount).	table add: (Array with: lwBacktrackPerCharacter with: #'lightweight backtrack per character' with: lwBacktrackPerCharacter).	table add: (Array with: lwRememberCount with: #'lightweight remember count' with: lwRememberCount).	table add: (Array with: lwRestoreCount with: #'lightweight restore count' with: lwRestoreCount).	^ table! !!PP2RecordingContext methodsFor: 'recording' stamp: '12/5/2016 22:12:51'!cacheHit	self event: #cacheHit! !!PP2RecordingContext methodsFor: 'reporting' stamp: '12/5/2016 22:12:51'!countFor: event	| count |	count := 0.	self eventsTrace entriesDo: [ :e |		(e event == event) ifTrue: [ count := count + 1 ].	].	^ count! !!PP2RecordingContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!event: value	| entry |	entry := PP2EventRecord new		position: self position;		strategy: self strategy;		event: value;		yourself.			eventsTrace addLast: entry! !!PP2RecordingContext methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!eventsTable	| trace |	trace := OrderedCollection new.	1 to: (10*1000 min: eventsTrace entriesCount) do: [ :index | 		trace addLast: { 			(eventsTrace entryAt: index) position . 			(eventsTrace entryAt: index) event . 			(eventsTrace entryAt: index) strategy .			(eventsTrace entryAt: index) node 		}	].	^ trace! !!PP2RecordingContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!eventsTrace	^ eventsTrace ! !!PP2RecordingContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!furthestPosition	^ furthestPosition max: position! !!PP2RecordingContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!furthestPosition: anObject	furthestPosition := anObject! !!PP2RecordingContext methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.	self reset.! !!PP2RecordingContext methodsFor: 'reporting' stamp: '12/5/2016 22:12:51'!invocationCount	^  self countFor: #methodInvoked! !!PP2RecordingContext methodsFor: 'events' stamp: '12/5/2016 22:12:51'!invoked	| entry |	entry := PP2InvocationRecord new		position: self position;		strategy: self strategy;		event: #invoked;		yourself.			eventsTrace addLast: entry! !!PP2RecordingContext methodsFor: 'testing' stamp: '12/5/2016 22:12:51'!isRecording	^ true! !!PP2RecordingContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!lastDebugResult	^ (self currentDebugResult children) isEmpty ifTrue: [ 		nil	] ifFalse: [		self currentDebugResult children last	]! !!PP2RecordingContext methodsFor: 'events' stamp: '12/5/2016 22:12:51'!namedInvoked	| entry |	entry := PP2InvocationRecord new		position: self position;		strategy: self strategy;		event: #namedInvoked;		yourself.			eventsTrace addLast: entry! !!PP2RecordingContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!next	self event: #next.	furthestPosition := (furthestPosition max: position + 1).		^ super next! !!PP2RecordingContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!next: number	self event: #next.	furthestPosition := (furthestPosition max: position + number).		^ super next: number! !!PP2RecordingContext methodsFor: 'private' stamp: '12/5/2016 22:12:51'!node	^ (thisContext findContextSuchThat: [ :ctxt | (ctxt receiver isKindOf: PP2AbstractStrategy)])		ifNil: [ nil ]		ifNotNil: [ :aContext |			aContext receiver node		].	! !!PP2RecordingContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!parser: aPP2Node	super parser: aPP2Node.		"Transform to recording strategies"	aPP2Node enableRecording.! !!PP2RecordingContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!position: value	self assert: value isInteger.	super position: value! !!PP2RecordingContext methodsFor: 'events' stamp: '12/5/2016 22:12:51'!remember	self event: #remember.	^ super remember! !!PP2RecordingContext methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!rememberPosition	self event: #rememberPosition.	^ super rememberPosition! !!PP2RecordingContext methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!reset	super reset.		eventsTrace := PP2EventsTrace new.	furthestPosition := -1.	totalSize := 0.! !!PP2RecordingContext methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restore: whatever	self event: #restore.	furthestPosition := (furthestPosition max: position).	^ super restore: whatever! !!PP2RecordingContext methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restorePosition: newPosition	self event: #restorePosition.	furthestPosition := (furthestPosition max: position).		^ super restorePosition: newPosition! !!PP2RecordingContext methodsFor: 'requirements' stamp: '12/5/2016 22:12:51'!setAsStartState	^ self startMemento: super remember! !!PP2RecordingContext methodsFor: 'private' stamp: '12/5/2016 22:12:51'!strategy	^ (thisContext findContextSuchThat: [ :ctxt | (ctxt receiver isKindOf: PP2AbstractStrategy)])		ifNil: [ PP2NilStrategy new ]		ifNotNil: [ :aContext | aContext receiver ].	! !!PP2RecordingContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!stream: aStream	super stream: aStream.	totalSize := totalSize + readLimit.! !!PP2RecordingContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!totalSize	^ totalSize! !!PP2RecordingContext methodsFor: 'events' stamp: '12/5/2016 22:12:51'!uncheckedNext	self event: #uncheckedNext.	^ super uncheckedNext! !!PP2RecordingContext methodsFor: 'events' stamp: '12/5/2016 22:12:51'!uncheckedPeek	self event: #uncheckedPeek.	^ super uncheckedPeek! !!PP2ReparsableContext methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!asReparsableContext	^ self! !!PP2ReparsableContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!furthestPosition	^ furthestPosition max: position! !!PP2ReparsableContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!furthestPosition: anObject	furthestPosition := anObject! !!PP2ReparsableContext methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!next: integer	furthestPosition := (furthestPosition max: position + integer).	^ super next: integer! !!PP2ReparsableContext methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!on: aCollection	furthestPosition := -1.	^ (super on: aCollection)! !!PP2ReparsableContext methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restore: contextMemento	furthestPosition := (furthestPosition max: position).	^ super restore: contextMemento! !!PP2ReparsableContext methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!restorePosition: contextMemento	furthestPosition := (furthestPosition max: position).	^ super restorePosition: contextMemento! !!PP2ReparsableContext methodsFor: 'converting' stamp: '12/5/2016 22:12:51'!startMemento: anObject	self assert: (anObject isKindOf: PP2ContextMemento).	super startMemento: anObject! !!PP2ReparsableContext methodsFor: 'memoization' stamp: '12/5/2016 22:12:51'!stream: aStream	super stream: aStream.	furthestPosition := position! !!Character methodsFor: '*petitparser2' stamp: '12/5/2016 22:12:51'!asPParser	"Answer a parser that accepts the receiving character."		^ PP2LiteralObjectNode on: self! !!PP2Stack methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!initialize	super initialize.		size := 0! !!PP2Stack methodsFor: 'removing' stamp: '12/5/2016 22:12:51'!pop	size := size - 1.	super pop! !!PP2Stack methodsFor: 'adding' stamp: '12/5/2016 22:12:51'!push: element	size := size + 1.	super push: element! !!PP2Stack methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!size	^ size! !!PositionableStream methodsFor: '*petitparser2' stamp: '12/5/2016 22:12:51'!asPetit2Stream	^ PP2Stream on: collection! !!Text methodsFor: '*PetitParser2' stamp: '12/5/2016 22:12:51'!asPetit2Stream	^ string asPetit2Stream! !!BlockClosure methodsFor: '*PetitParser2' stamp: '12/5/2016 22:12:51'!asCharSetPredicate	^ PP2CharSetPredicate on: self! !!BlockClosure methodsFor: '*PetitParser2' stamp: '12/5/2016 22:12:51'!asPParser	"Answer a parser implemented in the receiving one-argument block."	^ PP2PluggableNode on: self! !!Collection methodsFor: '*PetitParser2' stamp: '12/5/2016 22:12:51'!nodesDo: aBlock	self do: aBlock! !!PP2ReadKeysExample class methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!example	<example>	"Start typing into the window. You will see that the parser is happy when you write 'petit' :) "	self new open! !!PP2ReadKeysExample methodsFor: 'morphic ui' stamp: '12/5/2016 22:12:51'!buildWindow	self addMorph: textArea fullFrame: (LayoutFrame new topFraction: 0.2).						self addMorph: keyMorph fullFrame: LayoutFrame identity.! !!PP2ReadKeysExample methodsFor: 'open/close' stamp: '12/5/2016 22:12:51'!close	keyMorph close.	super close		! !!PP2ReadKeysExample methodsFor: 'accessing' stamp: '12/5/2016 22:12:51'!contents	^ stream contents! !!PP2ReadKeysExample methodsFor: 'initialize' stamp: '12/5/2016 22:12:51'!initialize	super initialize.		stream := String new writeStream.	keyMorph := PP2ReadKeysMorph new.	textArea := self textMorph.	keyMorph outputStream: self.		self buildWindow.! !!PP2ReadKeysExample methodsFor: 'stream mimicry' stamp: '12/5/2016 22:12:51'!nextPutAll: aString	stream nextPutAll: aString.	self changed: #contents.! !!PP2ReadKeysExample methodsFor: 'open/close' stamp: '12/5/2016 22:12:51'!open	super open.	keyMorph takeKeyboardFocus.	keyMorph startParsing.	! !!PP2ReadKeysExample methodsFor: 'morphic ui' stamp: '12/5/2016 22:12:51'!textMorph	| textMorph |	textMorph := RubPluggableTextMorph new		beWrapped;		getTextSelector: #contents;		on: self;		yourself.	textMorph hasUnacceptedEdits: false.	self nextPutAll: 'Keep focus on the blue area and start typing.		- as you type, parsing is happening (the input is NOT reparsed with every key stroke!!)		- whenever the "petit" sequence is recognized, the info morph appears'.	^ textMorph! !!PP2ReadKeysMorph methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!close	keyStream close! !!PP2ReadKeysMorph methodsFor: 'event handling' stamp: '12/5/2016 22:12:51'!handlesKeyboard: evt	^ true! !!PP2ReadKeysMorph methodsFor: 'event handling' stamp: '12/5/2016 22:12:51'!handlesMouseDown: evt	^ true! !!PP2ReadKeysMorph methodsFor: 'initialization' stamp: '12/5/2016 22:12:51'!initialize	super initialize.		keyStream := PP2AsyncStream new.	outputStream := Transcript.! !!PP2ReadKeysMorph methodsFor: 'event handling' stamp: '12/5/2016 22:12:51'!keyStroke: anEvent	outputStream nextPutAll: 'event: ', anEvent asString, String cr.		keyStream queueChar: anEvent keyCharacter.! !!PP2ReadKeysMorph methodsFor: 'event handling' stamp: '12/5/2016 22:12:51'!mouseDown: evt 	self takeKeyboardFocus! !!PP2ReadKeysMorph methodsFor: 'event handling' stamp: '12/5/2016 22:12:51'!openInWorld	super openInWorld.	self startParsing.! !!PP2ReadKeysMorph methodsFor: 'as yet unclassified' stamp: '12/5/2016 22:12:51'!outputStream: aStream	outputStream := aStream! !!PP2ReadKeysMorph methodsFor: 'initialize' stamp: '12/5/2016 22:12:51'!startParsing	parser := 		(('petit' asPParser ==> [ :literal | 				GrowlMorph openWithLabel: '"petit" detected' contents: '' ]) / 		  #any asPParser		) star. 		[ 			Transcript crShow: 'parsing'. 		parser parse: keyStream. 		Transcript crShow: 'parsing finished' 	] fork.! !!PP2ReadKeysMorph methodsFor: 'event handling' stamp: '12/5/2016 22:12:51'!takesKeyboardFocus	^ true! !!Trait method!afterAccept: ctx result: result	ctx node propertyAt: self propertySymbol ifAbsentPut: result! !!Trait method!afterAccept: ctx result: result	ctx node propertyAt: self propertySymbol ifAbsentPut: result! !!Trait method!afterAccept: ctx result: result	ctx node propertyAt: self propertySymbol ifAbsentPut: result! !!Trait method!afterAccept: ctx result: result	ctx node propertyAt: self propertySymbol ifAbsentPut: result! !!Trait method!doPass: node	| children child |	self visit: node.	children := node allNodes.		[child := children detect: [ :e | (e hasProperty: self propertySymbol) not ] 							ifNone: [ nil ] ] whileNotNil: [ 				self visit: child	]! !!Trait method!doPass: node	| children child |	self visit: node.	children := node allNodes.		[child := children detect: [ :e | (e hasProperty: self propertySymbol) not ] 							ifNone: [ nil ] ] whileNotNil: [ 				self visit: child	]! !!Trait method!doPass: node	| children child |	self visit: node.	children := node allNodes.		[child := children detect: [ :e | (e hasProperty: self propertySymbol) not ] 							ifNone: [ nil ] ] whileNotNil: [ 				self visit: child	]! !!Trait method!doPass: node	| children child |	self visit: node.	children := node allNodes.		[child := children detect: [ :e | (e hasProperty: self propertySymbol) not ] 							ifNone: [ nil ] ] whileNotNil: [ 				self visit: child	]! !!Trait method!propertySymbol	self explicitRequirement! !!Trait method!propertySymbol	self explicitRequirement! !!Trait method!propertySymbol	self explicitRequirement! !!Trait method!propertySymbol	self explicitRequirement! !!Trait method!applyChange: change	change updateContext: self.	change updateTokens: self returnValue.	change updateParser: self parser! !!Trait method!applyChange: change	change updateContext: self.	change updateTokens: self returnValue.	change updateParser: self parser! !!Trait method!currentDebugResult	^ self globalAt: #debugResult ifAbsentPut: [ PP2DebugResult new context: self; yourself ]! !!Trait method!currentDebugResult	^ self globalAt: #debugResult ifAbsentPut: [ PP2DebugResult new context: self; yourself ]! !!Trait method!currentDebugResult: anObject	self globalAt: #debugResult put: anObject ! !!Trait method!currentDebugResult: anObject	self globalAt: #debugResult put: anObject ! !!Trait method!debugResult	^ self globalAt: #debugResult ifAbsentPut: [ 		self restore: self startMemento.		self parser enableDebug parseWithContext: self.		self currentDebugResult	]! !!Trait method!debugResult	^ self globalAt: #debugResult ifAbsentPut: [ 		self restore: self startMemento.		self parser enableDebug parseWithContext: self.		self currentDebugResult	]! !!Trait method!defaultStack	^ self stackNamed: #defaultStack! !!Trait method!defaultStack	^ self stackNamed: #defaultStack! !!Trait method!isRecording	^ false! !!Trait method!isRecording	^ false! !!Trait method!parsedValue	"to provide some compatibility with PPToken"	^ self returnValue! !!Trait method!parsedValue	"to provide some compatibility with PPToken"	^ self returnValue! !!Trait method!position	self explicitRequirement! !!Trait method!position	self explicitRequirement! !!Trait method!returnValue	self explicitRequirement! !!Trait method!returnValue	self explicitRequirement! !!Trait method!returnValue: anObject	self explicitRequirement! !!Trait method!returnValue: anObject	self explicitRequirement! !!Trait method!setAsStartState	self startMemento: self remember! !!Trait method!setAsStartState	self startMemento: self remember! !!Trait method!stackNamed: identifier	^ self propertyAt: identifier ifAbsentPut: [ PP2Stack new ]! !!Trait method!stackNamed: identifier	^ self propertyAt: identifier ifAbsentPut: [ PP2Stack new ]! !!Trait method!start	^ self startMemento position! !!Trait method!start	^ self startMemento position! !!Trait method!startMemento	self explicitRequirement! !!Trait method!startMemento	self explicitRequirement! !!Trait method!startMemento: contextMemento	self explicitRequirement! !!Trait method!startMemento: contextMemento	self explicitRequirement! !!Trait method!stop	^ self position! !!Trait method!stop	^ self position! !!Trait method!waterPosition	^ self globalAt: #waterPosition ifAbsent: -1! !!Trait method!waterPosition	^ self globalAt: #waterPosition ifAbsent: -1! !!Trait method!waterPosition: anInteger	self globalAt: #waterPosition put: anInteger! !!Trait method!waterPosition: anInteger	self globalAt: #waterPosition put: anInteger! !!Trait method!debugResult	^ self globalAt: #debugResult ifAbsentPut: [ 		self restore: self startMemento.		self parser enableDebug parseWithContext: self.		self currentDebugResult	]! !!Trait method!debugResult	self explicitRequirement! !!Trait method!debugResult	^ self globalAt: #debugResult ifAbsentPut: [ 		self restore: self startMemento.		self parser enableDebug parseWithContext: self.		self currentDebugResult	]! !!Trait method!debugResult	self explicitRequirement! !!Trait method!globalAt: aKey	"Answer the global property value associated with aKey."		^ self globalAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!Trait method!globalAt: aKey	"Answer the global property value associated with aKey."		^ self globalAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!Trait method!globalAt: aKey ifAbsent: aBlock	"Answer the global property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ self globals isNil		ifTrue: [ aBlock value ]		ifFalse: [ self globals at: aKey ifAbsent: aBlock ]! !!Trait method!globalAt: aKey ifAbsent: aBlock	"Answer the global property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ self globals isNil		ifTrue: [ aBlock value ]		ifFalse: [ self globals at: aKey ifAbsent: aBlock ]! !!Trait method!globalAt: aKey ifAbsentPut: aBlock	"Answer the global property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self globalAt: aKey ifAbsent: [ self globalAt: aKey put: aBlock value ]! !!Trait method!globalAt: aKey ifAbsentPut: aBlock	"Answer the global property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self globalAt: aKey ifAbsent: [ self globalAt: aKey put: aBlock value ]! !!Trait method!globalAt: aKey put: anObject	"Set the global property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (self globals ifNil: [ self globals: (IdentityDictionary new: 1) ])		at: aKey put: anObject! !!Trait method!globalAt: aKey put: anObject	"Set the global property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (self globals ifNil: [ self globals: (IdentityDictionary new: 1) ])		at: aKey put: anObject! !!Trait method!globals	self explicitRequirement! !!Trait method!globals	self explicitRequirement! !!Trait method!hasGlobal: aKey	"Test if the global property aKey is present."		^ self globals notNil and: [ self globals includesKey: aKey ]! !!Trait method!hasGlobal: aKey	"Test if the global property aKey is present."		^ self globals notNil and: [ self globals includesKey: aKey ]! !!Trait method!removeGlobal: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeGlobal: aKey ifAbsent: [ self error: 'Property not found' ]! !!Trait method!removeGlobal: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeGlobal: aKey ifAbsent: [ self error: 'Property not found' ]! !!Trait method!removeGlobal: aKey ifAbsent: aBlock	"Remove the global property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	self globals isNil ifTrue: [ ^ aBlock value ].	answer := self globals removeKey: aKey ifAbsent: aBlock.	self globals isEmpty ifTrue: [ self globals: nil ].	^ answer! !!Trait method!removeGlobal: aKey ifAbsent: aBlock	"Remove the global property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	self globals isNil ifTrue: [ ^ aBlock value ].	answer := self globals removeKey: aKey ifAbsent: aBlock.	self globals isEmpty ifTrue: [ self globals: nil ].	^ answer! !!Trait method!hasProperty: aKey	"Test if the property aKey is present."		^ self properties notNil and: [ self properties includesKey: aKey ]! !!Trait method!hasProperty: aKey	"Test if the property aKey is present."		^ self properties notNil and: [ self properties includesKey: aKey ]! !!Trait method!hasProperty: aKey	"Test if the property aKey is present."		^ self properties notNil and: [ self properties includesKey: aKey ]! !!Trait method!hasProperty: aKey	"Test if the property aKey is present."		^ self properties notNil and: [ self properties includesKey: aKey ]! !!Trait method!hasProperty: aKey	"Test if the property aKey is present."		^ self properties notNil and: [ self properties includesKey: aKey ]! !!Trait method!hasProperty: aKey	"Test if the property aKey is present."		^ self properties notNil and: [ self properties includesKey: aKey ]! !!Trait method!properties	self explicitRequirement! !!Trait method!properties	self explicitRequirement! !!Trait method!properties	self explicitRequirement! !!Trait method!properties	self explicitRequirement! !!Trait method!properties	self explicitRequirement! !!Trait method!properties	self explicitRequirement! !!Trait method!properties: newProperties	self explicitRequirement! !!Trait method!properties: newProperties	self explicitRequirement! !!Trait method!properties: newProperties	self explicitRequirement! !!Trait method!properties: newProperties	self explicitRequirement! !!Trait method!properties: newProperties	self explicitRequirement! !!Trait method!properties: newProperties	self explicitRequirement! !!Trait method!propertiesCopy	self properties isNil ifTrue: [ ^ nil ].	^ self properties collect: #copy! !!Trait method!propertiesCopy	self properties isNil ifTrue: [ ^ nil ].	^ self properties collect: #copy! !!Trait method!propertiesCopy	self properties isNil ifTrue: [ ^ nil ].	^ self properties collect: #copy! !!Trait method!propertiesCopy	self properties isNil ifTrue: [ ^ nil ].	^ self properties collect: #copy! !!Trait method!propertiesCopy	self properties isNil ifTrue: [ ^ nil ].	^ self properties collect: #copy! !!Trait method!propertiesCopy	self properties isNil ifTrue: [ ^ nil ].	^ self properties collect: #copy! !!Trait method!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!Trait method!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!Trait method!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!Trait method!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!Trait method!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!Trait method!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!Trait method!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ self properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ self properties at: aKey ifAbsent: aBlock ]! !!Trait method!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ self properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ self properties at: aKey ifAbsent: aBlock ]! !!Trait method!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ self properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ self properties at: aKey ifAbsent: aBlock ]! !!Trait method!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ self properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ self properties at: aKey ifAbsent: aBlock ]! !!Trait method!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ self properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ self properties at: aKey ifAbsent: aBlock ]! !!Trait method!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ self properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ self properties at: aKey ifAbsent: aBlock ]! !!Trait method!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!Trait method!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!Trait method!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!Trait method!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!Trait method!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!Trait method!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!Trait method!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (self properties ifNil: [ self properties: (IdentityDictionary new: 1) ])		at: aKey put: anObject! !!Trait method!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (self properties ifNil: [ self properties: (IdentityDictionary new: 1) ])		at: aKey put: anObject! !!Trait method!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (self properties ifNil: [ self properties: (IdentityDictionary new: 1) ])		at: aKey put: anObject! !!Trait method!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (self properties ifNil: [ self properties: (IdentityDictionary new: 1) ])		at: aKey put: anObject! !!Trait method!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (self properties ifNil: [ self properties: (IdentityDictionary new: 1) ])		at: aKey put: anObject! !!Trait method!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (self properties ifNil: [ self properties: (IdentityDictionary new: 1) ])		at: aKey put: anObject! !!Trait method!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]! !!Trait method!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]! !!Trait method!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]! !!Trait method!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]! !!Trait method!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]! !!Trait method!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]! !!Trait method!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	self properties isNil ifTrue: [ ^ aBlock value ].	answer := self properties removeKey: aKey ifAbsent: aBlock.	self properties isEmpty ifTrue: [ self properties: nil ].	^ answer! !!Trait method!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	self properties isNil ifTrue: [ ^ aBlock value ].	answer := self properties removeKey: aKey ifAbsent: aBlock.	self properties isEmpty ifTrue: [ self properties: nil ].	^ answer! !!Trait method!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	self properties isNil ifTrue: [ ^ aBlock value ].	answer := self properties removeKey: aKey ifAbsent: aBlock.	self properties isEmpty ifTrue: [ self properties: nil ].	^ answer! !!Trait method!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	self properties isNil ifTrue: [ ^ aBlock value ].	answer := self properties removeKey: aKey ifAbsent: aBlock.	self properties isEmpty ifTrue: [ self properties: nil ].	^ answer! !!Trait method!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	self properties isNil ifTrue: [ ^ aBlock value ].	answer := self properties removeKey: aKey ifAbsent: aBlock.	self properties isEmpty ifTrue: [ self properties: nil ].	^ answer! !!Trait method!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	self properties isNil ifTrue: [ ^ aBlock value ].	answer := self properties removeKey: aKey ifAbsent: aBlock.	self properties isEmpty ifTrue: [ self properties: nil ].	^ answer! !!Trait method!cacheHit: context	self hits: self hits + 1.	context cacheHit.! !!Trait method!cacheHit: context	self hits: self hits + 1.	context cacheHit.! !!Trait method!cacheHit: context	self hits: self hits + 1.	context cacheHit.! !!Trait method!cacheHit: context	self hits: self hits + 1.	context cacheHit.! !!Trait method!hitRatio	^ self hits / (self invocations max: 1) asFloat! !!Trait method!hitRatio	^ self hits / (self invocations max: 1) asFloat! !!Trait method!hitRatio	^ self hits / (self invocations max: 1) asFloat! !!Trait method!hitRatio	^ self hits / (self invocations max: 1) asFloat! !!Trait method!hits	self explicitRequirement! !!Trait method!hits	self explicitRequirement! !!Trait method!hits	self explicitRequirement! !!Trait method!hits	self explicitRequirement! !!Trait method!hits: anInteger	self explicitRequirement! !!Trait method!hits: anInteger	self explicitRequirement! !!Trait method!hits: anInteger	self explicitRequirement! !!Trait method!hits: anInteger	self explicitRequirement! !!Trait method!initialize	super initialize.	self resetCounters.! !!Trait method!initialize	super initialize.	self resetCounters.! !!Trait method!initialize	super initialize.	self resetCounters.! !!Trait method!initialize	super initialize.	self resetCounters.! !!Trait method!invocation	self invocations: self invocations + 1! !!Trait method!invocation	self invocations: self invocations + 1! !!Trait method!invocation	self invocations: self invocations + 1! !!Trait method!invocation	self invocations: self invocations + 1! !!Trait method!invocations	self explicitRequirement! !!Trait method!invocations	self explicitRequirement! !!Trait method!invocations	self explicitRequirement! !!Trait method!invocations	self explicitRequirement! !!Trait method!invocations: anInteger	self explicitRequirement! !!Trait method!invocations: anInteger	self explicitRequirement! !!Trait method!invocations: anInteger	self explicitRequirement! !!Trait method!invocations: anInteger	self explicitRequirement! !!Trait method!isRecording	^ true! !!Trait method!isRecording	^ true! !!Trait method!isRecording	^ true! !!Trait method!isRecording	^ true! !!Trait method!recording	^ self! !!Trait method!recording	^ self! !!Trait method!recording	^ self! !!Trait method!recording	^ self! !!Trait method!resetCounters	self invocations: 0.	self hits: 0.! !!Trait method!resetCounters	self invocations: 0.	self hits: 0.! !!Trait method!resetCounters	self invocations: 0.	self hits: 0.! !!Trait method!resetCounters	self invocations: 0.	self hits: 0.! !"PetitParser2"!!TPP2AdaptableGrammarTest commentStamp: 'JanKurs 9/6/2016 14:04' prior: 0!TestSuite for PP2AdaptableGrammar!!TPP2ExpressionGrammarTest commentStamp: 'JanKurs 9/6/2016 14:04' prior: 0!TestSuite for PP2ExpressionGrammar!!ManifestPetitParserTests commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PP2MinimalStream commentStamp: 'JanKurs 9/3/2016 11:55' prior: 0!I provide a bare minimum of methods required by PP2 to be parsed:- atEnd- nextI can be converted to PP2Stream using the #asPetit2Stream!!TPP2AdaptableGrammarTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parserClass	^ PP2AdaptableGrammar! !!TPP2AdaptableGrammarTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testContent	self parse: '1_2__3___' rule: #content.	self fail: '1_2' rule: #content.! !!TPP2AdaptableGrammarTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testElement	self parse: '1a' rule: #element.	self parse: '2aa' rule: #element.	self fail: '2a' rule: #element.! !!TPP2AdaptableGrammarTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testElementNumberInBody	self parse: '10___4______' rule: #content.	self fail: '1_2' rule: #content.! !!TPP2AdaptableGrammarTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testHead	self parse: '1' rule: #head! !!TPP2CollectionAssertions methodsFor: 'assertions' stamp: ' 12/6/2016 07:12:31'!assert: aCollection allSatisfy: aBlock	self assert: (aCollection allSatisfy: aBlock)! !!TPP2CollectionAssertions methodsFor: 'assertions' stamp: ' 12/6/2016 07:12:31'!assert: aCollection anySatisfy: aBlock	self assert: (aCollection anySatisfy: aBlock)! !!TPP2CollectionAssertions methodsFor: 'assertions' stamp: ' 12/6/2016 07:12:31'!assert: aCollection includes: aBlock	self assert: (aCollection includes: aBlock)! !!TPP2CollectionAssertions methodsFor: 'assertions' stamp: ' 12/6/2016 07:12:31'!assert: aCollection noneSatisfy: aBlock	self assert: (aCollection noneSatisfy: aBlock)! !!TPP2ContextTest methodsFor: 'requirements' stamp: ' 12/6/2016 07:12:31'!contextOn: aString	self explicitRequirement! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAdoptString	| context |	context := self contextOn: 'foo'.		self assert: context contents equals: 'foo'.		context adoptString: 'bar'.	self assert: context contents equals: 'bar'.! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAtEnd	| context |	context := self contextOn: 'foo'.		self deny: context atEnd.	context next: 3.	self assert: context atEnd.! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testContents	| context |	context := self contextOn: 'foo'.		self assert: (context respondsTo: #contents).	self assert: context contents equals: 'foo'! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCopyGlobals	| context contextCopy |	context := self contextOn: 'foo'.	context globals: (IdentityDictionary newFromPairs: { #a . #b }).		contextCopy := context copy.		self assert: context globals equals: contextCopy globals.	self assert: context globals ~~ contextCopy globals.	! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testMemo	| context memento |	context := self contextOn: 'foobar'.	context propertyAt: #foo put: #bar.	memento := context remember.	context next.	context propertyAt: #bar put: #baz.	context propertyAt: #foo put: #bark.	context restore: memento.	self assert: context position equals: 0.	self deny: (context hasProperty: #bar).	self assert: (context propertyAt: #foo) equals: #bar.! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNext	| retval context |	context := self contextOn: 'foo'.		retval := context next: 3.	self assert: retval isPetit2Success.	self assert: retval equals: 'foo'.		retval := context next: 1.	self assert: retval isNil.		context position: 0.	retval := context next: 3.	self assert: retval isPetit2Success.	self assert: retval = 'foo'.! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNextAtEnd	| context retval |	context := self contextOn: 'foo'.		context position: 3.		retval := context next.	self assert: retval isNil.		self assert: context position equals: 3.! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testParser	| context parser |	parser := $a asPParser.		context := (self contextOn: 'bar')		parser: parser;		yourself.		self assert: context parser equals: parser.! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testRemember	| context memento |	context := self contextOn: 'foobar'.	context propertyAt: #foo put: #bar.	memento := context remember.	self assert: memento position equals: context position.	self assert: memento properties equals: context properties.	context propertyAt: #foo put: #baz.	self assert: (memento propertyAt: #foo) equals: #bar.! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testRestore	| context memento |	context := self contextOn: 'foobar'.	context propertyAt: #foo put: #bar.	memento := context remember.	context next.	context propertyAt: #foo put: #baz.	context propertyAt: #bar put: #baq.	context restore: memento.	self deny: (context hasProperty: #bar).	self assert: (context propertyAt: #foo) equals: #bar.	self assert: context position equals: 0.! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSuccess	| context |	context := (self contextOn: 'bar')		position: 1;		returnValue: #foo;		yourself.		self assert: context isPetit2Success.	self assert: context value == #foo.	self assert: context returnValue == #foo.	self assert: context atEnd not.	self assert: context uncheckedPeek == $a.! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUncheckedNext	| context retval |	context := self contextOn: 'foo'.		self assert: context position equals: 0.		retval := context uncheckedNext.	self assert: retval isPetit2Success.	self assert: retval equals: $f.	self assert: context position equals: 1.! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUncheckedPeek	| context |	context := self contextOn: 'foo'.			self assert: context uncheckedPeek == $f.		context position: 3.	self should: [context uncheckedPeek] raise: Error.	! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpTo	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upTo: $f.	self assert: context position equals: 1.	self assert: retval equals: 'f'.	! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpTo2	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upTo: $r.	self assert: context position equals: 6.	self assert: retval equals: 'foobar'.! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpTo3	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upTo: $x.	self assert: context position equals: 6.	self assert: retval equals: 'foobar'.! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpTo4	| context retval |	context := self contextOn: 'foof'.	context next.	self assert: context position equals: 1.			retval := context upTo: $f.	self assert: context position equals: 4.	self assert: retval equals: 'oof'.	! !!TPP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpToEnd	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upToEnd.	self assert: context position equals: 6.	self assert: retval equals: 'foobar'.	! !!TPP2ExpressionGrammarTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parserClass	^ PP2ExpressionGrammar ! !!TPP2ExpressionGrammarTest methodsFor: 'testing' stamp: ' 12/6/2016 07:12:31'!testAddition	self parse: '1 + 2' rule: #addition.	self parse: '1 + (2 + 3)' rule: #addition.		self parse: '1 + (2 * 3)' rule: #addition.					self fail: '1 * 2' rule: #addition.! !!TPP2ExpressionGrammarTest methodsFor: 'testing' stamp: ' 12/6/2016 07:12:31'!testMultiplication	self parse: '1 * 2' rule: #multiplication.	self parse: '1 * (2 + 3)' rule: #multiplication.		self parse: '1 * (2 * 3)' rule: #multiplication.					self fail: '1 + 2' rule: #multiplication.! !!TPP2ExpressionGrammarTest methodsFor: 'testing' stamp: ' 12/6/2016 07:12:31'!testNumber	self parse: '1' rule: #number.	self parse: '10' rule: #number.	self parse: '10.3' rule: #number.		self fail: 'foo' rule: #number.! !!TPP2ExpressionGrammarTest methodsFor: 'testing' stamp: ' 12/6/2016 07:12:31'!testParentheses	self parse: '(1)' rule: #parentheses.	self parse: '(1.2)' rule: #parentheses.! !!TPP2ExpressionGrammarTest methodsFor: 'testing' stamp: ' 12/6/2016 07:12:31'!testPrimary	self parse: '10.3' rule: #primary.	self parse: '(10.3)' rule: #primary.	self parse: '(1 * 2 + 3)' rule: #primary.! !!TPP2ExpressionGrammarTest methodsFor: 'testing' stamp: ' 12/6/2016 07:12:31'!testTerms	self parse: '1' rule: #terms.	self parse: '1 + 1' rule: #terms.	self parse: '1 * 1' rule: #terms.	self parse: '((1) * (2 + (3 + 4)))' rule: #terms.		self fail: '1 ^ 1' rule: #terms.! !!TPP2ExpressionParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNumber	self parse: '1' rule: #number to: 1.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testAction	| parser |	parser := #any asPParser ==> [:e | e asUppercase ].	self assert: parser parse: 'a' to: $A.	self assert: parser parse: 'b' to: $B! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testAnd	| parser |	parser := 'foo' asPParser, 'bar' asPParser and.	self		assert: parser		parse: 'foobar'		to: #('foo' 'bar')		end: 3.	self assert: parser fail: 'foobaz' end: 3.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testBlock	| parser |	parser := [ :ctx | 		self assert: (ctx isPetit2Context).		ctx next 	] asPParser.		self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: '' to: nil! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testChoice	| parser |	parser := $a asPParser / $b asPParser.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'ba' to: $b end: 1.	self assert: parser fail: ''.	self assert: parser fail: 'c'.	self assert: parser fail: 'ca'! !!TPP2ParseTest methodsFor: 'test - operators' stamp: ' 12/6/2016 07:12:31'!testDelimitedBy	| parser |	parser := $a asPParser delimitedBy: $b asPParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).	self assert: parser parse: 'ab' to: #($a $b).	self assert: parser parse: 'abab' to: #($a $b $a $b).	self assert: parser parse: 'ababab' to: #($a $b $a $b $a $b).		self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abc' to: #($a $b) end: 2.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.	self assert: parser parse: 'ababc' to: #($a $b $a $b) end: 4.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'c'! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testEnd	| parser |	parser := $a asPParser end.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''.	self assert: parser fail: 'aa' end: 1.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testEndLiteral	| parser |	parser := 'stuff' asPParser end.	self assert: parser parse: 'stuff' to: 'stuff'.	self assert: parser fail: 'stufff' end: 5.	self assert: parser fail: 'fluff'! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testEpsilon	| parser |	parser := nil asPParser.		self assert: parser parse: '' to: nil.		self assert: parser parse: 'a' to: nil end: 0.	self assert: parser parse: 'ab' to: nil end: 0! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testFailing	| parser |	parser := PP2FailingNode message: 'Plonk'.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'aa'.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testFlattenSequence	| parser |	parser := ($a asPParser, $b asPParser) flatten.		self assert: parser parse: 'ab' to: 'ab'.		self assert: parser fail: 'ac' end: 1.	self assert: parser fail: 'bc'! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testFragment	| fragment parser result |	fragment := $a asPParser plus fragment.	parser := fragment wrapped.		result := (self assert: parser parse: 'aa') returnValue.	self assert: result isPetit2Context.	self assert: result start equals: 0.	self assert: result stop equals: 2.	self assert: result parsedValue size equals: 2.	self assert: result parsedValue first equals: $a.		self assert: result parsedValue second equals: $a.	self assert: result parser == fragment.			self assert: parser fail: 'b'.	self assert: parser fail: ''.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testLiteralObject	| parser |	parser := $a asPParser.		self assert: parser literal equals: $a.	self assert: parser message equals: 'literal $a expected'.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testLiteralObjectCaseInsensitive	| parser |	parser := $a asPParser caseInsensitive.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'B'	! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testLiteralSequence	| parser |	parser := 'abc' asPParser.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser parse: 'abcd' to: 'abc' end: 3.	self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testLiteralSequenceCaseInsensitive	| parser |	parser := 'abc' asPParser caseInsensitive.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser parse: 'ABC' to: 'ABC'.	self assert: parser parse: 'abC' to: 'abC'.	self assert: parser parse: 'AbC' to: 'AbC'.		self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testMap	| parser |	parser := #any asPParser		map: [ :a | Array with: a ].	self assert: parser parse: 'a' to: #($a).	self assert: parser fail: ''.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testMapSequence	| parser |	parser := #any asPParser, #any asPParser		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: 'ab' to: #($b $a)! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testMapWrappedSequence	| parser |	parser := (#any asPParser, #any asPParser) wrapped		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: 'ab' to: #($b $a)! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testNot	| parser |	parser := 'foo' asPParser, 'bar' asPParser  not.		self assert: parser parse: 'foobaz' to: #('foo' nil) end: 3.	self assert: parser fail: 'foobar' end: 3! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testOptional	| parser |	parser := $a asPParser optional.		self assert: parser parse: '' to: nil.	self assert: parser parse: 'a' to: $a.		self assert: parser parse: 'aa' to: $a end: 1.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: nil end: 0.	self assert: parser parse: 'bb' to: nil end: 0.	self assert: parser parse: 'ba' to: nil end: 0! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testPlus	| parser |	parser := $a asPParser plus.	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'aab' to: #($a $a) end: 2.	self assert: parser parse: 'aaab' to: #($a $a $a) end: 3.			self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'ba'! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testPlus2	| parser |	parser := ($a asPParser, $b asPParser) plus.		self assert: parser parse: 'ab' to: #(#($a $b)).	self assert: parser fail: 'a' end: 1.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testPredicateAny	|  parser |		parser := #any asPParser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: Character null asString to: Character null.		self assert: parser fail: ''.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testPredicateDigit	|  parser |		parser := #digit asPParser.	self assert: parser parse: '1' to: $1.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '9' to: $9.	self assert: parser fail: 'a'.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testPredicateLetter	|  parser |		parser := #letter asPParser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ''.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testRepetitions	| parser result |	parser := ('foo' asPParser, ':=' asPParser) plus.		result := (self assert: parser parse: 'foo:=').		self assert: result value size equals: 1.	self assert: result value first equals: #('foo' ':=').		self assert: parser fail: 'foo' end: 3.! !!TPP2ParseTest methodsFor: 'test - operators' stamp: ' 12/6/2016 07:12:31'!testSeparatedBy	| parser |	parser := $a asPParser separatedBy: $b asPParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'abab' to: #($a $b $a) end: 3.	self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'c'! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testSequence	| parser |	parser := $a asPParser , $b asPParser.		self assert: parser parse: 'ab' to: #($a $b).		self assert: parser parse: 'aba' to: #($a $b) end: 2.	self assert: parser parse: 'abb' to: #($a $b) end: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a' end: 1.	self assert: parser fail: 'aa' end: 1.	self assert: parser fail: 'ba' end: 0.	self assert: parser fail: 'bab' end: 0! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testSequence2	| parser |	parser := ($a asPParser , $b asPParser) star, $a asPParser.	self assert: parser parse: 'a' to: (Array with: OrderedCollection new with: $a).	self assert: parser fail: 'ab' end: 2.	self assert: parser fail: ''.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testSequenceOfThree	| parser |	parser := $a asPParser , $b asPParser, $c asPParser.		self assert: parser parse: 'abc' to: #($a $b $c).	self assert: parser fail: 'ab' end: 2.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testStar	| parser |	parser := $a asPParser star.	self assert: parser parse: '' to: #().	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self		assert: parser		parse: 'b'		to: #()		end: 0.	self		assert: parser		parse: 'ab'		to: #($a)		end: 1.	self		assert: parser		parse: 'aab'		to: #($a $a)		end: 2.	self		assert: parser		parse: 'aaab'		to: #($a $a $a)		end: 3! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testTimes	| parser |	parser := $a asPParser times: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a' end: 1.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a) end: 2! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testToken	| parser |	parser := $a asPParser token.	self assert: parser parse: 'a'	toTokenValue: 'a'.			self assert: parser fail: 'b'.	self assert: parser fail: ''.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testTokenLiteral	| parser |	parser := 'foo' asPParser token.	self assert: parser parse: 'foo' toTokenValue: 'foo'.			self assert: parser fail: 'bar'.	self assert: parser fail: ''.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testTokenTrim	| parser |	parser := $a asPParser token trim.		self assert: parser parse: 'a' toTokenValue: 'a'.	self assert: parser parse: ' a' toTokenValue: 'a'.	self assert: parser parse: 'a ' toTokenValue: 'a' end: 2.	self assert: parser parse: ' a ' toTokenValue: 'a' end: 3.	self assert: parser parse: '  a  ' toTokenValue: 'a' end: 5.	self assert: parser fail: 'b'.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testTrim	| parser |	parser := 'a' asPParser trim.		self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: ' a' to: 'a'.	self assert: parser parse: 'a ' to: 'a' end: 2.	self assert: parser parse: ' a ' to: 'a' end: 3.	self assert: parser parse: '  a  ' to: 'a' end: 5.	self assert: parser fail: 'b'.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testWrapped	| parser |	parser := $a asPParser wrapped.		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testWrappedSequence	| parser |	parser := (($a asPParser , $b asPParser ) wrapped , $c asPParser).	self assert: parser parse: 'abc' to: #(#($a $b) $c)! !!TPP2ParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testWrapping	| parser |	parser := $a asPParser >=> [:c :cc | cc value].		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.! !!TPP2ReparsableAssertions methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!assert: aPP2Parser reparseWithContext: startContext	| resultContext |	resultContext := self parser optimize enableDebug reparseAdaptableWithContext: startContext.		self assert: resultContext isPetit2Success.	self assert: resultContext atEnd.		^ resultContext! !!TPP2ReparsableAssertions methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!fail: aPP2Parser reparseWithContext: startContext	| resultContext |	resultContext := self parser optimize enableDebug reparseAdaptableWithContext: startContext.		self assert: resultContext isPetit2Failure.		^ resultContext! !!TPP2ReparsableAssertions methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!parser	self explicitRequirement! !!TPP2SeaParserTest methodsFor: 'parse support' stamp: ' 12/6/2016 07:12:31'!emptySea	| nilSea |	nilSea := self seaInstance.	nilSea island: nil asPParser.	nilSea name: 'nil sea'.	^ nilSea! !!TPP2SeaParserTest methodsFor: 'parse support' stamp: ' 12/6/2016 07:12:31'!nestedBlock	| blockSea block nilIsland |	blockSea := self seaInstance.	nilIsland := (self emptySea ==> #first).		block := PP2DelegateNode new.	block child: (${ asPParser,  (blockSea plus / nilIsland), $} asPParser).	block name: 'block'.		blockSea island: block.	blockSea name: 'block island'.	^ block! !!TPP2SeaParserTest methodsFor: 'parse support' stamp: ' 12/6/2016 07:12:31'!result	self explicitRequirement! !!TPP2SeaParserTest methodsFor: 'parse support' stamp: ' 12/6/2016 07:12:31'!seaInstance	^ self explicitRequirement! !!TPP2SeaParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEOFBoundary	| sea |	sea := self seaInstance island: $a asPParser.		self assert: sea parse: '..a..'.	self assert: self result second equals: $a.	self assert: sea fail: '..'! !!TPP2SeaParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNestedBlockDeepNested	| block |	block := self nestedBlock.		self assert: block parse: '{ {} { {  } } }'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second size equals: 2.	self assert: self result second first size equals: 3.	self assert: self result second second size equals: 3.	self assert: self result third equals: $}.! !!TPP2SeaParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNestedBlockEmpty	| block |	block := self nestedBlock.		self assert: block parse: '{}'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second equals: #() asOrderedCollection.	self assert: self result third equals: $}.! !!TPP2SeaParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNestedBlockNested	| block |	block := self nestedBlock.		self assert: block parse: '{ {} }'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second size equals: 1.	self assert: self result second first size equals: 3.	self assert: self result third equals: $}.! !!TPP2SeaParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNestedBlockSpace	| block |	block := self nestedBlock.		self assert: block parse: '{ }'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second equals: #( $ ) asOrderedCollection.	self assert: self result third equals: $}.! !!TPP2SeaParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNilSea	| parser |	parser := self emptySea.		self assert: parser parse: ''.	self assert: self result first equals: #() asOrderedCollection.		self assert: parser parse: '...'.	self assert: self result first equals: #($. $. $.) asOrderedCollection.! !!TPP2SeaParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNilSeaPlus	| sea parser |	sea := self seaInstance island: nil asPParser.	parser := sea flatten nonEpsilon plus.		self assert: parser fail: ''.	self assert: parser parse: '...'.	self assert: self result size equals: 1.	self assert: self result first equals: '...'.! !!TPP2SeaParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNilSeaSequence	| sea sea2 parser |	sea := self seaInstance island: nil asPParser.	sea2 := self seaInstance island: nil asPParser.	parser := sea flatten, sea2 flatten.		self assert: parser parse: ''.	self assert: self result first equals: ''.		self assert: self result second equals: ''.		self assert: parser parse: '...'.	self assert: self result first equals: '...'.	self assert: self result second equals: ''.	! !!TPP2SeaParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNilSeaStar	| sea parser |	sea := self seaInstance island: #epsilon asPParser.	parser := sea flatten nonEpsilon star.		self assert: parser parse: ''.	self assert: self result isEmpty.	self assert: parser parse: '...'.	self assert: self result size equals: 1.	self assert: self result first equals: '...'.! !!TPP2SeaParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNullableBoundary	| parser sea |	sea := self seaInstance island: $a asPParser.	parser := sea, $b asPParser optional.		self assert: parser parse: '..a..'.	self assert: self result first second equals: $a.	self assert: parser parse: '..a..b'.	self assert: self result first second equals: $a.	self assert: parser fail: '..b'.	self assert: parser fail: '..'	.! !!TPP2SeaParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNullableIsland	| parser sea |	sea := self seaInstance island: nil asPParser.	parser := sea.		self assert: parser parse: '..'.	self assert: self result first equals: #($. $.) asOrderedCollection.	self assert: self result second equals: nil.	self assert: self result third equals: #() asOrderedCollection.	self assert: parser parse: ''.! !!TPP2SeaParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testOverlappingSeas	| seas seaOne seaTwo |	seaOne := self seaInstance island: $a asPParser.	seaTwo := self seaInstance island: $b asPParser.		seas := seaOne, seaTwo.		self assert: seas parse: '..a..b..'.	self assert: self result first second equals: $a.	self assert: self result second second equals: $b.		self assert: seas fail: '..b..a..b..'.	self assert: seas fail: '..a..'! !!TPP2SeaParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSeaPlus	| sea parser |	sea := self seaInstance island: $a asPParser.	parser := sea plus.	self assert: parser parse: '..a..a..a...'.	self assert: self result size equals: 3.		self assert: parser fail: '...'.! !!TPP2SeaParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSeaStar	| sea parser |	sea := self seaInstance island: $a asPParser.	parser := sea star.		self assert: parser parse: '..a..a..a...'.	self assert: self result size equals: 3.		self assert: parser parse: ''.	self assert: self result size equals: 0.	! !!TPP2StreamContextInterface methodsFor: 'tests - context interface' stamp: ' 12/6/2016 07:12:31'!testAtEnd	| stream |	stream := self streamOn: ''. 	self assert: (stream atEnd: 0).	self assert: (stream atEnd: 1).	stream := self streamOn: 'f'. 	self assert: (stream atEnd: 0) not.	self assert: (stream atEnd: 1).	self assert: (stream atEnd: 2).! !!TPP2StreamContextInterface methodsFor: 'tests - context interface' stamp: ' 12/6/2016 07:12:31'!testAtPosition	| stream |	stream := self streamOn: 'bar'. 		self assert: (stream atPosition: 1) = $b.	self assert: (stream atPosition: 2) = $a.	self assert: (stream atPosition: 3) = $r.! !!TPP2StreamContextInterface methodsFor: 'tests - context interface' stamp: ' 12/6/2016 07:12:31'!testAtPositionReversedOrder	| stream |	stream := self streamOn: 'bar'. 		self assert: (stream atPosition: 3) = $r.	self assert: (stream atPosition: 2) = $a.	self assert: (stream atPosition: 1) = $b.! !!TPP2StreamContextInterface methodsFor: 'tests - context interface' stamp: ' 12/6/2016 07:12:31'!testCopyFromTo	| stream |	stream := self streamOn: 'bar'.	self assert: (stream copyFrom: 1 to: 1) = 'b'.	self assert: (stream copyFrom: 1 to: 3) = 'bar'.! !!TPP2StreamContextInterface methodsFor: 'tests - context interface' stamp: ' 12/6/2016 07:12:31'!testNewTokenFromTo	| stream |	stream := self streamOn: 'foo'. 		self assert: (stream newToken: PP2Token from: 1 to: 3) value equals: 'foo'.! !!TPP2TypeAssertions methodsFor: 'assertions' stamp: ' 12/6/2016 07:12:31'!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!TPP2TypeAssertions methodsFor: 'assertions' stamp: ' 12/6/2016 07:12:31'!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!ManifestPetitParserTests class methodsFor: 'code-critics' stamp: ' 12/6/2016 07:12:31'!ruleRBBadMessageRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#PP2BufferStreamTest)) #'2016-04-02T11:47:21.362841+02:00') #(#(#RGClassDefinition #(#PP2DirectParseTest)) #'2016-04-03T14:06:27.898033+02:00') )! !!PP2AbstractParserTest class methodsFor: 'testing' stamp: ' 12/6/2016 07:12:31'!isAbstract	^ self name = #PP2AbstractParserTest! !!PP2AbstractParserTest class methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!packageNamesUnderTest	^ #('PetitParser' 'PetitTests')! !!PP2AbstractParserTest methodsFor: 'utilities' stamp: ' 12/6/2016 07:12:31'!assert: aParser fail: aCollection	^ self assert: aParser fail: aCollection end: 0! !!PP2AbstractParserTest methodsFor: 'utilities' stamp: ' 12/6/2016 07:12:31'!assert: aParser fail: aCollection end: anInteger	| stream result context |	self 		assert: aParser isPetit2Parser		description: 'Parser invalid'.	stream := aCollection asPetit2Stream.	context := self context.			result := self parse: stream withParser: aParser withContext: context.		self 		assert: result isPetit2Failure		description: 'Parser did not fail'.	self		assert: result position = anInteger		description: 'Parser failed at wrong position'.	^ result! !!PP2AbstractParserTest methodsFor: 'utilities' stamp: ' 12/6/2016 07:12:31'!assert: string1 includesSubstring: string2	"Support portability by using ANSI search method"	self assert: (string1 notEmpty and: [string2 notEmpty and: [0 < (string1 indexOfSubCollection: string2 startingAt: 1)]])! !!PP2AbstractParserTest methodsFor: 'utilities' stamp: ' 12/6/2016 07:12:31'!assert: aParser parse: aCollection	^ self assert: aParser parse: aCollection to: nil end: aCollection size ! !!PP2AbstractParserTest methodsFor: 'utilities' stamp: ' 12/6/2016 07:12:31'!assert: aParser parse: aCollection end: anInteger	^ self assert: aParser parse: aCollection to: nil end: anInteger! !!PP2AbstractParserTest methodsFor: 'utilities' stamp: ' 12/6/2016 07:12:31'!assert: aParser parse: aCollection to: anObject	^ self assert: aParser parse: aCollection to: anObject end: aCollection size ! !!PP2AbstractParserTest methodsFor: 'utilities' stamp: ' 12/6/2016 07:12:31'!assert: aParser parse: aCollection to: aTargetObject end: anInteger	| stream result ctx |	self assert: aParser isPetit2Parser description: 'Parser invalid'.	stream := aCollection asPetit2Stream.	ctx := self context.		result := self parse: stream withParser: aParser withContext: ctx.		aTargetObject isNil		ifTrue: [ self deny: result isPetit2Failure ]		ifFalse: [ self assert: result value asArray equals: aTargetObject asArray ].	self assert: result position = anInteger description: 'Parser accepted at wrong position'.	^ result! !!PP2AbstractParserTest methodsFor: 'utilities' stamp: ' 12/6/2016 07:12:31'!assert: aParser parse: aCollection toTokenValue: value	^ self assert: aParser parse: aCollection toTokenValue: value end: aCollection size! !!PP2AbstractParserTest methodsFor: 'utilities' stamp: ' 12/6/2016 07:12:31'!assert: aParser parse: aCollection toTokenValue: value end: end	| result |	result := self		assert: aParser		parse: aCollection		to: nil		end: end.	self assert: (result value isKindOf: PP2Token).	self assert: result value value equals: value.	^ result! !!PP2AbstractParserTest methodsFor: 'context' stamp: ' 12/6/2016 07:12:31'!context	^ PP2Context new! !!PP2AbstractParserTest methodsFor: 'initialization' stamp: ' 12/6/2016 07:12:31'!initialize	super initialize.! !!PP2AbstractParserTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parse: aStream withParser: aParser withContext: aContext	self subclassResponsibility! !!PP2AdaptableParseTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!context	context isNil ifTrue: [ 		context := super context	].	^ context! !!PP2AdaptableParseTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parse: aStream withParser: aParser withContext: aContext	^ aParser parseAdaptable: aStream withContext: aContext! !!PP2AdaptableParseTest methodsFor: 'test - context' stamp: ' 12/6/2016 07:12:31'!testMatch	| node |	node := $a asPParser match.		self context defaultStack push: $a.	self assert: node parse: 'a'.! !!PP2AdaptableParseTest methodsFor: 'test - context' stamp: ' 12/6/2016 07:12:31'!testMatchEmpty	| node |	node := $a asPParser match.		self assert: node fail: 'a'.! !!PP2AdaptableParseTest methodsFor: 'test - context' stamp: ' 12/6/2016 07:12:31'!testMatchFailure	| node |	node := $a asPParser match.		self context defaultStack push: $b.	self assert: node fail: 'b'.! !!PP2AdaptableParseTest methodsFor: 'test - context' stamp: ' 12/6/2016 07:12:31'!testMatchNoMatch	| node |	node := $a asPParser match.		self context defaultStack push: $b.	self assert: node fail: 'a'.! !!PP2AdaptableParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testNonEpsilon	|  parser |	parser := $a asPParser optional nonEpsilon.		self assert: parser fail: ''.	self assert: parser parse: 'a'! !!PP2AdaptableParseTest methodsFor: 'test - context' stamp: ' 12/6/2016 07:12:31'!testPop	| node |	node := nil asPParser pop.		self context defaultStack push: $a.	self assert: node parse: ''.	self assert: context defaultStack isEmpty.! !!PP2AdaptableParseTest methodsFor: 'test - context' stamp: ' 12/6/2016 07:12:31'!testPopStarOne	| node |	node := $a asPParser pop star.		self context defaultStack push: $a.	self assert: node parse: 'a'.	self assert: context defaultStack size equals: 0.! !!PP2AdaptableParseTest methodsFor: 'test - context' stamp: ' 12/6/2016 07:12:31'!testPopStarTwo	| node |	node := $a asPParser pop star.		self context defaultStack push: $a.	self context defaultStack push: $a.	self assert: node parse: 'aa'.	self assert: context defaultStack size equals: 0.! !!PP2AdaptableParseTest methodsFor: 'test - context' stamp: ' 12/6/2016 07:12:31'!testPopStarZero	| node |	node := $a asPParser pop star.		self context defaultStack push: $a.	self assert: node parse: ''.	self assert: context defaultStack size equals: 1.! !!PP2AdaptableParseTest methodsFor: 'test - context' stamp: ' 12/6/2016 07:12:31'!testPush	| node |	node := $a asPParser push.		self assert: node parse: 'a'.	self assert: context defaultStack size equals: 1.	self assert: context defaultStack top equals: $a.! !!PP2AdaptableParseTest methodsFor: 'test - context' stamp: ' 12/6/2016 07:12:31'!testPushStarOne	| node |	node := $a asPParser push star.		self assert: node parse: 'a'.	self assert: context defaultStack size equals: 1.! !!PP2AdaptableParseTest methodsFor: 'test - context' stamp: ' 12/6/2016 07:12:31'!testPushStarTwo	| node |	node := $a asPParser push star.		self assert: node parse: 'aa'.	self assert: self context defaultStack size equals: 2.! !!PP2AdaptableParseTest methodsFor: 'test - context' stamp: ' 12/6/2016 07:12:31'!testPushStarZero	| node |	node := $a asPParser push star.		self assert: node parse: ''.	self assert: self context defaultStack size equals: 0.! !!PP2AdaptableParseTest methodsFor: 'test - water' stamp: ' 12/6/2016 07:12:31'!testWaterBoundary	| water |	water := PP2WaterNode new		boundaryElements: 'foo' asPParser;		yourself.		self assert: water parse: 'foobar' to: '' end: 0.	self assert: water parse: 'barfoo' to: 'bar' end: 3.		self assert: water fail: ''.	self assert: water fail: 'barbar'.	! !!PP2AdaptableParseTest methodsFor: 'test - water' stamp: ' 12/6/2016 07:12:31'!testWaterDefault	| water |	water := PP2WaterNode new.		self assert: water parse: 'foobar' to: 'foobar'.	self assert: water parse: '' to: ''! !!PP2AdaptableParseTest methodsFor: 'test - water' stamp: ' 12/6/2016 07:12:31'!testWaterRecursive	| water |	water := PP2WaterNode new		yourself.	water boundary: water.	self assert: water parse: 'foobar' to: '' end: 0! !!PP2AdaptableParseTest methodsFor: 'test - water' stamp: ' 12/6/2016 07:12:31'!testWaterRecursive2	| water eof |	water := PP2WaterNode new		yourself.	eof := PP2EndOfInputNode new.	water boundary: (water, eof) / eof.	self assert: water parse: 'foobar' to: 'foobar'! !!PP2AdaptableReparseTest methodsFor: 'asserting' stamp: ' 12/6/2016 07:12:31'!assert: aPP2Parser reparseWithContext: startContext	| resultContext |	resultContext := aPP2Parser optimize enableDebug reparseAdaptableWithContext: startContext.		self assert: resultContext isPetit2Success.	self assert: resultContext atEnd.		^ resultContext! !!PP2AdaptableReparseTest methodsFor: 'asserting' stamp: ' 12/6/2016 07:12:31'!context	^ PP2ReparsableContext new! !!PP2AdaptableReparseTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parse: aStream withParser: aParser withContext: aContext	^ aParser optimize enableDebug parseAdaptable: aStream withContext: aContext! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseAndReparse	token1 := $a asPParser plus token reparsable.		parser := token1, #space asPParser plus ==> #first.		context := 'aa  ' asReparsableContext. 	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'aa'.	self assert: context returnValue start = 1.	self assert: context returnValue stop = 2.	self assert: context debugResult steps equals: 9.		context := 'aaa ' asReparsableContext.	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'aaa'.	self assert: context returnValue start = 1.	self assert: context returnValue stop = 3.	self assert: context debugResult steps equals: 10.! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseDeleteAfter	token1 := $a asPParser plus token reparsable.		parser := token1, #space asPParser star ==> #first.		context := self assert: parser parse: 'aa  '.	self assert: context returnValue value = 'aa'.	self assert: context returnValue start = 1.	self assert: context returnValue stop = 2.	self assert: context debugResult steps equals: 9.		context applyChange: (PP2DeleteCharacter on: 'aa ' at: 4).	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'aa'.	self assert: context returnValue start = 1.	self assert: context returnValue stop = 2.	self assert: context debugResult steps equals: 5.! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseDeleteBefore	token1 := $a asPParser plus token reparsable.		parser := #space asPParser star, token1 ==> #second.		context := self assert: parser parse: ' aa'.	self assert: context returnValue value = 'aa'.	self assert: context returnValue start = 2.	self assert: context returnValue stop = 3.	self assert: context debugResult steps equals: 9.		context applyChange: (PP2DeleteCharacter on: 'aa' at: 1).	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'aa'.	self assert: context returnValue start = 1.	self assert: context returnValue stop = 2.		self assert: context debugResult steps equals: 5.! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseDeleteHighBoundary	token1 := $a asPParser plus token reparsable.		parser := token1, #space asPParser star ==> #first.	context := self assert: parser parse: 'a  '.	self assert: context returnValue value = 'a'.	self assert: context debugResult steps equals: 8.		context applyChange: (PP2DeleteCharacter on: 'a ' at: 2).	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'a'.	self assert: context debugResult steps equals: 8.! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseDeleteHighBoundaryError	token1 := $a asPParser plus token reparsable.		parser := token1, #space asPParser star ==> #first.	context := self assert: parser parse: 'a a' end: 2.	self assert: context returnValue value = 'a'.	self assert: context debugResult steps equals: 8.		context applyChange: (PP2DeleteCharacter on: 'aa' at: 2).	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value equals: 'aa'.	self assert: context returnValue start equals: 1.	self assert: context debugResult steps equals: 9.! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseDeleteInRange	token1 := $a asPParser plus token reparsable.		parser := #space asPParser star, token1, #space asPParser star ==> #second.	context := self assert: parser parse: 'aaa'.	self assert: context returnValue value = 'aaa'.	self assert: context debugResult steps equals: 11.		context applyChange: (PP2DeleteCharacter on: 'aa' at: 2).	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'aa'.	self assert: context returnValue start = 1.	self assert: context returnValue stop = 2.	self assert: context debugResult steps equals: 10.! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseDeleteLowBoundary	token1 := $a asPParser plus token reparsable.		parser := #space asPParser star, token1 ==> #second.	context := self assert: parser parse: ' a'.	self assert: context returnValue value = 'a'.	self assert: context debugResult steps equals: 8.		context applyChange: (PP2InsertCharacter on: ' aa' at: 1).	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'aa'.	self assert: context debugResult steps equals: 9.! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseInsertAfter	token1 := $a asPParser plus token reparsable.		parser := token1, #space asPParser star ==> #first.		context := self assert: parser parse: 'a '.	self assert: context returnValue value = 'a'.	self assert: context returnValue start = 1.	self assert: context returnValue stop = 1.	self assert: context debugResult steps equals: 8.		context applyChange: (PP2InsertCharacter on: 'a  ' at: 3).	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'a'.	self assert: context returnValue start = 1.	self assert: context returnValue stop = 1.	self assert: context debugResult steps equals: 5.! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseInsertBefore	token1 := $a asPParser plus token reparsable.		parser := #space asPParser star, token1 ==> #second.		context := self assert: parser parse: ' a'.	self assert: context returnValue value = 'a'.	self assert: context returnValue start = 2.	self assert: context returnValue stop = 2.	self assert: context debugResult steps equals: 8.		context applyChange: (PP2InsertCharacter on: '  a' at: 1).	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'a'.	self assert: context returnValue start = 3.	self assert: context returnValue stop = 3.		self assert: context debugResult steps equals: 5.! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseInsertHighBoundary	token1 := $a asPParser plus token reparsable.		parser := token1, #space asPParser star ==> #first.	context := self assert: parser parse: 'a '.	self assert: context returnValue value = 'a'.	self assert: context debugResult steps equals: 8.		context applyChange: (PP2InsertCharacter on: 'aa ' at: 2).	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'aa'.	self assert: context debugResult steps equals: 9.! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseInsertHighBoundaryError	token1 := $a asPParser plus token reparsable.		parser := token1, #space asPParser star ==> #first.	context := self assert: parser parse: 'aa a' end: 3.	self assert: context returnValue value = 'aa'.	self assert: context debugResult steps equals: 9.		context applyChange: (PP2InsertCharacter on: 'a  ' at: 2).	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'a'.	self assert: context debugResult steps equals: 8.! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseInsertInRange	token1 := $a asPParser plus token reparsable.		parser := #space asPParser star, token1, #space asPParser star ==> #second.	context := self assert: parser parse: 'aa'.	self assert: context returnValue value = 'aa'.	self assert: context debugResult steps equals: 10.		context applyChange: (PP2InsertCharacter on: 'aaa' at: 2).	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'aaa'.	self assert: context returnValue start = 1.	self assert: context returnValue stop = 3.	self assert: context debugResult steps equals: 11.! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseInsertLowBoundary	token1 := $a asPParser plus token reparsable.		parser := #space asPParser star, token1 ==> #second.	context := self assert: parser parse: ' a'.	self assert: context returnValue value = 'a'.	self assert: context debugResult steps equals: 8.		context applyChange: (PP2InsertCharacter on: ' aa' at: 1).	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'aa'.	self assert: context debugResult steps equals: 9.! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseInsertLowBoundaryError	token1 := $a asPParser plus token reparsable.		parser := #space asPParser star, token1 ==> #second.	context := self assert: parser parse: ' a'.	self assert: context returnValue value = 'a'.	self assert: context debugResult steps equals: 8.		context applyChange: (PP2InsertCharacter on: '  a' at: 2).	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'a'.	self assert: context debugResult steps equals: 8.! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseMultipleChanges	token1 := $a asPParser plus token reparsable.		parser := #space asPParser plus, token1 ==> #second.		context := '  aa' asReparsableContext. 	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'aa'.	self assert: context returnValue start = 3.	self assert: context returnValue stop = 4.	self assert: context debugResult steps equals: 9.		context applyChange: (PP2InsertCharacter on: '   aa' at: 1).	context applyChange: (PP2InsertCharacter on: '    aa' at: 2).	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'aa'.	self assert: context returnValue start = 5.	self assert: context returnValue stop = 6.		self assert: context debugResult steps equals: 5.	! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseMultipleChangesAtEnd	token1 := $a asPParser plus token reparsable.		parser := #space asPParser plus, token1 ==> #second.		context := '  aa' asReparsableContext. 	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'aa'.	self assert: context returnValue start = 3.	self assert: context returnValue stop = 4.	self assert: context debugResult steps equals: 9.		context applyChange: (PP2InsertCharacter on: '  aaa' at: 4).	context applyChange: (PP2InsertCharacter on: '  aaaa' at: 5).	context := self assert: parser reparseWithContext: context.	self assert: context returnValue value = 'aaaa'.	self assert: context returnValue start = 3.	self assert: context returnValue stop = 6.		self assert: context debugResult steps equals: 11.	! !!PP2AdaptableReparseTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparseNested	token1 := $a asPParser plus token reparsable.		parser := (#space asPParser plus, token1) reparsable ==> #second.		context := self assert: parser parse: '  aa'.	self assert: context returnValue value = 'aa'.	self assert: context returnValue start = 3.	self assert: context returnValue stop = 4.	self assert: context debugResult steps equals: 9.		context applyChange: (PP2InsertCharacter on: '   aa' at: 1).	context := self assert: parser reparseWithContext: context.	self assert: context debugResult steps equals: 5.		context applyChange: (PP2InsertCharacter on: '    aa' at: 2).	context := self assert: parser reparseWithContext: context.	self assert: context debugResult steps equals: 5.! !!PP2BufferStreamIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!parse: aStream withParser: aParser withContext: aContext	^ aParser parse: aStream withContext: aContext! !!PP2BufferStreamIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!streamOn: aString	^ PP2BufferStream on: (PP2MinimalStream on: aString)! !!PP2BufferStreamIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!streamOn: aString bufferSize: size	^ PP2BufferStream on: (PP2MinimalStream on: aString) bufferSize: size! !!PP2BufferStreamIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testIdentifier	"Test with stream that provides only atEnd and next:"	parser := (#letter asPParser, #word asPParser plus) flatten.	stream := self streamOn: 'hi123'.		self assert: parser parse: 'hi123' to: 'hi123' end: 5.! !!PP2BufferStreamIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testIdentifierSmallBuffer	"Test with stream that provides only atEnd and next:"	parser := #letter asPParser, #word asPParser plus.	stream := self streamOn: 'hi123' bufferSize: 1.		self assert: parser parse: stream to: nil end: 5! !!PP2BufferStreamIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testIdentifierSmallBufferError	"Test with stream that provides only atEnd and next:"	parser := (#letter asPParser, #word asPParser plus) flatten.	stream := self streamOn: 'hi123' bufferSize: 1.		self should: [ self assert: parser parse: stream to: 'hi123' end: 5 ] raise: SubscriptOutOfBounds ! !!PP2BufferStreamIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPredicate	"Test with stream that provides only atEnd and next:"	parser := #letter asPParser.	stream := self streamOn: 'a'.		self assert: parser parse: stream to: $a end: 1.! !!PP2BufferStreamIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequence	"Test with stream that provides only atEnd and next:"	parser := $a asPParser, $a asPParser.	stream := self streamOn: 'aa'.		self assert: parser parse: stream to: #($a $a) end: 2! !!PP2BufferStreamIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testStreamBacktrack	parser := ('aa' asPParser, 'a' asPParser) / 'aa' asPParser.	stream := self streamOn: 'aa'.		self assert: parser parse: stream to: 'aa' end: 2.	! !!PP2BufferStreamIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testStreamBacktrackBufferSmall	parser := 'aa' asPParser.	stream := self streamOn: 'aa' bufferSize: 2.		parser := ('aa' asPParser, 'aa' asPParser) / 'aa' asPParser.		self assert: parser parse: stream to: 'aa' end: 2.	! !!PP2BufferStreamIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testStreamBacktrackBufferTooSmall	parser := 'aa' asPParser.	stream := self streamOn: 'aa' bufferSize: 1.		parser := ('aa' asPParser, 'aa' asPParser) / 'aa' asPParser.		self should: [ self assert: parser parse: stream to: 'aa' end: 2 ] raise: SubscriptOutOfBounds 	! !!PP2BufferStreamIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testStreamBufferTooSmall	parser := 'aa' asPParser.	stream := self streamOn: 'aa' bufferSize: 1.	self should: [ self assert: parser parse: stream to: 'aa' end: 2 ] raise: SubscriptOutOfBounds.	! !!PP2BufferStreamIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testToken	parser := 'aa' asPParser token.	stream := self streamOn: 'aa'.		self assert: parser parse: stream toTokenValue: 'aa' end: 2! !!PP2AdaptableGrammarTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parserClass	^ PP2AdaptableGrammar! !!PP2AdaptableGrammarTest_Optimized methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parserInstance	^ super parserInstance optimize! !!PP2CompositeNodeTest class methodsFor: 'testing' stamp: ' 12/6/2016 07:12:31'!isAbstract	^ self name = #PP2CompositeNodeTest! !!PP2CompositeNodeTest class methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!resources	^ Array with: PP2ParserResource! !!PP2CompositeNodeTest methodsFor: 'utilities' stamp: ' 12/6/2016 07:12:31'!assert: aCollection is: anObject	self parse: aCollection.	self		assert: result = anObject		description: 'Got: ' , result printString , '; Expected: ' , anObject printString		resumable: true! !!PP2CompositeNodeTest methodsFor: 'parsing' stamp: ' 12/6/2016 07:12:31'!fail: aString rule: aSymbol 	| production context |	production := self parserInstanceFor: aSymbol.	context := self context.		result := production parse: aString withContext: context.		self		assert: (result isPetit2Failure or: [context atEnd not])		description: 'Able to parse ' , aString printString.	^ result! !!PP2CompositeNodeTest methodsFor: 'parsing' stamp: ' 12/6/2016 07:12:31'!parse: aString 	^ self parse: aString rule: #start! !!PP2CompositeNodeTest methodsFor: 'parsing' stamp: ' 12/6/2016 07:12:31'!parse: aString rule: aSymbol	^ self parse: aString rule: aSymbol end: aString size! !!PP2CompositeNodeTest methodsFor: 'parsing' stamp: ' 12/6/2016 07:12:31'!parse: aString rule: aSymbol end: end	^ self parse: aString rule: aSymbol to: nil end: end checkResult: false! !!PP2CompositeNodeTest methodsFor: 'parsing' stamp: ' 12/6/2016 07:12:31'!parse: aString rule: aSymbol to: expectedResult	^ self parse: aString rule: aSymbol to: expectedResult end: aString size checkResult: true! !!PP2CompositeNodeTest methodsFor: 'parsing' stamp: ' 12/6/2016 07:12:31'!parse: aString rule: aSymbol to: expectedResult end: end	^ self parse: aString rule: aSymbol  to:  expectedResult  end: end checkResult:  true! !!PP2CompositeNodeTest methodsFor: 'parsing' stamp: ' 12/6/2016 07:12:31'!parse: aString rule: aSymbol to: expectedResult end: end checkResult: aBoolean	| production ctx |	production := self parserInstanceFor: aSymbol.	ctx := self context.	resultContext := self parse: aString withParser: production withContext: ctx.	result := resultContext value.		self		deny: resultContext isPetit2Failure		description: 'Unable to parse ' , aString printString.		self assert: resultContext position equals: end.	aBoolean ifTrue: [ self assert: expectedResult equals: result ].	^ result! !!PP2CompositeNodeTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parse: aStream withParser: aParser withContext: aContext	^ aParser parse: aStream withContext: aContext! !!PP2CompositeNodeTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parserClass	self subclassResponsibility! !!PP2CompositeNodeTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parserInstance	^ PP2ParserResource current parserAt: self parserClass! !!PP2CompositeNodeTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parserInstanceFor: aSymbol	^ aSymbol = #start		ifTrue: [ self parserInstance ]		ifFalse: [			self parserInstance				productionAt: aSymbol 				ifAbsent: [ self error: 'Production ' , self parserClass name , '>>' , aSymbol printString , ' not found.' ] ]! !!PP2CompositeNodeTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setUp	super setUp.	parser := self parserInstance! !!PP2CompositeNodeTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!tearDown	super tearDown.	parser := result := nil! !!PP2ExpressionGrammarTest class methodsFor: 'testing' stamp: ' 12/6/2016 07:12:31'!shouldInheritSelectors	^ true! !!PP2ExpressionGrammarTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parse: aStream withParser: aParser withContext: aContext	^ aParser parse: aStream withContext: aContext! !!PP2ExpressionParserTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!parserClass	^ PP2ExpressionParser! !!PP2ExpressionGrammarTest_Optimized methodsFor: 'context' stamp: ' 12/6/2016 07:12:31'!context	^ PP2InMemoryContext new! !!PP2ExpressionGrammarTest_Optimized methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parserInstance	^ super parserInstance optimize! !!PP2HtmlHeaderGrammarTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parserClass	^ PP2HtmlHeaderGrammar ! !!PP2HtmlHeaderGrammarTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testHeader	self parse: '<head>foobar</head>' rule: #header to: 'foobar'! !!PP2HtmlHeaderGrammarTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testHtmlFragment	self parse: '<html><head>foobar</head></html>' rule: #htmlFragment to: 'foobar' end: 25! !!PP2HtmlHeaderGrammarTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testHtmlFragmentNoHeader	self fail: '<html><body>foobar</body></html>' rule: #htmlFragment! !!PP2HtmlHeaderGrammarTest methodsFor: 'tests-integration' stamp: ' 12/6/2016 07:12:31'!testZincClientIntegration	| byteStream stream |	byteStream := ZnClient new 		url: 'http://pharo.org';  		streaming: true;  		get.	stream := PP2CharacterStream on: byteStream encoder: ZnUTF8Encoder new.	result := PP2HtmlHeaderGrammar new parse: stream.		self assert: stream atEnd not.	self assert: (result includesSubstring: 'Pharo')! !!PP2CsNodeTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!context	context isNil ifTrue: [ 		context := super context	].	^ context! !!PP2CsNodeTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parse: aStream withParser: aParser withContext: aContext	^ context := aParser parse: aStream withContext: aContext! !!PP2CsNodeTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testStackId	self assert: $a asPParser push stackId equals: #defaultStack.	self assert: $a asPParser pop stackId equals: #defaultStack.		self assert: $a asPParser match stackId equals: #defaultStack.! !!PP2InterpetParseTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!context	^ PP2Context new! !!PP2InterpetParseTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parse: aStream withParser: aParser withContext: aContext	^ (PP2Interpret  on: aParser) parse: aStream withContext: aContext! !!PP2InterpetParseTest methodsFor: 'test' stamp: ' 12/6/2016 07:12:31'!testPredicateDigit	|  parser |		parser := #digit asPParser.	self assert: parser parse: '1' to: $1.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '9' to: $9.	self assert: parser fail: 'a'.! !!PP2OptimizationParserTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!context	context isNil ifTrue: [		context := PP2RecordingContext new	].	^ context! !!PP2OptimizationParserTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parse: aStream withParser: aParser withContext: aContext	^ aParser parseAdaptable: aStream withContext: aContext! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAndLiteralObject	self assert: $a asPParser and parse: 'a' to: $a end: 0.! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAndPop	| parser |	self context defaultStack push: $a.	parser := $a asPParser pop and.	parser optimize.		self assert: parser parse: 'a' to: $a end: 0.	self assert: self context defaultStack top equals: $a.	self assert: self context defaultStack size equals: 1.	self assert: (self context countFor: #remember) equals: 1.! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAndPopFailure	| parser |	self context defaultStack push: $a.	parser := $a asPParser pop and.	parser optimize.		self assert: parser fail: 'b'.	self assert: self context defaultStack top equals: $a.	self assert: self context defaultStack size equals: 1.	self assert: (self context countFor: #remember) equals: 1.! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAndPredicateObject	self assert: #letter asPParser and parse: 'a' to: $a end: 0.	self assert: #letter asPParser and parse: 'z' to: $z end: 0.		self assert: #letter asPParser and fail: '1' end: 0.! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAndPush	| parser |	self context defaultStack push: $b.	parser := $a asPParser push and.	parser optimize.		self assert: parser parse: 'a' to: $a end: 0.	self assert: self context defaultStack top equals: $b.	self assert: self context defaultStack size equals: 1.	self assert: (self context countFor: #remember) equals: 1.! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAndPushFailure	| parser |	self context defaultStack push: $b.	parser := $a asPParser push and.	parser optimize.		self assert: parser fail: 'b'.	self assert: self context defaultStack top equals: $b.	self assert: self context defaultStack size equals: 1.	self assert: (self context countFor: #remember) equals: 1.! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCache	| counter parser contextOne contextTwo |	counter := 0.	parser := [ :ctx | counter := counter + 1. #foo ] asPParser.	parser strategy: parser strategy cache.	parser setOptimized.	contextOne := 'foo' asPetit2Context.	contextTwo := 'bar' asPetit2Context.		parser parseAdaptableWithContext: contextOne.	self assert: counter equals: 1.		parser parseAdaptableWithContext: contextOne.	self assert: counter equals: 2.		contextOne next.	parser parseAdaptableWithContext: contextOne.	self assert: counter equals: 3.	parser parseAdaptableWithContext: contextTwo.	self assert: counter equals: 4.	! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCache2	| parser context result |	parser := $a asPParser star.	parser strategy: parser strategy cache.	parser setOptimized.		context := 'aaa' asPetit2Context.	result := parser parseAdaptableWithContext: context.	self assert: result position equals: 3.		context := 'aabb' asPetit2Context.	result := parser parseAdaptableWithContext: context.	self assert: result position equals: 2.! !!PP2OptimizationParserTest methodsFor: 'tests - guards' stamp: ' 12/6/2016 07:12:31'!testGuardChoiceFailure	| parserOne parserTwo wrappedOne wrappedTwo result parser |	parserOne := $a asPParser.	parserTwo := $b asPParser.	wrappedOne := parserOne wrapped trim flatten. 	wrappedTwo := parserTwo wrapped trim flatten.	parser := wrappedOne / wrappedTwo.	parser optimize.	parser enableDebug.			result := self assert: parser fail: 'c'.	self assert: result debugResult steps equals: 4! !!PP2OptimizationParserTest methodsFor: 'tests - guards' stamp: ' 12/6/2016 07:12:31'!testGuardChoiceOptionOne	| parserOne parserTwo wrappedOne wrappedTwo parser result |	parserOne := $a asPParser.	parserTwo := $b asPParser.	wrappedOne := parserOne wrapped trim flatten. 	wrappedTwo := parserTwo wrapped trim flatten.	parser := wrappedOne / wrappedTwo.	parser optimize.	parser enableDebug.	result := self assert: parser parse: 'a ' to: 'a '.	self assert: result debugResult steps equals: 8! !!PP2OptimizationParserTest methodsFor: 'tests - guards' stamp: ' 12/6/2016 07:12:31'!testGuardChoiceOptionTwo	| parserOne parserTwo wrappedOne wrappedTwo parser result |	parserOne := $a asPParser.	parserTwo := $b asPParser.	wrappedOne := parserOne wrapped trim flatten. 	wrappedTwo := parserTwo wrapped trim flatten.	parser := wrappedOne / wrappedTwo.	parser optimize.	parser enableDebug.		result := self assert: parser parse: 'b ' to: 'b '.	self assert: result debugResult steps equals: 9! !!PP2OptimizationParserTest methodsFor: 'tests - guards' stamp: ' 12/6/2016 07:12:31'!testGuardOptional	|  wrappedOne parser result |	wrappedOne := $a asPParser wrapped trim flatten.	parser := wrappedOne optional.	parser optimize.	parser enableDebug.	result := self assert: parser parse: 'a' to: 'a' end: 1.	self assert: result debugResult steps equals: 8! !!PP2OptimizationParserTest methodsFor: 'tests - guards' stamp: ' 12/6/2016 07:12:31'!testGuardOptionalFailure	|  wrappedOne parser result |	wrappedOne := $a asPParser wrapped trim flatten.	parser := wrappedOne optional.	parser optimize.	parser enableDebug.	result := self assert: parser parse: 'c' to: nil end: 0.	self assert: result debugResult steps equals: 2! !!PP2OptimizationParserTest methodsFor: 'tests - guards' stamp: ' 12/6/2016 07:12:31'!testGuardPlus	| parserOne wrappedOne result parser |	parserOne := $a asPParser.	wrappedOne := parserOne wrapped trim flatten. 	parser := wrappedOne plus.	parser optimize.	parser enableDebug.	result := self assert: parser parse: 'a' to: #('a') end: 1.	self assert: result debugResult steps equals: 13! !!PP2OptimizationParserTest methodsFor: 'tests - guards' stamp: ' 12/6/2016 07:12:31'!testGuardPlusFailure	| result parser parserOne wrappedOne |	parserOne := $a asPParser.	wrappedOne := parserOne wrapped trim flatten. 	parser := wrappedOne plus.	parser optimize.	parser enableDebug.	result := self assert: parser fail: 'c'.	self assert: result debugResult steps equals: 2! !!PP2OptimizationParserTest methodsFor: 'tests - guards' stamp: ' 12/6/2016 07:12:31'!testGuardPlusTwo	| parserOne wrappedOne parser result |	parserOne := $a asPParser.	wrappedOne := parserOne wrapped trim flatten. 	parser := wrappedOne plus.	parser optimize.	parser enableDebug.	result := self assert: parser parse: 'aa' to: #('a' 'a') end: 2.	self assert: result debugResult steps equals: 19! !!PP2OptimizationParserTest methodsFor: 'tests - guards' stamp: ' 12/6/2016 07:12:31'!testGuardStar	| parser wrappedOne result |	wrappedOne := $a asPParser wrapped trim flatten. 	parser := wrappedOne star.	parser optimize.	parser enableDebug.	result := self assert: parser parse: 'a' to: #('a') end: 1.	self assert: result debugResult steps equals: 13.! !!PP2OptimizationParserTest methodsFor: 'tests - guards' stamp: ' 12/6/2016 07:12:31'!testGuardStarEmpty	| parser wrappedOne result |	wrappedOne := $a asPParser wrapped trim flatten. 	parser := wrappedOne star.	parser optimize.	parser enableDebug.	result := self assert: parser parse: 'c' to: #() end: 0.	self assert: result debugResult steps equals: 2.! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testLiteralObject		self assert: $a asPParser flatten parse: 'a'.! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testLiteralObjectTrimmingToken		self assert: $a asPParser wrapped token trim parse: '   a   ' toTokenValue: 'a'.! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNotLiteral	self assert: $a asPParser not parse: 'b' to: nil end: 0.! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNotPredicateObject	self assert: #letter asPParser not parse: '0' to: nil end: 0.	self assert: #letter asPParser not parse: '_' to: nil end: 0.		self assert: #letter asPParser not fail: 'a' end: 0.! !!PP2OptimizationParserTest methodsFor: 'tests - packrat' stamp: ' 12/6/2016 07:12:31'!testPackrat	| packrat parser result |	packrat := $a asPParser trim memoize.	parser := packrat and, packrat.		parser optimize.	parser enableDebug.		result := self assert: parser parse: ' a'.	self assert: result debugResult steps equals: 8.! !!PP2OptimizationParserTest methodsFor: 'tests - packrat' stamp: ' 12/6/2016 07:12:31'!testPackratContextSensitive	| packrat parser result |	packrat := #letter asPParser match memoize.	parser := (#letter asPParser push, packrat) and, #letter asPParser push, packrat.		parser optimize.	parser enableDebug.		result := self assert: parser parse: 'aa'.	self assert: result debugResult steps equals: 11! !!PP2OptimizationParserTest methodsFor: 'tests - packrat' stamp: ' 12/6/2016 07:12:31'!testPackratContextSensitiveFailure	| packrat parser result |	packrat := #letter asPParser match memoize.	parser := (#letter asPParser push, packrat) and, #letter asPParser, packrat.		parser optimize.	parser enableDebug.		result := self assert: parser fail: 'aa' end: 1! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSea	|  parser island result |		island := $a asPParser plus flatten.	parser := island sea.	parser optimize.	result := parser debug: '..aa..'.	self assert: result debugResult steps equals: 33.	! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceWithPush	| parser |	self context defaultStack push: $x.	parser := $a asPParser, $b asPParser push, $c asPParser.	parser optimize.		self assert: parser parse: 'abc'.	self assert: self context defaultStack top equals: $b.	self assert: self context defaultStack size equals: 2.	self assert: (self context countFor: #remember) equals: 1.! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceWithPushFailureFirst	| parser |	self context defaultStack push: $x.	parser := $a asPParser, $b asPParser push, $c asPParser.	parser optimize.		self assert: parser fail: 'xbc'.	self assert: self context defaultStack top equals: $x.	self assert: self context defaultStack size equals: 1.	self assert: (self context countFor: #remember) equals: 1.! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceWithPushFailureLast	| parser |	self context defaultStack push: $x.	parser := $a asPParser, $b asPParser push, $c asPParser.	parser optimize.		self assert: parser fail: 'abx' end: 2.	self assert: self context defaultStack top equals: $x.	self assert: self context defaultStack size equals: 1.	self assert: (self context countFor: #remember) equals: 1.! !!PP2OptimizationParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTrimming		self assert: $a asPParser trim parse: '   a   '.! !!PP2PredicateTest methodsFor: 'utilities' stamp: ' 12/6/2016 07:12:31'!assertCharacterSets: aParser	"Assert the character set of aParser does not overlap with the character set with the negated parser, and that they both cover the complete character space."	| positives negatives |	positives := self parsedCharacterSet: aParser.	negatives := self parsedCharacterSet: aParser negate.	self charactersDo: [ :char | 		| positive negative |		positive := positives includes: char.		negative := negatives includes: char.		self 			assert: ((positive and: [ negative not ])				or: [ positive not and: [ negative ] ])			description: char printString , ' should be in exactly one set' ]! !!PP2PredicateTest methodsFor: 'private' stamp: ' 12/6/2016 07:12:31'!charactersDo: aBlock	1 to: 256 do: [ :index | aBlock value: (Character codePoint: index) ]! !!PP2PredicateTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parse: aStream withParser: aParser withContext: aContext	^ aParser parse: aStream withContext: aContext! !!PP2PredicateTest methodsFor: 'utilities' stamp: ' 12/6/2016 07:12:31'!parsedCharacterSet: aParser	| result |	result := WriteStream on: String new.	self charactersDo: [ :char |		(aParser matches: (char asString))			ifTrue: [ result nextPut: char ] ].	^ result contents! !!PP2PredicateTest methodsFor: 'testing-objects' stamp: ' 12/6/2016 07:12:31'!testAny	| parser |	parser := #any asPParser.	self assertCharacterSets: parser.	self assert: parser parse: ' ' to: $ .	self assert: parser parse: '1' to: $1.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''! !!PP2PredicateTest methodsFor: 'testing-objects' stamp: ' 12/6/2016 07:12:31'!testAnyExceptAnyOf	| parser |	parser := PP2PredicateObjectNode noneOf: #($: $,).	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ':'.	self assert: parser fail: ','! !!PP2PredicateTest methodsFor: 'testing-objects' stamp: ' 12/6/2016 07:12:31'!testAnyOf	| parser |	parser := PP2PredicateObjectNode anyOf: #($a $z).	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: 'x'! !!PP2PredicateTest methodsFor: 'testing-chars' stamp: ' 12/6/2016 07:12:31'!testBlank	| parser |	parser := #blank asPParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character space) to: Character space.	self assert: parser parse: (String with: Character tab) to: Character tab.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: (String with: Character cr)! !!PP2PredicateTest methodsFor: 'testing-chars' stamp: ' 12/6/2016 07:12:31'!testChar	| parser |	parser := $* asPParser.	self assertCharacterSets: parser.	self assert: parser parse: '*' to: $*.	self assert: parser parse: '**' to: $* end: 1.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'! !!PP2PredicateTest methodsFor: 'testing-chars' stamp: ' 12/6/2016 07:12:31'!testDigit	| parser |	parser := #digit asPParser.	self assertCharacterSets: parser.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '9' to: $9.	self assert: parser fail: ''.	self assert: parser fail: 'a'! !!PP2PredicateTest methodsFor: 'testing-objects' stamp: ' 12/6/2016 07:12:31'!testExpect	| parser |	parser := PP2PredicateObjectNode expect: $a message: '$a expected'.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.	self assert: parser fail: ''! !!PP2PredicateTest methodsFor: 'testing-chars' stamp: ' 12/6/2016 07:12:31'!testHex	| parser |	parser := #hex asPParser.	self assertCharacterSets: parser.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '5' to: $5.	self assert: parser parse: '9' to: $9.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: 'D' to: $D.	self assert: parser parse: 'F' to: $F.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'e' to: $e.	self assert: parser parse: 'f' to: $f.	self assert: parser fail: ''.	self assert: parser fail: 'g'! !!PP2PredicateTest methodsFor: 'testing-chars' stamp: ' 12/6/2016 07:12:31'!testLetter	| parser |	parser := #letter asPParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'Z' to: $Z.	self assert: parser fail: ''.	self assert: parser fail: '0'! !!PP2PredicateTest methodsFor: 'testing-chars' stamp: ' 12/6/2016 07:12:31'!testNewline	| parser |	parser := #newline asPParser.	self assert: parser parse: String cr to: String cr.	self assert: parser parse: String lf to: String lf.	self assert: parser parse: String crlf to: String  crlf.	self assert: parser fail: ' '! !!PP2PredicateTest methodsFor: 'testing-sequence' stamp: ' 12/6/2016 07:12:31'!testSequenceParser	| parser |	parser := PP2PredicateSequenceNode		on: [ :value | value first isUppercase ]		message: 'uppercase 3 letter words'		size: 3.	self assert: parser size equals: 3.	self assert: parser parse: 'Abc'.	self assert: parser parse: 'ABc'.	self assert: parser parse: 'ABC'.	self assert: parser fail: 'abc'.	self assert: parser fail: 'aBC'.	self assert: parser fail: 'Ab'.	parser := parser negate.	self assert: parser size equals: 3.	self assert: parser fail: 'Abc'.	self assert: parser fail: 'ABc'.	self assert: parser fail: 'ABC'.	self assert: parser parse: 'abc'.	self assert: parser parse: 'aBC'.	self assert: parser fail: 'Ab'! !!PP2PredicateTest methodsFor: 'testing-chars' stamp: ' 12/6/2016 07:12:31'!testSpace	| parser |	parser := #space asPParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character tab) to: Character tab.	self assert: parser parse: ' ' to: Character space.	self assert: parser fail: ''.	self assert: parser fail: 'a'! !!PP2PredicateTest methodsFor: 'testing-chars' stamp: ' 12/6/2016 07:12:31'!testWord	| parser |	parser := #word asPParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: '0' to: $0.	self assert: parser fail: ''.	self assert: parser fail: '-'! !!PP2SeaOptimizationParserTest methodsFor: 'parse support' stamp: ' 12/6/2016 07:12:31'!assert: parser parse: input	parser optimize.	result := (super assert: parser parse: input) value! !!PP2SeaOptimizationParserTest methodsFor: 'parsing' stamp: ' 12/6/2016 07:12:31'!parse: aStream withParser: aParser withContext: aContext	^ aParser parseAdaptable: aStream withContext: aContext! !!PP2SeaOptimizationParserTest methodsFor: 'parse support' stamp: ' 12/6/2016 07:12:31'!result	^ result! !!PP2SeaOptimizationParserTest methodsFor: 'parse support' stamp: ' 12/6/2016 07:12:31'!seaInstance	^ PP2SeaNode new! !!PP2SeaParserTest methodsFor: 'utilities' stamp: ' 12/6/2016 07:12:31'!assert: parser parse: input	result := (super assert: parser parse: input) value! !!PP2SeaParserTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parse: aStream withParser: aParser withContext: aContext	^ aParser parseAdaptable: aStream withContext: aContext! !!PP2SeaParserTest methodsFor: 'parse support' stamp: ' 12/6/2016 07:12:31'!result	^ result! !!PP2SeaParserTest methodsFor: 'parse support' stamp: ' 12/6/2016 07:12:31'!seaInstance	^ PP2SeaNode new! !!PP2SeaParserTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNestedBlockDeepNested	| block |	block := self nestedBlock.		self assert: block parse: '{ {} { {  } } }'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second size equals: 2.	self assert: self result second first size equals: 3.	self assert: self result second second size equals: 3.	self assert: self result third equals: $}.! !!PP2WaterNodeTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testBoundaryElements	| water boundary |	water := PP2WaterNode new.	boundary := $a asPParser.		water boundaryElements: boundary asCollection.		self assert: water boundary isKindOf: PP2ChoiceNode.	self assert: water boundary firstChild isKindOf: PP2AndNode.	self assert: water boundaryElements first  == boundary! !!PP2AllNodesCacheTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!assert: node hasProperty: propertyName withValue: propertyValue	self assert: (node propertyAt: propertyName) equals: propertyValue! !!PP2AllNodesCacheTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSanity	| parser |	parser := PP2ExpressionGrammar new.	PP2AllNodesCache new doPass: parser.		parser allNodesDo: [ :child | 		self assert: (child hasProperty: #allNodesSize).	].	self assert: (parser productionAt: #number) hasProperty: #allNodesSize withValue: 12.	self assert: parser hasProperty: #allNodesSize withValue: parser allNodes size.	! !!PP2AllNodesVisitorTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setUp	visitor := PP2AllNodesVisitor new! !!PP2AllNodesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChoice	parser := $a asPParser / $b asPParser.	children := self visit: parser.		self assert: children isCollection.	self assert: children size = 3.	self assert: (children includes: parser).	self assert: (children includes: parser firstChild).	self assert: (children includes: parser secondChild).! !!PP2AllNodesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCycle	| delegate |	delegate := PP2DelegateNode new.	parser := delegate, delegate.	delegate child: parser.	children := self visit: parser.		self assert: children isCollection.	self assert: children size equals: 2.	self assert: (children includes: parser).	self assert: (children includes: delegate).	! !!PP2AllNodesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testLiteral	parser := $a asPParser.	children := self visit: parser.		self assert: children isCollection.	self assert: children size = 1.	self assert: children anyOne = parser.! !!PP2AllNodesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequence	parser := $a asPParser, $b asPParser.	children := self visit: parser.		self assert: children isCollection.	self assert: children size = 3.	self assert: (children includes: parser).	self assert: (children includes: parser firstChild).	self assert: (children includes: parser secondChild).! !!PP2AllNodesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTokenParser	parser := $a asPParser token.	children := self visit: parser.		self assert: children isCollection.	self assert: children size = 2.	self assert: (children includes: parser child).	self assert: (children includes: parser).	! !!PP2AllNodesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTrimParser	| trimmer |	trimmer := PP2FailingNode instance.	parser := $a asPParser trim: trimmer.		children := self visit: parser.		self assert: children isCollection.	self assert: children size = 3.	self assert: (children includes: parser child).	self assert: (children includes: parser).	self assert: (children includes: trimmer).	! !!PP2AllNodesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testWrapping	parser := $a asPParser wrapped.	children := self visit: parser.		self assert: children isCollection.	self assert: children size = 2.	self assert: (children includes: parser child).	self assert: (children includes: parser).	! !!PP2AllNodesVisitorTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!visit: node	^ visitor visit: node.! !!PP2BufferStreamTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setUp	super setUp! !!PP2BufferStreamTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!streamOn: collection	^ PP2BufferStream on: (PP2MinimalStream on: collection)! !!PP2BufferStreamTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!streamOn: collection bufferSize: size	^ PP2BufferStream on: (PP2MinimalStream on: collection) bufferSize: size! !!PP2BufferStreamTest methodsFor: 'tests - context interface' stamp: ' 12/6/2016 07:12:31'!testAtEndDifferentPosition	| stream |	stream := self streamOn: 'f'.	stream upToPosition: 1.	self assert: (stream atEnd: 0) not.	self assert: (stream atEnd: 1).		self assert: (stream atEnd: 2).! !!PP2BufferStreamTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testContents	| stream |	stream := self streamOn: 'bar'. 		self assert: (stream contents) equals: ''.! !!PP2BufferStreamTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testContentsAfterRead	| stream |	stream := self streamOn: 'bar'. 	stream upToPosition: 3.		self assert: (stream contents) equals: 'bar'.! !!PP2BufferStreamTest methodsFor: 'tests - context interface' stamp: ' 12/6/2016 07:12:31'!testCopyFromToBufferOverflow	| stream |	stream := self streamOn: 'bar' bufferSize:2.	self assert: (stream copyFrom: 2 to: 3) equals: 'ar'! !!PP2BufferStreamTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCopyFromToOOB	| stream |	stream := self streamOn: 'bar'.	self should: [ stream copyFrom: 4 to: 4 ] raise: SubscriptOutOfBounds.	self should: [ stream copyFrom: 1 to: 4 ] raise: SubscriptOutOfBounds.! !!PP2BufferStreamTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCopyFromToSmallBuffer	| stream |	stream :=  self streamOn: 'foobar' bufferSize: 3. 	self assert: (stream copyFrom: 1 to: 3) = 'foo'.	self assert: (stream copyFrom: 2 to: 4) = 'oob'.	self should: [ stream copyFrom: 1 to: 3 ] raise: Exception description: 'too much backtrack'.	self should: [ stream copyFrom: 2 to: 5 ] raise: Exception description: 'range too big'.! !!PP2BufferStreamTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testInstanceCreation	| stream |	stream := self streamOn: ''.	self assert: (stream buffer isKindOf: String).	self assert: (stream buffer size = stream bufferSize).! !!PP2BufferStreamTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testInstanceCreationSize	| stream |	stream := self streamOn: '' bufferSize: 2. 	self assert: (stream buffer isKindOf: String).	self assert: (stream buffer size = stream bufferSize).	self assert: (stream bufferSize = 2).! !!PP2BufferStreamTest methodsFor: 'tests - context interface' stamp: ' 12/6/2016 07:12:31'!testRandomAccessTooMuchBacktrack	| stream |	stream := self streamOn: 'bar' bufferSize: 2. 		self assert: (stream atPosition: 3) = $r.		self assert: (stream atPosition: 2) = $a.	self should: [ stream atPosition: 1 ] raise: SubscriptOutOfBounds description: 'too much backtrack'.! !!PP2BufferStreamTest methodsFor: 'tests - context interface' stamp: ' 12/6/2016 07:12:31'!testRandomAccessTwoPasses	| stream |	stream := self streamOn: 'foobar' bufferSize: 2. 		self assert: (stream atPosition: 1) = $f.		self assert: (stream atPosition: 2) = $o.	self assert: (stream atPosition: 3) = $o.		self assert: (stream atPosition: 4) = $b.	self assert: (stream atPosition: 5) = $a.	self assert: (stream atPosition: 6) = $r.		self should: [(stream atPosition: 1) ] raise: Exception.	self should: [(stream atPosition: 2) ] raise: Exception.	self should: [(stream atPosition: 3) ] raise: Exception.	self should: [(stream atPosition: 4) ] raise: Exception.	self assert: (stream atPosition: 5) = $a.	self assert: (stream atPosition: 6) = $r.! !!PP2BufferStreamTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUncheckedNext	| stream |	stream := self streamOn: 'foo'. 		self assert: stream uncheckedNext = $f.	self assert: stream uncheckedNext = $o.	self assert: stream uncheckedNext = $o.	self should: [ stream uncheckedNext ] raise: Exception.! !!PP2BypassVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!PP2BypassVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!setUp	visitor := PP2BypassVisitor new! !!PP2BypassVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testBypassCache	| cache |	cache := $a asPParser wrapped.	cache strategy: cache strategy cache.		parser := cache plus.	parser strategy: (PP2Plus on: parser).		self visit: parser.		self assert: parser strategy child isKindOf: PP2DelegateNode.! !!PP2BypassVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testPlus	parser := $a asPParser wrapped plus.	parser strategy: (PP2Plus on: parser).		self visit: parser.		self assert: parser strategy child isKindOf: PP2LiteralObjectNode.! !!PP2BypassVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testSequenceOfTwo	parser := $a asPParser wrapped, $b asPParser wrapped.	parser strategy: (PP2SequenceOfTwo on: parser).		self visit: parser.		self assert: parser strategy firstChild isKindOf: PP2LiteralObjectNode.	self assert: parser strategy secondChild isKindOf: PP2LiteralObjectNode.	! !!PP2BypassVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testSequenceOfTwoRecognizer	parser := $a asPParser wrapped, $b asPParser wrapped.	parser strategy: (PP2SequenceOfTwoRecognizer on: parser).		self visit: parser.		self assert: parser strategy firstChild isKindOf: PP2LiteralObjectNode.	self assert: parser strategy secondChild isKindOf: PP2LiteralObjectNode.	! !!PP2BypassVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testStar	parser := $a asPParser wrapped star.	parser strategy: (PP2Star on: parser).		self visit: parser.		self assert: parser strategy child isKindOf: PP2LiteralObjectNode.! !!PP2BypassVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!visit: node	visitor visit: node! !!PP2CommonPrefixVisitorTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setUp	super setUp.		visitor := PP2CommonPrefixVisitor new! !!PP2CommonPrefixVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChoice	| production |	production := 'foo' asPParser plus wrapped trim ==> [ :foo | foo ]		name: 'production';		yourself.		parser := production / ($a asPParser optional, production wrapped).		self visit: parser.		self assert: production strategy isKindOf: PP2Cache.! !!PP2CommonPrefixVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChoiceNonIdentical	| productionOne productionTwo |	productionOne := 'foo' asPParser plus wrapped trim ==> [ :foo | foo ]		name: 'production';		yourself.	productionTwo := 'foo' asPParser plus wrapped trim ==> [ :foo | foo ]		name: 'production';		yourself.		parser := productionOne / ($a asPParser optional, productionTwo wrapped).		self visit: parser.		self assert: productionOne strategy isKindOf: PP2Cache.	self assert: productionOne strategy isKindOf: PP2Cache.	self assert: productionOne strategy == productionTwo strategy.	! !!PP2CommonPrefixVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSea	| island |	island := 'foo' asPParser plus wrapped trim ==> [ :foo | foo ]		name: 'production';		yourself.		parser := island sea.		self visit: parser.		self assert: island strategy isKindOf: PP2Cache.! !!PP2CommonPrefixVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSeaBoundary	| sea |	sea := $a asPParser star trim flatten wrapped sea.		parser := $b asPParser plus trim wrapped flatten.	sea beforeWater boundaryElements: parser.	sea afterWater boundary: parser.		self visit: sea.	self assert: sea beforeWater boundaryElements allSatisfy: [:e | e strategy isKindOf: PP2Cache ].	self assert: sea afterWater boundaryElements allSatisfy: [:e | e strategy isKindOf: PP2Cache ].	! !!PP2CommonPrefixVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSeaNested	| sea |	sea := $a asPParser sea.		parser := (sea ==> #second) sea.	sea beforeWater boundary: $b asPParser plus flatten trim.	sea afterWater boundary: $c asPParser plus flatten trim.	self visit: parser.		self assert: sea beforeWater boundaryElements allSatisfy: [ :e | e strategy isKindOf: PP2Cache ].	self assert: sea afterWater boundaryElements allSatisfy: [ :e | e strategy isKindOf: PP2Cache ].	! !!PP2CommonPrefixVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequence	| production |	production := 'foo' asPParser plus wrapped trim ==> [ :foo | foo ]		name: 'production';		yourself.		parser := (production, $a asPParser) star, production wrapped.		self visit: parser.		self assert: production strategy isKindOf: PP2Cache.! !!PP2CommonPrefixVisitorTest methodsFor: 'visiting' stamp: ' 12/6/2016 07:12:31'!visit: node	visitor visit: node! !!PP2ContextChangesVisitorTest methodsFor: 'asserting' stamp: ' 12/6/2016 07:12:31'!assertChangesContext: node	self assert: (visitor visit: node) isContextChange! !!PP2ContextChangesVisitorTest methodsFor: 'asserting' stamp: ' 12/6/2016 07:12:31'!assertPop: node	self assert: (visitor visit: node) isContextPop! !!PP2ContextChangesVisitorTest methodsFor: 'asserting' stamp: ' 12/6/2016 07:12:31'!assertPush: node	self assert: (visitor visit: node) isContextPush! !!PP2ContextChangesVisitorTest methodsFor: 'asserting' stamp: ' 12/6/2016 07:12:31'!denyChangesContext: node	self deny: (visitor visit: node) isContextChange! !!PP2ContextChangesVisitorTest methodsFor: 'asserting' stamp: ' 12/6/2016 07:12:31'!denyPop: node	self deny: (visitor visit: node) isContextPop! !!PP2ContextChangesVisitorTest methodsFor: 'asserting' stamp: ' 12/6/2016 07:12:31'!denyPush: node	self deny: (visitor visit: node) isContextPush! !!PP2ContextChangesVisitorTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setUp	visitor := PP2ContextChangesVisitor new! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAnd	parser := $a asPParser and.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAndPush	parser := $a asPParser push and.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChoice	parser := $a asPParser / $b asPParser.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChoicePopPop	parser := $a asPParser pop / $b asPParser pop.		self assertChangesContext: parser.	self assertPop: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChoicePushPop	parser := $a asPParser push / $b asPParser pop.		self assertChangesContext: parser.	self denyPush: parser.	self denyPop: parser.! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChoicePushPush	parser := $a asPParser push / $b asPParser push.		self assertChangesContext: parser.	self assertPush: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChoiceWithPop	parser := $a asPParser / $b asPParser pop.		self assertChangesContext: parser.	self denyPop: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testDelegate	parser := $a asPParser wrapped.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testDelegatePop	parser := $a asPParser pop wrapped.		self assertPop: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testDelegatePush	parser := $a asPParser push wrapped.		self assertPush: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEpsilon	parser := #epsilon asPParser.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testLiteralObject	parser := $a asPParser.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testMatch	parser := $a asPParser match.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testOptional	parser := $a asPParser optional.		self denyChangesContext: parser.! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testOptionalPop	parser := $a asPParser pop optional.		self assertChangesContext: parser.	self denyPop: parser.! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testOptionalPush	parser := $a asPParser push optional.		self assertChangesContext: parser.	self denyPush: parser.! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPop	parser := $a asPParser pop.		self assertChangesContext: parser.	self assertPop: parser.! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPopOfPop	parser := $a asPParser pop pop.		self assertChangesContext: parser.	self denyPop: parser.! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPush	parser := $a asPParser push.		self assertChangesContext: parser.	self assertPush: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPushOfPush	parser := $a asPParser push push.		self assertChangesContext: parser.	self denyPush: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testRepetition	parser := $a asPParser star.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testRepetitionPop	parser := $a asPParser pop star.		self assertChangesContext: parser.	self denyPush: parser.! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testRepetitionPush	parser := $a asPParser push star.		self assertChangesContext: parser.	self denyPush: parser.! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequence	parser := $a asPParser, $b asPParser.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceWithPop	parser := $a asPParser, ($b asPParser pop).		self assertChangesContext: parser.	self assertPop: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceWithPopPush	parser := $a asPParser pop, $b asPParser push.		self assertChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceWithPush	parser := $a asPParser, $b asPParser push.		self assertChangesContext: parser.	self assertPush: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceWithPushPop	parser := $a asPParser push, $b asPParser pop.		self denyChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testWrapping	parser := $a asPParser >=> [ :ctx :cc | cc value ].		self assertChangesContext: parser! !!PP2ContextChangesVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testWrappingSetProperty	parser := $a asPParser >=> [ :ctx :cc | cc value ]		contextChanges: PP2CcChange noChange;		yourself.		 self denyChangesContext: parser! !!PP2ContextMementoTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEquals	| anotherMemento |	memento := PP2ContextMemento new.	memento position: 1.	memento propertyAt: #foo put: #bar.	anotherMemento := PP2ContextMemento new.	anotherMemento position: 1.	anotherMemento propertyAt: #foo put: #bar.		self assert: memento ~~ anotherMemento.	self assert: memento = anotherMemento.! !!PP2ContextMementoTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEqualsWithStack	| anotherMemento |	memento := PP2ContextMemento new.	memento position: 1.	memento propertyAt: #foo put: Stack new.	anotherMemento := PP2ContextMemento new.	anotherMemento position: 1.	anotherMemento propertyAt: #foo put: Stack new.		self assert: memento ~~ anotherMemento.	self assert: memento = anotherMemento.! !!PP2ContextMementoTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testHash	| anotherMemento |	memento := PP2ContextMemento new.	memento position: 1.	memento propertyAt: #foo put: #bar.	anotherMemento := PP2ContextMemento new.	anotherMemento position: 1.	anotherMemento propertyAt: #foo put: #bar.		self assert: memento hash = anotherMemento hash.! !!PP2ContextMementoTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testMinus	| anotherMemento |	memento := PP2ContextMemento new.	memento position: 1.		anotherMemento := memento - 1.		self assert: memento ~~ anotherMemento.	self assert: anotherMemento position equals: 0.	self assert: memento position equals: 1.! !!PP2ContextMementoTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPlus	| anotherMemento |	memento := PP2ContextMemento new.	memento position: 1.		anotherMemento := memento + 1.		self assert: memento ~~ anotherMemento.	self assert: anotherMemento position equals: 2.	self assert: memento position equals: 1.! !!PP2ContextMemoizationVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!assertCFMemoization: node	visitor visit: node.		self assert: (node memoizationStrategy isKindOf: PP2CFMemoization).! !!PP2ContextMemoizationVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!assertMemoized: node	visitor visit: node.		self assert: (node isMemoized).! !!PP2ContextMemoizationVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!assertPopMemoization: node	visitor visit: node.		self assert: (node memoizationStrategy isKindOf: PP2PopMemoization).! !!PP2ContextMemoizationVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!assertPushMemoization: node	visitor visit: node.		self assert: (node memoizationStrategy isKindOf: PP2PushMemoization).! !!PP2ContextMemoizationVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!denyCFMemoization: node	visitor visit: node.		self deny: (node memoizationStrategy isKindOf: PP2CFMemoization).! !!PP2ContextMemoizationVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!setUp	visitor := PP2ContextMemoizationVisitor new! !!PP2ContextMemoizationVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testAnd	parser := $a asPParser and.		self assertCFMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testAndCS	parser := $a asPParser push and.		self denyCFMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testAndPop	parser := $a asPParser pop and.		self assertPopMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testAndPush	parser := $a asPParser push and.		self assertPushMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testNonEpsilon	parser := $a asPParser nonEpsilon.		self assertCFMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testSequence	parser := $a asPParser, $b asPParser match, $c asPParser.		self assertCFMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testSequencePop	parser := $a asPParser, $b asPParser pop, $c asPParser.		self assertPopMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testSequencePush	parser := $a asPParser, $b asPParser push, $c asPParser.		self assertPushMemoization: parser.! !!PP2ContextMemoizationVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testSequencePushPop	parser := $a asPParser push, #letter asPParser match, $a asPParser pop.		self denyCFMemoization: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'asserting' stamp: ' 12/6/2016 07:12:31'!assertIsContextSensitive: node	self assert: (visitor visit: node) description: 'should be context sensitive'! !!PP2ContextSensitivityVisitorTest methodsFor: 'asserting' stamp: ' 12/6/2016 07:12:31'!denyIsContextSensitive: node	self deny: (visitor visit: node) description: 'should not be context sensitive'! !!PP2ContextSensitivityVisitorTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setUp	visitor := PP2ContextSensitivityVisitor new! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAndMatch	parser := $a asPParser match and.		self assertIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testLiteralObject	parser := $a asPParser.		self denyIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testMatch	parser := $a asPParser match.		self assertIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSea	parser := $a asPParser sea.		self denyIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSeaWithCSIsland	parser := $a asPParser match sea.		self assertIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequence	parser := $a asPParser, $b asPParser.		self denyIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceWithMatch	parser := $a asPParser, $b asPParser match.		self assertIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceWithPush	parser := #letter asPParser, #letter asPParser push.		self denyIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceWithPushMatch	parser := (#letter asPParser push), (#letter asPParser match).		self denyIsContextSensitive: parser.! !!PP2ContextSensitivityVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceWithPushMatchPop	parser := (#letter asPParser push), (#letter asPParser match), (#letter asPParser pop).		self denyIsContextSensitive: parser.! !!PP2ContextTest methodsFor: 'requirements' stamp: ' 12/6/2016 07:12:31'!contextOn: aString	^ PP2Context on: aString asPetit2Stream! !!PP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAsPetit2Context	| context |	context := (PP2MinimalStream on: 'foo') asPetit2Stream asPetit2Context.		self assert: (context isKindOf: PP2Context).	self assert: context isPetit2Success.! !!PP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAsPositionableStream	| context |	context := (PP2MinimalStream on: 'foo') asPetit2Stream asPetit2Context.	context position: 2.	self should: [ context asPositionableStream ] raise: Exception! !!PP2ContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCopy	| newContext context |	context := PP2Context new 		position: #postion;		stream: #stream;		parser: #parser;		startMemento: #startMemento;		yourself.			newContext := context copy.		self deny: context == newContext.	self assert: context position = newContext position.	self assert: context stream = newContext stream.		self assert: context parser = newContext parser.	self assert: context startMemento = newContext startMemento.! !!PP2DebugResultIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testArithmetic	| parser result |	parser := PP2ExpressionParser new.	result := parser debug: '1 + 2'.	self assert: result debugResult children size equals: 1.	self assert: result debugResult children first result equals: #(1 $+ 2)! !!PP2DebugResultIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testArithmeticCache	| parser result number links |	parser := PP2ExpressionParser new.	number := (parser productionAt: #number).	number strategy: number strategy cache.		result := parser debug: '1'.	links := result debugResult allResults select: [ :e | 		e children isEmpty not and: [ e children first isKindOf: PP2DebugResultLink ]	] thenCollect: [ :e | e children first ].	self assert: links size equals: 2.	self assert: links allSatisfy: [ :l | l reference parser name = #number ].! !!PP2DebugResultIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testArithmeticFailure	| parser result |	parser := PP2ExpressionParser new.	result := parser debug: '1 / 2'.	self assert: result debugResult children size equals: 1.	self assert: result debugResult children first result isPetit2Failure! !!PP2DebugResultIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testGtCacheReport	| parser result wrapper |	parser := PP2ExpressionParser new.	result := parser debug: '1 + 2'.	wrapper := GLMWrapper new.	self shouldnt: [ wrapper show: [:a | result gtCacheReport: a ] ] raise: Exception.! !!PP2DebugResultIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNumberParser	| parser result |	parser := PP2ExpressionParser new productionAt: #number.	result := parser debug: '1'.	self assert: result debugResult children size equals: 1.	self assert: result debugResult children first result equals: 1! !!PP2DebugResultIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testProfilingContext	| parser result |	parser := PP2ExpressionParser new productionAt: #number.	result := parser debug: '1'.	self assert: result isKindOf: PP2RecordingContext.! !!PP2DebugResultTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testContents	| result |	result := PP2DebugResult new.	result context: 'a' asPetit2Context.		self assert: result contents equals: 'a'! !!PP2DebugResultTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testStartStopInterval	| result |	result := PP2DebugResult new.		self assert: result startStopInterval isNotNil.! !!PP2DebuggingStrategyTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!setUp	node := $a asPParser.	strategy := node strategy.! !!PP2DebuggingStrategyTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testCache	| debugStrategy |	debugStrategy := strategy debug.		self assert: debugStrategy cache == debugStrategy.	self assert: debugStrategy strategy isKindOf: PP2Cache	! !!PP2DebuggingStrategyTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testDebug	| debugStrategy |	debugStrategy := strategy debug.		self assert: debugStrategy debug == debugStrategy.	! !!PP2DebuggingStrategyTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testParsingGuard	| classification debugStrategy |	debugStrategy := strategy debug.	classification := Array new: 255 withAll: false.		self assert: (debugStrategy parsingGuard: classification) == debugStrategy.	self assert: debugStrategy strategy isKindOf: PP2ParsingGuard.		self assert: debugStrategy strategy retval isPetit2Failure.! !!PP2DebuggingStrategyTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testParsingGuardOptional	| classification debugStrategy optional |	optional := $a asPParser optional.		debugStrategy := optional strategy debug.	classification := Array new: 255 withAll: false.		self assert: (debugStrategy parsingGuard: classification) == debugStrategy.	self assert: debugStrategy strategy isKindOf: PP2ParsingGuard.		self assert: debugStrategy strategy retval isNil.! !!PP2DebuggingStrategyTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testRecognizer	| debugStrategy |	node := #letter asPParser.	strategy := node strategy.	debugStrategy := strategy debug.	self assert: debugStrategy strategy isKindOf: PP2PredicateObject.		self assert: debugStrategy recognizer == debugStrategy.	self assert: debugStrategy strategy isKindOf: PP2PredicateObjectRecognizer.	! !!PP2DebuggingStrategyTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testReparsable	| debugStrategy |	debugStrategy := strategy debug.		self assert: debugStrategy reparsable == debugStrategy.	self assert: debugStrategy strategy isKindOf: PP2Reparsable	! !!PP2DeleteCharacterTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setUp	context := PP2Context on: 'foobar'.	buffer := IdentityDictionary new.	change := PP2DeleteCharacter new.	memento := PP2Memento new.! !!PP2DeleteCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChangeAfterRange	change position: 2.	self assert: (change changeAfterRange: 0).	self deny: (change changeAfterRange: 1).	self deny: (change changeAfterRange: 2).! !!PP2DeleteCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChangeBeforeRange	change position: 2.	self assert: (change changeBeforeRange: 4).	self assert: (change changeBeforeRange: 3).	self deny: (change changeBeforeRange: 2).! !!PP2DeleteCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChangeBetweenAnd	change position: 2.	self assert: (change changeBetween: 2 and: 2).	self assert: (change changeBetween: 2 and: 3).	self assert: (change changeBetween: 1 and: 2).	self assert: (change changeBetween: 1 and: 1).	self deny: (change changeBetween: 3 and: 3).! !!PP2DeleteCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateBufferChangeAfter	key := 0. "+1"	memento furthestPosition: 1.	change position: 3.	context position: memento furthestPosition.	memento contextMemento: context remember.	buffer at: key put: memento.		newBuffer := change updateBuffer: buffer.	self assert: (newBuffer at: key) equals: memento.	self assert: memento contextMemento position equals: 1.! !!PP2DeleteCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateBufferChangeBefore	key := 1. "+1"	memento furthestPosition: 3.	change position: 1.	context position: memento furthestPosition.	memento contextMemento: context remember.	buffer at: key put: memento.		newBuffer := change updateBuffer: buffer.	self assert: (newBuffer at: key - 1) equals: memento.	self assert: memento contextMemento position equals: 2.! !!PP2DeleteCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateBufferInRange	key := 0. "+1"	memento furthestPosition: 3.	change position: 2.	context position: memento furthestPosition.	memento contextMemento: context remember.	buffer at: key put: memento.		newBuffer := change updateBuffer: buffer.	self assert: (newBuffer at: key) isKindOf: PP2MementoPromise.	self assert: (newBuffer at: key) buffer equals: newBuffer.	self assert: (newBuffer at: key) contextMemento position equals: 2.	self assert: (newBuffer at: key) furthestPosition equals: 2.	"not 100% it should be 2 or 3"	self assert: (newBuffer at: key) position equals: key.	! !!PP2DeleteCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateBufferInRangeHighBoundary	key := 0. "+1"	memento furthestPosition: 3.	change position: 4.	context position: memento furthestPosition.	memento contextMemento: context remember.	buffer at: key put: memento.		newBuffer := change updateBuffer: buffer.	self assert: (newBuffer at: key) isKindOf: PP2MementoPromise.	self assert: (newBuffer at: key) buffer equals: newBuffer.	self assert: (newBuffer at: key) contextMemento position equals: 2.	self assert: (newBuffer at: key) position equals: key.	! !!PP2DeleteCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateBufferInRangeLowBoundary	key := 0. "+1"	memento furthestPosition: 2.	change position: 1.	context position: memento furthestPosition.	memento contextMemento: context remember.	buffer at: key put: memento.		newBuffer := change updateBuffer: buffer.	self assert: (newBuffer at: key) isKindOf: PP2MementoPromise.	self assert: (newBuffer at: key) buffer equals: newBuffer.	self assert: (newBuffer at: key) contextMemento position equals: 1.	self assert: (newBuffer at: key) position equals: key.	! !!PP2DeleteCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateTokens	| token anotherToken returnValue originalInput |	originalInput := '_foobar'.	token := PP2Token on: originalInput start: 2 stop: 4.	anotherToken := PP2Token on: originalInput start: 5 stop: 7.		returnValue := OrderedCollection with: token with: #foobar with: anotherToken.	change input: 'foobar'.	change position: 1.	change updateTokens: returnValue.		self assert: token start equals: 1.	self assert: token stop equals: 3.	self assert: token value = 'foo'.		self assert: anotherToken start equals: 4.	self assert: anotherToken stop equals: 6.	self assert: anotherToken value equals: 'bar'.! !!PP2DeleteCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateTokensAfterChange	| token anotherToken returnValue originalInput |	originalInput := 'foo___bar'.	token := PP2Token on: originalInput start: 1 stop: 3.	anotherToken := PP2Token on: originalInput start: 7 stop: 9.		returnValue := OrderedCollection with: token with: #foobar with: anotherToken.	change input: 'foo__bar'.	change position: 5.	change updateTokens: returnValue.		self assert: token start equals: 1.	self assert: token stop equals: 3.	self assert: token value = 'foo'.		self assert: anotherToken start equals: 6.	self assert: anotherToken stop equals: 8.	self assert: anotherToken value equals: 'bar'.! !!PP2DeleteCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateTokensOnce	| token returnValue originalInput |	originalInput := '__foobar'.	token := PP2Token on: originalInput start: 3 stop: 5.		returnValue := OrderedCollection with: token with: #foobar with: token.	change input: '_foobar'.	change position: 1.	change updateTokens: returnValue.		self assert: token start equals: 2.	self assert: token stop equals: 4.	self assert: token value = 'foo'.! !!PP2DeleteCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateTokensSingleToken	| returnValue originalInput |	originalInput := '__foobar'.	returnValue := PP2Token on: originalInput start: 3 stop: 5.			change input: '_foobar'.	change position: 1.	change updateTokens: returnValue.		self assert: returnValue start equals: 2.	self assert: returnValue stop equals: 4.	self assert: returnValue value = 'foo'.! !!PP2FirstCharSetTest methodsFor: 'support' stamp: ' 12/6/2016 07:12:31'!assert: aPP2CharSetPredicate value: anInteger	self assert: (aPP2CharSetPredicate value: anInteger) ! !!PP2FirstCharSetTest methodsFor: 'support' stamp: ' 12/6/2016 07:12:31'!reject: aPP2CharSetPredicate value: anInteger	self assert: (aPP2CharSetPredicate value: anInteger) not! !!PP2FirstCharSetTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEmptyLiteralSequence	firstCharSet := '' asPParser firstCharSet.	1 to: 255 do: [ :index |		self assert: firstCharSet value: (Character codePoint: index).	].	self assert: firstCharSet value: (Character codePoint: 0).	self assert: firstCharSet value: (Character codePoint: 1234).! !!PP2FirstCharSetTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEpsilon	firstCharSet := nil asPParser firstCharSet.	1 to: 255 do: [ :index |		self assert: firstCharSet value: (Character codePoint: index).	].	self assert: firstCharSet value: (Character codePoint: 0).	self assert: firstCharSet value: (Character codePoint: 1234).! !!PP2FirstCharSetTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testLiteralObject	firstCharSet := $b asPParser firstCharSet.	self assert: firstCharSet value: $b.	self reject: firstCharSet value: $a.	self reject: firstCharSet value: $c.		self reject: firstCharSet value: (Character codePoint: 1024).	! !!PP2FirstCharSetTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testLiteralSequence	firstCharSet := 'foobar' asPParser firstCharSet.	self assert: firstCharSet value: $f.	self reject: firstCharSet value: $e.	self reject: firstCharSet value: $o.	self reject: firstCharSet value: $b.		self reject: firstCharSet value: 1024.	! !!PP2FirstCharSetTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNot	firstCharSet := #digit asPParser not firstCharSet.	self should: [ firstCharSet value: $1 ] raise: Error! !!PP2FirstCharSetTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPluggable	firstCharSet := ([ :c | c next ] asPParser) firstCharSet.	self assert: firstCharSet isUnknown.! !!PP2FirstCharSetTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPredicateObject	firstCharSet := #digit asPParser firstCharSet.	self assert: firstCharSet value: $0.	self assert: firstCharSet value: $1.	self assert: firstCharSet value: $2.	self assert: firstCharSet value: $3.	self assert: firstCharSet value: $4.	self assert: firstCharSet value: $5.	self assert: firstCharSet value: $6.	self assert: firstCharSet value: $7.	self assert: firstCharSet value: $8.	self assert: firstCharSet value: $9.	self reject: firstCharSet value: $/.	self reject: firstCharSet value: $:.		self reject: firstCharSet value: (Character codePoint: 1024).	self reject: firstCharSet value: (Character codePoint: 0).	! !!PP2FirstCharSetTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testStartOfLine	firstCharSet := #startOfLine asPParser firstCharSet.	self should: [ firstCharSet value: $1 ] raise: Error! !!PP2FirstCharSetTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testWrapping	firstCharSet := ($a asPParser >=> [ :c :cc | cc value ]) firstCharSet.	self assert: firstCharSet isUnknown.! !!PP2FirstCharSetTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testWrappingNonFunctional	firstCharSet := ($b asPParser >==> [ :c :cc | cc value ]) firstCharSet.	self assert: firstCharSet value: $b.	self reject: firstCharSet value: $a.	self reject: firstCharSet value: $c.! !!PP2FirstProductionSetCacheTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSanity	| parser |	parser := PP2ExpressionGrammar new.	PP2FirstProductionSetCache new doPass: parser.		parser allNodesDo: [ :child | 		self assert: (child hasProperty: #firstProductionSet).		self assert: (child firstProductionSet allSatisfy: [ :e | e isProduction  ])	]! !!PP2FirstSetCacheTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSanity	| parser |	parser := ((($f asPParser, 'oo' asPParser) wrapped not ==> [ :e | e ]) star / 				   (nil asPParser, '' asPParser)) end.	PP2FirstSetCache new doPass: parser.		self assert: (parser allNodes allSatisfy: [ :child | child hasProperty: #firstSet ])! !!PP2FirstSetVisitorTest methodsFor: 'converting' stamp: ' 12/6/2016 07:12:31'!assert: aSet anySatisfy: anObject	self assert: (aSet anySatisfy: anObject)! !!PP2FirstSetVisitorTest methodsFor: 'converting' stamp: ' 12/6/2016 07:12:31'!assert: aSet includes: anObject	self assert: (aSet includes: anObject)! !!PP2FirstSetVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!firstSet: aPP2Node	^ PP2FirstSetVisitor firstSet visit: aPP2Node! !!PP2FirstSetVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!firstSetWithProduction: aPP2Node	^ PP2FirstSetVisitor productionSet visit: aPP2Node! !!PP2FirstSetVisitorTest methodsFor: 'tests - seas or terminals' stamp: ' 12/6/2016 07:12:31'!firstSetWithSeasOrTerminals: node	^ PP2FirstSetVisitor seasOrTerminalsSet visit: node! !!PP2FirstSetVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!firstSetWithTokens: aPP2Node	^ PP2FirstSetVisitor tokenSet visit: aPP2Node! !!PP2FirstSetVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!firstSetWithoutDuplicates: aPP2Node	^ self withoutDuplicates: (PP2FirstSetVisitor firstSet visit: aPP2Node)! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAdaptable	parser := PP2AdaptableNode new.	parser changeChild: $a asPParser.	firstSet := self firstSet: parser.	self assert: firstSet size equals: 2.	self assert: firstSet includes: PP2EpsilonNode instance.		1 to: 255 do: [ :index | 		self assert: firstSet anySatisfy: [ :e | 			(e parse: (Character codePoint: index) asString) isPetit2Success 		]	]	! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAnd	| sequence |	parser := #letter asPParser.	sequence := parser and, $b asPParser.	firstSet := self firstSet: sequence.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChoice	| parserOne parserTwo |	parserOne := $a asPParser.	parserTwo := $b asPParser.			firstSet := self firstSet: parserOne / parserTwo.	self assert: firstSet size equals: 2.	self assert: firstSet includes: parserOne.	self assert: firstSet includes: parserTwo.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCycle	| delegateOne delegateTwo sequence |	delegateOne := PP2DelegateNode new.	delegateTwo := PP2DelegateNode new.	sequence := nil asPParser, delegateTwo.		delegateOne child: delegateTwo.	delegateTwo child: delegateOne.		self should: [ firstSet := self firstSet: sequence ] raise: Error."	self assert: firstSet isEmpty"! !!PP2FirstSetVisitorTest methodsFor: 'tests - productions' stamp: ' 12/6/2016 07:12:31'!testDeepProductions	| productionTop productionOne productionTwo |	productionOne := 'foo' asPParser name: 'bar'.	productionTwo := 'bar' asPParser name: 'baz'.	productionTop := (productionOne / productionTwo) wrapped name: 'bark'.	parser := productionTop plus.		firstSet := self firstSetWithProduction: parser.	self assert: firstSet size equals: 3.	self assert: (firstSet includes: productionOne).	self assert: (firstSet includes: productionTwo).		self assert: (firstSet includes: productionTop).		! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testDelegate	| delegate  |	parser := $a asPParser. 	delegate := parser wrapped.		firstSet := self firstSet: delegate.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEndOfInput	parser := PP2EndOfInputNode new.		firstSet := self firstSet: parser.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests - tokens' stamp: ' 12/6/2016 07:12:31'!testFirstWithTokensOneToken	| token  |	token := $a asPParser token.	parser := $b asPParser.		firstSet := self firstSetWithTokens: token / parser.		self assert: firstSet size equals: 2.	self assert: firstSet includes: token.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests - tokens' stamp: ' 12/6/2016 07:12:31'!testFirstWithTokensTwoTokens	| tokenOne tokenTwo trimmer |	trimmer := $c asPParser.	tokenOne := $a asPParser token.	tokenTwo := $b asPParser token trim: trimmer.		firstSet := self firstSetWithTokens: tokenOne / tokenTwo.		self assert: firstSet size equals: 3.	self assert: firstSet includes: tokenOne.	self assert: firstSet includes: tokenTwo child.	self assert: firstSet includes: tokenTwo trimmer.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testFlatten	| flattened |	parser := #letter asPParser.	flattened := parser, #word asPParser star.	firstSet := self firstSet: flattened.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests - seas or terminals' stamp: ' 12/6/2016 07:12:31'!testJustSeaSoT	parser := $a asPParser sea.		firstSet := self firstSetWithSeasOrTerminals: parser.		self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testLiteralObject	parser := $a asPParser.	firstSet := self firstSet: parser.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testLiteralSequence	parser := 'foo' asPParser.	firstSet := self firstSet: parser.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNonEpsilon	| terminal |	terminal := $b asPParser.	parser := terminal optional nonEpsilon.		firstSet := self firstSet: parser.		self assert: firstSet size equals: 1.	self assert: firstSet includes: terminal.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNonEpsilonWithoutEpsilon	| terminal |	terminal := $b asPParser.	parser := terminal nonEpsilon.		firstSet := self firstSet: parser.		self assert: firstSet size equals: 1.	self assert: firstSet includes: terminal.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNot	| sequence |	parser := $a asPParser not.	sequence := parser, $b asPParser.	firstSet := self firstSet: sequence.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testOptional	| optional |	parser := $a asPParser.	optional := parser optional.	firstSet := self firstSet: optional.	self assert: firstSet size equals: 2.	self assert: firstSet includes: PP2EpsilonNode instance.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests - seas or terminals' stamp: ' 12/6/2016 07:12:31'!testOptionalSeaSoT	| sea |	sea := $a asPParser sea.	parser := sea optional wrapped.		firstSet := self firstSetWithSeasOrTerminals: parser.		self assert: firstSet size equals: 2.	self assert: firstSet includes: sea! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPluggable	parser := [:ctx | ctx next] asPParser.	firstSet := self firstSet: parser.	"JK: Not sure if it should contain epsilon or not"	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPlus	| plus |	parser := $a asPParser.	plus := parser plus.	firstSet := self firstSet: plus.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPlusOptional	| plus |	parser := $a asPParser.	"JK: This should actually throw warning somewhere"	plus := parser optional plus.	firstSet := self firstSet: plus.	self assert: firstSet size equals: 2.	self assert: firstSet includes: PP2EpsilonNode instance.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests - seas or terminals' stamp: ' 12/6/2016 07:12:31'!testPossibleSeaSoT	| sea before |	sea := $a asPParser sea.	before := $b asPParser.	parser := before optional, sea.		firstSet := self firstSetWithSeasOrTerminals: parser.		self assert: firstSet size equals: 2.	self assert: firstSet includes: sea.	self assert: firstSet includes: before.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPredicateObject	parser := #letter asPParser.	firstSet := self firstSet: parser.	self assert: firstSet size equals: 1.	self assert: firstSet anyOne equals: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests - productions' stamp: ' 12/6/2016 07:12:31'!testProductions	| productionOne productionTwo |	productionOne := 'foo' asPParser name: 'bar'.	productionTwo := 'bar' asPParser name: 'baz'.	parser := productionOne / productionTwo.		firstSet := self firstSetWithProduction: parser.	self assert: firstSet size equals: 2.	self assert: (firstSet includes: productionOne).	self assert: (firstSet includes: productionTwo).	! !!PP2FirstSetVisitorTest methodsFor: 'tests - productions' stamp: ' 12/6/2016 07:12:31'!testProductionsSelf	parser := 'foo' asPParser name: 'bar'.		firstSet := self firstSetWithProduction: parser.	self assert: firstSet size equals: 1.	self assert: (firstSet includes: parser)! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSea	| sea |	parser := $a asPParser.	sea := parser sea.	firstSet := self firstSetWithoutDuplicates: sea.		self assert: firstSet size equals: 2.	self assert: firstSet includes: parser.	self assert: firstSet includes: #any asPParser. ! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSeaNullable	| sea |	parser := $a asPParser.	sea := parser optional sea.	firstSet := self firstSetWithoutDuplicates: sea.	self assert: firstSet size equals: 3.	self assert: firstSet includes: parser.	self assert: firstSet includes: #any asPParser.	self assert: firstSet includes: #eoi asPParser.	! !!PP2FirstSetVisitorTest methodsFor: 'tests - seas or terminals' stamp: ' 12/6/2016 07:12:31'!testSeaRepetitionSoT	| sea |	sea := $a asPParser sea.	parser := sea plus.		firstSet := self firstSetWithSeasOrTerminals: parser.		self assert: firstSet size equals: 1.	self assert: firstSet includes: sea.! !!PP2FirstSetVisitorTest methodsFor: 'tests - seas or terminals' stamp: ' 12/6/2016 07:12:31'!testSeaSoT	| sea |	sea := $a asPParser sea.	parser := sea wrapped.		firstSet := self firstSetWithSeasOrTerminals: parser.		self assert: firstSet size equals: 1.	self assert: firstSet includes: sea.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSeaWaterTokens	| sea waterToken tokenOne tokenTwo |	parser := $a asPParser.	tokenOne := $b asPParser.	tokenTwo := $c asPParser.	waterToken := tokenOne / tokenTwo.		sea := parser sea: waterToken.	firstSet := self firstSetWithoutDuplicates: sea.	self assert: firstSet size equals: 3.	self assert: firstSet includes: parser.	self assert: firstSet includes: tokenOne.	self assert: firstSet includes: tokenTwo.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequence	| sequence |	parser := $a asPParser.	sequence := parser, $b asPParser.	 	firstSet := self firstSet: sequence.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceTwoEpsilons	| sequence parserOne parserTwo |	parserOne := $a asPParser.	parserTwo := nil asPParser.	sequence := parserOne star, parserTwo.	 	firstSet := self firstSet: sequence.	self assert: firstSet size equals: 2.	self assert: firstSet includes: parserOne.	self assert: firstSet includes: parserTwo! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceTwoStars	| sequence parserOne parserTwo |	parserOne := $a asPParser.	parserTwo := $b asPParser.	sequence := parserOne star, parserTwo star.	 	firstSet := self firstSet: sequence.	self assert: firstSet size equals: 3.	self assert: firstSet includes: parserOne.	self assert: firstSet includes: parserTwo.	self assert: firstSet includes: PP2EpsilonNode instance! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceWithNil	| sequence parserOne parserTwo |	parserOne := nil asPParser.	parserTwo := $b asPParser.	sequence := parserOne, parserTwo.	 	firstSet := self firstSet: sequence.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parserTwo! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceWithStar	| sequence parserOne parserTwo |	parserOne := $a asPParser.	parserTwo := $b asPParser.	sequence := parserOne star, parserTwo.	 	firstSet := self firstSet: sequence.	self assert: firstSet size equals: 2.	self assert: firstSet includes: parserOne.	self assert: firstSet includes: parserTwo! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testStar	| star |	parser := $a asPParser.	star := parser star.	firstSet := self firstSet: star.	self assert: firstSet size equals: 2.	self assert: firstSet includes: parser.	self assert: firstSet includes: PP2EpsilonNode instance! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testStartOfLine	parser := #startOfLine asPParser.	firstSet := self firstSet: parser.	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testToken	| token |	parser := 'foo' asPParser.	token := parser token.	firstSet := self firstSet: token.	self assert: firstSet size equals: 1.	self assert: firstSet anyOne equals: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTrimming	| trimming |	parser := 'foo' asPParser.	trimming := parser trim.	firstSet := self firstSet: trimming.	self assert: firstSet size equals: 2.	self assert: firstSet includes: parser.	self assert: firstSet includes: trimming trimmer child.	! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTrimmingWithEpsilon	| trimming |	parser := 'foo' asPParser.	trimming := parser optional trim.	firstSet := self firstSet: trimming.	self assert: firstSet size equals: 3.	self assert: firstSet includes: parser.	self assert: firstSet includes: trimming trimmer child.		self assert: firstSet includes: PP2EpsilonNode instance.		! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTwoParents	| sequence |	parser := $a asPParser.	sequence := parser star, parser star.		firstSet := self firstSet: sequence.		self assert: firstSet size equals: 2.	self assert: firstSet includes: PP2EpsilonNode instance.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testWaterFirstSet	| boundary waterToken |	boundary := $b asPParser.	waterToken := $a asPParser.	parser := PP2WaterNode new boundary: boundary; waterToken: waterToken.		firstSet := self firstSet: parser.		self assert: firstSet size equals: 2.	self assert: firstSet includes: boundary.	self assert: firstSet includes: waterToken.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testWrapping	parser := $a asPParser >=> [:c :cc | cc value].	firstSet := self firstSet: parser.	"JK: Not sure if it should contain epsilon or not"	self assert: firstSet size equals: 1.	self assert: firstSet includes: parser.! !!PP2FirstSetVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testWrappingNonFunctional	| literal |	literal := $a asPParser.	parser := literal >==> [:c :cc | cc value].	firstSet := self firstSet: parser.	"JK: Not sure if it should contain epsilon or not"	self assert: firstSet size equals: 1.	self assert: firstSet includes: literal.! !!PP2FirstSetVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!withoutDuplicates: set	| newSet |	newSet := Set new.	newSet addAll: set.	^ newSet! !!PP2GuardVisitorTest methodsFor: 'support' stamp: ' 12/6/2016 07:12:31'!assert: booleanArray at: position	self assert: (booleanArray at: position)! !!PP2GuardVisitorTest methodsFor: 'support' stamp: ' 12/6/2016 07:12:31'!deny: booleanArray at: position	self assert: (booleanArray at: position) not! !!PP2GuardVisitorTest methodsFor: 'support' stamp: ' 12/6/2016 07:12:31'!optimize: node	PP2IsNullableCache new doPass: node.	PP2FirstSetCache new doPass: node.	PP2GuardVisitor new doPass: node! !!PP2GuardVisitorTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setUp	super setUp.		visitor := PP2GuardVisitor new! !!PP2GuardVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChoice	| parserOne parserTwo |	parserOne := 'foo' asPParser token trim wrapped.	parserTwo := 'bar' asPParser token trim wrapped.		self optimize: parserOne / parserTwo.		self assert: parserOne strategy isKindOf: PP2ParsingGuard.	self assert: parserOne strategy classification isNotNil.		self assert: parserTwo strategy isKindOf: PP2ParsingGuard.	self assert: parserTwo strategy classification isNotNil.! !!PP2GuardVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testClassificationFor	| classification |	parser := $a asPParser / $b asPParser.		classification := visitor classificationFor: parser.		self assert: classification at: $a codePoint.	self assert: classification at: $b codePoint.	self deny: classification at: $" codePoint.	self deny: classification at: $c codePoint.	! !!PP2GuardVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testClassificationFor2	| classification |	parser := #letter asPParser / #digit asPParser.		classification := visitor classificationFor: parser.		1 to: 255 do: [ :index | 		self assert: (classification at: index) equals: ((Character codePoint: index )isAlphaNumeric).	]! !!PP2GuardVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testDelegate	parser := 'foo' asPParser plus flatten wrapped.		self optimize: parser.		self assert: parser strategy isKindOf: PP2ParsingGuard.	self assert: parser strategy classification isNotNil.! !!PP2GuardVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testGuardedChoice	| parserOne parserTwo parserThree choiceOne |	parserOne := 'foo' asPParser token trim wrapped.	parserTwo := 'bar' asPParser token trim wrapped.	parserThree := 'baz' asPParser token trim wrapped.		choiceOne := (parserOne / parserTwo) wrapped.		self optimize: choiceOne / parserThree.		self assert: choiceOne strategy isKindOf: PP2ParsingGuard.	self assert: choiceOne strategy classification isNotNil.		self assert: parserThree strategy isKindOf: PP2ParsingGuard.	self assert: parserThree strategy classification isNotNil.		self assert: parserOne strategy isKindOf: PP2ParsingGuard.	self assert: parserTwo strategy isKindOf: PP2ParsingGuard.! !!PP2GuardVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testGuardedChoice2	| parserOne parserTwo parserThree choiceOne |	parserOne := 'baz' asPParser token trim wrapped.	parserTwo := 'bar' asPParser token trim wrapped.	parserThree := 'foo' asPParser token trim wrapped.		choiceOne := (parserOne / parserTwo) wrapped.	parser := choiceOne / parserThree.	self optimize: parser.		self assert: choiceOne strategy isKindOf: PP2ParsingGuard.	self assert: choiceOne strategy classification isNotNil.		self assert: parserThree strategy isKindOf: PP2ParsingGuard.	self assert: parserThree strategy classification isNotNil.		"already guarded by a parent!!"	self deny: parserOne strategy isKindOf: PP2ParsingGuard.	self deny: parserTwo strategy isKindOf: PP2ParsingGuard.! !!PP2GuardVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testOptional	parser := 'foo' asPParser token trim optional.		self optimize: parser.		self assert: parser strategy isKindOf: PP2ParsingGuard.	self assert: parser strategy retval isNil.! !!PP2GuardVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPlus	parser := 'foo' asPParser token trim plus.	parser strategy: (PP2Plus on: parser).		self optimize: parser.		self assert: parser strategy isKindOf: PP2ParsingGuard.	self assert: parser strategy retval isPetit2Failure.! !!PP2GuardVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testStar	parser := 'foo' asPParser token trim star.	parser strategy: (PP2Star on: parser).		self optimize: parser.		self assert: parser strategy isKindOf: PP2ParsingGuard.	self assert: parser strategy retval equals: #().! !!PP2GuardVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTimes	parser := 'foo' asPParser token trim times: 3.		self optimize: parser.		self assert: parser strategy isKindOf: PP2ParsingGuard.	self assert: parser strategy classification isNotNil.	self assert: parser strategy retval isPetit2Failure! !!PP2InMemoryContextTest methodsFor: 'requirements' stamp: ' 12/6/2016 07:12:31'!contextOn: aString	^ PP2InMemoryContext on: aString! !!PP2InMemoryContextTest methodsFor: 'tests - converting' stamp: ' 12/6/2016 07:12:31'!testAsPetit2Context	| context |	context := 'foo' asPetit2Stream asPetit2Context.		self assert: (context isKindOf: PP2InMemoryContext).	self assert: context isPetit2Success.! !!PP2InMemoryContextTest methodsFor: 'tests - converting' stamp: ' 12/6/2016 07:12:31'!testAsPetit2ContextDirect	| context |	context := 'foo' asPetit2Context.	self assert: context isKindOf: PP2InMemoryContext.	self assert: context start equals: 0.	self assert: context readLimit equals: 3! !!PP2InMemoryContextTest methodsFor: 'tests - converting' stamp: ' 12/6/2016 07:12:31'!testAsPositionableStream	| stream context |		context := 'bar' asPetit2Stream asPetit2Context.	context position: 2.	stream := context asPositionableStream.		self assert: (stream isKindOf: PositionableStream).	self assert: stream position equals: 2.	self assert: stream peek equals: $r.! !!PP2InMemoryContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCopy	| stream newContext context |	stream := 'foo' asPetit2Stream.		context := PP2InMemoryContext new		stream: stream; 		position: 1;		parser: #parser;		startMemento: #startMemento;		yourself.			newContext := context copy.		self deny: context == newContext.	self assert: context position = newContext position.	self assert: context contents = newContext contents.		self assert: context parser = newContext parser.	self assert: context startMemento = newContext startMemento.! !!PP2InsertCharacterTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setUp	context := PP2Context on: 'foobar'.	buffer := IdentityDictionary new.	change := PP2InsertCharacter new.	memento := PP2Memento new.! !!PP2InsertCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChangeAfterRange	change position: 2.	self assert: (change changeAfterRange: 0).	self deny: (change changeAfterRange: 1).! !!PP2InsertCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChangeBeforeRange	change position: 2.	self assert: (change changeBeforeRange: 4).	self assert: (change changeBeforeRange: 3).	self deny: (change changeBeforeRange: 2).! !!PP2InsertCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChangeBetweenAnd	change position: 2.	self assert: (change changeBetween: 2 and: 2).	self assert: (change changeBetween: 2 and: 3).	self assert: (change changeBetween: 1 and: 2).	self assert: (change changeBetween: 1 and: 1).	self deny: (change changeBetween: 3 and: 3).	self deny: (change changeBetween: 0 and: 0).! !!PP2InsertCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateBufferChangeAfter	key := 0. "+1"	memento furthestPosition: 1.	change position: 3.	context position: memento furthestPosition.	memento contextMemento: context remember.		buffer at: key put: memento.		newBuffer := change updateBuffer: buffer.	self assert: (newBuffer at: key) equals: memento.	self assert: memento contextMemento position equals: 1.! !!PP2InsertCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateBufferChangeBefore	key := 2. "+1"	memento furthestPosition: 3.	change position: 1.	context position: memento furthestPosition.	memento contextMemento: context remember.		buffer at: key put: memento.		newBuffer := change updateBuffer: buffer.	self assert: (newBuffer at: key + 1) equals: memento.	self assert: memento contextMemento position equals: 4.! !!PP2InsertCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateBufferInRange	key := 0. "+1"	memento furthestPosition: 3.	change position: 2.		context position: memento furthestPosition.	memento contextMemento: context remember.		buffer at: key put: memento.		newBuffer := change updateBuffer: buffer.	self assert: (newBuffer at: key) isKindOf: PP2MementoPromise.	self assert: (newBuffer at: key) buffer equals: newBuffer.	self assert: (newBuffer at: key) contextMemento position equals: 4.	self assert: (newBuffer at: key) furthestPosition equals: 4.	self assert: (newBuffer at: key) position equals: key.	! !!PP2InsertCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateBufferInRangeHighBoundary	key := 0. "+1"	memento furthestPosition: 1.	change position: 2.	context position: memento furthestPosition.	memento contextMemento: context remember.	buffer at: key put: memento.		newBuffer := change updateBuffer: buffer.	self assert: (newBuffer at: key) isKindOf: PP2MementoPromise.	self assert: (newBuffer at: key) buffer equals: newBuffer.	self assert: (newBuffer at: key) contextMemento position equals: 2.		self assert: (newBuffer at: key) position equals: key.! !!PP2InsertCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateBufferInRangeLowBoundary	key := 1. "+1"	memento furthestPosition: 3.	change position: 2.	context position: memento furthestPosition.	memento contextMemento: context remember.		buffer at: key put: memento.		newBuffer := change updateBuffer: buffer.	self assert: (newBuffer at: key) isKindOf: PP2MementoPromise.	self assert: (newBuffer at: key) buffer equals: newBuffer.	self assert: (newBuffer at: key) contextMemento position equals: 4.	self assert: (newBuffer at: key) position equals: key.		! !!PP2InsertCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateTokens	| token anotherToken returnValue originalInput |	originalInput := '_foobar'.	token := PP2Token on: originalInput start: 2 stop: 4.	anotherToken := PP2Token on: originalInput start: 5 stop: 7.		returnValue := OrderedCollection with: token with: #foobar with: anotherToken.	change input: '__foobar'.	change position: 1.	change updateTokens: returnValue.		self assert: token start equals: 3.	self assert: token stop equals: 5.	self assert: token value = 'foo'.		self assert: anotherToken start equals: 6.	self assert: anotherToken stop equals: 8.	self assert: anotherToken value equals: 'bar'.! !!PP2InsertCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateTokensAfterChange	| token anotherToken returnValue originalInput |	originalInput := 'foo__bar'.	token := PP2Token on: originalInput start: 1 stop: 3.	anotherToken := PP2Token on: originalInput start: 6 stop: 8.		returnValue := OrderedCollection with: token with: #foobar with: anotherToken.	change input: 'foo___bar'.	change position: 5.	change updateTokens: returnValue.		self assert: token start equals: 1.	self assert: token stop equals: 3.	self assert: token value = 'foo'.		self assert: anotherToken start equals: 7.	self assert: anotherToken stop equals: 9.	self assert: anotherToken value equals: 'bar'.! !!PP2InsertCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateTokensOnce	| token returnValue originalInput |	originalInput := '_foobar'.	token := PP2Token on: originalInput start: 2 stop: 4.		returnValue := OrderedCollection with: token with: #foobar with: token.	change input: '__foobar'.	change position: 1.	change updateTokens: returnValue.		self assert: token start equals: 3.	self assert: token stop equals: 5.	self assert: token value = 'foo'.! !!PP2InsertCharacterTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateTokensSingleToken	| returnValue originalInput |	originalInput := '_foobar'.	returnValue := PP2Token on: originalInput start: 2 stop: 4.			change input: '__foobar'.	change position: 1.	change updateTokens: returnValue.		self assert: returnValue start equals: 3.	self assert: returnValue stop equals: 5.	self assert: returnValue value = 'foo'.! !!PP2IsNullableCacheTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSanity	| parser |	parser := ((($f asPParser, 'oo' asPParser) wrapped not ==> [ :e | e ]) star / 				   (nil asPParser, '' asPParser)) end.	PP2IsNullableCache new doPass: parser.		self assert: (parser allNodes allSatisfy: [ :child | child hasProperty: #isNullable ])! !!PP2IsNullableVisitorTest methodsFor: 'support' stamp: ' 12/6/2016 07:12:31'!assertIsNullable: node	| retval |	retval := visitor visit: node.	self assert: retval! !!PP2IsNullableVisitorTest methodsFor: 'support' stamp: ' 12/6/2016 07:12:31'!denyIsNullable: node	| retval |	retval := visitor visit: node.	self assert: retval not! !!PP2IsNullableVisitorTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setUp	super setUp.		visitor := PP2IsNullableVisitor new! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAction	self denyIsNullable: #letter asPParser ==> [ :foo | foo ].! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testActionEmpty	self assertIsNullable: nil asPParser ==> [ :foo | foo ].	! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAdaptable	parser := PP2AdaptableNode new.	parser changeChild: $a asPParser.	self denyIsNullable: parser! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAdaptableEpsilon	parser := PP2AdaptableNode new.	parser changeChild: nil asPParser.	self denyIsNullable: parser! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAnd	self denyIsNullable: #letter asPParser and! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testBlock	| block |	block := [ :context | context next ] asPParser.	self denyIsNullable: block.! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testBlockAcceptsEpsilon	| block |	block := [ :context | context next ] asPParser					isNullable: true;					yourself.	self assertIsNullable: block.! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCycle	| delegateOne delegateTwo sequence |	delegateOne := PP2DelegateNode new.	delegateTwo := PP2DelegateNode new.	sequence := nil asPParser, delegateTwo.		delegateOne child: delegateTwo.	delegateTwo child: delegateOne.		self should: [ self assertIsNullable: sequence ] raise: Error! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCycleNoRecursion	| delegateOne delegateTwo sequence |	delegateOne := PP2DelegateNode new.	delegateTwo := PP2DelegateNode new.	sequence := $a asPParser, delegateTwo.		delegateOne child: delegateTwo.	delegateTwo child: delegateOne.		self denyIsNullable: sequence! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEmptyLiteral	self assertIsNullable: '' asPParser! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEnd	self denyIsNullable: 'foo' asPParser end! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEndEmpty	self assertIsNullable: nil asPParser end! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEndOfInput	self denyIsNullable: PP2EndOfInputNode new! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testLiteral	self denyIsNullable: 'foo' asPParser! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testLiteralObject	self denyIsNullable: $a asPParser.! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNil	self assertIsNullable: nil asPParser optional.! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNot	self denyIsNullable: #letter asPParser not! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testOptional	self assertIsNullable: #letter asPParser optional.! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPluggable	self denyIsNullable: [:ctx | ctx] asPParser.! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPlus	self denyIsNullable: #letter asPParser plus.! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPlusEplsilon	self assertIsNullable: nil asPParser plus.! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPredicate	self denyIsNullable: #letter asPParser.! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPredicateObject	self denyIsNullable: #letter asPParser.! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPredicateObjectAny	self denyIsNullable: #any asPParser.! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequence	self denyIsNullable: #letter asPParser, #word asPParser! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceEmpty	self assertIsNullable: #letter asPParser optional, nil asPParser! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceFirstEpsilon	self denyIsNullable: #letter asPParser optional, #word asPParser! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testStar	self assertIsNullable: #letter asPParser star.! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testStartOfLine	self denyIsNullable: #startOfLine asPParser! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testWater	self denyIsNullable: (PP2WaterNode new boundary: nil asPParser).	self denyIsNullable: (PP2WaterNode new boundary: $a asPParser).! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testWrapping	parser := $a asPParser >=> [ :c :cc | cc value ].	self denyIsNullable: parser! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testWrappingAcceptsEpsilon	| wrapped |	wrapped := $a asPParser >=> [ :context :cc |  ]		isNullable: true;		yourself.		self assertIsNullable: wrapped! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testWrappingNonFunctional	parser := $a asPParser >==> [:c :cc | cc value].	self denyIsNullable: parser! !!PP2IsNullableVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testWrappingNonFunctionalEpsilon	parser := nil asPParser >==> [:c :cc | cc value].	self assertIsNullable: parser! !!PP2NextSetsContextTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!setUp	o1 := Object new.	o2 := Object new.	o3 := Object new.		context1 := PP2NextSetsContext new.	context2 := PP2NextSetsContext new.! !!PP2NextSetsContextTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testEqual	context1 currentNext: (IdentitySet with: o1 with: o2).	context2 currentNext: (IdentitySet with: o2 with: o1).		self deny: context1 == context2.	self assert: context1 = context2.! !!PP2NextSetsContextTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testEqualNot	context1 currentNext: (IdentitySet with: o1 with: o2).	context2 currentNext: (IdentitySet with: o2 with: o3).		self deny: context1 == context2.	self deny: context1 = context2.! !!PP2NextSetsContextTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testHash	context1 currentNext: (IdentitySet with: o1 with: o2).	context2 currentNext: (IdentitySet with: o2 with: o1).		self assert: context1 hash equals: context2 hash. ! !!PP2NextSetsContextTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testHashNotEqual	context1 currentNext: (IdentitySet with: o1 with: o2).	context2 currentNext: (IdentitySet with: o2 with: o1 with: o3).		self deny: context1 hash = context2 hash. ! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!assert: aSet includes: anObject	self assert: (aSet includes: anObject)! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!nextSet: node in: root	visitor visit: root.	^ nextSet := visitor nextSets at: node! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!setUp	visitor := PP2NextSetsVisitor new.	eoi := visitor instVarNamed: #eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testAction	| action |	parser := $a asPParser.	action := parser ==> [:e | e].		self nextSet: parser in: action.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: action in: action.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testChoice	| choice |	parser := $a asPParser.	choice := parser / parser wrapped.		self nextSet: parser in: choice.		self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testDelegate	| delegate |	parser := $a asPParser.	delegate := parser wrapped.		self nextSet: parser in: delegate.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: delegate in: delegate.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testEpsilon	parser := nil asPParser.		self nextSet: parser in: parser.		self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testFlatten	| flatten |	parser := $a asPParser.	flatten := parser flatten.		self nextSet: parser in: flatten.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: flatten in: flatten.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testLiteralObject	parser := $a asPParser.		self nextSet: parser in: parser.		self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testLiteralSequence	parser := 'foo' asPParser.		self nextSet: parser in: parser.		self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testOptional	| optional |	parser := $a asPParser.	optional := parser optional.		self nextSet: parser in: optional.		self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testPossesiveRepeating	| plus |	parser := $a asPParser.	plus := parser plus.		self nextSet: parser in: plus.	self assert: nextSet size equals: 2.	self assert: nextSet includes: eoi.		self nextSet: plus in: plus.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testRoot	parser := $a asPParser.		self nextSet: parser in: parser.		self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testSequence	| sequence |	parser := $a asPParser.	nextParser := $b asPParser.		sequence := parser, nextParser.		self nextSet: parser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: nextParser.	self nextSet: nextParser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.			self nextSet: sequence in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testSequenceOfDelegates	| sequence |	parser := $a asPParser.	nextParser := $b asPParser wrapped.		sequence := parser wrapped, nextParser.		self nextSet: parser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: nextParser.		self nextSet: nextParser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: sequence in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testSequenceOfThree	| sequence nextNextParser |	parser := $a asPParser.	nextParser := $b asPParser.	nextNextParser := $c asPParser.		sequence := parser, nextParser, nextNextParser.		self nextSet: parser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: nextParser.		self nextSet: nextParser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: nextNextParser.		self nextSet: nextNextParser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: sequence in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testSequenceOfThreeWithNullable	| sequence nextNextParser |	parser := $a asPParser.	nextParser := $b asPParser optional.	nextNextParser := $c asPParser.		sequence := parser, nextParser, nextNextParser.		self nextSet: parser in: sequence.	self assert: nextSet size equals: 2.	self assert: nextSet includes: nextParser.	self assert: nextSet includes: nextNextParser.		self nextSet: nextParser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: nextNextParser.		self nextSet: nextNextParser in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: sequence in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testSequenceOptional	| sequence |	parser := $a asPParser.	nextParser := $b asPParser optional.		sequence := parser, nextParser.		self nextSet: parser in: sequence.		self assert: nextSet size equals: 2.	self assert: nextSet includes: nextParser.	self assert: nextSet includes: eoi.			self nextSet: sequence in: sequence.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testToken	| token |	parser := $a asPParser.	token := parser token.		self nextSet: parser in: token.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: token in: token.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testTrim	| trim |	parser := $a asPParser.	trim := parser trim.		self nextSet: parser in: trim.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: trim in: trim.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NextSetsVisitorTest methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testTrimmingToken	| token |	parser := $a asPParser.	token := parser token trim.		self nextSet: parser in: token.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.		self nextSet: token in: token.	self assert: nextSet size equals: 1.	self assert: nextSet includes: eoi.! !!PP2NodeCopyTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCopy	| node nodeCopy |	node := $a asPParser.		nodeCopy := node copy.		self assert: node equals: nodeCopy.	self assert: node ~~ nodeCopy.		self assert: node strategy node == node.	self assert: nodeCopy strategy node == nodeCopy.! !!PP2NodeCopyTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCopyDelegate	| node nodeCopy |	node := $a asPParser wrapped.		nodeCopy := node copy.		self assert: node equals: nodeCopy.	self assert: node ~~ nodeCopy.		self assert: node child == nodeCopy child.! !!PP2NodeCopyTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCopyProperties	| node nodeCopy |	node := $a asPParser.	node propertyAt: #foo put: #bar.		nodeCopy := node copy.		self assert: node equals: nodeCopy.	self assert: node properties equals: nodeCopy properties.	self assert: node properties ~~ nodeCopy properties.! !!PP2NodeCopyTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testDuplicateDelegate	| node nodeCopy |	node := $a asPParser wrapped.		nodeCopy := node duplicate.		self assert: node equals: nodeCopy.	self assert: node ~~ nodeCopy.		self assert: node child equals: nodeCopy child.	self assert: node child ~~ nodeCopy child.	! !!PP2NodeCopyTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testDuplicateSequence	| node nodeCopy |	node := $a asPParser, $b asPParser.		nodeCopy := node duplicate.		self assert: node equals: nodeCopy.	self assert: node ~~ nodeCopy.		self assert: node firstChild ~~ nodeCopy firstChild.	self assert: node secondChild ~~ nodeCopy secondChild.	! !!PP2NodeDebugTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEnableDebug	parser := PP2ExpressionGrammar new.	parser enableDebug.		self assert: parser allNodes allSatisfy: [ :node | node strategies size = 2 ].	self assert: parser allNodes allSatisfy: [ :node |  node strategies first isDebugging ].	self assert: parser allNodes noneSatisfy: [ :node |  node strategies second isDebugging ]	! !!PP2NodeDebugTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEnableDebugAndRecordingTwice	parser := PP2ExpressionGrammar new.	parser enableDebug.	parser enableRecording.	parser enableDebug.	parser enableRecording.		self assert: parser allNodes allSatisfy: [ :node | node strategies size = 2 ].	self assert: parser allNodes allSatisfy: [ :node |  node strategies first isDebugging ].	self assert: parser allNodes allSatisfy: [ :node |  node strategies first isRecording ].	self assert: parser allNodes noneSatisfy: [ :node |  node strategies second isDebugging ]	.! !!PP2NodeDebugTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEnableDebugAndRecordingTwiceOptimized	| strategies |	parser := PP2ExpressionGrammar new.	parser optimize.	parser enableDebug.	parser enableRecording.		strategies := IdentityDictionary new.	parser allNodesDo: [ :node | strategies at: node put: node strategies ].		parser enableDebug.	parser enableRecording.		parser allNodesDo: [ :node | 		self assert: (strategies at: node) equals: node strategies.	]! !!PP2NodeDebugTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEnableDebugTwice	parser := PP2ExpressionGrammar new.	parser enableDebug.	parser enableDebug.		self assert: parser allNodes allSatisfy: [ :node | node strategies size = 2 ].	self assert: parser allNodes allSatisfy: [ :node |  node strategies first isDebugging ].	self assert: parser allNodes noneSatisfy: [ :node |  node strategies second isDebugging ]	! !!PP2NodeDebugTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEnableRecordingCaches	parser := PP2ExpressionGrammar new.	parser optimize.		parser enableRecording.		self deny: parser collectCaches isEmpty.	self assert: parser collectCaches allSatisfy: [ :c | c isRecording ].! !!PP2NodeDebugTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEnableRecordingDebugInvocations	parser := PP2ExpressionGrammar new.	parser optimize.		parser enableDebug.	parser enableRecording.		self assert: parser allNodes allSatisfy: [ :n | n strategy isRecording ].! !!PP2NodeDebugTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEnableRecordingInvocations	parser := PP2ExpressionGrammar new.	parser optimize.		parser enableRecording.		self flag: 'JK: Does not work right now, should implement?'"	self assert: parser allNodes allSatisfy: [ :n | n strategy isRecording ]."! !!PP2NodeDebugTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testEnableRecordingRefreshCaches	parser := PP2ExpressionGrammar new.	parser optimize.		parser enableRecording.		self deny: parser collectCaches isEmpty.	self assert: parser allCaches equals: parser collectCaches.! !!PP2NodeEqualityTest methodsFor: 'support' stamp: ' 12/6/2016 07:12:31'!deny: anObject equals: anotherObject	self assert: (anObject = anotherObject) not! !!PP2NodeEqualityTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCycle	parserOne := PP2DelegateNode new.	parserTwo := PP2DelegateNode new.		parserOne child: parserTwo.	parserTwo child: parserOne.		self deny:  parserOne == parserTwo.	self assert: parserOne equals: parserTwo.		self assert: parserOne hash equals: parserTwo hash.! !!PP2NodeEqualityTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPossesiveRepeating	parserOne := #space asPParser star.	parserTwo := #space asPParser star.		self deny:  	 parserOne == parserTwo.	self assert: parserOne equals: parserTwo.		self assert: parserOne hash equals: parserTwo hash.! !!PP2NodeEqualityTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPossesiveRepeatingDifferent	parserOne := #space asPParser star.	parserTwo := #space asPParser plus.		self deny: parserOne == parserTwo.	self deny: parserOne equals: parserTwo.		self deny: parserOne hash equals: parserTwo hash.! !!PP2NodeEqualityTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPossesiveRepeatingDifferent2	parserOne := #space asPParser star.	parserTwo := #blank asPParser star.		self deny: parserOne == parserTwo.	self deny: parserOne equals: parserTwo.		self deny: parserOne hash equals: parserTwo hash.! !!PP2NodeEqualityTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPredicateObject	parserOne := #space asPParser.	parserTwo := #space asPParser.		self deny:   parserOne == parserTwo.	self assert: parserOne equals: parserTwo.		self assert: parserOne hash equals: parserTwo hash.! !!PP2NodeEqualityTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequence	parserOne := $a asPParser, #word asPParser.	parserTwo := $a asPParser, #word asPParser.		self deny:   parserOne == parserTwo.	self assert: parserOne equals: parserTwo.		self assert: parserOne hash equals: parserTwo hash.! !!PP2NodeTransformationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testDelegateReplace	| one other delegate |	one := $a asPParser.	other := $b asPParser.		delegate := one token.	self assert: delegate children first == one.	self deny: delegate children first == other.		delegate replace: other with: one.	self assert: delegate children first == one.	self deny: delegate children first == other.		delegate replace: one with: other.	self deny: delegate children first == one.	self assert: delegate children first == other! !!PP2NodeTransformationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testListReplace	| one other another list |	one := $a asParser.	other := $b asParser.	another := $c asParser.	list := one , another , one.	self assert: list children first == one.	self assert: list children second == another.	self assert: list children last == one.		list replace: other with: one.	self assert: list children first == one.	self assert: list children second == another.	self assert: list children last == one.		list replace: one with: other.	self assert: list children first == other.	self assert: list children second == another.	self assert: list children last == other.		list replace: another with: one.	self assert: list children first == other.	self assert: list children second == one.	self assert: list children last == other! !!PP2NodeTransformationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testRepetitionReplace	| one two otherone othertwo repetition |	one := $a asParser.	two := $b asParser.	otherone := $1 asParser.	othertwo := $2 asParser.		repetition := one starLazy: two.	self assert: repetition children first == one.	self assert: repetition children second == two.		repetition replace: one with: otherone.	self assert: repetition children first == otherone.	self assert: repetition children second == two.		repetition replace: two with: othertwo.	self assert: repetition children first == otherone.	self assert: repetition children second == othertwo! !!PP2NodeTransformationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSeaReplace	| island sea beforeWater afterWater otherIsland otherBeforeWater otherAfterWater |	island := $a asPParser.	sea := island sea.	beforeWater := sea beforeWater.	afterWater := sea afterWater.		otherIsland := $b asPParser.	otherBeforeWater := $c asPParser.	otherAfterWater := $d asPParser.			self assert: sea children first == beforeWater.	self assert: sea children second == island.	self assert: sea children third == afterWater.		sea replace: island with: otherIsland.	self assert: sea children second == otherIsland.	self assert: sea children first == beforeWater.	self assert: sea children third == afterWater.		sea replace: beforeWater  with: otherBeforeWater.	self assert: sea children first == otherBeforeWater.		sea replace: afterWater  with: otherAfterWater.	self assert: sea children third == otherAfterWater.! !!PP2NodeTransformationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTrimmingReplace	| one trimmer trimming other otherTrimmer |	one := $a asPParser.	trimmer := $b asPParser.		other := $c asPParser.	otherTrimmer := $d asPParser.		trimming := one trim: trimmer.	self assert: trimming children first == trimmer.	self assert: trimming children second == one.	self deny: trimming children first == otherTrimmer.	self deny: trimming children second == other.		trimming replace: trimmer with: otherTrimmer.	self assert: trimming children first == otherTrimmer.	self assert: trimming children second == one.		trimming replace: one with: other.	self assert: trimming children second == other! !!PP2NoopVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!setUp	super setUp.		visitor := PP2MockNoopVisitor new! !!PP2NoopVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testVisitCharacter	parser := $a asPParser.	result := visitor visit: parser.		self assert: result equals: visitor! !!PP2NoopVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testVisitCycle	| delegate |	delegate := PP2DelegateNode new.	parser := delegate, delegate.	delegate child: parser.		result := visitor visit: parser.		self assert: result equals: visitor.		self assert: (visitor closedSet includes: (PP2NoopContext with: parser)). 	self assert: (visitor closedSet includes: (PP2NoopContext with: delegate)). 	self assert: (visitor openSet isEmpty). 			self assert: visitor visitOrder size equals: 2.	self assert: visitor visitOrder first equals: parser.	self assert: visitor visitOrder second equals: delegate.! !!PP2NoopVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testVisitDelegate	parser := $a asPParser wrapped.	result := visitor visit: parser.		self assert: result equals: visitor! !!PP2NoopVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testVisitSequence	parser := $a asPParser, $b asPParser.	result := visitor visit: parser.		self assert: result equals: visitor! !!PP2OptimizationIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testBypass	parser := #letter asPParser wrapped star optimize.		self assert: parser strategy child isKindOf: PP2PredicateObjectNode! !!PP2OptimizationIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCommonPrefix	| prefixOne prefixTwo |	prefixOne := #letter asPParser star wrapped flatten name: 'id'.	prefixTwo := #letter asPParser star wrapped flatten name: 'id'.		parser := (prefixOne token trim) / ((prefixTwo, $a asPParser) token trim).		parser optimize.		self assert: prefixOne strategy isKindOf: PP2Cache.	self assert: prefixTwo strategy isKindOf: PP2Cache.		self assert: prefixOne strategy == prefixTwo strategy.! !!PP2OptimizationIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testIdentifier	parser := #letter asPParser, #word asPParser star.		parser optimize.		self assert: parser strategy isKindOf: PP2SequenceOfTwo.	self assert: parser secondChild strategy isKindOf: PP2StarPredicateObject.! !!PP2OptimizationIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testIdentifierToken	parser := (#letter asPParser, #word asPParser star) token.		parser optimize.		self assert: parser child strategy isKindOf: PP2SequenceOfTwoRecognizer.	self assert: parser child secondChild strategy isKindOf: PP2StarPredicateObjectRecognizer.! !!PP2OptimizationIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testIdentifierTrimmingToken	parser := (#letter asPParser, #word asPParser star) token trim.		parser optimize.		self assert: parser strategy isKindOf: PP2TrimmingToken.	self assert: parser strategy tokenChild strategy isKindOf: PP2SequenceOfTwoRecognizer.	self assert: parser strategy tokenChild firstChild strategy isKindOf: PP2PredicateObjectRecognizer.	self assert: parser strategy tokenChild secondChild strategy isKindOf: PP2StarPredicateObjectRecognizer.! !!PP2OptimizationIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testMemoization	| id |	id := #any asPParser, #word asPParser star.	id memoize.		parser := id / id optional.	parser optimize.		self assert: id strategy isKindOf: PP2Packrat.! !!PP2OptimizationIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTrimming	parser := #letter asPParser trim optimize.		self assert: parser trimmer strategy isKindOf: PP2TrimmingCache.	self assert: parser trimmer strategy strategy isKindOf: PP2StarPredicateObjectRecognizer.! !!PP2OptimizationIntegrationTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTrimmingToken	parser := #letter asPParser trim optimize.		self assert: parser trimmer strategy isKindOf: PP2TrimmingCache.	self assert: parser trimmer strategy strategy isKindOf: PP2StarPredicateObjectRecognizer.! !!PP2PackratVisitorTest methodsFor: 'asserting' stamp: ' 12/6/2016 07:12:31'!assertMemoized: node	visitor visit: node.		self assert: (node isMemoized).! !!PP2PackratVisitorTest methodsFor: 'asserting' stamp: ' 12/6/2016 07:12:31'!denyMemoized: node	visitor visit: node.		self deny: (node isMemoized).! !!PP2PackratVisitorTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setUp	visitor := PP2PackratVisitor new! !!PP2PackratVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testMemoize	parser := $a asPParser memoize.		self assertMemoized: parser.! !!PP2PackratVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testMemoizeMatch	parser := $a asPParser match memoize.		self assertMemoized: parser.! !!PP2PackratVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testMemoizeMemoized	parser := $a asPParser memoize memoize.		self assertMemoized: parser.	self assert: parser strategies size equals: 2.! !!PP2PackratVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testMemoizePop	parser := $a asPParser pop memoize.		self denyMemoized: parser.	self assert: parser warnings size equals: 1.! !!PP2PackratVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testMemoizePush	parser := $a asPParser push memoize.		self denyMemoized: parser.	self assert: parser warnings size equals: 1.! !!PP2ParentAnalysisVisitorTest methodsFor: 'support' stamp: ' 12/6/2016 07:12:31'!assert: aCollection includes: anObject	self assert: (aCollection includes: anObject) ! !!PP2ParentAnalysisVisitorTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setUp	visitor := PP2ParentAnalysisVisitor new! !!PP2ParentAnalysisVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testCycle	|  delegateOne delegateTwo |	delegateOne := PP2DelegateNode new.	delegateTwo := PP2DelegateNode new.	delegateOne child: delegateTwo.	delegateTwo child: delegateOne.		visitor visit: delegateOne.		self assert: delegateOne parents size equals: 1.	self assert: delegateOne parents includes: delegateTwo.	self assert: delegateTwo parents size equals: 1.	self assert: delegateTwo parents includes: delegateOne.		! !!PP2ParentAnalysisVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testDeepParent	| superParent |	parser := $a asPParser.	parent := parser wrapped.	superParent := parent wrapped.		visitor visit: superParent.		self assert: parser parents anyOne equals: parent.	self assert: parent parents anyOne equals: superParent.	self assert: superParent parents isEmpty.! !!PP2ParentAnalysisVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testMultipleParents	| parentOne parentTwo superParent |	parser := $a asPParser.	parentOne := parser wrapped.	parentTwo := parser star.	superParent := parentOne, parentTwo.		visitor visit: superParent.		self assert: parser parents size equals: 2.	self assert: parser parents includes: parentOne.	self assert: parser parents includes: parentTwo.		! !!PP2ParentAnalysisVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNoParent	parser := $a asPParser.		visitor visit: parser.		self assert: parser parents isEmpty.! !!PP2ParentAnalysisVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testParent	parser := $a asPParser.	parent := parser wrapped.		visitor visit: parent.		self assert: parser parents size equals: 1.	self assert: parent parents isEmpty.	self assert: parser parents includes: parent.! !!PP2ParentAnalysisVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testParentOfSequence	| parserOne parserTwo |	parserOne := $a asPParser.	parserTwo := $b asPParser.	parent := parserOne, parserTwo.		visitor visit: parent.		self assert: parserOne parents size equals: 1.	self assert: parserOne parents includes: parent.	self assert: parserTwo parents size equals: 1.	self assert: parserTwo parents includes: parent.	self assert: parent parents isEmpty.! !!PP2ParsingGuardTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!guardOn: parser	| guard |	guard := PP2ParsingGuard on: parser.	guard classification: (Array new: 255 withAll: true).	guard retval: (PP2Failure message: 'ooups').	^ guard! !!PP2ParsingGuardTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testParseOn	| parser context guard |	parser := #letter asPParser.	guard := self guardOn: parser.	context := 'a' asPetit2Stream asPetit2Context.			self assert: (guard parseOn: context) isPetit2Success! !!PP2ParsingGuardTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testParseOnFailure	| parser context guard |	parser := #letter asPParser.	guard := self guardOn: parser.	context := '1' asPetit2Stream asPetit2Context.		self assert: (guard parseOn: context) isPetit2Failure! !!PP2ParsingGuardTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testParseOnUnicode	| parser context guard |	parser := #letter asPParser.	guard := self guardOn: parser.	context := '' asPetit2Stream asPetit2Context.		self assert: (guard parseOn: context) isPetit2Success.! !!PP2RecognizerVisitorTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setUp	visitor := PP2RecognizerVisitor new! !!PP2RecognizerVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testFlatten	| flattened |	parser := #letter asPParser star.	parser strategy: (PP2StarPredicateObject on: parser).	flattened := parser flatten.		self visit: flattened.		self assert: parser strategy isKindOf: PP2StarPredicateObjectRecognizer ! !!PP2RecognizerVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPredicateObject	parser := #letter asPParser.	token := parser token.		self visit: token.		self assert: parser strategy isKindOf: PP2PredicateObjectRecognizer  ! !!PP2RecognizerVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceOfTwo	parser := $a asPParser, $b asPParser.	parser strategy: (PP2SequenceOfTwo on: parser).	token := parser token.		self visit: token.		self assert: parser strategy isKindOf: PP2SequenceOfTwoRecognizer ! !!PP2RecognizerVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testToken	parser := #letter asPParser star.	parser strategy: (PP2StarPredicateObject on: parser).	token := parser token.		self visit: token.		self assert: parser strategy isKindOf: PP2StarPredicateObjectRecognizer ! !!PP2RecognizerVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTwoParents	parser := #letter asPParser star.	parser strategy: (PP2StarPredicateObject on: parser).	token := parser token.	sequence := token, parser.		self visit: sequence.		self assert: parser warnings size equals: 1.	self assert: parser strategy isKindOf: PP2StarPredicateObject.! !!PP2RecognizerVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTwoParentsDifferentContext	| wrapped |	parser := #letter asPParser star.	parser strategy: (PP2StarPredicateObject on: parser).	wrapped := parser wrapped.	token := wrapped token.	sequence := wrapped, token.		self visit: sequence.		self assert: parser warnings size equals: 1.	self assert: parser strategy isKindOf: PP2StarPredicateObject.! !!PP2RecognizerVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTwoParentsNoWarning	| tokenOne tokenTwo |	parser := #letter asPParser star.	parser strategy: (PP2StarPredicateObject on: parser).	tokenOne := parser token.	tokenTwo := parser token.	sequence := tokenOne, tokenTwo.		self visit: sequence.		self assert: parser warnings isEmpty.	self assert: parser strategy isKindOf: PP2StarPredicateObjectRecognizer.! !!PP2RecognizerVisitorTest methodsFor: 'support' stamp: ' 12/6/2016 07:12:31'!visit: node	visitor doPass: node! !!PP2RecordingCacheTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testInvocations	| cachedParser parser result |	cachedParser := $a asPParser star.	cachedParser strategy: cachedParser strategy cache recording.		parser := cachedParser and, cachedParser.		result := parser parse: 'aaa' withContext: PP2RecordingContext new.		self assert: result isPetit2Success.	self assert: cachedParser strategy invocations equals: 2.	self assert: cachedParser strategy hits equals: 1.	! !!PP2RecordingContextTest methodsFor: 'requirements' stamp: ' 12/6/2016 07:12:31'!contextOn: aString	^ PP2RecordingContext on: aString! !!PP2RecordingContextTest methodsFor: 'tests - profiling' stamp: ' 12/6/2016 07:12:31'!testAsFrequencyTable	| parser context table |	parser := PP2ExpressionParser new optimize enableDebug.	context := self contextOn: '1+2'.		parser parseWithContext: context.		table := context asFrequencyTable.	self assert: (table collect: #first) noneSatisfy: [ :e | e isNil ].	self assert: (table collect: #second) allSatisfy: [ :e | e isNumber ].	self assert: (table collect: #third) allSatisfy: [ :e | e isNumber ].		"This comes from the parseAdaptableWithContext, when remember is called"	self assert: (context eventsTrace strategies) anySatisfy: [ :e | e isKindOf: PP2NilStrategy  ]! !!PP2RecordingContextTest methodsFor: 'tests - debugging' stamp: ' 12/6/2016 07:12:31'!testDebugResultDebug	| context parser resultContext |	context := PP2RecordingContext new.		parser := 'foo' asPParser star.	resultContext := parser debug: 'foofoofoo' withContext: context.		self assert: resultContext returnValue isPetit2Success.	self assert: context debugResult isNil not.	self assert: context debugResult children size equals: 1.! !!PP2RecordingContextTest methodsFor: 'tests - debugging' stamp: ' 12/6/2016 07:12:31'!testDebugResultNoDebug	| context parser resultContext |	context := PP2RecordingContext new.		parser := 'foo' asPParser star.	resultContext := parser parse: 'foofoofoo' withContext: context.		self assert: resultContext returnValue isPetit2Success.	self assert: context debugResult isNil not.	self assert: context debugResult children size equals: 1.! !!PP2RecordingContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testFurthestPosition	| context parser |	context := 'a' asReparsableContext.	parser := $a asPParser.	parser parseWithContext: context.		self assert: context furthestPosition equals: 1.! !!PP2RecordingContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testFurthestPositionBactrack	| parser context |	parser := 'a' asPParser star, 'b' asPParser.	context := parser parseWithContext: 'aaaac' asReparsableContext.	self assert: context furthestPosition equals: 5.! !!PP2RecordingContextTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testFurthestPositionLiteralChoice	| context parser |	context := 'a' asReparsableContext.	parser := 'aaa' asPParser / 'a' asPParser.	parser parseWithContext: context.		self assert: context furthestPosition equals: 3.! !!PP2RecordingContextTest methodsFor: 'tests - profiling' stamp: ' 12/6/2016 07:12:31'!testMultipleProfilingStrategies	| cache parser context debugging |	parser := #letter asPParser.	cache := parser strategy cache.	debugging := PP2DebuggingStrategy on: cache.	parser strategy: debugging.		context := self contextOn: ''.	context parser: parser.		self assert: parser strategies size equals: 3.	self assert: (parser strategies first isKindOf: PP2RecordingDebuggingStrategy).	self assert: (parser strategies second isKindOf: PP2RecordingCache).	! !!PP2RecordingContextTest methodsFor: 'tests - profiling' stamp: ' 12/6/2016 07:12:31'!testParserRefreshCache	| parser context |	parser := (#letter asPParser plus token trim, #word asPParser star token trim) flatten.	parser optimize.	self assert:( parser allCaches noneSatisfy: [:c | c isRecording ]).		context := self contextOn: ''.	context parser: parser.	self assert: parser allCaches size equals: 2.	self assert:( parser allCaches allSatisfy: [:c | c isRecording ]).	! !!PP2RecordingContextTest methodsFor: 'tests - profiling' stamp: ' 12/6/2016 07:12:31'!testRecordingCache	| parser context |	parser := #letter asPParser.	parser strategy: parser strategy cache.		context := self contextOn: ''.	context parser: parser.	self assert: parser strategies size equals: 2.	self assert: (parser strategy isKindOf: PP2RecordingCache).	! !!PP2RecordingContextTest methodsFor: 'tests - debugging' stamp: ' 12/6/2016 07:12:31'!testSwitchToDebugging	| parser context |	parser := (#letter asPParser plus token trim, #word asPParser star token trim) flatten.	parser optimize.	self assert:( parser allCaches noneSatisfy: [:c | c isRecording ]).		context := self contextOn: ''.	context parser: parser.	self assert: parser allCaches size equals: 2.	self assert:( parser allCaches allSatisfy: [:c | c isRecording ]).	! !!PP2ReparsableContextTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testFurthestPosition	context := 'a' asReparsableContext.	parser := $a asPParser.	parser parseWithContext: context.		self assert: context furthestPosition equals: 1.! !!PP2ReparsableContextTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testFurthestPositionBactrack	parser := 'a' asPParser star, 'b' asPParser.	context := parser parseWithContext: 'aaaac' asReparsableContext.	self assert: context furthestPosition equals: 5.! !!PP2ReparsableContextTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testFurthestPositionLiteralChoice	context := 'a' asReparsableContext.	parser := 'aaa' asPParser / 'a' asPParser.	parser parseWithContext: context.		self assert: context furthestPosition equals: 3.! !!PP2ReparsableTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testMemoHit	memoized := $a asPParser plus.	memoized strategy: (PP2Reparsable on: memoized strategy).		parser := (memoized, $b asPParser) / (memoized, $c asPParser).	parser setOptimized.		context := parser parseWithContext: 'aac' asReparsableContext.		self assert: context debugResult allResults size equals: 11.	self assert: context returnValue size equals: 2.	self assert: context returnValue first size equals: 2.	self assert: context returnValue first first equals: $a.	self assert: context returnValue second equals: $c.! !!PP2ReparsableTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testMemoMiss	memoized := $a asPParser plus.	memoized strategy: (PP2Reparsable on: memoized strategy).			parser := (memoized, $b asPParser) / ($a asPParser, memoized).	parser setOptimized.		context := parser parseWithContext: 'aaa' asReparsableContext.		self assert: context debugResult steps equals: 15.	self assert: context returnValue size equals: 2.	self assert: context returnValue first equals: $a.	self assert: context returnValue second first equals: $a.	! !!PP2ReparsableTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testParseAndParse	parser := $a asPParser plus.	parser strategy: (PP2Reparsable on: parser strategy).	parser setOptimized.	parser enableDebug.		context := parser parseWithContext: 'aa' asReparsableContext.	self assert: context debugResult steps equals: 5.		context := parser parseWithContext: context asReparsableContext.	self assert: context debugResult steps equals: 5.! !!PP2ReparsableTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testReparse	| startContext |	parser := $a asPParser plus.	parser strategy: (PP2Reparsable on: parser strategy).	parser setOptimized.	parser enableDebug.		startContext := 'aa' asReparsableContext.		context := parser parseWithContext: startContext.	self assert: context debugResult steps equals: 5.		context := parser reparseWithContext: context.	self assert: context debugResult steps equals: 2.! !!PP2ReparsableVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testReparsable	reparsable := #letter asPParser star reparsable.	parser := reparsable wrapped.		self visit: parser.		self assert: reparsable strategy isKindOf: PP2Reparsable ! !!PP2ReparsableVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!visit: node	^ PP2ReparsableVisitor new visit: node! !!PP2SeaNodeTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAfterWater	sea := PP2SeaNode new		island: $a asPParser;		yourself.	self assert: sea afterWater isKindOf: PP2WaterNode.! !!PP2SeaNodeTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testBeforeWater	sea := PP2SeaNode new		island: $a asPParser;		yourself.	self assert: sea beforeWater isKindOf: PP2WaterNode.! !!PP2SeaNodeTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testChildren	| waterToken island |	waterToken := #space asPParser.	island := $a asPParser optional.	sea := PP2SeaNode new		island: island;		waterToken: waterToken;		yourself.	self assert: sea children size equals: 3.	self assert: sea children first isKindOf: PP2Node.	self assert: sea children second == island.	self assert: sea children third isKindOf: PP2Node.! !!PP2SeaNodeTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNonNullableIsland	| waterToken island beforeWater boundary elements |	waterToken := #space asPParser.	island := $a asPParser optional.	sea := PP2SeaNode new		island: island;		waterToken: waterToken;		yourself.	boundary := $b asPParser.			parser := sea, boundary.		sea updateBeforeWater: parser.	beforeWater := sea beforeWater.				elements := beforeWater boundaryElements.	self assert: elements size equals: 2.		self assert: elements noneSatisfy: [ :e | e isNullable  ].! !!PP2SeaNodeTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateAfterWater	| waterToken island afterWater boundary elements nextBoundary |	waterToken := #space asPParser.	island := $a asPParser.	sea := PP2SeaNode new		island: island;		waterToken: waterToken;		yourself.	boundary := $b asPParser optional.	nextBoundary := $c asPParser.			parser := sea, boundary, nextBoundary.		sea updateAfterWater: parser.	afterWater := sea afterWater.		self assert: afterWater isKindOf: PP2WaterNode.	self assert: afterWater waterToken equals: waterToken.	self assert: afterWater boundary isKindOf: PP2ChoiceNode.	self assert: afterWater boundary children allSatisfy: [ :child | child isKindOf: PP2AndNode].				elements := afterWater boundaryElements.	self assert: elements size equals: 2.		self assert: elements noneSatisfy: [ :n | n isNullable ].	self assert: elements includes: nextBoundary.	! !!PP2SeaNodeTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testUpdateBeforeWater	| waterToken island beforeWater boundary elements |	waterToken := #space asPParser.	island := $a asPParser.	sea := PP2SeaNode new		island: island;		waterToken: waterToken;		yourself.	boundary := $b asPParser.			parser := sea, boundary.		sea updateBeforeWater: parser.	beforeWater := sea beforeWater.		self assert: beforeWater isKindOf: PP2WaterNode.	self assert: beforeWater waterToken equals: waterToken.	self assert: beforeWater boundary isKindOf: PP2ChoiceNode.	self assert: beforeWater boundary children allSatisfy: [ :child | child isKindOf: PP2AndNode ].				elements := beforeWater boundaryElements.	self assert: elements size equals: 2.		self assert: elements includes: island.	self assert: elements includes: boundary.! !!PP2SeaOptimizationVisitorTest methodsFor: 'asserting' stamp: ' 12/6/2016 07:12:31'!assert: set anySatisfy: aBlock	self assert: (set anySatisfy: aBlock)	! !!PP2SeaOptimizationVisitorTest methodsFor: 'asserting' stamp: ' 12/6/2016 07:12:31'!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!PP2SeaOptimizationVisitorTest methodsFor: 'asserting' stamp: ' 12/6/2016 07:12:31'!assert: set noneSatisfy: aBlock	self assert: (set noneSatisfy: aBlock)	! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testJustSea	parser := $a asPParser sea.		self visit: parser.	self assert: parser strategy isKindOf: PP2Sea! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testMemoizedSea	sea := $a asPParser sea.		parser := sea, ($a asPParser / sea).		self visit: parser.	self assert: sea strategy isKindOf: PP2MemoizedSea.	self assert: sea afterWater allNodes anySatisfy: [ :n | n isSea ]! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNestedSea	sea := $a asPParser sea.		parser := sea star sea.	self visit: parser.	self assert: sea strategy isKindOf: PP2Sea.	self assert: sea afterWater boundaryElements noneSatisfy: [ :e | e isSea ].	self assert: sea afterWater boundaryElements anySatisfy: [ :e | e == sea island ]! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testOverlappingSeas	| seaOne seaTwo |	seaOne := $a asPParser sea.	seaTwo := $b asPParser sea.		parser := seaOne, seaTwo.		self visit: parser.	self assert: seaOne strategy isKindOf: PP2Sea.	self assert: seaTwo strategy isKindOf: PP2Sea.	self assert: seaOne afterWater allNodes noneSatisfy: [ :n | n isSea ]! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testRepetitionInBoundary	sea := $a asPParser sea.	parser := sea, $b asPParser plus.		self visit: parser.	self assert: sea beforeWater boundaryElements noneSatisfy: [ :e | e isRepeating ].		self assert: sea afterWater boundaryElements noneSatisfy: [ :e | e isRepeating ].! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSeaInBoundary	parser := $a asPParser sea.		self visit: parser.	self assert: parser strategy isKindOf: PP2Sea.	self assert: parser beforeWater boundaryElements noneSatisfy: [ :e | e isSea ].! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSeaOptimizations	| bw aw |	sea := $a asPParser sea.		parser := sea star.	self visit: parser.	bw := sea beforeWater boundary.	aw := sea afterWater boundary.	parser parse: '..a..'.		self assert: sea beforeWater boundary == bw.	self assert: sea afterWater boundary == aw.! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSeaOptimizationsReset	| bw aw |	sea := $a asPParser sea.		parser := sea star.	self visit: parser.	bw := sea beforeWater boundary.	aw := sea afterWater boundary.	sea parse: '..a..'.		self assert: sea beforeWater boundary ~= bw.	self assert: sea afterWater boundary ~= aw.! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSeaPlus	sea := $a asPParser sea.		parser := sea plus.		self visit: parser.	self assert: sea strategy isKindOf: PP2Sea.	self assert: sea afterWater allNodes noneSatisfy: [ :n | n isSea ]! !!PP2SeaOptimizationVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSeaStar	sea := $a asPParser sea.		parser := sea star.		self visit: parser.	self assert: sea strategy isKindOf: PP2Sea.	self assert: sea afterWater allNodes noneSatisfy: [ :n | n isSea ]! !!PP2SeaOptimizationVisitorTest methodsFor: 'visiting' stamp: ' 12/6/2016 07:12:31'!visit: node	PP2SeaOptimizationVisitor new visit: node! !!PP2SpecializingVisitorTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setUp	visitor := PP2SpecializingVisitor new! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAndLiteraObject	parser := $a asPParser and.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2AndLiteralObject.! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testAndPredicateObject	parser := #letter asPParser and.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2AndPredicateObject! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testMappingOfThree	parser := ($a asPParser, $b asPParser, $c asPParser) map: [ :a :b :c | $d ].		visitor visit: parser.		self assert: parser strategy isKindOf: PP2MappingOfThree.! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testMappingOfTwo	parser := ($a asPParser, $b asPParser) map: [ :a :b | $c ].		visitor visit: parser.		self assert: parser strategy isKindOf: PP2MappingOfTwo.! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testNotLiteraObject	parser := $a asPParser not.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2NotLiteralObject.! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testOptionalLiteraObject	parser := $a asPParser optional.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2OptionalLiteralObject.! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPlus	parser := $a asPParser plus.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2Plus.! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPlusPredicateObject	parser := #letter asPParser plus.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2PlusPredicateObject.! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testPlusPredicateObject2	parser := #letter asPParser plus.	parser max: 20.		visitor visit: parser.	self deny: parser strategy isKindOf: PP2PlusPredicateObject.! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceOfThree	parser := $a asPParser, $b asPParser, $c asPParser.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2SequenceOfThree.! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testSequenceOfTwo	parser := $a asPParser, $b asPParser.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2SequenceOfTwo.! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testStar	parser := $a asPParser star.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2Star.! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testStarPredicateObject	parser := #letter asPParser star.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2StarPredicateObject.! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testStarPredicateObject2	parser := #letter asPParser star.	parser max: 2.		visitor visit: parser.	self deny: parser strategy isKindOf: PP2StarPredicateObject.! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTrimmingLiteralObjectToken	parser := $a asPParser token trim.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2TrimmingLiteralObjectToken.	self assert: parser strategy literal equals: $a.	! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTrimmingLiteralObjectTokenWrapped	parser := $a asPParser wrapped token trim.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2TrimmingLiteralObjectToken.	self assert: parser strategy literal equals: $a.! !!PP2SpecializingVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTrimmingToken	parser := $a asPParser plus token trim.		visitor visit: parser.		self assert: parser strategy isKindOf: PP2TrimmingToken.	self assert: parser strategy trimmer equals: parser trimmer.	self assert: parser strategy tokenClass equals: parser child tokenClass.! !!PP2StreamTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setUp	super setUp! !!PP2StreamTest methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!streamOn: collection	^ PP2Stream on: collection! !!PP2StreamTest methodsFor: 'tests - context interface' stamp: ' 12/6/2016 07:12:31'!testContents	| stream |	stream := self streamOn: 'bar'. 		self assert: stream contents equals: 'bar'.! !!PP2TransformVisitorTest methodsFor: 'grammars' stamp: ' 12/6/2016 07:12:31'!grammarA	"A highly recrusive grammar."	| grammar |	grammar := PP2UnresolvedNode new.	grammar def: (grammar , $+ asPParser , grammar) / $1 asPParser.	^grammar! !!PP2TransformVisitorTest methodsFor: 'grammars' stamp: ' 12/6/2016 07:12:31'!grammarB	"The most stupid parser, it just references itself and never consumes anything. All algorithms should survive such an attack."	| parser |	parser := PP2DelegateNode new.	parser child: parser.	^ parser! !!PP2TransformVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTransformIdentityGrammarA	| orig tran |	orig := self grammarA.	tran := orig transform: [ :each | each ].	self deny: orig == tran.	self deny: orig children first == tran children first.	self deny: orig children first children first == tran children first children first.	self deny: orig children first children last == tran children first children last.	self deny: orig children last == tran children last.		self assert: orig class == PP2ChoiceNode.	self assert: orig children first class == PP2SequenceNode.	self assert: orig children first children first == orig.	self assert: orig children first children last == orig.	self assert: orig children last class == PP2LiteralObjectNode.	self assert: tran class == PP2ChoiceNode.	self assert: tran children first class == PP2SequenceNode.	self assert: tran children first children first == tran.	self assert: tran children first children last == tran.	self assert: tran children last class == PP2LiteralObjectNode! !!PP2TransformVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTransformIdentityGrammarB	| orig tran |	orig := self grammarB.	tran := orig transform: [ :each | each ].	self deny: orig == tran.	self deny: orig children first == tran children first.		self assert: orig class == PP2DelegateNode.	self assert: orig children first == orig.		self assert: tran class == PP2DelegateNode.	self assert: tran children first == tran! !!PP2TransformVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTransformWrapGrammarA	| orig tran |	orig := self grammarA.	tran := orig transform: [ :each | each wrapped ].	self assert: orig class == PP2ChoiceNode.	self assert: orig children first class == PP2SequenceNode.	self assert: orig children first children first == orig.	self assert: orig children first children last == orig.	self assert: orig children last class == PP2LiteralObjectNode.		self assert: tran class == PP2DelegateNode.	self assert: tran children first class == PP2ChoiceNode.	self assert: tran children first children first class == PP2DelegateNode.	self assert: tran children first children first children first class == PP2SequenceNode.	self assert: tran children first children first children first children first == tran.	self assert: tran children first children first children first children last == tran.	self assert: tran children first children last class == PP2DelegateNode.	self assert: tran children first children last children first class == PP2LiteralObjectNode! !!PP2TransformVisitorTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testTransformWrapGrammarB	| orig tran |	orig := self grammarB.	tran := orig transform: [ :each | each wrapped ].		self assert: orig class == PP2DelegateNode.	self assert: orig child == orig.		self assert: tran class == PP2DelegateNode.	self assert: tran child class == PP2DelegateNode.	self assert: tran child child == tran! !!PP2TrimmingCacheVisitorTest methodsFor: 'support' stamp: ' 12/6/2016 07:12:31'!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!PP2TrimmingCacheVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!setUp	super setUp.		visitor := PP2TrimmingCacheVisitor new! !!PP2TrimmingCacheVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testDifferentTrimmers	parser := $a asPParser trimSpaces, $b asPParser trimBlanks.		visitor doPass: parser.	self assert: parser firstChild trimmer strategy isKindOf: PP2PossesiveRepeating.	self assert: parser secondChild trimmer strategy isKindOf: PP2PossesiveRepeating	! !!PP2TrimmingCacheVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testSequence	parser := $a asPParser trim, $b asPParser trim.		visitor doPass: parser.	self assert: parser firstChild trimmer strategy isKindOf: PP2TrimmingCache.	self assert: parser secondChild trimmer strategy isKindOf: PP2TrimmingCache	! !!PP2TrimmingCacheVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testSimpleTrimming	parser := $a asPParser trim.		visitor doPass: parser.	self assert: parser trimmer strategy isKindOf: PP2TrimmingCache! !!PP2TrimmingCacheVisitorTest methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!testSimpleTrimmingToken	parser := $a asPParser token trim.		visitor doPass: parser.	self assert: parser trimmer strategy isKindOf: PP2TrimmingCache! !!PP2MinimalStream class methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!on: values	^ self basicNew 		initialize;		values: values;		yourself! !!PP2MinimalStream methodsFor: 'minimal interface' stamp: ' 12/6/2016 07:12:31'!atEnd	^ position == values size! !!PP2MinimalStream methodsFor: 'private' stamp: ' 12/6/2016 07:12:31'!contents	^ values! !!PP2MinimalStream methodsFor: 'initialization' stamp: ' 12/6/2016 07:12:31'!initialize	position := 0.! !!PP2MinimalStream methodsFor: 'minimal interface' stamp: ' 12/6/2016 07:12:31'!next	position := position + 1.	^ values at: position! !!PP2MinimalStream methodsFor: 'private' stamp: ' 12/6/2016 07:12:31'!values: anObject	values := anObject! !!PP2MockNoopVisitor methodsFor: 'initialization' stamp: ' 12/6/2016 07:12:31'!initialize	super initialize.		visitOrder := OrderedCollection new! !!PP2MockNoopVisitor methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!visitOrder	^ visitOrder! !!PP2MockNoopVisitor methodsFor: 'visiting' stamp: ' 12/6/2016 07:12:31'!visitPP2Node: aPP2Node	visitOrder add: aPP2Node.		^ super visitPP2Node: aPP2Node! !!PP2ParserResource methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parserAt: aParserClass	"Answer a cached instance of aParserClass."		^ parsers at: aParserClass name ifAbsentPut: [ aParserClass new ]! !!PP2ParserResource methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setUp	super setUp.	parsers := Dictionary new! !!Trait method!parserClass	^ PP2AdaptableGrammar! !!Trait method!parserClass	^ PP2AdaptableGrammar! !!Trait method!testContent	self parse: '1_2__3___' rule: #content.	self fail: '1_2' rule: #content.! !!Trait method!testContent	self parse: '1_2__3___' rule: #content.	self fail: '1_2' rule: #content.! !!Trait method!testElement	self parse: '1a' rule: #element.	self parse: '2aa' rule: #element.	self fail: '2a' rule: #element.! !!Trait method!testElement	self parse: '1a' rule: #element.	self parse: '2aa' rule: #element.	self fail: '2a' rule: #element.! !!Trait method!testElementNumberInBody	self parse: '10___4______' rule: #content.	self fail: '1_2' rule: #content.! !!Trait method!testElementNumberInBody	self parse: '10___4______' rule: #content.	self fail: '1_2' rule: #content.! !!Trait method!testHead	self parse: '1' rule: #head! !!Trait method!testHead	self parse: '1' rule: #head! !!Trait method!assert: aCollection allSatisfy: aBlock	self assert: (aCollection allSatisfy: aBlock)! !!Trait method!assert: aCollection allSatisfy: aBlock	self assert: (aCollection allSatisfy: aBlock)! !!Trait method!assert: aCollection allSatisfy: aBlock	self assert: (aCollection allSatisfy: aBlock)! !!Trait method!assert: aCollection allSatisfy: aBlock	self assert: (aCollection allSatisfy: aBlock)! !!Trait method!assert: aCollection allSatisfy: aBlock	self assert: (aCollection allSatisfy: aBlock)! !!Trait method!assert: aCollection anySatisfy: aBlock	self assert: (aCollection anySatisfy: aBlock)! !!Trait method!assert: aCollection anySatisfy: aBlock	self assert: (aCollection anySatisfy: aBlock)! !!Trait method!assert: aCollection anySatisfy: aBlock	self assert: (aCollection anySatisfy: aBlock)! !!Trait method!assert: aCollection anySatisfy: aBlock	self assert: (aCollection anySatisfy: aBlock)! !!Trait method!assert: aCollection anySatisfy: aBlock	self assert: (aCollection anySatisfy: aBlock)! !!Trait method!assert: aCollection includes: aBlock	self assert: (aCollection includes: aBlock)! !!Trait method!assert: aCollection includes: aBlock	self assert: (aCollection includes: aBlock)! !!Trait method!assert: aCollection includes: aBlock	self assert: (aCollection includes: aBlock)! !!Trait method!assert: aCollection includes: aBlock	self assert: (aCollection includes: aBlock)! !!Trait method!assert: aCollection includes: aBlock	self assert: (aCollection includes: aBlock)! !!Trait method!assert: aCollection noneSatisfy: aBlock	self assert: (aCollection noneSatisfy: aBlock)! !!Trait method!assert: aCollection noneSatisfy: aBlock	self assert: (aCollection noneSatisfy: aBlock)! !!Trait method!assert: aCollection noneSatisfy: aBlock	self assert: (aCollection noneSatisfy: aBlock)! !!Trait method!assert: aCollection noneSatisfy: aBlock	self assert: (aCollection noneSatisfy: aBlock)! !!Trait method!assert: aCollection noneSatisfy: aBlock	self assert: (aCollection noneSatisfy: aBlock)! !!Trait method!contextOn: aString	self explicitRequirement! !!Trait method!contextOn: aString	self explicitRequirement! !!Trait method!contextOn: aString	self explicitRequirement! !!Trait method!testAdoptString	| context |	context := self contextOn: 'foo'.		self assert: context contents equals: 'foo'.		context adoptString: 'bar'.	self assert: context contents equals: 'bar'.! !!Trait method!testAdoptString	| context |	context := self contextOn: 'foo'.		self assert: context contents equals: 'foo'.		context adoptString: 'bar'.	self assert: context contents equals: 'bar'.! !!Trait method!testAdoptString	| context |	context := self contextOn: 'foo'.		self assert: context contents equals: 'foo'.		context adoptString: 'bar'.	self assert: context contents equals: 'bar'.! !!Trait method!testAtEnd	| context |	context := self contextOn: 'foo'.		self deny: context atEnd.	context next: 3.	self assert: context atEnd.! !!Trait method!testAtEnd	| context |	context := self contextOn: 'foo'.		self deny: context atEnd.	context next: 3.	self assert: context atEnd.! !!Trait method!testAtEnd	| context |	context := self contextOn: 'foo'.		self deny: context atEnd.	context next: 3.	self assert: context atEnd.! !!Trait method!testContents	| context |	context := self contextOn: 'foo'.		self assert: (context respondsTo: #contents).	self assert: context contents equals: 'foo'! !!Trait method!testContents	| context |	context := self contextOn: 'foo'.		self assert: (context respondsTo: #contents).	self assert: context contents equals: 'foo'! !!Trait method!testContents	| context |	context := self contextOn: 'foo'.		self assert: (context respondsTo: #contents).	self assert: context contents equals: 'foo'! !!Trait method!testCopyGlobals	| context contextCopy |	context := self contextOn: 'foo'.	context globals: (IdentityDictionary newFromPairs: { #a . #b }).		contextCopy := context copy.		self assert: context globals equals: contextCopy globals.	self assert: context globals ~~ contextCopy globals.	! !!Trait method!testCopyGlobals	| context contextCopy |	context := self contextOn: 'foo'.	context globals: (IdentityDictionary newFromPairs: { #a . #b }).		contextCopy := context copy.		self assert: context globals equals: contextCopy globals.	self assert: context globals ~~ contextCopy globals.	! !!Trait method!testCopyGlobals	| context contextCopy |	context := self contextOn: 'foo'.	context globals: (IdentityDictionary newFromPairs: { #a . #b }).		contextCopy := context copy.		self assert: context globals equals: contextCopy globals.	self assert: context globals ~~ contextCopy globals.	! !!Trait method!testMemo	| context memento |	context := self contextOn: 'foobar'.	context propertyAt: #foo put: #bar.	memento := context remember.	context next.	context propertyAt: #bar put: #baz.	context propertyAt: #foo put: #bark.	context restore: memento.	self assert: context position equals: 0.	self deny: (context hasProperty: #bar).	self assert: (context propertyAt: #foo) equals: #bar.! !!Trait method!testMemo	| context memento |	context := self contextOn: 'foobar'.	context propertyAt: #foo put: #bar.	memento := context remember.	context next.	context propertyAt: #bar put: #baz.	context propertyAt: #foo put: #bark.	context restore: memento.	self assert: context position equals: 0.	self deny: (context hasProperty: #bar).	self assert: (context propertyAt: #foo) equals: #bar.! !!Trait method!testMemo	| context memento |	context := self contextOn: 'foobar'.	context propertyAt: #foo put: #bar.	memento := context remember.	context next.	context propertyAt: #bar put: #baz.	context propertyAt: #foo put: #bark.	context restore: memento.	self assert: context position equals: 0.	self deny: (context hasProperty: #bar).	self assert: (context propertyAt: #foo) equals: #bar.! !!Trait method!testNext	| retval context |	context := self contextOn: 'foo'.		retval := context next: 3.	self assert: retval isPetit2Success.	self assert: retval equals: 'foo'.		retval := context next: 1.	self assert: retval isNil.		context position: 0.	retval := context next: 3.	self assert: retval isPetit2Success.	self assert: retval = 'foo'.! !!Trait method!testNext	| retval context |	context := self contextOn: 'foo'.		retval := context next: 3.	self assert: retval isPetit2Success.	self assert: retval equals: 'foo'.		retval := context next: 1.	self assert: retval isNil.		context position: 0.	retval := context next: 3.	self assert: retval isPetit2Success.	self assert: retval = 'foo'.! !!Trait method!testNext	| retval context |	context := self contextOn: 'foo'.		retval := context next: 3.	self assert: retval isPetit2Success.	self assert: retval equals: 'foo'.		retval := context next: 1.	self assert: retval isNil.		context position: 0.	retval := context next: 3.	self assert: retval isPetit2Success.	self assert: retval = 'foo'.! !!Trait method!testNextAtEnd	| context retval |	context := self contextOn: 'foo'.		context position: 3.		retval := context next.	self assert: retval isNil.		self assert: context position equals: 3.! !!Trait method!testNextAtEnd	| context retval |	context := self contextOn: 'foo'.		context position: 3.		retval := context next.	self assert: retval isNil.		self assert: context position equals: 3.! !!Trait method!testNextAtEnd	| context retval |	context := self contextOn: 'foo'.		context position: 3.		retval := context next.	self assert: retval isNil.		self assert: context position equals: 3.! !!Trait method!testParser	| context parser |	parser := $a asPParser.		context := (self contextOn: 'bar')		parser: parser;		yourself.		self assert: context parser equals: parser.! !!Trait method!testParser	| context parser |	parser := $a asPParser.		context := (self contextOn: 'bar')		parser: parser;		yourself.		self assert: context parser equals: parser.! !!Trait method!testParser	| context parser |	parser := $a asPParser.		context := (self contextOn: 'bar')		parser: parser;		yourself.		self assert: context parser equals: parser.! !!Trait method!testRemember	| context memento |	context := self contextOn: 'foobar'.	context propertyAt: #foo put: #bar.	memento := context remember.	self assert: memento position equals: context position.	self assert: memento properties equals: context properties.	context propertyAt: #foo put: #baz.	self assert: (memento propertyAt: #foo) equals: #bar.! !!Trait method!testRemember	| context memento |	context := self contextOn: 'foobar'.	context propertyAt: #foo put: #bar.	memento := context remember.	self assert: memento position equals: context position.	self assert: memento properties equals: context properties.	context propertyAt: #foo put: #baz.	self assert: (memento propertyAt: #foo) equals: #bar.! !!Trait method!testRemember	| context memento |	context := self contextOn: 'foobar'.	context propertyAt: #foo put: #bar.	memento := context remember.	self assert: memento position equals: context position.	self assert: memento properties equals: context properties.	context propertyAt: #foo put: #baz.	self assert: (memento propertyAt: #foo) equals: #bar.! !!Trait method!testRestore	| context memento |	context := self contextOn: 'foobar'.	context propertyAt: #foo put: #bar.	memento := context remember.	context next.	context propertyAt: #foo put: #baz.	context propertyAt: #bar put: #baq.	context restore: memento.	self deny: (context hasProperty: #bar).	self assert: (context propertyAt: #foo) equals: #bar.	self assert: context position equals: 0.! !!Trait method!testRestore	| context memento |	context := self contextOn: 'foobar'.	context propertyAt: #foo put: #bar.	memento := context remember.	context next.	context propertyAt: #foo put: #baz.	context propertyAt: #bar put: #baq.	context restore: memento.	self deny: (context hasProperty: #bar).	self assert: (context propertyAt: #foo) equals: #bar.	self assert: context position equals: 0.! !!Trait method!testRestore	| context memento |	context := self contextOn: 'foobar'.	context propertyAt: #foo put: #bar.	memento := context remember.	context next.	context propertyAt: #foo put: #baz.	context propertyAt: #bar put: #baq.	context restore: memento.	self deny: (context hasProperty: #bar).	self assert: (context propertyAt: #foo) equals: #bar.	self assert: context position equals: 0.! !!Trait method!testSuccess	| context |	context := (self contextOn: 'bar')		position: 1;		returnValue: #foo;		yourself.		self assert: context isPetit2Success.	self assert: context value == #foo.	self assert: context returnValue == #foo.	self assert: context atEnd not.	self assert: context uncheckedPeek == $a.! !!Trait method!testSuccess	| context |	context := (self contextOn: 'bar')		position: 1;		returnValue: #foo;		yourself.		self assert: context isPetit2Success.	self assert: context value == #foo.	self assert: context returnValue == #foo.	self assert: context atEnd not.	self assert: context uncheckedPeek == $a.! !!Trait method!testSuccess	| context |	context := (self contextOn: 'bar')		position: 1;		returnValue: #foo;		yourself.		self assert: context isPetit2Success.	self assert: context value == #foo.	self assert: context returnValue == #foo.	self assert: context atEnd not.	self assert: context uncheckedPeek == $a.! !!Trait method!testUncheckedNext	| context retval |	context := self contextOn: 'foo'.		self assert: context position equals: 0.		retval := context uncheckedNext.	self assert: retval isPetit2Success.	self assert: retval equals: $f.	self assert: context position equals: 1.! !!Trait method!testUncheckedNext	| context retval |	context := self contextOn: 'foo'.		self assert: context position equals: 0.		retval := context uncheckedNext.	self assert: retval isPetit2Success.	self assert: retval equals: $f.	self assert: context position equals: 1.! !!Trait method!testUncheckedNext	| context retval |	context := self contextOn: 'foo'.		self assert: context position equals: 0.		retval := context uncheckedNext.	self assert: retval isPetit2Success.	self assert: retval equals: $f.	self assert: context position equals: 1.! !!Trait method!testUncheckedPeek	| context |	context := self contextOn: 'foo'.			self assert: context uncheckedPeek == $f.		context position: 3.	self should: [context uncheckedPeek] raise: Error.	! !!Trait method!testUncheckedPeek	| context |	context := self contextOn: 'foo'.			self assert: context uncheckedPeek == $f.		context position: 3.	self should: [context uncheckedPeek] raise: Error.	! !!Trait method!testUncheckedPeek	| context |	context := self contextOn: 'foo'.			self assert: context uncheckedPeek == $f.		context position: 3.	self should: [context uncheckedPeek] raise: Error.	! !!Trait method!testUpTo	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upTo: $f.	self assert: context position equals: 1.	self assert: retval equals: 'f'.	! !!Trait method!testUpTo	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upTo: $f.	self assert: context position equals: 1.	self assert: retval equals: 'f'.	! !!Trait method!testUpTo	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upTo: $f.	self assert: context position equals: 1.	self assert: retval equals: 'f'.	! !!Trait method!testUpTo2	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upTo: $r.	self assert: context position equals: 6.	self assert: retval equals: 'foobar'.! !!Trait method!testUpTo2	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upTo: $r.	self assert: context position equals: 6.	self assert: retval equals: 'foobar'.! !!Trait method!testUpTo2	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upTo: $r.	self assert: context position equals: 6.	self assert: retval equals: 'foobar'.! !!Trait method!testUpTo3	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upTo: $x.	self assert: context position equals: 6.	self assert: retval equals: 'foobar'.! !!Trait method!testUpTo3	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upTo: $x.	self assert: context position equals: 6.	self assert: retval equals: 'foobar'.! !!Trait method!testUpTo3	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upTo: $x.	self assert: context position equals: 6.	self assert: retval equals: 'foobar'.! !!Trait method!testUpTo4	| context retval |	context := self contextOn: 'foof'.	context next.	self assert: context position equals: 1.			retval := context upTo: $f.	self assert: context position equals: 4.	self assert: retval equals: 'oof'.	! !!Trait method!testUpTo4	| context retval |	context := self contextOn: 'foof'.	context next.	self assert: context position equals: 1.			retval := context upTo: $f.	self assert: context position equals: 4.	self assert: retval equals: 'oof'.	! !!Trait method!testUpTo4	| context retval |	context := self contextOn: 'foof'.	context next.	self assert: context position equals: 1.			retval := context upTo: $f.	self assert: context position equals: 4.	self assert: retval equals: 'oof'.	! !!Trait method!testUpToEnd	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upToEnd.	self assert: context position equals: 6.	self assert: retval equals: 'foobar'.	! !!Trait method!testUpToEnd	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upToEnd.	self assert: context position equals: 6.	self assert: retval equals: 'foobar'.	! !!Trait method!testUpToEnd	| context retval |	context := self contextOn: 'foobar'.	self assert: context position equals: 0.			retval := context upToEnd.	self assert: context position equals: 6.	self assert: retval equals: 'foobar'.	! !!Trait method!parserClass	^ PP2ExpressionGrammar ! !!Trait method!parserClass	^ PP2ExpressionGrammar ! !!Trait method!testAddition	self parse: '1 + 2' rule: #addition.	self parse: '1 + (2 + 3)' rule: #addition.		self parse: '1 + (2 * 3)' rule: #addition.					self fail: '1 * 2' rule: #addition.! !!Trait method!testAddition	self parse: '1 + 2' rule: #addition.	self parse: '1 + (2 + 3)' rule: #addition.		self parse: '1 + (2 * 3)' rule: #addition.					self fail: '1 * 2' rule: #addition.! !!Trait method!testMultiplication	self parse: '1 * 2' rule: #multiplication.	self parse: '1 * (2 + 3)' rule: #multiplication.		self parse: '1 * (2 * 3)' rule: #multiplication.					self fail: '1 + 2' rule: #multiplication.! !!Trait method!testMultiplication	self parse: '1 * 2' rule: #multiplication.	self parse: '1 * (2 + 3)' rule: #multiplication.		self parse: '1 * (2 * 3)' rule: #multiplication.					self fail: '1 + 2' rule: #multiplication.! !!Trait method!testNumber	self parse: '1' rule: #number.	self parse: '10' rule: #number.	self parse: '10.3' rule: #number.		self fail: 'foo' rule: #number.! !!Trait method!testNumber	self parse: '1' rule: #number.	self parse: '10' rule: #number.	self parse: '10.3' rule: #number.		self fail: 'foo' rule: #number.! !!Trait method!testParentheses	self parse: '(1)' rule: #parentheses.	self parse: '(1.2)' rule: #parentheses.! !!Trait method!testParentheses	self parse: '(1)' rule: #parentheses.	self parse: '(1.2)' rule: #parentheses.! !!Trait method!testPrimary	self parse: '10.3' rule: #primary.	self parse: '(10.3)' rule: #primary.	self parse: '(1 * 2 + 3)' rule: #primary.! !!Trait method!testPrimary	self parse: '10.3' rule: #primary.	self parse: '(10.3)' rule: #primary.	self parse: '(1 * 2 + 3)' rule: #primary.! !!Trait method!testTerms	self parse: '1' rule: #terms.	self parse: '1 + 1' rule: #terms.	self parse: '1 * 1' rule: #terms.	self parse: '((1) * (2 + (3 + 4)))' rule: #terms.		self fail: '1 ^ 1' rule: #terms.! !!Trait method!testTerms	self parse: '1' rule: #terms.	self parse: '1 + 1' rule: #terms.	self parse: '1 * 1' rule: #terms.	self parse: '((1) * (2 + (3 + 4)))' rule: #terms.		self fail: '1 ^ 1' rule: #terms.! !!Trait method!testNumber	self parse: '1' rule: #number to: 1.! !!Trait method!testAction	| parser |	parser := #any asPParser ==> [:e | e asUppercase ].	self assert: parser parse: 'a' to: $A.	self assert: parser parse: 'b' to: $B! !!Trait method!testAction	| parser |	parser := #any asPParser ==> [:e | e asUppercase ].	self assert: parser parse: 'a' to: $A.	self assert: parser parse: 'b' to: $B! !!Trait method!testAnd	| parser |	parser := 'foo' asPParser, 'bar' asPParser and.	self		assert: parser		parse: 'foobar'		to: #('foo' 'bar')		end: 3.	self assert: parser fail: 'foobaz' end: 3.! !!Trait method!testAnd	| parser |	parser := 'foo' asPParser, 'bar' asPParser and.	self		assert: parser		parse: 'foobar'		to: #('foo' 'bar')		end: 3.	self assert: parser fail: 'foobaz' end: 3.! !!Trait method!testBlock	| parser |	parser := [ :ctx | 		self assert: (ctx isPetit2Context).		ctx next 	] asPParser.		self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: '' to: nil! !!Trait method!testBlock	| parser |	parser := [ :ctx | 		self assert: (ctx isPetit2Context).		ctx next 	] asPParser.		self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: '' to: nil! !!Trait method!testChoice	| parser |	parser := $a asPParser / $b asPParser.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'ba' to: $b end: 1.	self assert: parser fail: ''.	self assert: parser fail: 'c'.	self assert: parser fail: 'ca'! !!Trait method!testChoice	| parser |	parser := $a asPParser / $b asPParser.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'ba' to: $b end: 1.	self assert: parser fail: ''.	self assert: parser fail: 'c'.	self assert: parser fail: 'ca'! !!Trait method!testDelimitedBy	| parser |	parser := $a asPParser delimitedBy: $b asPParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).	self assert: parser parse: 'ab' to: #($a $b).	self assert: parser parse: 'abab' to: #($a $b $a $b).	self assert: parser parse: 'ababab' to: #($a $b $a $b $a $b).		self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abc' to: #($a $b) end: 2.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.	self assert: parser parse: 'ababc' to: #($a $b $a $b) end: 4.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'c'! !!Trait method!testDelimitedBy	| parser |	parser := $a asPParser delimitedBy: $b asPParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).	self assert: parser parse: 'ab' to: #($a $b).	self assert: parser parse: 'abab' to: #($a $b $a $b).	self assert: parser parse: 'ababab' to: #($a $b $a $b $a $b).		self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abc' to: #($a $b) end: 2.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.	self assert: parser parse: 'ababc' to: #($a $b $a $b) end: 4.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'c'! !!Trait method!testEnd	| parser |	parser := $a asPParser end.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''.	self assert: parser fail: 'aa' end: 1.! !!Trait method!testEnd	| parser |	parser := $a asPParser end.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''.	self assert: parser fail: 'aa' end: 1.! !!Trait method!testEndLiteral	| parser |	parser := 'stuff' asPParser end.	self assert: parser parse: 'stuff' to: 'stuff'.	self assert: parser fail: 'stufff' end: 5.	self assert: parser fail: 'fluff'! !!Trait method!testEndLiteral	| parser |	parser := 'stuff' asPParser end.	self assert: parser parse: 'stuff' to: 'stuff'.	self assert: parser fail: 'stufff' end: 5.	self assert: parser fail: 'fluff'! !!Trait method!testEpsilon	| parser |	parser := nil asPParser.		self assert: parser parse: '' to: nil.		self assert: parser parse: 'a' to: nil end: 0.	self assert: parser parse: 'ab' to: nil end: 0! !!Trait method!testEpsilon	| parser |	parser := nil asPParser.		self assert: parser parse: '' to: nil.		self assert: parser parse: 'a' to: nil end: 0.	self assert: parser parse: 'ab' to: nil end: 0! !!Trait method!testFailing	| parser |	parser := PP2FailingNode message: 'Plonk'.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'aa'.! !!Trait method!testFailing	| parser |	parser := PP2FailingNode message: 'Plonk'.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'aa'.! !!Trait method!testFlattenSequence	| parser |	parser := ($a asPParser, $b asPParser) flatten.		self assert: parser parse: 'ab' to: 'ab'.		self assert: parser fail: 'ac' end: 1.	self assert: parser fail: 'bc'! !!Trait method!testFlattenSequence	| parser |	parser := ($a asPParser, $b asPParser) flatten.		self assert: parser parse: 'ab' to: 'ab'.		self assert: parser fail: 'ac' end: 1.	self assert: parser fail: 'bc'! !!Trait method!testFragment	| fragment parser result |	fragment := $a asPParser plus fragment.	parser := fragment wrapped.		result := (self assert: parser parse: 'aa') returnValue.	self assert: result isPetit2Context.	self assert: result start equals: 0.	self assert: result stop equals: 2.	self assert: result parsedValue size equals: 2.	self assert: result parsedValue first equals: $a.		self assert: result parsedValue second equals: $a.	self assert: result parser == fragment.			self assert: parser fail: 'b'.	self assert: parser fail: ''.! !!Trait method!testFragment	| fragment parser result |	fragment := $a asPParser plus fragment.	parser := fragment wrapped.		result := (self assert: parser parse: 'aa') returnValue.	self assert: result isPetit2Context.	self assert: result start equals: 0.	self assert: result stop equals: 2.	self assert: result parsedValue size equals: 2.	self assert: result parsedValue first equals: $a.		self assert: result parsedValue second equals: $a.	self assert: result parser == fragment.			self assert: parser fail: 'b'.	self assert: parser fail: ''.! !!Trait method!testLiteralObject	| parser |	parser := $a asPParser.		self assert: parser literal equals: $a.	self assert: parser message equals: 'literal $a expected'.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'! !!Trait method!testLiteralObject	| parser |	parser := $a asPParser.		self assert: parser literal equals: $a.	self assert: parser message equals: 'literal $a expected'.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'! !!Trait method!testLiteralObjectCaseInsensitive	| parser |	parser := $a asPParser caseInsensitive.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'B'	! !!Trait method!testLiteralObjectCaseInsensitive	| parser |	parser := $a asPParser caseInsensitive.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'B'	! !!Trait method!testLiteralSequence	| parser |	parser := 'abc' asPParser.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser parse: 'abcd' to: 'abc' end: 3.	self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'! !!Trait method!testLiteralSequence	| parser |	parser := 'abc' asPParser.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser parse: 'abcd' to: 'abc' end: 3.	self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'! !!Trait method!testLiteralSequenceCaseInsensitive	| parser |	parser := 'abc' asPParser caseInsensitive.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser parse: 'ABC' to: 'ABC'.	self assert: parser parse: 'abC' to: 'abC'.	self assert: parser parse: 'AbC' to: 'AbC'.		self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'! !!Trait method!testLiteralSequenceCaseInsensitive	| parser |	parser := 'abc' asPParser caseInsensitive.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser parse: 'ABC' to: 'ABC'.	self assert: parser parse: 'abC' to: 'abC'.	self assert: parser parse: 'AbC' to: 'AbC'.		self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'! !!Trait method!testMap	| parser |	parser := #any asPParser		map: [ :a | Array with: a ].	self assert: parser parse: 'a' to: #($a).	self assert: parser fail: ''.! !!Trait method!testMap	| parser |	parser := #any asPParser		map: [ :a | Array with: a ].	self assert: parser parse: 'a' to: #($a).	self assert: parser fail: ''.! !!Trait method!testMapSequence	| parser |	parser := #any asPParser, #any asPParser		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: 'ab' to: #($b $a)! !!Trait method!testMapSequence	| parser |	parser := #any asPParser, #any asPParser		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: 'ab' to: #($b $a)! !!Trait method!testMapWrappedSequence	| parser |	parser := (#any asPParser, #any asPParser) wrapped		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: 'ab' to: #($b $a)! !!Trait method!testMapWrappedSequence	| parser |	parser := (#any asPParser, #any asPParser) wrapped		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: 'ab' to: #($b $a)! !!Trait method!testNot	| parser |	parser := 'foo' asPParser, 'bar' asPParser  not.		self assert: parser parse: 'foobaz' to: #('foo' nil) end: 3.	self assert: parser fail: 'foobar' end: 3! !!Trait method!testNot	| parser |	parser := 'foo' asPParser, 'bar' asPParser  not.		self assert: parser parse: 'foobaz' to: #('foo' nil) end: 3.	self assert: parser fail: 'foobar' end: 3! !!Trait method!testOptional	| parser |	parser := $a asPParser optional.		self assert: parser parse: '' to: nil.	self assert: parser parse: 'a' to: $a.		self assert: parser parse: 'aa' to: $a end: 1.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: nil end: 0.	self assert: parser parse: 'bb' to: nil end: 0.	self assert: parser parse: 'ba' to: nil end: 0! !!Trait method!testOptional	| parser |	parser := $a asPParser optional.		self assert: parser parse: '' to: nil.	self assert: parser parse: 'a' to: $a.		self assert: parser parse: 'aa' to: $a end: 1.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: nil end: 0.	self assert: parser parse: 'bb' to: nil end: 0.	self assert: parser parse: 'ba' to: nil end: 0! !!Trait method!testPlus	| parser |	parser := $a asPParser plus.	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'aab' to: #($a $a) end: 2.	self assert: parser parse: 'aaab' to: #($a $a $a) end: 3.			self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'ba'! !!Trait method!testPlus	| parser |	parser := $a asPParser plus.	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'aab' to: #($a $a) end: 2.	self assert: parser parse: 'aaab' to: #($a $a $a) end: 3.			self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'ba'! !!Trait method!testPlus2	| parser |	parser := ($a asPParser, $b asPParser) plus.		self assert: parser parse: 'ab' to: #(#($a $b)).	self assert: parser fail: 'a' end: 1.! !!Trait method!testPlus2	| parser |	parser := ($a asPParser, $b asPParser) plus.		self assert: parser parse: 'ab' to: #(#($a $b)).	self assert: parser fail: 'a' end: 1.! !!Trait method!testPredicateAny	|  parser |		parser := #any asPParser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: Character null asString to: Character null.		self assert: parser fail: ''.! !!Trait method!testPredicateAny	|  parser |		parser := #any asPParser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: Character null asString to: Character null.		self assert: parser fail: ''.! !!Trait method!testPredicateDigit	|  parser |		parser := #digit asPParser.	self assert: parser parse: '1' to: $1.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '9' to: $9.	self assert: parser fail: 'a'.! !!Trait method!testPredicateDigit	|  parser |		parser := #digit asPParser.	self assert: parser parse: '1' to: $1.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '9' to: $9.	self assert: parser fail: 'a'.! !!Trait method!testPredicateLetter	|  parser |		parser := #letter asPParser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ''.! !!Trait method!testPredicateLetter	|  parser |		parser := #letter asPParser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ''.! !!Trait method!testRepetitions	| parser result |	parser := ('foo' asPParser, ':=' asPParser) plus.		result := (self assert: parser parse: 'foo:=').		self assert: result value size equals: 1.	self assert: result value first equals: #('foo' ':=').		self assert: parser fail: 'foo' end: 3.! !!Trait method!testRepetitions	| parser result |	parser := ('foo' asPParser, ':=' asPParser) plus.		result := (self assert: parser parse: 'foo:=').		self assert: result value size equals: 1.	self assert: result value first equals: #('foo' ':=').		self assert: parser fail: 'foo' end: 3.! !!Trait method!testSeparatedBy	| parser |	parser := $a asPParser separatedBy: $b asPParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'abab' to: #($a $b $a) end: 3.	self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'c'! !!Trait method!testSeparatedBy	| parser |	parser := $a asPParser separatedBy: $b asPParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'abab' to: #($a $b $a) end: 3.	self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'c'! !!Trait method!testSequence	| parser |	parser := $a asPParser , $b asPParser.		self assert: parser parse: 'ab' to: #($a $b).		self assert: parser parse: 'aba' to: #($a $b) end: 2.	self assert: parser parse: 'abb' to: #($a $b) end: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a' end: 1.	self assert: parser fail: 'aa' end: 1.	self assert: parser fail: 'ba' end: 0.	self assert: parser fail: 'bab' end: 0! !!Trait method!testSequence	| parser |	parser := $a asPParser , $b asPParser.		self assert: parser parse: 'ab' to: #($a $b).		self assert: parser parse: 'aba' to: #($a $b) end: 2.	self assert: parser parse: 'abb' to: #($a $b) end: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a' end: 1.	self assert: parser fail: 'aa' end: 1.	self assert: parser fail: 'ba' end: 0.	self assert: parser fail: 'bab' end: 0! !!Trait method!testSequence2	| parser |	parser := ($a asPParser , $b asPParser) star, $a asPParser.	self assert: parser parse: 'a' to: (Array with: OrderedCollection new with: $a).	self assert: parser fail: 'ab' end: 2.	self assert: parser fail: ''.! !!Trait method!testSequence2	| parser |	parser := ($a asPParser , $b asPParser) star, $a asPParser.	self assert: parser parse: 'a' to: (Array with: OrderedCollection new with: $a).	self assert: parser fail: 'ab' end: 2.	self assert: parser fail: ''.! !!Trait method!testSequenceOfThree	| parser |	parser := $a asPParser , $b asPParser, $c asPParser.		self assert: parser parse: 'abc' to: #($a $b $c).	self assert: parser fail: 'ab' end: 2.! !!Trait method!testSequenceOfThree	| parser |	parser := $a asPParser , $b asPParser, $c asPParser.		self assert: parser parse: 'abc' to: #($a $b $c).	self assert: parser fail: 'ab' end: 2.! !!Trait method!testStar	| parser |	parser := $a asPParser star.	self assert: parser parse: '' to: #().	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self		assert: parser		parse: 'b'		to: #()		end: 0.	self		assert: parser		parse: 'ab'		to: #($a)		end: 1.	self		assert: parser		parse: 'aab'		to: #($a $a)		end: 2.	self		assert: parser		parse: 'aaab'		to: #($a $a $a)		end: 3! !!Trait method!testStar	| parser |	parser := $a asPParser star.	self assert: parser parse: '' to: #().	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self		assert: parser		parse: 'b'		to: #()		end: 0.	self		assert: parser		parse: 'ab'		to: #($a)		end: 1.	self		assert: parser		parse: 'aab'		to: #($a $a)		end: 2.	self		assert: parser		parse: 'aaab'		to: #($a $a $a)		end: 3! !!Trait method!testTimes	| parser |	parser := $a asPParser times: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a' end: 1.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a) end: 2! !!Trait method!testTimes	| parser |	parser := $a asPParser times: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a' end: 1.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a) end: 2! !!Trait method!testToken	| parser |	parser := $a asPParser token.	self assert: parser parse: 'a'	toTokenValue: 'a'.			self assert: parser fail: 'b'.	self assert: parser fail: ''.! !!Trait method!testToken	| parser |	parser := $a asPParser token.	self assert: parser parse: 'a'	toTokenValue: 'a'.			self assert: parser fail: 'b'.	self assert: parser fail: ''.! !!Trait method!testTokenLiteral	| parser |	parser := 'foo' asPParser token.	self assert: parser parse: 'foo' toTokenValue: 'foo'.			self assert: parser fail: 'bar'.	self assert: parser fail: ''.! !!Trait method!testTokenLiteral	| parser |	parser := 'foo' asPParser token.	self assert: parser parse: 'foo' toTokenValue: 'foo'.			self assert: parser fail: 'bar'.	self assert: parser fail: ''.! !!Trait method!testTokenTrim	| parser |	parser := $a asPParser token trim.		self assert: parser parse: 'a' toTokenValue: 'a'.	self assert: parser parse: ' a' toTokenValue: 'a'.	self assert: parser parse: 'a ' toTokenValue: 'a' end: 2.	self assert: parser parse: ' a ' toTokenValue: 'a' end: 3.	self assert: parser parse: '  a  ' toTokenValue: 'a' end: 5.	self assert: parser fail: 'b'.! !!Trait method!testTokenTrim	| parser |	parser := $a asPParser token trim.		self assert: parser parse: 'a' toTokenValue: 'a'.	self assert: parser parse: ' a' toTokenValue: 'a'.	self assert: parser parse: 'a ' toTokenValue: 'a' end: 2.	self assert: parser parse: ' a ' toTokenValue: 'a' end: 3.	self assert: parser parse: '  a  ' toTokenValue: 'a' end: 5.	self assert: parser fail: 'b'.! !!Trait method!testTrim	| parser |	parser := 'a' asPParser trim.		self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: ' a' to: 'a'.	self assert: parser parse: 'a ' to: 'a' end: 2.	self assert: parser parse: ' a ' to: 'a' end: 3.	self assert: parser parse: '  a  ' to: 'a' end: 5.	self assert: parser fail: 'b'.! !!Trait method!testTrim	| parser |	parser := 'a' asPParser trim.		self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: ' a' to: 'a'.	self assert: parser parse: 'a ' to: 'a' end: 2.	self assert: parser parse: ' a ' to: 'a' end: 3.	self assert: parser parse: '  a  ' to: 'a' end: 5.	self assert: parser fail: 'b'.! !!Trait method!testWrapped	| parser |	parser := $a asPParser wrapped.		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.! !!Trait method!testWrapped	| parser |	parser := $a asPParser wrapped.		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.! !!Trait method!testWrappedSequence	| parser |	parser := (($a asPParser , $b asPParser ) wrapped , $c asPParser).	self assert: parser parse: 'abc' to: #(#($a $b) $c)! !!Trait method!testWrappedSequence	| parser |	parser := (($a asPParser , $b asPParser ) wrapped , $c asPParser).	self assert: parser parse: 'abc' to: #(#($a $b) $c)! !!Trait method!testWrapping	| parser |	parser := $a asPParser >=> [:c :cc | cc value].		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.! !!Trait method!testWrapping	| parser |	parser := $a asPParser >=> [:c :cc | cc value].		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.! !!Trait method!emptySea	| nilSea |	nilSea := self seaInstance.	nilSea island: nil asPParser.	nilSea name: 'nil sea'.	^ nilSea! !!Trait method!emptySea	| nilSea |	nilSea := self seaInstance.	nilSea island: nil asPParser.	nilSea name: 'nil sea'.	^ nilSea! !!Trait method!nestedBlock	| blockSea block nilIsland |	blockSea := self seaInstance.	nilIsland := (self emptySea ==> #first).		block := PP2DelegateNode new.	block child: (${ asPParser,  (blockSea plus / nilIsland), $} asPParser).	block name: 'block'.		blockSea island: block.	blockSea name: 'block island'.	^ block! !!Trait method!nestedBlock	| blockSea block nilIsland |	blockSea := self seaInstance.	nilIsland := (self emptySea ==> #first).		block := PP2DelegateNode new.	block child: (${ asPParser,  (blockSea plus / nilIsland), $} asPParser).	block name: 'block'.		blockSea island: block.	blockSea name: 'block island'.	^ block! !!Trait method!result	self explicitRequirement! !!Trait method!result	self explicitRequirement! !!Trait method!seaInstance	^ self explicitRequirement! !!Trait method!seaInstance	^ self explicitRequirement! !!Trait method!testEOFBoundary	| sea |	sea := self seaInstance island: $a asPParser.		self assert: sea parse: '..a..'.	self assert: self result second equals: $a.	self assert: sea fail: '..'! !!Trait method!testEOFBoundary	| sea |	sea := self seaInstance island: $a asPParser.		self assert: sea parse: '..a..'.	self assert: self result second equals: $a.	self assert: sea fail: '..'! !!Trait method!testNestedBlockDeepNested	| block |	block := self nestedBlock.		self assert: block parse: '{ {} { {  } } }'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second size equals: 2.	self assert: self result second first size equals: 3.	self assert: self result second second size equals: 3.	self assert: self result third equals: $}.! !!Trait method!testNestedBlockDeepNested	| block |	block := self nestedBlock.		self assert: block parse: '{ {} { {  } } }'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second size equals: 2.	self assert: self result second first size equals: 3.	self assert: self result second second size equals: 3.	self assert: self result third equals: $}.! !!Trait method!testNestedBlockEmpty	| block |	block := self nestedBlock.		self assert: block parse: '{}'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second equals: #() asOrderedCollection.	self assert: self result third equals: $}.! !!Trait method!testNestedBlockEmpty	| block |	block := self nestedBlock.		self assert: block parse: '{}'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second equals: #() asOrderedCollection.	self assert: self result third equals: $}.! !!Trait method!testNestedBlockNested	| block |	block := self nestedBlock.		self assert: block parse: '{ {} }'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second size equals: 1.	self assert: self result second first size equals: 3.	self assert: self result third equals: $}.! !!Trait method!testNestedBlockNested	| block |	block := self nestedBlock.		self assert: block parse: '{ {} }'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second size equals: 1.	self assert: self result second first size equals: 3.	self assert: self result third equals: $}.! !!Trait method!testNestedBlockSpace	| block |	block := self nestedBlock.		self assert: block parse: '{ }'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second equals: #( $ ) asOrderedCollection.	self assert: self result third equals: $}.! !!Trait method!testNestedBlockSpace	| block |	block := self nestedBlock.		self assert: block parse: '{ }'.	self assert: self result size equals: 3.	self assert: self result first equals: ${.	self assert: self result second equals: #( $ ) asOrderedCollection.	self assert: self result third equals: $}.! !!Trait method!testNilSea	| parser |	parser := self emptySea.		self assert: parser parse: ''.	self assert: self result first equals: #() asOrderedCollection.		self assert: parser parse: '...'.	self assert: self result first equals: #($. $. $.) asOrderedCollection.! !!Trait method!testNilSea	| parser |	parser := self emptySea.		self assert: parser parse: ''.	self assert: self result first equals: #() asOrderedCollection.		self assert: parser parse: '...'.	self assert: self result first equals: #($. $. $.) asOrderedCollection.! !!Trait method!testNilSeaPlus	| sea parser |	sea := self seaInstance island: nil asPParser.	parser := sea flatten nonEpsilon plus.		self assert: parser fail: ''.	self assert: parser parse: '...'.	self assert: self result size equals: 1.	self assert: self result first equals: '...'.! !!Trait method!testNilSeaPlus	| sea parser |	sea := self seaInstance island: nil asPParser.	parser := sea flatten nonEpsilon plus.		self assert: parser fail: ''.	self assert: parser parse: '...'.	self assert: self result size equals: 1.	self assert: self result first equals: '...'.! !!Trait method!testNilSeaSequence	| sea sea2 parser |	sea := self seaInstance island: nil asPParser.	sea2 := self seaInstance island: nil asPParser.	parser := sea flatten, sea2 flatten.		self assert: parser parse: ''.	self assert: self result first equals: ''.		self assert: self result second equals: ''.		self assert: parser parse: '...'.	self assert: self result first equals: '...'.	self assert: self result second equals: ''.	! !!Trait method!testNilSeaSequence	| sea sea2 parser |	sea := self seaInstance island: nil asPParser.	sea2 := self seaInstance island: nil asPParser.	parser := sea flatten, sea2 flatten.		self assert: parser parse: ''.	self assert: self result first equals: ''.		self assert: self result second equals: ''.		self assert: parser parse: '...'.	self assert: self result first equals: '...'.	self assert: self result second equals: ''.	! !!Trait method!testNilSeaStar	| sea parser |	sea := self seaInstance island: #epsilon asPParser.	parser := sea flatten nonEpsilon star.		self assert: parser parse: ''.	self assert: self result isEmpty.	self assert: parser parse: '...'.	self assert: self result size equals: 1.	self assert: self result first equals: '...'.! !!Trait method!testNilSeaStar	| sea parser |	sea := self seaInstance island: #epsilon asPParser.	parser := sea flatten nonEpsilon star.		self assert: parser parse: ''.	self assert: self result isEmpty.	self assert: parser parse: '...'.	self assert: self result size equals: 1.	self assert: self result first equals: '...'.! !!Trait method!testNullableBoundary	| parser sea |	sea := self seaInstance island: $a asPParser.	parser := sea, $b asPParser optional.		self assert: parser parse: '..a..'.	self assert: self result first second equals: $a.	self assert: parser parse: '..a..b'.	self assert: self result first second equals: $a.	self assert: parser fail: '..b'.	self assert: parser fail: '..'	.! !!Trait method!testNullableBoundary	| parser sea |	sea := self seaInstance island: $a asPParser.	parser := sea, $b asPParser optional.		self assert: parser parse: '..a..'.	self assert: self result first second equals: $a.	self assert: parser parse: '..a..b'.	self assert: self result first second equals: $a.	self assert: parser fail: '..b'.	self assert: parser fail: '..'	.! !!Trait method!testNullableIsland	| parser sea |	sea := self seaInstance island: nil asPParser.	parser := sea.		self assert: parser parse: '..'.	self assert: self result first equals: #($. $.) asOrderedCollection.	self assert: self result second equals: nil.	self assert: self result third equals: #() asOrderedCollection.	self assert: parser parse: ''.! !!Trait method!testNullableIsland	| parser sea |	sea := self seaInstance island: nil asPParser.	parser := sea.		self assert: parser parse: '..'.	self assert: self result first equals: #($. $.) asOrderedCollection.	self assert: self result second equals: nil.	self assert: self result third equals: #() asOrderedCollection.	self assert: parser parse: ''.! !!Trait method!testOverlappingSeas	| seas seaOne seaTwo |	seaOne := self seaInstance island: $a asPParser.	seaTwo := self seaInstance island: $b asPParser.		seas := seaOne, seaTwo.		self assert: seas parse: '..a..b..'.	self assert: self result first second equals: $a.	self assert: self result second second equals: $b.		self assert: seas fail: '..b..a..b..'.	self assert: seas fail: '..a..'! !!Trait method!testOverlappingSeas	| seas seaOne seaTwo |	seaOne := self seaInstance island: $a asPParser.	seaTwo := self seaInstance island: $b asPParser.		seas := seaOne, seaTwo.		self assert: seas parse: '..a..b..'.	self assert: self result first second equals: $a.	self assert: self result second second equals: $b.		self assert: seas fail: '..b..a..b..'.	self assert: seas fail: '..a..'! !!Trait method!testSeaPlus	| sea parser |	sea := self seaInstance island: $a asPParser.	parser := sea plus.	self assert: parser parse: '..a..a..a...'.	self assert: self result size equals: 3.		self assert: parser fail: '...'.! !!Trait method!testSeaPlus	| sea parser |	sea := self seaInstance island: $a asPParser.	parser := sea plus.	self assert: parser parse: '..a..a..a...'.	self assert: self result size equals: 3.		self assert: parser fail: '...'.! !!Trait method!testSeaStar	| sea parser |	sea := self seaInstance island: $a asPParser.	parser := sea star.		self assert: parser parse: '..a..a..a...'.	self assert: self result size equals: 3.		self assert: parser parse: ''.	self assert: self result size equals: 0.	! !!Trait method!testSeaStar	| sea parser |	sea := self seaInstance island: $a asPParser.	parser := sea star.		self assert: parser parse: '..a..a..a...'.	self assert: self result size equals: 3.		self assert: parser parse: ''.	self assert: self result size equals: 0.	! !!Trait method!testAtEnd	| stream |	stream := self streamOn: ''. 	self assert: (stream atEnd: 0).	self assert: (stream atEnd: 1).	stream := self streamOn: 'f'. 	self assert: (stream atEnd: 0) not.	self assert: (stream atEnd: 1).	self assert: (stream atEnd: 2).! !!Trait method!testAtEnd	| stream |	stream := self streamOn: ''. 	self assert: (stream atEnd: 0).	self assert: (stream atEnd: 1).	stream := self streamOn: 'f'. 	self assert: (stream atEnd: 0) not.	self assert: (stream atEnd: 1).	self assert: (stream atEnd: 2).! !!Trait method!testAtPosition	| stream |	stream := self streamOn: 'bar'. 		self assert: (stream atPosition: 1) = $b.	self assert: (stream atPosition: 2) = $a.	self assert: (stream atPosition: 3) = $r.! !!Trait method!testAtPosition	| stream |	stream := self streamOn: 'bar'. 		self assert: (stream atPosition: 1) = $b.	self assert: (stream atPosition: 2) = $a.	self assert: (stream atPosition: 3) = $r.! !!Trait method!testAtPositionReversedOrder	| stream |	stream := self streamOn: 'bar'. 		self assert: (stream atPosition: 3) = $r.	self assert: (stream atPosition: 2) = $a.	self assert: (stream atPosition: 1) = $b.! !!Trait method!testAtPositionReversedOrder	| stream |	stream := self streamOn: 'bar'. 		self assert: (stream atPosition: 3) = $r.	self assert: (stream atPosition: 2) = $a.	self assert: (stream atPosition: 1) = $b.! !!Trait method!testCopyFromTo	| stream |	stream := self streamOn: 'bar'.	self assert: (stream copyFrom: 1 to: 1) = 'b'.	self assert: (stream copyFrom: 1 to: 3) = 'bar'.! !!Trait method!testCopyFromTo	| stream |	stream := self streamOn: 'bar'.	self assert: (stream copyFrom: 1 to: 1) = 'b'.	self assert: (stream copyFrom: 1 to: 3) = 'bar'.! !!Trait method!testNewTokenFromTo	| stream |	stream := self streamOn: 'foo'. 		self assert: (stream newToken: PP2Token from: 1 to: 3) value equals: 'foo'.! !!Trait method!testNewTokenFromTo	| stream |	stream := self streamOn: 'foo'. 		self assert: (stream newToken: PP2Token from: 1 to: 3) value equals: 'foo'.! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !"PetitParser2-Tests"!!PP2SkipValidation commentStamp: 'JanKurs 8/13/2016 15:03' prior: 0!If there is something wrong with the validation, throw this error. The PPValidator will skip validation for this source.!!PP2BufferStreamValidator methodsFor: 'validation' stamp: 'JanKurs 9/3/2016 17:58'!actualForSource: source	| result |		[		result := parser parse: (PP2BufferStream on: (PP2MinimalStream on: source) bufferSize: 64).	] on: SubscriptOutOfBounds do: [  		(PP2SkipValidation reason: 'To small buffer') signal	].	^ result isPetit2Failure ifFalse: [ 		result value isCollection 			ifTrue: [  result value ] 			ifFalse: [ Array with: result value ]	] ifTrue: [ 		#failure	]! !!PP2BufferStreamValidator methodsFor: 'validation' stamp: 'JanKurs 9/3/2016 17:58'!expectedForSource: source	| result |	result := parser parse: source.		^ result isPetit2Failure ifFalse: [ 		result value isCollection 			ifTrue: [  result value ] 			ifFalse: [ Array with: result value ]	] ifTrue: [ 		#failure	]! !!PP2BufferStreamValidator methodsFor: 'initialization' stamp: 'JanKurs 9/3/2016 13:27'!initialize	super initialize.		parser := PP2ExpressionParser new! !!PP2BufferStreamValidator methodsFor: 'accessing' stamp: 'JanKurs 8/13/2016 11:30'!name	^ 'PP2BufferStream'! !!PP2BufferStreamValidator methodsFor: 'accessing' stamp: 'JanKurs 8/23/2016 15:09'!sources	^ PP2Sources current inputs: #expressionOfSize: steps: 200 amount: 1 max: 200! !!PP2ExpressionGrammarOptimizaitonsValidator methodsFor: 'validation' stamp: 'JanKurs 8/31/2016 19:23'!actualForSource: source	| result |	result := optimizedParser parse: source.	^ result isPetit2Failure ifFalse: [ 		result value	] ifTrue: [ 		#failure	]! !!PP2ExpressionGrammarOptimizaitonsValidator methodsFor: 'validation' stamp: 'JanKurs 8/31/2016 16:41'!expectedForSource: source	| result |	result := parser parse: source.		^ result isPetit2Failure ifFalse: [ 		result value	] ifTrue: [ 		#failure	]! !!PP2ExpressionGrammarOptimizaitonsValidator methodsFor: 'initialization' stamp: 'JanKurs 8/31/2016 16:41'!initialize	super initialize.		parser := PP2ExpressionGrammar new.	optimizedParser := PP2ExpressionGrammar new optimize! !!PP2ExpressionGrammarOptimizaitonsValidator methodsFor: 'accessing' stamp: 'JanKurs 8/31/2016 16:41'!name	^ 'PP2ExpressionGrammar(Opt)'! !!PP2ExpressionGrammarOptimizaitonsValidator methodsFor: 'accessing' stamp: 'JanKurs 9/16/2016 09:30'!optimizedParser	^ optimizedParser! !!PP2ExpressionGrammarOptimizaitonsValidator methodsFor: 'accessing' stamp: 'JanKurs 9/16/2016 09:30'!parser	^ parser! !!PP2ExpressionGrammarOptimizaitonsValidator methodsFor: 'accessing' stamp: 'JanKurs 9/16/2016 09:31'!sources	^ PP2Sources current inputs: #expressionOfSize: steps: 200 amount: 1 max: 200! !!PP2Validator methodsFor: 'validation' stamp: 'JanKurs 8/23/2016 14:17'!actualForSource: source	self subclassResponsibility! !!PP2Validator methodsFor: 'reporting' stamp: 'JanKurs 8/23/2016 14:17'!compactReportTo: filename	| file |	file := FileStream forceNewFileNamed: filename.	self report printCompactOnStream: file.	file close.! !!PP2Validator methodsFor: 'validation' stamp: 'JanKurs 8/23/2016 14:17'!expectedForSource: source	self subclassResponsibility! !!PP2Validator methodsFor: 'utilities' stamp: 'JanKurs 8/23/2016 14:17'!fileContents: filename	^ (FileStream fileNamed: filename) contents! !!PP2Validator methodsFor: 'initialization' stamp: 'JanKurs 9/15/2016 17:28'!initialize	super initialize.		silent := true! !!PP2Validator methodsFor: 'accessing' stamp: 'JanKurs 8/23/2016 14:17'!name	self subclassResponsibility! !!PP2Validator methodsFor: 'accessing' stamp: 'JanKurs 8/23/2016 14:17'!report	^ report! !!PP2Validator methodsFor: 'utilities' stamp: 'JanKurs 8/23/2016 14:17'!showDiffForSource: source	| actual expected |	actual := self actualForSource: source.	expected := self expectedForSource: source.		(DiffMorph 		from: (actual joinUsing: Character lf) 		to: (expected joinUsing: Character lf)) openInWindow! !!PP2Validator methodsFor: 'accessing' stamp: 'JanKurs 8/23/2016 14:17'!silent	^ silent! !!PP2Validator methodsFor: 'accessing' stamp: 'JanKurs 8/23/2016 14:17'!silent: aBoolean	^ silent := aBoolean! !!PP2Validator methodsFor: 'accessing' stamp: 'JanKurs 8/23/2016 14:17'!sources	self subclassResponsibility! !!PP2Validator methodsFor: 'accessing' stamp: 'JanKurs 8/23/2016 14:17'!timeout	^ 30 asDuration! !!PP2Validator methodsFor: 'transcript' stamp: 'JanKurs 9/15/2016 17:29'!transcriptCr	self silent ifTrue: [ ^ self ].		Transcript cr.! !!PP2Validator methodsFor: 'transcript' stamp: 'JanKurs 9/15/2016 17:29'!transcriptShow: text	self silent ifTrue: [ ^ self ].		Transcript show: text.! !!PP2Validator methodsFor: 'validation' stamp: 'JanKurs 8/23/2016 14:17'!validate	[ self validateBlocking ] fork! !!PP2Validator methodsFor: 'validation' stamp: 'JanKurs 9/15/2016 17:33'!validateBlocking	| time sources |	self transcriptCr; transcriptShow: 'Validating: ', self name.			report := PP2ValidatorReport new.	report parserName: self name.		time := [		sources := self sources.		report sources: sources.				self transcriptCr.		sources withIndexDo: [ :source :index | 		[ 			((index % ((sources size // 50) max: 1)) = 0) ifTrue: [ self transcriptShow: '-' ].			(self validateSource: source report: report).		] on: Error do: [ :err | 			report error: err forSource: source.			silent ifFalse: [ err signal ]		]	]] timeToRun.	report time: time.	self transcriptShow: report asString! !!PP2Validator methodsFor: 'validation' stamp: 'JanKurs 8/25/2016 15:28'!validateSource: source report: aPPValidatorReport	| expected actual |	[		[ expected := self expectedForSource: source. ] on: PP2SkipValidation do: [ ^ self ].	] on: NotFound do: [ 		"Dunno why, but expected source not found just skip..."		^ self	].		[		[  actual := self actualForSource: source. ] on: PP2SkipValidation do: [  ^ self ]	] valueWithin: self timeout onTimeout: [ 		actual := #().		report timeout: source.	].	aPPValidatorReport actual: actual vs: expected for: source	! !!PP2ValidatorReport methodsFor: 'events' stamp: 'JanKurs 9/3/2016 17:54'!actual: actual vs: expected for: source	| entry |	(actual isPetit2Failure and: [ expected isPetit2Failure not ]) ifTrue: [ 		entry := PP2ValidatorReportEntry new.		entry actual: #().		entry expected: expected.		entries at: source put: entry.				^ self failure: actual forSource: source.	].	(actual isPetit2Failure and: [ expected isPetit2Failure ]) ifTrue: [ 		entry := PP2ValidatorReportEntry new.		entry expected: #().		entry actual: #().		entries at: source put: entry.				^ self	].	(actual isPetit2Failure not and: [ expected isPetit2Failure ]) ifTrue: [ 		entry := PP2ValidatorReportEntry new.		entry expected: #().		entry actual: actual.		entries at: source put: entry.				^ self	].	"		both are ok	"	entry := PP2ValidatorReportEntry new.	entry expected: expected.	entry actual: actual.	entries at: source put: entry! !!PP2ValidatorReport methodsFor: 'converting' stamp: 'JanKurs 9/16/2016 10:52'!asString	| stream |	stream := '' writeStream.	self printOnStream: stream.	^ stream contents! !!PP2ValidatorReport methodsFor: 'events' stamp: 'JanKurs 6/7/2016 14:29'!error: error forSource: source	errors add: (error -> source).! !!PP2ValidatorReport methodsFor: 'accessing' stamp: 'JanKurs 6/7/2016 14:26'!errors	^ errors! !!PP2ValidatorReport methodsFor: 'events' stamp: 'JanKurs 6/7/2016 15:55'!failure: failure forSource: source	failures add: (failure -> source)! !!PP2ValidatorReport methodsFor: 'stats' stamp: 'JanKurs 6/10/2016 10:15'!failureRate	^ ((timeouts size + failures size) / sources size) asFloat! !!PP2ValidatorReport methodsFor: 'accessing' stamp: 'JanKurs 6/7/2016 14:26'!failures	^ failures! !!PP2ValidatorReport methodsFor: 'initialization' stamp: 'JanKurs 6/7/2016 16:14'!initialize	entries := Dictionary new.	failures := OrderedCollection new.	timeouts := OrderedCollection new.	errors := OrderedCollection new.! !!PP2ValidatorReport methodsFor: 'accessing' stamp: 'JanKurs 6/10/2016 10:18'!parserName	^ parserName! !!PP2ValidatorReport methodsFor: 'accessing' stamp: 'JanKurs 6/10/2016 10:16'!parserName: aString	parserName := aString! !!PP2ValidatorReport methodsFor: 'stats' stamp: 'JanKurs 6/7/2016 16:11'!precision	| truePositives falsePositives |	truePositives := entries  inject: 0 into: [ :sum :e | sum + e truePositives size ].	falsePositives := entries values inject: 0 into: [ :sum :e | sum + e falsePositives size ].		^ truePositives / (truePositives + falsePositives) asFloat	! !!PP2ValidatorReport methodsFor: 'printing' stamp: 'JanKurs 6/10/2016 13:57'!printCompactOnStream: stream	stream nextPutAll: self parserName; tab.	stream nextPutAll: self precision asString; tab.	stream nextPutAll: self recall asString; tab.	stream nextPutAll: self failureRate asString; tab.	stream nextPutAll: self timePerSource asString; tab.		stream nextPutAll: failures size asString; tab.	stream nextPutAll: timeouts size asString; tab.	stream nextPutAll: errors size asString; cr.	stream flush.! !!PP2ValidatorReport methodsFor: 'printing' stamp: 'JanKurs 7/16/2016 21:11'!printOnStream: stream	stream cr; nextPutAll: 'Validated in: ', time asMilliseconds asString, 'ms on ', sources  size asString, ' files'.	stream cr; nextPutAll: 'precision: ', (self precision printShowingDecimalPlaces: 3).	stream cr; nextPutAll: 'recall: ', (self recall printShowingDecimalPlaces: 3).	stream cr; nextPutAll: 'total elements: ', (self total asString).	stream cr; nextPutAll: 'failure rate: ', (self failureRate printShowingDecimalPlaces: 3).	stream cr; nextPutAll: 'average time: ', (self timePerSource printShowingDecimalPlaces: 3), 'ms'.		stream cr; nextPutAll: 'failures: ', failures size asString.	stream cr; nextPutAll: 'timeouts: ', timeouts size asString.	stream cr; nextPutAll: 'errors: ', errors size asString.	stream flush.! !!PP2ValidatorReport methodsFor: 'stats' stamp: 'JanKurs 6/8/2016 14:50'!recall	| truePositives falseNegatives |	truePositives := entries values inject: 0 into: [ :sum :e | sum + e truePositives size ].	falseNegatives := entries values inject: 0 into: [ :sum :e | sum + e falseNegatives size ].	^ truePositives / (truePositives + falseNegatives) asFloat	! !!PP2ValidatorReport methodsFor: 'accessing' stamp: 'JanKurs 6/7/2016 14:26'!sources	^ sources! !!PP2ValidatorReport methodsFor: 'accessing' stamp: 'JanKurs 6/7/2016 14:26'!sources: anObject	sources := anObject! !!PP2ValidatorReport methodsFor: 'accessing' stamp: 'JanKurs 6/7/2016 16:07'!time: aTime	time := aTime! !!PP2ValidatorReport methodsFor: 'stats' stamp: 'JanKurs 6/7/2016 16:18'!timePerSource	^ (time asMilliSeconds / sources size) asFloat! !!PP2ValidatorReport methodsFor: 'events' stamp: 'JanKurs 6/7/2016 14:29'!timeout: source	timeouts add: source! !!PP2ValidatorReport methodsFor: 'accessing' stamp: 'JanKurs 6/7/2016 14:26'!timeouts	^ timeouts! !!PP2ValidatorReport methodsFor: 'stats' stamp: 'JanKurs 7/19/2016 11:44'!total	^ entries values inject: 0 into: [ :sum :e | sum + e expected size ].	! !!PP2ValidatorReportEntry methodsFor: 'accessing' stamp: 'JanKurs 6/7/2016 15:19'!actual	^ actual! !!PP2ValidatorReportEntry methodsFor: 'accessing' stamp: 'JanKurs 6/7/2016 15:19'!actual: anObject	actual := anObject! !!PP2ValidatorReportEntry methodsFor: 'accessing' stamp: 'JanKurs 6/7/2016 15:19'!expected	^ expected! !!PP2ValidatorReportEntry methodsFor: 'accessing' stamp: 'JanKurs 6/7/2016 15:19'!expected: anObject	expected := anObject! !!PP2ValidatorReportEntry methodsFor: 'stats' stamp: 'JanKurs 6/7/2016 15:18'!falseNegatives	^ expected select: [ :e | (actual includes: e) not ].! !!PP2ValidatorReportEntry methodsFor: 'stats' stamp: 'JanKurs 6/7/2016 15:18'!falsePositives	^ actual select: [ :e | (expected includes: e) not ].! !!PP2ValidatorReportEntry methodsFor: 'testing' stamp: 'JanKurs 7/16/2016 19:46'!isPerfect	^ self precision = 1 and: [ self recall = 1 ]! !!PP2ValidatorReportEntry methodsFor: 'stats' stamp: 'JanKurs 8/31/2016 19:25'!precision	( actual isEmpty) ifTrue: [ ^ 1 ].		^ self truePositives size / (self truePositives size + self falsePositives size) asFloat	! !!PP2ValidatorReportEntry methodsFor: 'printing' stamp: 'JanKurs 6/8/2016 14:19'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	aStream nextPutAll: (self precision  printShowingDecimalPlaces: 2).	aStream nextPutAll: ', '.	aStream nextPutAll: (self recall  printShowingDecimalPlaces: 2).	aStream nextPut: $).! !!PP2ValidatorReportEntry methodsFor: 'stats' stamp: 'JanKurs 8/31/2016 19:25'!recall	(expected isEmpty) ifTrue: [ ^ 1 ].	^ self truePositives size / (self truePositives size + self falseNegatives size) asFloat! !!PP2ValidatorReportEntry methodsFor: 'printing' stamp: 'JanKurs 7/17/2016 15:51'!showStringDiff	(DiffMorph 		from: (actual joinUsing: Character lf) 		to: (expected joinUsing: Character lf)) openInWindow! !!PP2ValidatorReportEntry methodsFor: 'stats' stamp: 'JanKurs 6/7/2016 15:18'!truePositives	^ actual select: [ :e | (expected includes: e) ].! !!PP2Sources class methodsFor: 'as yet unclassified' stamp: 'JanKurs 9/16/2016 14:18'!downloadUrl	^ 'http://scg.unibe.ch/download/jk/sources/'! !!PP2Sources methodsFor: 'seas' stamp: 'JanKurs 8/23/2016 14:17'!aIslandOfSize: size	| collection |	collection := String new: size.		1 to: size do: [ :index |	 		collection at: index put: $. .		].	collection at: size atRandom put: $a.	^ collection! !!PP2Sources methodsFor: 'seas' stamp: 'JanKurs 9/16/2016 11:44'!aIslandSourcesBenchmarking	^ self cachedValue: #aIslandSourcesBenchmarking ifAbsentPut: [ 		self inputs: #aIslandOfSize: steps: 30 amount: 1 max: 1*1000*1000	]! !!PP2Sources methodsFor: 'seas' stamp: 'JanKurs 9/16/2016 11:44'!aIslandSourcesComplexity	^ self cachedValue: #aIslandSourcesComplexity ifAbsentPut: [ 		self inputs: #aIslandOfSize: steps: 30 amount: 1 max: 1*1000*1000	]! !!PP2Sources methodsFor: 'seas' stamp: 'JanKurs 9/16/2016 11:44'!aIslandSourcesProfiling	^ self cachedValue: #aIslandSourcesProfiling ifAbsentPut: [ 		self inputs: #aIslandOfSize: steps: 30 amount: 1 max: 100*1000	]! !!PP2Sources methodsFor: 'seas' stamp: 'JanKurs 8/23/2016 14:17'!aIslandsOfSize: size	| collection |	collection := String new: size.		1 to: size do: [ :index |		(10 atRandom == 1) ifTrue: [ 			collection at: index put: $a.		] ifFalse: [ 	 		collection at: index put: $. .			]	].	^ collection! !!PP2Sources methodsFor: 'seas' stamp: 'JanKurs 9/16/2016 11:44'!aIslandsSourcesBenchmarking	^ self cachedValue: #aIslandsSourcesBenchmarking ifAbsentPut: [ 		self inputs: #aIslandsOfSize: steps: 30 amount: 1 max: 1*1000*1000	]! !!PP2Sources methodsFor: 'seas' stamp: 'JanKurs 9/16/2016 11:44'!aIslandsSourcesComplexity	^ self cachedValue: #aIslandsSourcesComplexity ifAbsentPut: [ 		self inputs: #aIslandsOfSize: steps: 30 amount: 1 max: 100*1000	]! !!PP2Sources methodsFor: 'seas' stamp: 'JanKurs 9/16/2016 11:44'!aIslandsSourcesProfiling	^ self cachedValue: #aIslandsSourcesProfiling ifAbsentPut: [ 		self inputs: #aIslandsOfSize: steps: 30 amount: 1 max: 2*1000	]! !!PP2Sources methodsFor: 'seas' stamp: 'JanKurs 8/23/2016 14:17'!blockIslandsOfSize: size	| stream |	stream := WriteStream on: (String new: size).	self blockIslandsOfSize: size stream: stream.	self assert: (stream size - size) == 0.	^ stream contents! !!PP2Sources methodsFor: 'seas' stamp: 'JanKurs 8/23/2016 14:17'!blockIslandsOfSize: size stream: stream	| index rand |	index := 0.	rand := Random new.		[index < size] whileTrue: [  		((size - index >= 2) and: [(rand next < 0.1)]) ifTrue: [  			| subSize |			subSize := (0 max: (size - index - 2)).			subSize > 0 ifTrue: [ subSize := rand nextInt: subSize ].			stream nextPut: ${.			self blockIslandsOfSize: subSize stream: stream.			stream nextPut: $}.			index := index + subSize  + 2.		] ifFalse: [ 			stream nextPut: $. .			index := index + 1.		].	]! !!PP2Sources methodsFor: 'seas' stamp: 'JanKurs 9/16/2016 11:44'!blockIslandsSourcesBenchmarking	^ self cachedValue: #blockIslandsSourcesBenchmarking ifAbsentPut: [ 		self inputs: #blockIslandsOfSize: steps: 30 amount: 1 max: 1*1000*1000	]! !!PP2Sources methodsFor: 'seas' stamp: 'JanKurs 9/16/2016 11:44'!blockIslandsSourcesComplexity	^ self cachedValue: #blockIslandsSourcesComplexity ifAbsentPut: [ 		self inputs: #blockIslandsOfSize: steps: 30 amount: 1 max: 50*1000	]! !!PP2Sources methodsFor: 'seas' stamp: 'JanKurs 9/16/2016 11:44'!blockIslandsSourcesProfiling	^ self cachedValue: #blockIslandsSourcesProfiling ifAbsentPut: [ 		self inputs: #blockIslandsOfSize: steps: 30 amount: 3 max: 2*1000	]! !!PP2Sources methodsFor: 'seas' stamp: 'JanKurs 9/16/2016 11:44'!blockIslandsSourcesTesting	^ self cachedValue: #blockIslandsSourcesTesting ifAbsentPut: [ 		self inputs: #blockIslandsOfSize: steps: 30 amount: 1 max: 1*1000	]! !!PP2Sources methodsFor: 'caching' stamp: 'JanKurs 9/16/2016 11:44'!cachedValue: key ifAbsentPut: block	^ cache at: key ifAbsentPut: block! !!PP2Sources methodsFor: 'download' stamp: 'JanKurs 9/17/2016 21:27'!download: zipFile	zipFile asFileReference exists ifFalse: [ 		ZnClient new			url: self class downloadUrl, zipFile;			signalProgress: true;			downloadTo: FileSystem workingDirectory.	].	^  (FileSystem zip: zipFile asFileReference) open workingDirectory! !!PP2Sources methodsFor: 'download' stamp: 'JanKurs 9/17/2016 21:27'!downloadUI: zipFile	zipFile asFileReference exists ifFalse: [ 		UIManager default informUserDuring: [ :bar |			bar label: 'Downloading ...'.			[ ZnClient new				url: self class downloadUrl, zipFile;				signalProgress: true;				downloadTo: FileSystem workingDirectory ]			on: HTTPProgress 			do: [ :progress |				progress isEmpty ifFalse: [ 					bar current: progress percentage.					progress total ifNotNil: [ :aTotalNumber |						bar label: 'Downloading ' ] ].				progress resume ] 		]		].	^  (FileSystem zip: zipFile asFileReference) open workingDirectory! !!PP2Sources methodsFor: 'expressions' stamp: 'JanKurs 8/23/2016 14:17'!expressionOfSize: size	| stream |	stream := WriteStream on: (String new: size * 5).	self expressionOfSize: size stream: stream.	^ stream contents! !!PP2Sources methodsFor: 'expressions' stamp: 'JanKurs 8/23/2016 14:17'!expressionOfSize: size stream: stream	| index rand |	index := 0.	rand := Random new.		[index < size] whileTrue: [  		(rand next < 0.1) ifTrue: [  			| subSize |			subSize := rand nextInt: (size - index - 1) + 1.			stream nextPutAll: ' ('.			self expressionOfSize: subSize stream: stream.			stream nextPutAll: ') '.			index := index + subSize.		] ifFalse: [ 			stream nextPutAll: (rand nextInt: 100) asString.			index := index + 1.		].			(index < size) ifTrue: [  			(rand next < 0.5) 				ifTrue: [  stream nextPutAll: ' + ' ] 				ifFalse: [ stream nextPutAll: ' * ' ]		]	]! !!PP2Sources methodsFor: 'expressions' stamp: 'JanKurs 9/16/2016 11:44'!expressionSourcesBenchmarking	^ self cachedValue: #expressionSourcesBenchmarking ifAbsentPut: [ 		self inputs: #expressionOfSize: steps: 50 amount: 10 max: 200.	].	! !!PP2Sources methodsFor: 'expressions' stamp: 'JanKurs 9/16/2016 11:44'!expressionSourcesComplexity	^ self cachedValue: #expressionSourcesComplexity ifAbsentPut: [ 		self inputs: #expressionOfSize: steps: 50 amount: 3 max: 2000.	].	! !!PP2Sources methodsFor: 'expressions' stamp: 'JanKurs 9/16/2016 11:44'!expressionSourcesProfiling	^ self cachedValue: #expressionSourcesProfiling ifAbsentPut: [ 		self inputs: #expressionOfSize: steps: 50 amount: 1 max: 100.	].	! !!PP2Sources methodsFor: 'expressions' stamp: 'JanKurs 9/16/2016 11:44'!expressionSourcesVerification	^ self cachedValue: #expressionSourcesVerification ifAbsentPut: [ 		self inputs: #expressionOfSize: steps: 500 amount: 1 max: 500.	].	! !!PP2Sources methodsFor: 'utility' stamp: 'JanKurs 8/23/2016 14:17'!files: files withExtension: extension	^ files select: [ :f | f extension = extension ] ! !!PP2Sources methodsFor: 'micro' stamp: 'JanKurs 9/16/2016 11:44'!idsSourcesBenchmarking	"		PPValidatorSources current idsSourcesBenchmarking.	"	^ self cachedValue: #idsSourcesBenchmarking ifAbsentPut: [ 		self inputs: #loremIpsum: steps: 50 amount: 1 max: 200*1000	]! !!PP2Sources methodsFor: 'expressions' stamp: 'JanKurs 8/23/2016 14:17'!indentExpressionOfSize: size	| stream |	stream := WriteStream on: (String new: size * 5).	self indentExpressionOfSize: size stream: stream indent: 0 limit: size.	^ stream contents! !!PP2Sources methodsFor: 'expressions' stamp: 'JanKurs 8/23/2016 14:17'!indentExpressionOfSize: size stream: stream indent: indent limit: limit	| index rand |	index := 0.	rand := Random new.	[index < size] whileTrue: [  		(index ~= 0 and: [ indent < 500 and: [ rand next < 0.1]] ) ifTrue: [  			| subSize |			subSize := rand nextInt: (size - index - 1) + 1.			stream nextPut: Character cr.			(indent + 1) timesRepeat: [ stream nextPutAll: '    ' ].			self indentExpressionOfSize: subSize stream: stream indent: (indent + 1) limit: limit.			stream nextPut: Character cr.			indent timesRepeat: [ stream nextPutAll: '    ' ].			index := index + subSize.		] ifFalse: [ 			stream nextPutAll: (rand nextInt: 100) asString.			index := index + 1.		].			(index < size) ifTrue: [  			(rand next < 0.5) 				ifTrue: [  stream nextPutAll: '+' ] 				ifFalse: [ stream nextPutAll: '*' ]		]	]! !!PP2Sources methodsFor: 'expressions' stamp: 'JanKurs 9/16/2016 11:44'!indentExpressionSourcesBenchmarking	^ self cachedValue: #indentExpressionSourcesBenchmarking ifAbsentPut: [ 		self inputs: #indentExpressionOfSize: steps: 50 amount: 3 max: 200.	].	! !!PP2Sources methodsFor: 'expressions' stamp: 'JanKurs 9/16/2016 11:44'!indentExpressionSourcesComplexity	^ self cachedValue: #indentExpressionSourcesComplexity ifAbsentPut: [ 		self inputs: #indentExpressionOfSize: steps: 50 amount: 3 max: 2000.	].	! !!PP2Sources methodsFor: 'expressions' stamp: 'JanKurs 9/16/2016 11:44'!indentExpressionSourcesProfiling	^ self cachedValue: #indentExpressionSourcesProfiling ifAbsentPut: [ 		self inputs: #indentExpressionOfSize: steps: 50 amount: 1 max: 50.	].	! !!PP2Sources methodsFor: 'expressions' stamp: 'JanKurs 9/16/2016 11:44'!indentExpressionSourcesVerification	^ self cachedValue: #indentExpressionSourcesVerification ifAbsentPut: [ 		self inputs: #indentExpressionOfSize: steps: 50 amount: 1 max: 50.	].	! !!PP2Sources methodsFor: 'initialization' stamp: 'JanKurs 8/23/2016 14:17'!initialize	super initialize.	cache := IdentityDictionary new! !!PP2Sources methodsFor: 'utility' stamp: 'JanKurs 8/23/2016 14:17'!inputs: selector steps: steps amount: amount max: max	| input size step |	input := OrderedCollection new.	step := max // steps.		1 to: steps do: [ :index |		size := step * index.		amount timesRepeat: [ 			input add: (self perform: selector with: size).		]	].	^ input! !!PP2Sources methodsFor: 'expressions' stamp: 'JanKurs 9/16/2016 11:44'!ll1expressionSourcesBenchmarking	^ self cachedValue: #ll1expressionSourcesBenchmarking ifAbsentPut: [ 		self inputs: #expressionOfSize: steps: 50 amount: 3 max: 2000.	].	! !!PP2Sources methodsFor: 'expressions' stamp: 'JanKurs 9/16/2016 11:44'!ll1expressionSourcesComplexity	^ self cachedValue: #ll1expressionSourcesComplexity ifAbsentPut: [ 		self inputs: #expressionOfSize: steps: 200 amount: 1 max: 10*1000.	].	! !!PP2Sources methodsFor: 'expressions' stamp: 'JanKurs 9/16/2016 11:44'!ll1indentExpressionSourcesBenchmarking	^ self cachedValue: #ll1indentExpressionSourcesBenchmarking ifAbsentPut: [ 		self inputs: #indentExpressionOfSize: steps: 50 amount: 3 max: 500.	].	! !!PP2Sources methodsFor: 'expressions' stamp: 'JanKurs 9/16/2016 11:44'!ll1indentExpressionSourcesComplexity	^ self cachedValue: #ll1indentExpressionSourcesComplexity ifAbsentPut: [ 		self inputs: #indentExpressionOfSize: steps: 200 amount: 1 max: 5*1000.	].	! !!PP2Sources methodsFor: 'utility' stamp: 'JanKurs 8/23/2016 14:17'!loremIpsum	^ 'Lorem ipsum dolor sit amet  consectetur adipiscing elit  sed do eiusmod tempor incididunt ut labore et dolore magna aliqua  Ut enim ad minim veniam  quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat  Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur  Excepteur sint occaecat cupidatat non proident  sunt in culpa qui officia deserunt mollit anim id est laborum'! !!PP2Sources methodsFor: 'utility' stamp: 'JanKurs 8/23/2016 14:17'!loremIpsum: size	"Return a mostly random multi-paragraph filler string of the specified size.	The result is pure ASCII, uses CR for newlines and no dots and newlines."		"	PPValidatorSources new loremIpsum: 2048	"		| words out |	words := (self loremIpsum findTokens: ' ') collect: #asLowercase.	(out := LimitedWriteStream on: (String new: size withAll: Character space))		setLimit: size - 2 		limitBlock: [ 			^ out originalContents 				at: size put: Character cr; 				yourself ].	[ 		out << self loremIpsum; cr; cr.		5 atRandom timesRepeat: [			15 atRandom timesRepeat: [	 			out << words atRandom capitalized.				20 atRandom timesRepeat: [ out space; << words atRandom ].				out space ].			out cr; cr ] ] repeat! !!PP2Sources methodsFor: 'utility' stamp: 'JanKurs 9/16/2016 14:14'!readDirectory: directory	| file |	( (Smalltalk respondsTo: #isSmalltalkX) and:[ Smalltalk isSmalltalkX ] ) ifTrue:[ 		file := self class dataDirectory asFilename / directory.		file exists ifFalse:[  			self error: 'Directory does not exist'.		].		^ (file recursiveDirectoryContentsAsFilenames select:[:each | each isRegularFile ]) asSortedCollection 	] ifFalse:[ 		"Assuming Pharo..."		ZnClient new			url: 'http://scg.unibe.ch/download/jk/sources/smalltalk-src-selected.zip';			signalProgress: true;			downloadTo: FileSystem workingDirectory.		file := (FileSystem zip: 'smalltalk-src-selected.zip' asFileReference) open workingDirectory."		file := self class dataDirectory download		file := self class dataDirectory asFileReference / directory.		file exists ifFalse: [ 			self error: 'Directory', directory asString, ' does not exist'.		]."		^ file allFiles asSortedCollection 	]	"Modified: / 10-05-2015 / 07:54:14 / Jan Vrany <jan.vrany@fit.cvut.cz>"! !!PP2Sources methodsFor: 'utility' stamp: 'JanKurs 9/17/2016 21:08'!selectEvenly: n fromFiles: collection	^ self selectEvenly: n fromFiles: collection thatSatisfy: [ :e | true ]! !!PP2Sources methodsFor: 'utility' stamp: 'JanKurs 9/17/2016 21:22'!selectEvenly: n fromFiles: collection thatSatisfy: aBlock	| set step index size sorted |	set := IdentitySet new.		step := 65537.	index := 0.	size := collection size.	sorted := collection sort.	self assert: collection atRandom isFile.		[set size = n] whileFalse: [ 		index := ((index + step) % size).		(aBlock value: (sorted at: (index + 1) )) ifTrue: [ 			set add: (sorted at: (index + 1)).		].	].	^ set asOrderedCollection sorted collect: [ :file | file contents ]! !!PP2SkipValidation class methodsFor: 'instance creation' stamp: 'JanKurs 8/13/2016 15:08'!reason: aString	^ self new		reason: aString;		yourself! !!PP2SkipValidation methodsFor: 'accessing' stamp: 'JanKurs 8/13/2016 15:08'!reason	^ reason! !!PP2SkipValidation methodsFor: 'accessing' stamp: 'JanKurs 8/13/2016 15:09'!reason: aString	reason := aString! !"PetitParser2-Validation"!!PP2VerificationTests commentStamp: 'JanKurs 8/23/2016 14:32' prior: 0!I am aspecial kind of test. I do not test validation  itself, but that that validation returns expected results.!!PP2BufferStreamValidatorTest methodsFor: 'running' stamp: 'JanKurs 9/3/2016 13:26'!setUp	super setUp.	validator := PP2BufferStreamValidator new.! !!PP2BufferStreamValidatorTest methodsFor: 'tests' stamp: 'JanKurs 9/3/2016 13:27'!testActualForSource	| result |	result := validator actualForSource: '1+2'.		self assert: result size = 3.	self assert: result first = 1.	self assert: result second = $+.	self assert: result third = 2.! !!PP2BufferStreamValidatorTest methodsFor: 'tests' stamp: 'JanKurs 9/3/2016 17:57'!testActualForSourceSingleNumber	| result |	result := validator actualForSource: '52'.		self assert: result isCollection.! !!PP2BufferStreamValidatorTest methodsFor: 'tests' stamp: 'JanKurs 9/3/2016 13:27'!testExpectedForSource	| result |	result := validator expectedForSource: '1+2'.		self assert: result size = 3.	self assert: result first = 1.	self assert: result second = $+.	self assert: result third = 2.! !!PP2BufferStreamValidatorTest methodsFor: 'tests' stamp: 'JanKurs 9/3/2016 17:57'!testExpectedForSourceSingleNumber	| result |	result := validator expectedForSource: '52'.		self assert: result isCollection.! !!PP2ExpressionGrammarOptimizationsValidator methodsFor: 'as yet unclassified' stamp: 'JanKurs 9/3/2016 13:29'!setUp	super setUp.	validator := PP2ExpressionGrammarOptimizaitonsValidator new.! !!PP2ExpressionGrammarOptimizationsValidator methodsFor: 'as yet unclassified' stamp: 'JanKurs 9/3/2016 13:29'!testActualForSource	| result |	result := validator actualForSource: '1+2'.		self assert: result size = 3.	self assert: result first = '1'.	self assert: result second = $+.	self assert: result third = '2'.! !!PP2ExpressionGrammarOptimizationsValidator methodsFor: 'as yet unclassified' stamp: 'JanKurs 9/3/2016 13:30'!testExpectedForSource	| result |	result := validator expectedForSource: '1+2'.		self assert: result size = 3.	self assert: result first = '1'.	self assert: result second = $+.	self assert: result third = '2'.! !!PP2ExpressionGrammarOptimizationsValidator methodsFor: 'as yet unclassified' stamp: 'JanKurs 9/3/2016 13:30'!testOptimization	self assert: validator optimizedParser isOptimized! !!PP2VerificationTests methodsFor: 'streams' stamp: 'JanKurs 8/23/2016 14:54'!testPP2BufferStream	| validator |	validator := PP2BufferStreamValidator new.	validator validateBlocking.		self assert: validator report precision equals: 1.	self assert: validator report recall equals: 1.! !!PP2VerificationTests methodsFor: 'optimizations' stamp: 'JanKurs 8/31/2016 16:42'!testPP2ExpressionGrammarOptimizations	| validator |	validator := PP2ExpressionGrammarOptimizaitonsValidator new.	validator validateBlocking.		self assert: validator report precision equals: 1.	self assert: validator report recall equals: 1.! !"PetitParser2-Validation-Tests"!!ManifestPetitParserBenchmarks commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!PP2BenchmarkTest methodsFor: 'tests' stamp: ' 12/6/2016 07:12:31'!testExpressionGrammar	| parser bench result input |	bench := PP2Benchmark new setupExpressionGrammar.	parser := bench parser.		self assert: parser class equals: PP2ExpressionGrammar.	self assert: (bench context isKindOf: PP2InMemoryContext).		result := parser end parse: '1 + (2 * 3)'.	self assert: result value size = 3.	self assert: result value first equals: '1'.		input := bench input.	context := bench context.	selector := bench selector.	self assert: (bench parser end perform: selector withArguments: {input first . context }) isPetit2Failure not.! !!PP2BenchmarkTest methodsFor: 'testing - expressions' stamp: ' 12/6/2016 07:12:31'!testExpressionGrammarNoOpt	| parser bench result input |	bench := PP2Benchmark new setupExpressionGrammarNoOpt.	parser := bench parser.		self assert: parser class equals: PP2ExpressionGrammar.	self assert: (bench context isKindOf: PP2Context).		result := parser end parse: '1 + (2 * 3)'.	self assert: result value size = 3.	self assert: result value first equals: '1'.		input := bench input.	context := bench context.	selector := bench selector.	self assert: (bench parser end perform: selector withArguments: {input first . context }) isPetit2Failure not.! !!PP2BenchmarkTest methodsFor: 'testing - expressions' stamp: ' 12/6/2016 07:12:31'!testExpressionParser	| parser bench result input |	bench := PP2Benchmark new setupExpressionParser.	parser := bench parser.		self assert: parser class equals: PP2ExpressionParser.		result := parser end parse: '1 + (2 * 3)'.	self assert: result value size = 3.	self assert: result value first equals: 1.	input := bench input.	context := bench context.	selector := bench selector.	self assert: (bench parser end perform: selector withArguments: {input first . context }) isPetit2Failure not.! !!PP2Benchmark class methodsFor: 'examples' stamp: ' 12/6/2016 07:12:31'!exampleExpressionGrammar	<example>		| b |	b := PP2Benchmark new.	b benchmarkExpressionGrammar.	b benchmarkExpressionGrammarNoOpt.	b showTpcs inspect! !!PP2Benchmark methodsFor: 'benchmarks - expression grammar' stamp: ' 12/6/2016 07:12:31'!benchmarkExpressionGrammar	self smartSetupAndRun: thisContext method selector.! !!PP2Benchmark methodsFor: 'benchmarks - expression grammar' stamp: ' 12/6/2016 07:12:31'!benchmarkExpressionGrammarNoOpt	self smartSetupAndRun: thisContext method selector.! !!PP2Benchmark methodsFor: 'benchmarks - expression grammar' stamp: ' 12/6/2016 07:12:31'!benchmarkExpressionParser	self smartSetupAndRun: thisContext method selector.! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!context	^ contextClass new! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!contextClass: aClass	^ contextClass := aClass! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!createResources	^ PP2Sources current! !!PP2Benchmark methodsFor: 'accessing - properties' stamp: ' 12/6/2016 07:12:31'!hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ]! !!PP2Benchmark methodsFor: 'initialization' stamp: ' 12/6/2016 07:12:31'!initialize	super initialize.	resources := self createResources.		contextClass := PP2Context.	preferredRepetitions := 1.	report := PP2BenchmarkReport new.	sourcesSize := 'Benchmarking'.		selector := #'parse:withContext:'! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!input	^ input! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!input: anObject	input := anObject! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!instantiate: aParserClass	^ aParserClass new! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parser	^ parser! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parser: anObject	parser := anObject! !!PP2Benchmark methodsFor: 'accessing - properties' stamp: ' 12/6/2016 07:12:31'!properties	^ properties! !!PP2Benchmark methodsFor: 'accessing - properties' stamp: ' 12/6/2016 07:12:31'!properties: aDictionary	properties := aDictionary ! !!PP2Benchmark methodsFor: 'accessing - properties' stamp: ' 12/6/2016 07:12:31'!propertyAt: aKey 	^ self propertyAt: aKey  ifAbsent: [ nil ]! !!PP2Benchmark methodsFor: 'accessing - properties' stamp: ' 12/6/2016 07:12:31'!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ properties at: aKey ifAbsent: aBlock ]! !!PP2Benchmark methodsFor: 'accessing - properties' stamp: ' 12/6/2016 07:12:31'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!PP2Benchmark methodsFor: 'accessing - properties' stamp: ' 12/6/2016 07:12:31'!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (properties ifNil: [ properties := Dictionary new: 1 ])		at: aKey put: anObject! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!repetitions	^ repetitions isNil ifTrue: [ preferredRepetitions  ] ifFalse: [ repetitions ]! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!repetitions: anObject	repetitions := anObject! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!repetitionsIfNotSet: value	repetitions := value! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!report	^ report! !!PP2Benchmark methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!reportInput: anInput time: time gcTime: gcTime name: nameOrNil	| size name |	size := anInput inject: 0 into: [:r :e | r + e size  ].		name := nameOrNil isNil 		ifTrue: [ parser class printString ]		ifFalse: [ nameOrNil ].		report addEntry: name size: size time: time gcTime: gcTime.! !!PP2Benchmark methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!reportInput: anInput time: time name: nameOrNil	self reportInput: anInput time: time gcTime:  0 name: nameOrNil! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!resources	^ resources! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!resources: newResources	resources := newResources! !!PP2Benchmark methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!run	| time gcTime |	self repetitions timesRepeat: [ 		3 timesRepeat: [ Smalltalk garbageCollect ].		gcTime := Smalltalk vm totalGCTime.		time := [ input do: [ :source | 			"parser parse: source withContext: self context"			parser perform: selector withArguments: {  source . self context }.		] ] timeToRun asMilliseconds.				self reportInput: input time: time gcTime: (Smalltalk vm totalGCTime - gcTime) name: parser name	]! !!PP2Benchmark methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!runTimeout: timeout	| time gcTime |	self repetitions timesRepeat: [ 		3 timesRepeat: [ Smalltalk garbageCollect ].		gcTime := Smalltalk vm totalGCTime.		time := [ input do: [ :source | 			[ parser parse: source withContext: self context ]				valueWithin: timeout				onTimeout: [ Transcript show: 'timeout'; cr. #timeout ]		] ] timeToRun asMilliSeconds.		self reportInput: input time: time gcTime: (Smalltalk vm totalGCTime - gcTime) name: parser class asString	]! !!PP2Benchmark methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!saveReport: filename	report save: filename	! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!selector	^ selector ! !!PP2Benchmark methodsFor: 'setup & teardown' stamp: ' 12/6/2016 07:12:31'!setup: class sources: name	parser := self instantiate: class.	input := self sourcesFor: name	! !!PP2Benchmark methodsFor: 'benchmarks - expression grammar' stamp: ' 12/6/2016 07:12:31'!setupExpressionGrammar	self setup: PP2ExpressionGrammar sources: 'expression'.	parser name: 'Arithmetic Expressions'.	self parser optimize.		contextClass := PP2InMemoryContext.	selector := #'parseAdaptable:withContext:'.	preferredRepetitions := 3! !!PP2Benchmark methodsFor: 'benchmarks - expression grammar' stamp: ' 12/6/2016 07:12:31'!setupExpressionGrammarNoOpt	self setup: PP2ExpressionGrammar sources: 'expression'.	parser name: 'Arithmetic Expressions (NoOpt)'.	preferredRepetitions := 3.		contextClass := PP2Context.	selector := #'parseAdaptable:withContext:'.	preferredRepetitions := 3.! !!PP2Benchmark methodsFor: 'benchmarks - expression grammar' stamp: ' 12/6/2016 07:12:31'!setupExpressionParser	self setup: PP2ExpressionParser sources: 'expression'.	parser name: 'Arithmetic Expressions Parser'.	preferredRepetitions := 3.		contextClass := PP2Context.! !!PP2Benchmark methodsFor: 'setup & teardown' stamp: ' 12/6/2016 07:12:31'!setupMock: id	input := OrderedCollection with: 'mock'.	parser := (nil asPParser)		name: id;		yourself! !!PP2Benchmark methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!setupSelector: setupSelector	self perform: ('setup', setupSelector) asSymbol.! !!PP2Benchmark methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!showDetailedReport	report showDetailed! !!PP2Benchmark methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!showReport	report show! !!PP2Benchmark methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!showSpeedup	report speedup! !!PP2Benchmark methodsFor: 'setup & teardown' stamp: ' 12/6/2016 07:12:31'!smartSetupAndRun: benchmarkSelector	^ self testSetupAndRun: (benchmarkSelector removePrefix: 'benchmark')! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!sourcesFor: language	| sourcesSelector |	sourcesSelector := (language asString, 'Sources', sourcesSize) asSymbol.		^ resources perform: sourcesSelector! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!sourcesSize: aString	sourcesSize := aString! !!PP2Benchmark methodsFor: 'setup & teardown' stamp: ' 12/6/2016 07:12:31'!teardownSelector: teardownSelector	| symbol |	symbol := ('teardown', teardownSelector) asSymbol.		(self respondsTo: symbol) ifTrue: [ 		self perform: symbol.	]! !!PP2Benchmark methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!testClass	^ PP2BenchmarkTest! !!PP2Benchmark methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!testSelector: testSelector	self testClass new perform: ('test', testSelector) asSymbol.! !!PP2Benchmark methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!testSetupAndRun: runSelector	self testSelector: runSelector.	self setupSelector: runSelector.	self run.	self teardownSelector: runSelector.! !!PP2ComplexityBenchmark methodsFor: 'initialization' stamp: ' 12/6/2016 07:12:31'!initialize	super initialize.		sourcesSize := 'Complexity'.! !!PP2ComplexityBenchmark methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!reportInput: anInput time: time gcTime: gcTime name: nameOrNil	| size name |	size := anInput size.		name := nameOrNil isNil 		ifTrue: [ parser class printString ]		ifFalse: [ nameOrNil ].		report addEntry: name size: size time: time gcTime: gcTime.! !!PP2ComplexityBenchmark methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!run	^ self runTimeout: 30 asDuration! !!PP2ComplexityBenchmark methodsFor: 'running' stamp: ' 12/6/2016 07:12:31'!runTimeout: timeout	| time |	self repetitions timesRepeat: [ 				input withIndexDo: [ :source :index | 			time := [[ parser parse: source withContext: self context ]				valueWithin: timeout				onTimeout: [ Transcript cr; show: 'timeout'; cr. #TIMEOUT ] ] timeToRunWithoutGC.			self reportInput: source time: time name: parser name.		].	].	^ report! !!PP2BenchmarkEntry methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!gcTime	^ gcTime ifNil: [ 0 ]! !!PP2BenchmarkEntry methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!gcTime: anObject	gcTime := anObject! !!PP2BenchmarkEntry methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!name	^ name! !!PP2BenchmarkEntry methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!name: anObject	name := anObject! !!PP2BenchmarkEntry methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!size	^ size! !!PP2BenchmarkEntry methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!size: anObject	size := anObject! !!PP2BenchmarkEntry methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!time	^ time! !!PP2BenchmarkEntry methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!time: anObject	time := anObject! !!PP2BenchmarkEntry methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!timestamp	^ timestamp! !!PP2BenchmarkEntry methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!timestamp: anObject	timestamp := anObject! !!PP2BenchmarkEntry methodsFor: 'stats' stamp: ' 12/6/2016 07:12:31'!tpc	^ time / size! !!PP2BenchmarkReport methodsFor: 'logging' stamp: ' 12/6/2016 07:12:31'!addEntry: entry	entries add: entry! !!PP2BenchmarkReport methodsFor: 'logging' stamp: ' 12/6/2016 07:12:31'!addEntry: parserName size: inputSize time: milliseconds	self addEntry: parserName size: inputSize time: milliseconds gcTime: 0! !!PP2BenchmarkReport methodsFor: 'logging' stamp: ' 12/6/2016 07:12:31'!addEntry: parserName size: inputSize time: milliseconds gcTime: gcMilliseconds	| entry |	entry := PP2BenchmarkEntry new		name: parserName ;		size: inputSize ;		time: milliseconds ;		gcTime: gcMilliseconds ;		timestamp: DateAndTime current.			self addEntry: entry! !!PP2BenchmarkReport methodsFor: 'converting' stamp: ' 12/6/2016 07:12:31'!asString	| stream |	stream := WriteStream on: ''.	self show: stream.	^ stream contents! !!PP2BenchmarkReport methodsFor: 'statistics' stamp: ' 12/6/2016 07:12:31'!fiveNumberSummary: list	| median min max lowerQuartile upperQuartile |	median := self median: list.	min := self min: list.	max := self max: list.	lowerQuartile := self lowerQuartile: list.	upperQuartile := self upperQuartile: list.		^ {  min . lowerQuartile . median . upperQuartile . max } ! !!PP2BenchmarkReport methodsFor: 'summary' stamp: ' 12/6/2016 07:12:31'!gcTimesFrom: subentries	^ subentries collect: #gcTime! !!PP2BenchmarkReport methodsFor: 'summary' stamp: ' 12/6/2016 07:12:31'!groupBy: fieldName	| dictionary |	dictionary := OrderedDictionary new.	entries do: [ :e |		| collection |		collection := dictionary at: (e perform: fieldName) ifAbsentPut: [ OrderedCollection new ].		collection add: e.	].	^ dictionary! !!PP2BenchmarkReport methodsFor: 'initialization' stamp: ' 12/6/2016 07:12:31'!initialize	entries := OrderedCollection new! !!PP2BenchmarkReport methodsFor: 'statistics' stamp: ' 12/6/2016 07:12:31'!lowerHalf: list	| return mean |	mean := self median: list.	return := list select: [ :e | e < mean ].		return isEmpty ifTrue: [ return add: list anyOne ].	^ return! !!PP2BenchmarkReport methodsFor: 'statistics' stamp: ' 12/6/2016 07:12:31'!lowerQuartile: list	^ self mean: (self lowerHalf: list)! !!PP2BenchmarkReport methodsFor: 'statistics' stamp: ' 12/6/2016 07:12:31'!max: list	^ list max! !!PP2BenchmarkReport methodsFor: 'statistics' stamp: ' 12/6/2016 07:12:31'!mean: list	^ list average! !!PP2BenchmarkReport methodsFor: 'statistics' stamp: ' 12/6/2016 07:12:31'!median: list	| sorted size |	sorted := list sort.	size := sorted size.	^ (size % 2 = 0) ifTrue: [ 		((sorted at: (size // 2)) + (sorted at: ((size // 2) + 1))) / 2	] ifFalse: [ 		sorted at: (size // 2) + 1	]! !!PP2BenchmarkReport methodsFor: 'statistics' stamp: ' 12/6/2016 07:12:31'!min: list	^ list min! !!PP2BenchmarkReport methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!printFiveNumberSummary: summary on: stream	"expeted: min, q1 mean q3 max"	^ self printNumberSummary: summary on: stream ! !!PP2BenchmarkReport methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!printNumberSummary: summary on: stream	"expeted: min, q1 mean q3 max"	summary do: [ :e | 		stream 			nextPut: Character tab;			nextPutAll: (e printShowingDecimalPlaces: 3);			yourself	]! !!PP2BenchmarkReport methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!save: filename	| file    |	file := FileStream forceNewFileNamed: filename.	self show: file.	file close.! !!PP2BenchmarkReport methodsFor: 'reporting complexity' stamp: ' 12/6/2016 07:12:31'!saveComplexity: filename	| file    |	file := FileStream forceNewFileNamed: filename.	self saveComplexityStream: file.	file close.! !!PP2BenchmarkReport methodsFor: 'reporting complexity' stamp: ' 12/6/2016 07:12:31'!saveComplexityEntries: subentries stream: stream	| entry time gcTime |	entry := subentries anyOne.	time := self mean: (subentries collect: #time).	gcTime := self mean: (subentries collect: #gcTime).		stream 		nextPutAll: entry name;		nextPut: Character tab;		nextPutAll: entry size asString;		nextPut: Character tab;		nextPutAll: time asFloat asString;		nextPut: Character tab;		nextPutAll: gcTime asFloat asString;		nextPut: Character lf;		flush! !!PP2BenchmarkReport methodsFor: 'reporting complexity' stamp: ' 12/6/2016 07:12:31'!saveComplexityStream: stream	(self groupBy: #size) keysAndValuesDo: [ :size :subentries |		self saveComplexityEntries: subentries stream: stream	]! !!PP2BenchmarkReport methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!saveEntriesNamed: name entries: subentries stream: stream	| size  timeSummary timeWithoutGCSummary gcSummary |	size := (self sizesFrom: subentries) anyOne.	timeSummary := self fiveNumberSummary: (self withoutMax: (self timesFrom: subentries)).	timeWithoutGCSummary := self fiveNumberSummary: (self withoutMax: (self timesWithoutGCFrom: subentries)).	gcSummary := self fiveNumberSummary: (self withoutMax: (self gcTimesFrom: subentries)).			stream			nextPutAll: name;			"With GC"			nextPut: Character tab;			nextPutAll: 'with gc'.	self printFiveNumberSummary: (timeSummary collect: [ :e | e / size * 1000 ]) on: stream.	stream			"Without GC"			nextPut: Character tab;			nextPutAll: 'without gc'.	self printFiveNumberSummary: (timeWithoutGCSummary collect: [ :e | e / size * 1000 ]) on: stream.	stream			"GC TIMES"			nextPut: Character tab;			nextPutAll: 'gc'.	self printFiveNumberSummary: (gcSummary collect: [ :e | e / size * 1000 ]) on: stream.	stream			nextPutAll: String lf;			flush.! !!PP2BenchmarkReport methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!show	Transcript show: '============'; cr.	self show: Transcript! !!PP2BenchmarkReport methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!show: stream	(self groupBy: #name) keysAndValuesDo: [ :name :subentries |		self saveEntriesNamed: name entries: subentries stream: stream	].! !!PP2BenchmarkReport methodsFor: 'reporting complexity' stamp: ' 12/6/2016 07:12:31'!showComplexity	self saveComplexityStream: Transcript! !!PP2BenchmarkReport methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!showDetailed	(self groupBy: #name) keysAndValuesDo: [ :name :subentries |		self showEntries: subentries	]! !!PP2BenchmarkReport methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!showEntries: subentries	subentries do: [ :e | 		self showEntry: e	]! !!PP2BenchmarkReport methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!showEntry: entry	Transcript crShow: 'Size: ', entry size asString.	Transcript crShow: entry name, ' time: ', entry time asString.	Transcript crShow: 'Time per character: ', (entry tpc * 1000.0) asString, ' microseconds'.		Transcript crShow: 'GC time: ', (entry gcTime) asString, 'ms'.! !!PP2BenchmarkReport methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!size	^ entries size! !!PP2BenchmarkReport methodsFor: 'summary' stamp: ' 12/6/2016 07:12:31'!sizesFrom: subentries	^ subentries collect: #size! !!PP2BenchmarkReport methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!speedup	self speedup: Transcript! !!PP2BenchmarkReport methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!speedup: stream	| grouped firstKey first firstName related relatedName |	grouped := (self groupBy: #name).	firstKey := grouped orderedKeys first.	first := (self fiveNumberSummary: (self timesFrom: (grouped at: firstKey))) first.	firstName := (grouped at: firstKey) anyOne name. 		grouped orderedKeys allButFirstDo: [ :key | 		key isNil ifFalse: [ 			related := (self fiveNumberSummary: (self timesFrom: (grouped at: key))) first.			relatedName := (grouped at: key) anyOne name.					stream nextPutAll: firstName, ' vs ', relatedName, ' speedup: ', ((first / related) asFloat printShowingDecimalPlaces: 3).			stream nextPutAll: String lf.		]	].	stream flush.! !!PP2BenchmarkReport methodsFor: 'statistics' stamp: ' 12/6/2016 07:12:31'!standardDeviation: data	^ (self variance: data)	sqrt! !!PP2BenchmarkReport methodsFor: 'reporting' stamp: ' 12/6/2016 07:12:31'!time: timeValue characters: size	^ (timeValue / size * 1000) printShowingDecimalPlaces: 3! !!PP2BenchmarkReport methodsFor: 'summary' stamp: ' 12/6/2016 07:12:31'!timesFrom: subentries	^ subentries collect: #time! !!PP2BenchmarkReport methodsFor: 'summary' stamp: ' 12/6/2016 07:12:31'!timesWithoutGCFrom: subentries	^ subentries collect: [:e | e time - e gcTime ]! !!PP2BenchmarkReport methodsFor: 'summary' stamp: ' 12/6/2016 07:12:31'!tpcsFrom: subentries	| size |	size := (self sizesFrom: subentries) anyOne.	^ (subentries collect: #time) collect: [ :e | e / size * 1000 ]! !!PP2BenchmarkReport methodsFor: 'statistics' stamp: ' 12/6/2016 07:12:31'!upperHalf: list	| mean |	mean := self median: list.	^ list select: [ :e | e >= mean ]! !!PP2BenchmarkReport methodsFor: 'statistics' stamp: ' 12/6/2016 07:12:31'!upperQuartile: list	^ self mean: (self upperHalf: list)! !!PP2BenchmarkReport methodsFor: 'statistics' stamp: ' 12/6/2016 07:12:31'!variance: data	| mean squaredDiffs |	mean := self mean: data.	squaredDiffs := data collect: [ :value | (value - mean) abs squared ].		^ squaredDiffs average! !!PP2BenchmarkReport methodsFor: 'statistics' stamp: ' 12/6/2016 07:12:31'!withoutMax: list	| max new |	(list size <= 1) ifTrue: [ ^ list ].		max := self max: list.	new := list copy asOrderedCollection.	new remove: max.	^ new! !!PP2BenchmarkReport methodsFor: 'statistics' stamp: ' 12/6/2016 07:12:31'!withoutWorst: list	^ list sort removeLast! !!RBParser methodsFor: '*PetitParser2-Benchmarks' stamp: ' 12/6/2016 07:12:31'!name	^ 'RBParser'! !"PetitParser2-Benchmarks"!!PP2Benchmark class methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!exampleSmalltalk	<example>		| b |	Metacello new  		baseline: 'SmaCC';		repository: 'github://ThierryGoubier/SmaCC:v2.0.5'; 		load: 'SmaCC-Smalltalk-Parser'.	b := PP2Benchmark new.	b benchmarkSmalltalkParser.	b benchmarkSmalltalkParserNoOpt.	b benchmarkSmalltalkParserSmacc.	b benchmarkRBParser.	b showTpcs inspect! !!PP2Benchmark methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!benchmarkRBParser	| time  |	self setupRBParser.		self repetitions timesRepeat: [ 		time := [ input do: [ :source | 						parser initializeParserWith: source.			parser parseMethod: source					] ] timeToRunWithoutGC "timeToRun asMilliseconds.".				self reportInput: input time: time name: parser name	]! !!PP2Benchmark methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!benchmarkSmalltalkGrammar		self smartSetupAndRun: thisContext method selector.! !!PP2Benchmark methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!benchmarkSmalltalkGrammarIM	"IM: Interpreted with Mutable context"	self smartSetupAndRun: thisContext method selector.! !!PP2Benchmark methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!benchmarkSmalltalkGrammarNoOpt		self smartSetupAndRun: thisContext method selector.! !!PP2Benchmark methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!benchmarkSmalltalkParser		self smartSetupAndRun: thisContext method selector.! !!PP2Benchmark methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!benchmarkSmalltalkParserNoOpt		self smartSetupAndRun: thisContext method selector.! !!PP2Benchmark methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!benchmarkSmalltalkParserSmacc	| time  gcTime |	self setupSmalltalkParserSmacc.		self repetitions timesRepeat: [ 		3 timesRepeat: [ Smalltalk garbageCollect ].			gcTime := Smalltalk vm totalGCTime.		time := [ input do: [ :source | 			parser parse: source		] ] timeToRun asMilliseconds.				self reportInput: input time: time gcTime: (Smalltalk vm totalGCTime - gcTime) name: parser name	]! !!PP2Benchmark methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!setupRBParser		input := self sourcesFor: 'smalltalk'.	parser := RBParser new.	preferredRepetitions := 3.! !!PP2Benchmark methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!setupSmalltalkGrammar	self setup: PP2SmalltalkGrammar sources: 'smalltalk'.	self parser name: 'Smalltalk Grammar'.	self parser optimize.		contextClass := PP2InMemoryContext.	selector := #'parseAdaptable:withContext:'.	preferredRepetitions := 3.	! !!PP2Benchmark methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!setupSmalltalkGrammarIM	"IM: Interpreted with Mutable context"		self setup: PP2SmalltalkGrammar sources: 'smalltalk'.	self parser name: 'Smalltalk Grammar (IM)'.		contextClass := PP2Context.	selector := #'parseInterpreted:withContext:'.	preferredRepetitions := 3.! !!PP2Benchmark methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!setupSmalltalkGrammarNoOpt	self setup: PP2SmalltalkGrammar sources: 'smalltalk'.	self parser name: 'Smalltalk Grammar (NoOpt)'.		contextClass := PP2Context.	selector := #'parseAdaptable:withContext:'.	preferredRepetitions := 3.	! !!PP2Benchmark methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!setupSmalltalkParser	self setup: PP2SmalltalkParser sources: 'smalltalk'.	self parser name: 'Smalltalk Parser'.	self parser optimize.		contextClass := PP2InMemoryContext.	selector := #'parseAdaptable:withContext:'.	preferredRepetitions := 3.	! !!PP2Benchmark methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!setupSmalltalkParserNoOpt	self setup: PP2SmalltalkParser sources: 'smalltalk'.	self parser name: 'Smalltalk Parser (NoOpt)'.		contextClass := PP2Context.	selector := #'parseAdaptable:withContext:'.	preferredRepetitions := 3.	! !!PP2Benchmark methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!setupSmalltalkParserSmacc	"		Metacello new		  	baseline: 'SmaCC';  			repository: 'github://ThierryGoubier/SmaCC:v2.0.5';  			load: 'SmaCC-Smalltalk-Parser'	"			input := self sourcesFor: 'smalltalk'.	parser := Smalltalk at: #StParser.	preferredRepetitions := 3.! !!RBProgramNode methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!pp2AddComments: aCollectionOfIntervals	(aCollectionOfIntervals isNil or: [ aCollectionOfIntervals isEmpty ])		ifFalse: [ self comments: self comments , aCollectionOfIntervals ]! !!PP2FirstSetVisitor methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!visitSmalltalkWhitespace: node	| returnSet |	(self isTerminal: node) ifTrue: [ ^ self setWithPossible: node ].	returnSet := self setWithPossible: node.		returnSet addAll: (self visit: #space asPParser).	returnSet addAll: (self visit: $" asPParser).		^ returnSet! !!PP2SmalltalkWhitespaceStrategy methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!initializeFor: aPP2Node	super initializeFor: aPP2Node.		failure := PP2Failure message: 'no whitespace found'! !!PP2SmalltalkWhitespaceStrategy methodsFor: 'parsing' stamp: ' 12/6/2016 07:12:31'!parseOn: aPP2Context	[ 		[ aPP2Context peek isSeparator ] whileTrue: [ 			aPP2Context shift 		].			(aPP2Context peek == $" ) 	] whileTrue: [		aPP2Context shift.		aPP2Context upTo: $".	].	^ failure! !!PP2Sources methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!smalltalkAllUrl	^ 'smalltalk-src-selected.zip'! !!PP2Sources methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!smalltalkFiles	^ self files: ((self downloadUI: self smalltalkAllUrl) allFiles) withExtension: 'st'! !!PP2Sources methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!smalltalkSourcesAll	^ self cachedValue: #smalltalkSourcesAll ifAbsentPut: [ 		(self downloadUI: self smalltalkAllUrl) allFiles collect: [ :f | f contents ]	]! !!PP2Sources methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!smalltalkSourcesBenchmarking	^ self cachedValue: #smalltalkSourcesBenchmarking ifAbsentPut: [ 		"self smalltalkSourcesInDirectory: self smalltalkSelectedDirectory."		self 			selectEvenly: 10000 			fromFiles: 	self smalltalkFiles		]! !!PP2Sources methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!smalltalkSourcesProfiling	^ self cachedValue: #smalltalkSourcesProfiling ifAbsentPut: [ 		self 			selectEvenly: 1000 			fromFiles: 	self smalltalkFiles	]! !!PP2Sources methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!smalltalkSourcesVerification	^ self cachedValue: #smalltalkSourcesVerification ifAbsentPut: [ 		"self smalltalkSourcesInDirectory: self smalltalkSelectedDirectory."		self 			selectEvenly: 5*1000 			fromFiles: self smalltalkFiles	]! !!PP2SmalltalkGrammar class methodsFor: 'testing' stamp: ' 12/6/2016 07:12:31'!allowUnderscoreAssignment	^ (Scanner respondsTo: #allowUnderscoreAsAssignment) and: [ Scanner allowUnderscoreAsAssignment ]! !!PP2SmalltalkGrammar class methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parseExpression: aString	^ self new parseExpression: aString! !!PP2SmalltalkGrammar class methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parseExpression: aString onError: aBlock	^ self new parseExpression: aString onError: aBlock! !!PP2SmalltalkGrammar class methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parseMethod: aString	^ self new parseMethod: aString! !!PP2SmalltalkGrammar class methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!parseMethod: aString onError: aBlock	^ self new parseMethod: aString onError: aBlock! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!array	^ ${ asPParser smalltalkToken , (expression delimitedBy: periodToken) optional , $} asPParser smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!arrayItem	^ literal / symbolLiteralArray / arrayLiteralArray / byteLiteralArray! !!PP2SmalltalkGrammar methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!arrayLiteral	^ '#(' asPParser smalltalkToken , arrayItem star , $) asPParser smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!arrayLiteralArray	^ $( asPParser smalltalkToken , arrayItem star , $) asPParser smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!assignment	^ variable , assignmentToken! !!PP2SmalltalkGrammar methodsFor: 'token' stamp: ' 12/6/2016 07:12:31'!assignmentToken	^ ':=' asPParser smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'primitives' stamp: ' 12/6/2016 07:12:31'!binary	^ (PP2PredicateObjectNode anyOf: '!!%&*+,-/<=>?@\|~') plus! !!PP2SmalltalkGrammar methodsFor: 'grammar-messages' stamp: ' 12/6/2016 07:12:31'!binaryExpression	^ unaryExpression , binaryMessage star! !!PP2SmalltalkGrammar methodsFor: 'grammar-messages' stamp: ' 12/6/2016 07:12:31'!binaryMessage	^ (binaryToken , unaryExpression) ==> [ :nodes | 		Array 			with: (Array with: nodes first)			with: (Array with: nodes second) ]! !!PP2SmalltalkGrammar methodsFor: 'grammar-methods' stamp: ' 12/6/2016 07:12:31'!binaryMethod	^ (binaryToken , variable) ==> [ :nodes | 		Array 			with: (Array with: nodes first)			with: (Array with: nodes second) ]! !!PP2SmalltalkGrammar methodsFor: 'grammar-pragmas' stamp: ' 12/6/2016 07:12:31'!binaryPragma	^ (binaryToken , arrayItem) ==> [ :nodes | 		Array 			with: (Array with: nodes first)			with: (Array with: nodes second) ]! !!PP2SmalltalkGrammar methodsFor: 'token' stamp: ' 12/6/2016 07:12:31'!binaryToken	^ binary smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'grammar-blocks' stamp: ' 12/6/2016 07:12:31'!block	^ $[ asPParser smalltalkToken , blockBody , $] asPParser smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'grammar-blocks' stamp: ' 12/6/2016 07:12:31'!blockArgument	^ $: asPParser smalltalkToken , variable! !!PP2SmalltalkGrammar methodsFor: 'grammar-blocks' stamp: ' 12/6/2016 07:12:31'!blockArguments	^ blockArgumentsWith / blockArgumentsWithout! !!PP2SmalltalkGrammar methodsFor: 'grammar-blocks' stamp: ' 12/6/2016 07:12:31'!blockArgumentsWith	^ blockArgument plus , ($| asPParser smalltalkToken / ($] asPParser smalltalkToken and ==> [ :node | nil ]))! !!PP2SmalltalkGrammar methodsFor: 'grammar-blocks' stamp: ' 12/6/2016 07:12:31'!blockArgumentsWithout	^ nil asPParser ==> [ :nodes | Array with: #() with: nil ]! !!PP2SmalltalkGrammar methodsFor: 'grammar-blocks' stamp: ' 12/6/2016 07:12:31'!blockBody	^ blockArguments , sequence! !!PP2SmalltalkGrammar methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!byteLiteral	^ '#[' asPParser smalltalkToken , numberLiteral star , $] asPParser smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!byteLiteralArray	^ $[ asPParser smalltalkToken , numberLiteral star , $] asPParser smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'grammar-messages' stamp: ' 12/6/2016 07:12:31'!cascadeExpression	^ keywordExpression , cascadeMessage star! !!PP2SmalltalkGrammar methodsFor: 'grammar-messages' stamp: ' 12/6/2016 07:12:31'!cascadeMessage	^ $; asPParser smalltalkToken , message! !!PP2SmalltalkGrammar methodsFor: 'primitives' stamp: ' 12/6/2016 07:12:31'!char	^ $$ asPParser , #any asPParser! !!PP2SmalltalkGrammar methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!charLiteral	^ charToken! !!PP2SmalltalkGrammar methodsFor: 'token' stamp: ' 12/6/2016 07:12:31'!charToken	^ char smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!expression	^ assignment star , cascadeExpression! !!PP2SmalltalkGrammar methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!falseLiteral	^ falseToken! !!PP2SmalltalkGrammar methodsFor: 'token' stamp: ' 12/6/2016 07:12:31'!falseToken	^ ('false' asPParser , #word asPParser not) smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'primitives' stamp: ' 12/6/2016 07:12:31'!identifier	| word letter |	letter := (PP2PredicateObjectNode				on: [ :each | each isLetter or: [ each = $_ ] ]				message: 'letter expected').					word := (PP2PredicateObjectNode				on: [ :each | each isAlphaNumeric or: [ each = $_ ] ]				message: 'letter or digit expected').					^ (letter, word star)! !!PP2SmalltalkGrammar methodsFor: 'token' stamp: ' 12/6/2016 07:12:31'!identifierToken	^ identifier smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'primitives' stamp: ' 12/6/2016 07:12:31'!keyword	^ identifier , $: asPParser! !!PP2SmalltalkGrammar methodsFor: 'grammar-messages' stamp: ' 12/6/2016 07:12:31'!keywordExpression	^ binaryExpression , keywordMessage optional! !!PP2SmalltalkGrammar methodsFor: 'grammar-messages' stamp: ' 12/6/2016 07:12:31'!keywordMessage	^ (keywordToken , binaryExpression) plus ==> [ :nodes | 		Array 			with: (nodes collect: [ :each | each first ])			with: (nodes collect: [ :each | each second ]) ]! !!PP2SmalltalkGrammar methodsFor: 'grammar-methods' stamp: ' 12/6/2016 07:12:31'!keywordMethod	^ (keywordToken , variable) plus ==> [ :nodes | 		Array 			with: (nodes collect: [ :each | each first ])			with: (nodes collect: [ :each | each second ]) ]! !!PP2SmalltalkGrammar methodsFor: 'grammar-pragmas' stamp: ' 12/6/2016 07:12:31'!keywordPragma	^ (keywordToken , arrayItem) plus ==> [ :nodes | 		Array 			with: (nodes collect: [ :each | each first ])			with: (nodes collect: [ :each | each second ]) ]! !!PP2SmalltalkGrammar methodsFor: 'token' stamp: ' 12/6/2016 07:12:31'!keywordToken	^ self keyword smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!literal	^ numberLiteral / stringLiteral / charLiteral / arrayLiteral / byteLiteral / symbolLiteral / nilLiteral / trueLiteral / falseLiteral! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!message	^ keywordMessage / binaryMessage / unaryMessage! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!method	^ methodDeclaration , methodSequence! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!methodDeclaration	^ keywordMethod / unaryMethod / binaryMethod! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!methodSequence	^ periodToken star , pragmas , periodToken star , temporaries , periodToken star , pragmas , periodToken star , statements! !!PP2SmalltalkGrammar methodsFor: 'primitives' stamp: ' 12/6/2016 07:12:31'!multiword	^ keyword plus! !!PP2SmalltalkGrammar methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!nilLiteral	^ nilToken! !!PP2SmalltalkGrammar methodsFor: 'token' stamp: ' 12/6/2016 07:12:31'!nilToken	^ ('nil' asPParser , #word asPParser not) smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'primitives' stamp: ' 12/6/2016 07:12:31'!number	^ ($- asPParser optional , #digit asPParser) and , [ :context | 		[ | stream retval |			stream := context asPositionableStream.		  	retval := (NumberParser on: stream) nextNumber.			(context position: stream position)				returnValue: retval;				yourself		] on: Error do: [ :err | context failure: err messageText ] 	] asPParser! !!PP2SmalltalkGrammar methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!numberLiteral	^ numberToken! !!PP2SmalltalkGrammar methodsFor: 'token' stamp: ' 12/6/2016 07:12:31'!numberToken	^ number smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!parens	^ $( asPParser smalltalkToken , expression , $) asPParser smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'parsing' stamp: ' 12/6/2016 07:12:31'!parseExpression: aString 	^ self parseExpression: aString onError: [ :msg :pos | self error: msg ]! !!PP2SmalltalkGrammar methodsFor: 'parsing' stamp: ' 12/6/2016 07:12:31'!parseExpression: aString onError: aBlock	^ startExpression parse: aString onError: aBlock! !!PP2SmalltalkGrammar methodsFor: 'parsing' stamp: ' 12/6/2016 07:12:31'!parseMethod: aString 	^ self parseMethod: aString onError: [ :msg :pos | self error: msg ]! !!PP2SmalltalkGrammar methodsFor: 'parsing' stamp: ' 12/6/2016 07:12:31'!parseMethod: aString onError: aBlock	^ startMethod parse: aString onError: aBlock! !!PP2SmalltalkGrammar methodsFor: 'primitives' stamp: ' 12/6/2016 07:12:31'!period	^ $. asPParser! !!PP2SmalltalkGrammar methodsFor: 'token' stamp: ' 12/6/2016 07:12:31'!periodToken	^ period smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!pragma	^ $< asPParser smalltalkToken , pragmaMessage , $> asPParser smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'grammar-pragmas' stamp: ' 12/6/2016 07:12:31'!pragmaMessage	^ keywordPragma / unaryPragma / binaryPragma! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!pragmas	^ pragma star! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!primary	^ literal / variable / block / parens / array! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!return	^ $^ asPParser smalltalkToken , expression! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!sequence	^ temporaries , periodToken star , statements! !!PP2SmalltalkGrammar methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!start	"Default start production."	^ startMethod! !!PP2SmalltalkGrammar methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!startExpression	"Start production for the expression."	^ sequence end! !!PP2SmalltalkGrammar methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!startMethod	"Start production for the method."	^ method end! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!statements	^ 	(expression wrapped , ((periodToken plus , statements ==> [ :nodes | nodes first , nodes last ])								/ periodToken star)			==> [ :nodes | (Array with: nodes first) , (nodes last) ])	/	(return , periodToken star			==> [ :nodes | (Array with: nodes first) , (nodes last) ])	/	(periodToken star)! !!PP2SmalltalkGrammar methodsFor: 'primitives' stamp: ' 12/6/2016 07:12:31'!string	^ ($' asPParser , ('''''' asPParser / $' asPParser negate) star , $' asPParser)		forbidCache;		yourself! !!PP2SmalltalkGrammar methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!stringLiteral	^ stringToken! !!PP2SmalltalkGrammar methodsFor: 'token' stamp: ' 12/6/2016 07:12:31'!stringToken	^ string smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'primitives' stamp: ' 12/6/2016 07:12:31'!symbol	^ unary / binary / multiword / string! !!PP2SmalltalkGrammar methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!symbolLiteral	"This is totally fucked up: The Pharo compiler allows multiple #, arbitrary spaces between the # and the symbol, as well as comments inbetween. And yes, it is used."	^ $# asPParser smalltalkToken plus , symbol smalltalkToken ==> [ :tokens | tokens first copyWith: tokens last ]! !!PP2SmalltalkGrammar methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!symbolLiteralArray	^ symbol smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!temporaries	^ ($| asPParser smalltalkToken , variable star , $| asPParser smalltalkToken) optional ==> [ :nodes | nodes ifNil: [ #() ] ]! !!PP2SmalltalkGrammar methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!trueLiteral	^ trueToken! !!PP2SmalltalkGrammar methodsFor: 'token' stamp: ' 12/6/2016 07:12:31'!trueToken	^ ('true' asPParser , #word asPParser not) smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'primitives' stamp: ' 12/6/2016 07:12:31'!unary	^ identifier , $: asPParser not! !!PP2SmalltalkGrammar methodsFor: 'grammar-messages' stamp: ' 12/6/2016 07:12:31'!unaryExpression	^ primary , unaryMessage star! !!PP2SmalltalkGrammar methodsFor: 'grammar-messages' stamp: ' 12/6/2016 07:12:31'!unaryMessage	^ unaryToken ==> [ :node | 		Array 			with: (Array with: node)			with: Array new ]! !!PP2SmalltalkGrammar methodsFor: 'grammar-methods' stamp: ' 12/6/2016 07:12:31'!unaryMethod	^ identifierToken ==> [ :node | 		Array 			with: (Array with: node)			with: Array new ]! !!PP2SmalltalkGrammar methodsFor: 'grammar-pragmas' stamp: ' 12/6/2016 07:12:31'!unaryPragma	^ identifierToken ==> [ :node | 		Array 			with: (Array with: node)			with: (Array new) ]! !!PP2SmalltalkGrammar methodsFor: 'token' stamp: ' 12/6/2016 07:12:31'!unaryToken	^ unary smalltalkToken! !!PP2SmalltalkGrammar methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!variable	^ identifierToken! !!PP2SmalltalkParser methodsFor: 'private' stamp: ' 12/6/2016 07:12:31'!addStatements: aCollection into: aNode	aCollection isNil 		ifTrue: [ ^ aNode ].	aCollection do: [ :each |		each class == PP2SmalltalkToken			ifFalse: [ aNode addNode:  each ]			ifTrue: [				aNode statements isEmpty					ifTrue: [ aNode pp2AddComments: each comments ]					ifFalse: [ aNode statements last pp2AddComments: each comments ].				aNode periods: (aNode periods asOrderedCollection					addLast: each start;					yourself) ] ].	^ aNode! !!PP2SmalltalkParser methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!array	^ super array map: [ :openNode :statementNodes :closeNode |		(self buildArray: statementNodes)			left: openNode start;			right: closeNode start;			yourself ]! !!PP2SmalltalkParser methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!arrayLiteral	^ super arrayLiteral		==> [ :nodes | 			RBLiteralArrayNode				startPosition: nodes first start				contents: nodes second				stopPosition: nodes last start				isByteArray: false ]! !!PP2SmalltalkParser methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!arrayLiteralArray	^ super arrayLiteralArray		==> [ :nodes | 			RBLiteralArrayNode				startPosition: nodes first start				contents: nodes second				stopPosition: nodes last start				isByteArray: false ]! !!PP2SmalltalkParser methodsFor: 'grammar-messages' stamp: ' 12/6/2016 07:12:31'!binaryExpression	^ super binaryExpression map: [ :receiverNode :messageNodes | self build: receiverNode messages: messageNodes ]! !!PP2SmalltalkParser methodsFor: 'token' stamp: ' 12/6/2016 07:12:31'!binaryToken	^ super binaryToken		==> [ :token | 			(RBBinarySelectorToken value: token value start: token start)				comments: token comments;				yourself ]! !!PP2SmalltalkParser methodsFor: 'grammar-blocks' stamp: ' 12/6/2016 07:12:31'!block	^ super block map: [ :leftToken :blockNode :rightToken | blockNode left: leftToken start; right: rightToken start ]! !!PP2SmalltalkParser methodsFor: 'grammar-blocks' stamp: ' 12/6/2016 07:12:31'!blockArgument	^ super blockArgument ==> #second! !!PP2SmalltalkParser methodsFor: 'grammar-blocks' stamp: ' 12/6/2016 07:12:31'!blockBody	^ super blockBody		==> [ :nodes | 			| result |			result := RBBlockNode arguments: nodes first first body: nodes last.			nodes first last ifNotNil: [ result bar: nodes first last start ].			result ]! !!PP2SmalltalkParser methodsFor: 'private' stamp: ' 12/6/2016 07:12:31'!build: aNode assignment: anArray	^ anArray isEmpty		ifTrue: [ aNode ]		ifFalse: [			anArray reverse 				inject: aNode				into: [ :result :each |					RBAssignmentNode 						variable: each first						value: result						position: each second start ] ]! !!PP2SmalltalkParser methodsFor: 'private' stamp: ' 12/6/2016 07:12:31'!build: aNode cascade: anArray 	| messages semicolons |	^ (anArray isNil or: [ anArray isEmpty ]) 		ifTrue: [ aNode ]		ifFalse: [			messages := OrderedCollection new: anArray size + 1.			messages addLast: aNode.			semicolons := OrderedCollection new.			anArray do: [ :each | 				messages addLast: (self 					build: aNode receiver					messages: (Array with: each second)).				semicolons addLast: each first start ].			RBCascadeNode messages: messages semicolons: semicolons ]! !!PP2SmalltalkParser methodsFor: 'private' stamp: ' 12/6/2016 07:12:31'!build: aNode messages: anArray	^ (anArray isNil or: [ anArray isEmpty ])		ifTrue: [ aNode ]		ifFalse: [ 			anArray				inject: aNode				into: [ :rec :msg | 					msg isNil						ifTrue: [ rec ]						ifFalse: [ 							RBMessageNode								receiver: rec								selector: (self buildSelector: msg first)								keywordsPositions: (msg first collect: [ :each | each start ])								arguments: msg second ] ] ]! !!PP2SmalltalkParser methodsFor: 'private' stamp: ' 12/6/2016 07:12:31'!build: aTempCollection sequence: aStatementCollection	| result |	result := self		addStatements: aStatementCollection		into: RBSequenceNode new.	aTempCollection isEmpty ifFalse: [		result			leftBar: aTempCollection first start			temporaries: aTempCollection second			rightBar: aTempCollection last start ].	^ result! !!PP2SmalltalkParser methodsFor: 'private' stamp: ' 12/6/2016 07:12:31'!buildArray: aStatementCollection	^ self addStatements: aStatementCollection into: RBArrayNode new! !!PP2SmalltalkParser methodsFor: 'private' stamp: ' 12/6/2016 07:12:31'!buildMethod: aMethodNode	self flag: 'check this one thoroughly as it is unclear if the changes preserve 	the original behavior from before the AST refactoring '."	aMethodNode selectorParts 		do: [ :each | aMethodNode addComments: each comments ]."	aMethodNode arguments		do: [ :each | aMethodNode pp2AddComments: each comments ].	aMethodNode pragmas do: [ :aPragma |		aMethodNode pp2AddComments: aPragma comments.		aMethodNode pp2AddComments: aPragma comments.		aPragma arguments do: [ :each | 			each isLiteralArray				ifFalse: [ aMethodNode pp2AddComments: each comments ] ].		aPragma comments: #() ].	^ aMethodNode! !!PP2SmalltalkParser methodsFor: 'private' stamp: ' 12/6/2016 07:12:31'!buildSelector: anArray	^ (String streamContents: [ :stream | anArray do: [ :each | stream nextPutAll: each value ] ]) asSymbol! !!PP2SmalltalkParser methodsFor: 'private' stamp: ' 12/6/2016 07:12:31'!buildString: aString 	(aString isEmpty or: [ aString first ~= $' or: [ aString last ~= $' ] ])		ifTrue: [ ^ aString ].	^ (aString 		copyFrom: 2		to: aString size - 1) 		copyReplaceAll: ''''''		with: ''''! !!PP2SmalltalkParser methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!byteLiteral	^ super byteLiteral		==> [ :nodes | 			RBLiteralArrayNode				startPosition: nodes first start				contents: nodes second				stopPosition: nodes last start				isByteArray: true ]! !!PP2SmalltalkParser methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!byteLiteralArray	^ super byteLiteralArray		==> [ :nodes | 			RBLiteralArrayNode				startPosition: nodes first start				contents: nodes second				stopPosition: nodes last start				isByteArray: true ]! !!PP2SmalltalkParser methodsFor: 'grammar-messages' stamp: ' 12/6/2016 07:12:31'!cascadeExpression	^ super cascadeExpression map: [ :receiverNode :messageNodes | self build: receiverNode cascade: messageNodes ]! !!PP2SmalltalkParser methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!charLiteral	^ super charLiteral		==> [ :token | 			(RBLiteralValueNode 				value: token value second 				start: token start 				stop: token stop)				comments: token comments;				yourself ]! !!PP2SmalltalkParser methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!expression	^ super expression map: [ :variableNodes :expressionNodes | self build: expressionNodes assignment: variableNodes ]! !!PP2SmalltalkParser methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!falseLiteral	^ super falseLiteral		==> [ :token | 			(RBLiteralValueNode 				value: false 				start: token start 				stop: token stop)				comments: token comments;				yourself ]! !!PP2SmalltalkParser methodsFor: 'token' stamp: ' 12/6/2016 07:12:31'!identifierToken	^ (super identifierToken		==> [ :token | 			(RBIdentifierToken value: token value start: token start)				comments: token comments;				yourself ])		forbidCache;		yourself! !!PP2SmalltalkParser methodsFor: 'grammar-messages' stamp: ' 12/6/2016 07:12:31'!keywordExpression	^ super keywordExpression map: [ :receiveNode :messageNode | self build: receiveNode messages: (Array with: messageNode) ]! !!PP2SmalltalkParser methodsFor: 'token' stamp: ' 12/6/2016 07:12:31'!keywordToken	^ super keywordToken		==> [ :token | 			(RBKeywordToken value: token value start: token start)				comments: token comments;				yourself ]! !!PP2SmalltalkParser methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!method	^ super method map: [ :methodNode :bodyNode | 		methodNode pragmas: bodyNode first.		methodNode body: bodyNode second.		self buildMethod: methodNode ]! !!PP2SmalltalkParser methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!methodDeclaration	^ super methodDeclaration		==> [ :nodes | 			RBMethodNode				selector: (self buildSelector: nodes first)				keywordsPositions: (nodes first collect: [ :each | each start ])				arguments: nodes second ]! !!PP2SmalltalkParser methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!methodSequence	^ super methodSequence map: [ :periodNodes1 :pragmaNodes1 :periodNodes2 :tempNodes :periodNodes3 :pragmaNodes2 :periodNodes4 :statementNodes |		Array			with: pragmaNodes1 , pragmaNodes2			with: (self build: tempNodes sequence: periodNodes1 , periodNodes2 , periodNodes3 , periodNodes4 , statementNodes) ]! !!PP2SmalltalkParser methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!nilLiteral	^ super nilLiteral		==> [ :token | 			(RBLiteralValueNode 				value: nil 				start: token start 				stop: token stop)				comments: token comments;				yourself ]! !!PP2SmalltalkParser methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!numberLiteral	^ super numberLiteral		==> [ :token | 			(RBLiteralValueNode				value: (Number readFrom: token value)				start: token start				stop: token stop				source: token value)				comments: token comments;				yourself ]! !!PP2SmalltalkParser methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!parens	^ super parens map: [ :openToken :expressionNode :closeToken | expressionNode addParenthesis: (openToken start to: closeToken start) ]! !!PP2SmalltalkParser methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!pragma	^ super pragma		==> [ :nodes | 			(RBPragmaNode				selector: (self buildSelector: nodes second first)				keywordsPositions: (nodes second first collect: [ :each | each start ])				arguments: nodes second second)				pp2AddComments: nodes first comments;				pp2AddComments: nodes last comments;				left: nodes first start;				right: nodes last start;				yourself ]! !!PP2SmalltalkParser methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!return	^ super return map: [ :token :expressionNode | RBReturnNode return: token start value: expressionNode ]! !!PP2SmalltalkParser methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!sequence	^ super sequence map: [ :tempNodes :periodNodes :statementNodes | self build: tempNodes sequence: periodNodes , statementNodes ]! !!PP2SmalltalkParser methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!startExpression	"Make the sequence node has a method node as its parent and that the source is set."	^ ([ :context | context contents ] asPParser and , super startExpression) map: [ :source :node | 		(RBMethodNode selector: #doIt body: node)			source: source.		(node statements size = 1 and: [ node temporaries isEmpty ])			ifTrue: [ node statements first ]			ifFalse: [ node ] ]! !!PP2SmalltalkParser methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!startMethod	"Make sure the method node has the source code properly set."	^ ([ :context | context upToEnd ] asPParser and, super startMethod)		map: [ :source :node | node source: source ]! !!PP2SmalltalkParser methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!stringLiteral	^ super stringLiteral		==> [ :token | 			(RBLiteralValueNode 				value: (self buildString: token value) 				start: token start 				stop: token stop)				comments: token comments;				yourself ]! !!PP2SmalltalkParser methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!symbolLiteral	^ super symbolLiteral		==> [ :tokens | 			(RBLiteralValueNode				value: (self buildString: tokens last value) asSymbol				start: tokens first start				stop: tokens last stop)				comments: tokens last comments;				yourself ]! !!PP2SmalltalkParser methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!symbolLiteralArray	^ super symbolLiteralArray		==> [ :token | 			(RBLiteralValueNode 				value: (self buildString: token value) asSymbol 				start: token start 				stop: token stop)				comments: token comments;				yourself ]! !!PP2SmalltalkParser methodsFor: 'grammar-literals' stamp: ' 12/6/2016 07:12:31'!trueLiteral	^ super trueLiteral		==> [ :token | 			(RBLiteralValueNode value: true start: token start stop: token stop)				comments: token comments;				yourself ]! !!PP2SmalltalkParser methodsFor: 'grammar-messages' stamp: ' 12/6/2016 07:12:31'!unaryExpression	^ super unaryExpression map: [ :receiverNode :messageNodes | self build: receiverNode messages: messageNodes ]! !!PP2SmalltalkParser methodsFor: 'token' stamp: ' 12/6/2016 07:12:31'!unaryToken	^ super unaryToken		==> [ :token | 			(RBIdentifierToken value: token value start: token start)				comments: token comments;				yourself ]! !!PP2SmalltalkParser methodsFor: 'grammar' stamp: ' 12/6/2016 07:12:31'!variable	^ super variable ==> [ :token | RBVariableNode identifierNamed: token value  at: token start ]! !!PP2IsNullableVisitor methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!visitSmalltalkWhitespace: node	^ true! !!PP2SourcesTest methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!testSmalltalkSources	| s1 s2 |	PP2Sources reset.	s1 := PP2Sources current smalltalkSourcesProfiling.	PP2Sources reset.	s2 := PP2Sources current smalltalkSourcesProfiling.		self assert: s1 equals: s2.! !!PP2NodeVisitor methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!visitSmalltalkWhitespace: node	^ self visitPP2Node: node! !!PP2BenchmarkTest methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!testSmalltalkGrammar	| input  bench |	bench := PP2Benchmark new.	bench setupSmalltalkGrammar.	self assert: (bench parser isKindOf: PP2SmalltalkGrammar).	self assert: (bench parser isOptimized).		input := bench input.	context := bench context.	selector := bench selector.	self assert: (bench parser end perform: selector withArguments: {input first . context }) isPetit2Failure not.! !!PP2BenchmarkTest methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!testSmalltalkGrammarIM	| input  bench |	bench := PP2Benchmark new.	bench setupSmalltalkGrammarIM.	self assert: (bench parser isKindOf: PP2SmalltalkGrammar).	input := bench input.	context := bench context.	selector := bench selector.	self assert: (bench parser end perform: selector withArguments: {input first . context }) isPetit2Failure not.! !!PP2BenchmarkTest methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!testSmalltalkGrammarNoOpt	| input  bench |	bench := PP2Benchmark new.	bench setupSmalltalkGrammarNoOpt.	self assert: (bench parser isKindOf: PP2SmalltalkGrammar).	self assert: (bench parser isOptimized not).		input := bench input.	context := bench context.	selector := bench selector.	self assert: (bench parser end perform: selector withArguments: {input first . context }) isPetit2Failure not.! !!PP2BenchmarkTest methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!testSmalltalkParser	| input  bench result rbresult |	bench := PP2Benchmark new.	bench setupSmalltalkParser.	self assert: (bench parser isKindOf: PP2SmalltalkParser).	self assert: (bench parser isOptimized).		input := bench input.	context := bench context.	selector := bench selector.	self assert: (result := bench parser end perform: selector withArguments: {input first . context }) isPetit2Failure not.	self assert: result isPetit2Failure not.	self assert: result value isMethod.		"Sanity check against RBParser"	rbresult := RBParser parseMethod: input first.	self assert: result value equals: rbresult	! !!PP2BenchmarkTest methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!testSmalltalkParserNoOpt	| input  bench result |	bench := PP2Benchmark new.	bench setupSmalltalkParserNoOpt.	self assert: (bench parser isKindOf: PP2SmalltalkParser).	self assert: (bench parser isOptimized not).		input := bench input.	context := bench context.	selector := bench selector.	self assert: (result := bench parser end perform: selector withArguments: {input first . context }) isPetit2Failure not.	self assert: result isPetit2Failure not.	self assert: result value isMethod.	! !!PP2SmalltalkParserOptimizationsValidator methodsFor: 'validation' stamp: ' 12/6/2016 07:12:31'!actualForSource: source	| result |	result := optimizedParser parse: source.	^ result isPetit2Failure ifFalse: [ 		Array with: result value	] ifTrue: [ 		#failure	]! !!PP2SmalltalkParserOptimizationsValidator methodsFor: 'validation' stamp: ' 12/6/2016 07:12:31'!expectedForSource: source	| result |	result := parser parse: source.		^ result isPetit2Failure ifFalse: [ 		Array with: result value	] ifTrue: [ 		#failure	]! !!PP2SmalltalkParserOptimizationsValidator methodsFor: 'initialization' stamp: ' 12/6/2016 07:12:31'!initialize	super initialize.		parser := PP2SmalltalkParser new.	optimizedParser := PP2SmalltalkParser new optimize! !!PP2SmalltalkParserOptimizationsValidator methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!name	^ 'PP2SmalltalkParser(Opt)'! !!PP2SmalltalkParserOptimizationsValidator methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!sources	^ PP2Sources current smalltalkSourcesVerification! !!PP2Interpret methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!visitSmalltalkWhitespace: node		[ 		[ currentContext atEnd not and: [ currentContext uncheckedPeek isSeparator ]] whileTrue: [ 			currentContext shift 		].			(currentContext atEnd not and: [ currentContext uncheckedPeek = $" ]) 	] whileTrue: [		currentContext shift.		currentContext upTo: $".	].! !!PP2Node methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!smalltalkToken	^ (self token: PP2SmalltalkToken) trim: PP2SmalltalkWhitespaceNode instance! !!PP2SmalltalkWhitespaceNode class methodsFor: 'instance creation' stamp: ' 12/6/2016 07:12:31'!instance	instance isNil ifTrue: [ 		instance := self new	].	"		I would rather not to see this as a singleton				The reason to reset is that optimizations set some strategies. And these will not get 		restored.	"	instance resetStrategies.	^ instance ! !!PP2SmalltalkWhitespaceNode class methodsFor: 'instance creation' stamp: ' 12/6/2016 07:12:31'!reset	instance := nil! !!PP2SmalltalkWhitespaceNode methodsFor: 'visiting' stamp: ' 12/6/2016 07:12:31'!accept: visitor	^ visitor visitSmalltalkWhitespace: self! !!PP2SmalltalkWhitespaceNode methodsFor: 'initialization' stamp: ' 12/6/2016 07:12:31'!initialize	super initialize.		self resetStrategies.! !!PP2SmalltalkWhitespaceNode methodsFor: 'analysis - first' stamp: ' 12/6/2016 07:12:31'!isFirstSetTerminal	^ false! !!PP2SmalltalkWhitespaceNode methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!name	^ 'smalltalk_ws'! !!PP2SmalltalkWhitespaceNode methodsFor: 'initialization' stamp: ' 12/6/2016 07:12:31'!resetStrategy	strategy := PP2SmalltalkWhitespaceStrategy on: self! !!PP2ContextChangesVisitor methodsFor: '*PetitParser2-Smalltalk' stamp: ' 12/6/2016 07:12:31'!visitSmalltalkWhitespace: node	^ PP2CcChange noChange ! !!PP2SmalltalkToken methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!comments	^ comments ifNil: [ #() ]! !!PP2SmalltalkToken methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!comments: anArray	comments := anArray! !!PP2SmalltalkToken methodsFor: 'compatiblity' stamp: ' 12/6/2016 07:12:31'!length	^ self size! !"PetitParser2-Smalltalk"!!ManifestPetitParserSmalltalkTests commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!TPP2SmalltalkGrammarTests methodsFor: 'accessing' stamp: 'JanKurs 9/6/2016 14:11'!parserClass	^ PP2SmalltalkGrammar! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:11'!testArgumentsBlock1	self 		parse: '[ :a | ]'		rule: #block! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:11'!testArgumentsBlock2	self 		parse: '[ :a :b | ]'		rule: #block! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:11'!testArgumentsBlock3	self 		parse: '[ :a :b :c | ]'		rule: #block! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testArray1	self 		parse: '{}'		rule: #array! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testArray2	self 		parse: '{self foo}'		rule: #array! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testArray3	self 		parse: '{self foo. self bar}'		rule: #array! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testArray4	self 		parse: '{self foo. self bar.}'		rule: #array! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testArrayLiteral1	self 		parse: '#()'		rule: #arrayLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testArrayLiteral10	self 		parse: '#((1 2) #(1 2 3))'		rule: #arrayLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testArrayLiteral11	self 		parse: '#([1 2] #[1 2 3])'		rule: #arrayLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testArrayLiteral2	self 		parse: '#(1)'		rule: #arrayLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testArrayLiteral3	self 		parse: '#(1 2)'		rule: #arrayLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testArrayLiteral4	self 		parse: '#(true false nil)'		rule: #arrayLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testArrayLiteral5	self 		parse: '#($a)'		rule: #arrayLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testArrayLiteral6	self 		parse: '#(1.2)'		rule: #arrayLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testArrayLiteral7	self 		parse: '#(size #at: at:put: #''=='')'		rule: #arrayLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testArrayLiteral8	self 		parse: '#(''baz'')'		rule: #arrayLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testArrayLiteral9	self 		parse: '#((1) 2)'		rule: #arrayLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testAssignment1	self 		parse: '1'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testAssignment2	self 		parse: 'a := 1'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testAssignment3	self 		parse: 'a := b := 1'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testAssignment4	self fail: 'a _ 1' rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testAssignment5	self fail: 'a _ b _ 1' rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testAssignment6	self 		parse: 'a := (b := c)'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testBinaryExpression1	self 		parse: '1 + 2'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testBinaryExpression2	self 		parse: '1 + 2 + 3'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testBinaryExpression3	self 		parse: '1 // 2'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testBinaryExpression4	self 		parse: '1 -- 2'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testBinaryExpression5	self 		parse: '1 ==> 2'		rule: #expression.! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testBinaryMethod1	self 		parse: '+ a'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testBinaryMethod2	self 		parse: '+ a | b |'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testBinaryMethod3	self 		parse: '+ a b'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testBinaryMethod4	self 		parse: '+ a | b | c'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testBinaryMethod5	self 		parse: '-- a'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testBlock1	self 		parse: '[]'		rule: #block! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testByteLiteral1	self 		parse: '#[]'		rule: #byteLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testByteLiteral2	self 		parse: '#[0]'		rule: #byteLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testByteLiteral3	self 		parse: '#[255]'		rule: #byteLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testByteLiteral4	self 		parse: '#[ 1 2 ]'		rule: #byteLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testByteLiteral5	self 		parse: '#[ 2r1010 8r77 16rFF ]'		rule: #byteLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testCascadeExpression1	self 		parse: '1 abs; negated'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testCascadeExpression2	self 		parse: '1 abs negated; raisedTo: 12; negated'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testCascadeExpression3	self 		parse: '1 + 2; - 3'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testCharLiteral1	self 		parse: '$a'		rule: #charLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testCharLiteral2	self 		parse: '$ '		rule: #charLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testCharLiteral3	self 		parse: '$$'		rule: #charLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testComment1	self 		parse: '1"one"+2'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testComment2	self 		parse: '1 "one" +2'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testComment3	self 		parse: '1"one"+"two"2'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testComment4	self 		parse: '1"one""two"+2'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testComment5	self 		parse: '1"one"	"two"+2'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:11'!testComplexBlock1	self 		parse: '[ :a | | b | c ]'		rule: #block! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:11'!testComplexBlock2	self 		parse: '[:a||b|c]'		rule: #block! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testKeywordExpression1	self 		parse: '1 to: 2'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testKeywordExpression2	self 		parse: '1 to: 2 by: 3'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testKeywordExpression3	self 		parse: '1 to: 2 by: 3 do: 4'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testKeywordMethod1	self 		parse: 'to: a'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testKeywordMethod2	self 		parse: 'to: a do: b | c |'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testKeywordMethod3	self 		parse: 'to: a do: b by: c d'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testKeywordMethod4	self 		parse: 'to: a do: b by: c | d | e'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testMethod1	self 		parse: 'negated ^ 0 - self'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testMethod2	"Spaces at the beginning of the method."	self 		parse: '	  negated ^ 0 - self'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testMethod3	"Spaces at the end of the method."	self 		parse: '	negated ^ 0 - self  '		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testNumberLiteral1	self 		parse: '0'		rule: #numberLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testNumberLiteral10	self 		parse: '10r10'		rule: #numberLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testNumberLiteral11	self 		parse: '8r777'		rule: #numberLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testNumberLiteral12	self 		parse: '16rAF'		rule: #numberLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testNumberLiteral13	self 		parse: '16rCA.FE'		rule: #numberLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testNumberLiteral14	self 		parse: '3r-22.2'		rule: #numberLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testNumberLiteral15	self 		parse: '0.50s2'		rule: #numberLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testNumberLiteral2	self 		parse: '0.1'		rule: #numberLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testNumberLiteral3	self 		parse: '123'		rule: #numberLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testNumberLiteral4	self 		parse: '123.456'		rule: #numberLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testNumberLiteral5	self 		parse: '-0'		rule: #numberLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testNumberLiteral6	self 		parse: '-0.1'		rule: #numberLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testNumberLiteral7	self 		parse: '-123'		rule: #numberLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testNumberLiteral8	self 		parse: '-123'		rule: #numberLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testNumberLiteral9	self 		parse: '-123.456'		rule: #numberLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma1	self 		parse: 'method <foo>'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma10	self 		parse: 'method <foo: bar>'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma11	self 		parse: 'method <foo: true>'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma12	self 		parse: 'method <foo: false>'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma13	self 		parse: 'method <foo: nil>'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma14	self 		parse: 'method <foo: ()>'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma15	self 		parse: 'method <foo: #()>'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma16	self 		parse: 'method < + 1 >'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma17	self 		parse: 'method <foo: 1 bar: 2>'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma18	self 		parse: 'method <foo: 1 bar: 2  baz: b>'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma2	self 		parse: 'method <foo> <bar>'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma3	self 		parse: 'method | a | <foo>'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma4	self 		parse: 'method <foo> | a |'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma5	self 		parse: 'method <foo> | a | <bar>'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma6	self 		parse: 'method <foo: 1>'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma7	self 		parse: 'method <foo: 1.2>'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma8	self 		parse: 'method <foo: ''bar''>'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:11'!testPragma9	self 		parse: 'method <foo: #''bar''>'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testSequence1	self 		parse: '| a | 1 . 2'		rule: #sequence! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:11'!testSimpleBlock1	self 		parse: '[ ]'		rule: #block! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:11'!testSimpleBlock2	self 		parse: '[ nil ]'		rule: #block! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:11'!testSimpleBlock3	self 		parse: '[ :a ]'		rule: #block! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testSpecialLiteral1	self 		parse: 'true'		rule: #trueLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testSpecialLiteral2	self 		parse: 'false'		rule: #falseLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testSpecialLiteral3	self 		parse: 'nil'		rule: #nilLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:11'!testStatementBlock1	self 		parse: '[ nil ]'		rule: #block! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:11'!testStatementBlock2	self 		parse: '[ | a | nil ]'		rule: #block! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:11'!testStatementBlock3	self 		parse: '[ | a b | nil ]'		rule: #block! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testStatements1	self 		parse: '1'		rule: #sequence! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testStatements2	self 		parse: '1 . 2'		rule: #sequence! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testStatements3	self 		parse: '1 . 2 . 3'		rule: #sequence! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testStatements4	self 		parse: '1 . 2 . 3 .'		rule: #sequence! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testStatements5	self 		parse: '1 . . 2'		rule: #sequence! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testStatements6	self 		parse: '1. 2'		rule: #sequence! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testStatements7	self 		parse: '. 1'		rule: #sequence! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testStatements8	self 		parse: '.1'		rule: #sequence! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testStatements9	self 		parse: ''		rule: #statements! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testStringLiteral1	self 		parse: ''''''		rule: #stringLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testStringLiteral2	self 		parse: '''ab'''		rule: #stringLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testStringLiteral3	self 		parse: '''ab''''cd'''		rule: #stringLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testSymbolLiteral1	self 		parse: '#foo'		rule: #symbolLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testSymbolLiteral2	self 		parse: '#+'		rule: #symbolLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testSymbolLiteral3	self 		parse: '#key:'		rule: #symbolLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testSymbolLiteral4	self 		parse: '#key:value:'		rule: #symbolLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testSymbolLiteral5	self 		parse: '#''testing-result'''		rule: #symbolLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testSymbolLiteral6		self 			parse: '#__gen__binding'			rule: #symbolLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testSymbolLiteral7	self 		parse: '# fucker'		rule: #symbolLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testSymbolLiteral8	self 		parse: '##fucker'		rule: #symbolLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:11'!testSymbolLiteral9	self 		parse: '## fucker'		rule: #symbolLiteral! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testTemporaries1	self 		parse: '| a |'		rule: #sequence! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testTemporaries2	self 		parse: '| a b |'		rule: #sequence! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testTemporaries3	self 		parse: '| a b c |'		rule: #sequence! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testUnaryExpression1	self 		parse: '1 abs'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testUnaryExpression2	self 		parse: '1 abs negated'		rule: #expression! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testUnaryMethod1	self 		parse: 'abs'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testUnaryMethod2	self 		parse: 'abs | a |'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testUnaryMethod3	self 		parse: 'abs a'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testUnaryMethod4	self 		parse: 'abs | a | b'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:11'!testUnaryMethod5	self 		parse: 'abs | a |'		rule: #method! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testVariable1	self 		parse: 'trueBinding'		rule: #primary! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testVariable2	self 		parse: 'falseBinding'		rule: #primary! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testVariable3	self 		parse: 'nilly'		rule: #primary! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testVariable4	self 		parse: 'selfish'		rule: #primary! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testVariable5	self 		parse: 'supernanny'		rule: #primary! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testVariable6		self 			parse: 'super_nanny'			rule: #primary! !!TPP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testVariable7		self 			parse: '__gen_var_123__'			rule: #primary ! !!TPP2SmalltalkParserTests methodsFor: 'private' stamp: 'JanKurs 9/6/2016 14:42'!assert: aNode format: aString	aNode isCollection		ifFalse: [ ^ self assert: (Array with: aNode) format: (Array with: aString) ].	self assert: aNode size equals: aString size.	aNode with: aString do: [ :node :string | self assert: (BIConfigurableFormatter format: node) equals: string ]! !!TPP2SmalltalkParserTests methodsFor: 'accessing' stamp: 'JanKurs 9/6/2016 14:42'!parserClass	^ PP2SmalltalkParser! !!TPP2SmalltalkParserTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:43'!testArgumentsBlock1	super testArgumentsBlock1.	self assert: self result isBlock.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:43'!testArgumentsBlock2	super testArgumentsBlock2.	self assert: self result isBlock.	self assert: self result arguments size equals: 2.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result arguments second isVariable.	self assert: self result arguments second name equals: 'b'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:43'!testArgumentsBlock3	super testArgumentsBlock3.	self assert: self result isBlock.	self assert: self result arguments size equals: 3.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result arguments second isVariable.	self assert: self result arguments second name equals: 'b'.	self assert: self result arguments third isVariable.	self assert: self result arguments third name equals: 'c'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:43'!testArray1	super testArray1.	self assert: self result isArray.	self assert: self result statements isEmpty.	self assert: self result periods isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:43'!testArray2	super testArray2.	self assert: self result isArray.	self assert: self result periods isEmpty.	self assert: self result statements size equals: 1.	self assert: self result statements first isMessage.	self assert: self result statements first selector equals: #foo! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:44'!testArray3	super testArray3.	self assert: self result isArray.	self assert: self result periods size equals: 1.	self assert: self result statements size equals: 2.	self assert: self result statements first isMessage.	self assert: self result statements first selector equals: #foo.	self assert: self result statements last isMessage.	self assert: self result statements last selector equals: #bar! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:44'!testArray4	super testArray4.	self assert: self result isArray.	self assert: self result periods size equals: 2.	self assert: self result statements size equals: 2.	self assert: self result statements first isMessage.	self assert: self result statements first selector equals: #foo.	self assert: self result statements last isMessage.	self assert: self result statements last selector equals: #bar! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:44'!testArrayLiteral1	super testArrayLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: #()! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:44'!testArrayLiteral10	super testArrayLiteral10.	self assert: self result isLiteralNode.	self assert: self result value equals: #(#(1 2) #(1 2 3))! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:44'!testArrayLiteral11	super testArrayLiteral11.	self assert: self result isLiteralNode.	self assert: self result value size equals: 2.	self assert: (self result value first isKindOf: ByteArray).	self assert: self result value first size equals: 2.	self assert: (self result value last isKindOf: ByteArray).	self assert: self result value last size equals: 3! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:44'!testArrayLiteral2	super testArrayLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: #(1)! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:44'!testArrayLiteral3	super testArrayLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: #(1 2)! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:44'!testArrayLiteral4	super testArrayLiteral4.	self assert: self result isLiteralNode.	self assert: self result value equals: #(true false nil)! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:44'!testArrayLiteral5	super testArrayLiteral5.	self assert: self result isLiteralNode.	self assert: self result value equals: #($a)! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:44'!testArrayLiteral6	super testArrayLiteral6.	self assert: self result isLiteralNode.	self assert: self result value equals: #(1.2)! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:44'!testArrayLiteral7	super testArrayLiteral7.	self assert: self result isLiteralNode.	self assert: self result value equals: #(#size #at: #at:put: #==).	self result value do: [ :each | self assert: each isSymbol ]! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:44'!testArrayLiteral8	super testArrayLiteral8.	self assert: self result isLiteralNode.	self assert: self result value equals: #('baz').	self assert: self result value first isString.	self assert: self result value first isSymbol not! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:44'!testArrayLiteral9	super testArrayLiteral9.	self assert: self result isLiteralNode.	self assert: self result value equals: #(#(1) 2)! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:44'!testAssignment1	super testAssignment1.	self assert: self result isLiteralNode.	self assert: self result value equals: 1! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:44'!testAssignment2	super testAssignment2.	self assert: self result isAssignment.	self assert: self result variable isVariable.	self assert: self result variable name equals: 'a'.	self assert: self result value isLiteralNode.	self assert: self result value value equals: 1! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:44'!testAssignment3	super testAssignment3.	self assert: self result isAssignment.	self assert: self result variable isVariable.	self assert: self result variable name equals: 'a'.	self assert: self result value isAssignment.	self assert: self result value variable isVariable.	self assert: self result value variable name equals: 'b'.	self assert: self result value value isLiteralNode.	self assert: self result value value value equals: 1! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:42'!testAssignment4	super testAssignment4.! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:42'!testAssignment5	super testAssignment5.! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:44'!testAssignment6	super testAssignment6.	self assert: self result isAssignment.	self assert: self result variable isVariable.	self assert: self result variable name equals: 'a'.	self assert: self result value isAssignment.	self assert: self result value variable isVariable.	self assert: self result value variable name equals: 'b'.	self assert: self result value value isVariable.	self assert: self result value value name equals: 'c'! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:44'!testBinaryExpression1	super testBinaryExpression1.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:45'!testBinaryExpression2	super testBinaryExpression2.	self assert: self result isMessage.	self assert: self result receiver isMessage.	self assert: self result receiver receiver isLiteralNode.	self assert: self result receiver receiver value equals: 1.	self assert: self result receiver arguments size equals: 1.	self assert: self result receiver arguments first isLiteralNode.	self assert: self result receiver arguments first value equals: 2.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 3! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:45'!testBinaryExpression3	super testBinaryExpression3.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result selector equals: #//.	self assert: self result keywordsPositions equals: #(3) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:45'!testBinaryExpression4	super testBinaryExpression4.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result selector equals: #--.	self assert: self result keywordsPositions equals: #(3) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:45'!testBinaryExpression5	super testBinaryExpression5.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result selector equals: #==>.	self assert: self result keywordsPositions equals: #(3) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:45'!testBinaryMethod1	super testBinaryMethod1.	self assert: self result isMethod.	self assert: self result selector equals: #+.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:45'!testBinaryMethod2	super testBinaryMethod2.	self assert: self result isMethod.	self assert: self result selector equals: #+.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:45'!testBinaryMethod3	super testBinaryMethod3.	self assert: self result isMethod.	self assert: self result selector equals: #+.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.		self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:45'!testBinaryMethod4	super testBinaryMethod4.	self assert: self result isMethod.	self assert: self result selector equals: #+.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.		self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:45'!testBinaryMethod5	super testBinaryMethod5.	self assert: self result isMethod.	self assert: self result selector equals: #--.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.		self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:45'!testBlock1	super testBlock1.	self assert: self result isBlock.	self assert: self result arguments size equals: 0.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:45'!testByteLiteral1	super testByteLiteral1.	self assert: self result isLiteralNode.	self assert: (self result value isKindOf: ByteArray).	self assert: self result value isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:45'!testByteLiteral2	super testByteLiteral2.	self assert: self result isLiteralNode.	self assert: (self result value isKindOf: ByteArray).	self assert: self result value size equals: 1.	self assert: self result value first equals: 0! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:46'!testByteLiteral3	super testByteLiteral3.	self assert: self result isLiteralNode.	self assert: (self result value isKindOf: ByteArray).	self assert: self result value size equals: 1.	self assert: self result value first equals: 255! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:46'!testByteLiteral4	super testByteLiteral4.	self assert: self result isLiteralNode.	self assert: (self result value isKindOf: ByteArray).	self assert: self result value size equals: 2.	self assert: self result value first equals: 1.	self assert: self result value last equals: 2! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:46'!testByteLiteral5	super testByteLiteral5.	self assert: self result isLiteralNode.	self assert: (self result value isKindOf: ByteArray).	self assert: self result value size equals: 3.	self assert: self result value first equals: 10.	self assert: self result value second equals: 63.	self assert: self result value last equals: 255! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:46'!testCascadeExpression1	super testCascadeExpression1.	self assert: self result isCascade.	self assert: self result receiver isLiteralNode.	self assert: self result messages size equals: 2.	self assert: self result messages first receiver equals: self result receiver.	self assert: self result messages first selector equals: #abs.	self assert: self result messages first keywordsPositions equals: #(3) asIntegerArray.	self assert: self result messages second receiver equals: self result receiver.	self assert: self result messages second selector equals: #negated.	self assert: self result messages second keywordsPositions equals: #(8) asIntegerArray! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:46'!testCascadeExpression2	super testCascadeExpression2.	self assert: self result isCascade.	self assert: self result receiver isMessage.	self assert: self result receiver receiver isLiteralNode.	self assert: self result receiver receiver value equals: 1.	self assert: self result receiver selector equals: #abs.	self assert: self result receiver keywordsPositions equals: #(3) asIntegerArray.	self assert: self result messages size equals: 3.	self assert: self result messages first receiver equals: self result receiver.	self assert: self result messages first selector equals: #negated.	self assert: self result messages first keywordsPositions equals: #(7) asIntegerArray.	self assert: self result messages second receiver equals: self result receiver.	self assert: self result messages second selector equals: #raisedTo:.	self assert: self result messages second keywordsPositions equals: #(16) asIntegerArray.	self assert: self result messages third receiver equals: self result receiver.	self assert: self result messages third selector equals: #negated.	self assert: self result messages third keywordsPositions equals: #(30) asIntegerArray! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:46'!testCascadeExpression3	super testCascadeExpression3.	self assert: self result isCascade.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result messages size equals: 2.	self assert: self result messages first receiver equals: self result receiver.	self assert: self result messages first selector equals: #+.	self assert: self result messages first keywordsPositions equals: #(3) asIntegerArray.					self assert: self result messages first arguments size equals: 1.	self assert: self result messages second receiver equals: self result receiver.	self assert: self result messages second selector equals: #-.	self assert: self result messages second keywordsPositions equals: #(8) asIntegerArray.					self assert: self result messages second arguments size equals: 1! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:46'!testCharLiteral1	super testCharLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: $a! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:46'!testCharLiteral2	super testCharLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: Character space! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:46'!testCharLiteral3	super testCharLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: $$! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:46'!testComment1	super testComment1.	self assert: self result isMessage.	self assert: self result receiver isValue.	self assert: self result selector equals: #+.	self assert: self result arguments first isValue! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:46'!testComment2	super testComment2.	self assert: self result isMessage.	self assert: self result receiver isValue.	self assert: self result selector equals: #+.	self assert: self result arguments first isValue! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:46'!testComment3	super testComment3.	self assert: self result isMessage.	self assert: self result receiver isValue.	self assert: self result selector equals: #+.	self assert: self result arguments first isValue! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:46'!testComment4	super testComment4.	self assert: self result isMessage.	self assert: self result receiver isValue.	self assert: self result selector equals: #+.	self assert: self result arguments first isValue! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:46'!testComment5	super testComment5.	self assert: self result isMessage.	self assert: self result receiver isValue.	self assert: self result selector equals: #+.	self assert: self result arguments first isValue! !!TPP2SmalltalkParserTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:46'!testComplexBlock1	super testComplexBlock1.	self assert: self result isBlock.	self assert: self result arguments size equals: 1.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!TPP2SmalltalkParserTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:46'!testComplexBlock2	super testComplexBlock2.	self assert: self result isBlock.	self assert: self result arguments size equals: 1.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:46'!testKeywordExpression1	super testKeywordExpression1.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result selector equals: #to:.	self assert: self result keywordsPositions equals: #(3) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:46'!testKeywordExpression2	super testKeywordExpression2.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result selector equals: #to:by:.	self assert: self result keywordsPositions equals: #(3 9) asIntegerArray.	self assert: self result arguments size equals: 2.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2.	self assert: self result arguments second isLiteralNode.	self assert: self result arguments second value equals: 3! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:47'!testKeywordExpression3	super testKeywordExpression3.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result selector equals: #to:by:do:.	self assert: self result keywordsPositions equals: #(3 9 15) asIntegerArray.	self assert: self result arguments size equals: 3.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2.	self assert: self result arguments second isLiteralNode.	self assert: self result arguments second value equals: 3.	self assert: self result arguments third isLiteralNode.	self assert: self result arguments third value equals: 4! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:47'!testKeywordMethod1	super testKeywordMethod1.	self assert: self result isMethod.	self assert: self result selector equals: #to:.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.			self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:47'!testKeywordMethod2	super testKeywordMethod2.	self assert: self result isMethod.	self assert: self result selector equals: #to:do:.	self assert: self result keywordsPositions equals: #(1 7) asIntegerArray.			self assert: self result arguments size equals: 2.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result arguments second isVariable.	self assert: self result arguments second name equals: 'b'.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:47'!testKeywordMethod3	super testKeywordMethod3.	self assert: self result isMethod.	self assert: self result selector equals: #to:do:by:.	self assert: self result keywordsPositions equals: #(1 7 13) asIntegerArray.				self assert: self result arguments size equals: 3.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result arguments second isVariable.	self assert: self result arguments second name equals: 'b'.	self assert: self result arguments third isVariable.	self assert: self result arguments third name equals: 'c'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:47'!testKeywordMethod4	super testKeywordMethod4.	self assert: self result isMethod.	self assert: self result selector equals: #to:do:by:.	self assert: self result keywordsPositions equals: #(1 7 13) asIntegerArray.				self assert: self result arguments size equals: 3.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result arguments second isVariable.	self assert: self result arguments second name equals: 'b'.	self assert: self result arguments third isVariable.	self assert: self result arguments third name equals: 'c'.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:47'!testMethod1	super testMethod1.	self assert: self result isMethod.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1.	self assert: self result body statements first isReturn.	self assert: self result body statements first value isMessage.	self assert: self result body statements first value receiver isLiteralNode.	self assert: self result body statements first value selector equals: #-.	self assert: self result body statements first value arguments size equals: 1.	self assert: self result body statements first value arguments first isVariable! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:47'!testMethod2	super testMethod2.	self assert: self result isMethod.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1.	self assert: self result body statements first isReturn.	self assert: self result body statements first value isMessage.	self assert: self result body statements first value receiver isLiteralNode.	self assert: self result body statements first value selector equals: #-.	self assert: self result body statements first value arguments size equals: 1.	self assert: self result body statements first value arguments first isVariable! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:47'!testMethod3	super testMethod3.	self assert: self result isMethod.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1.	self assert: self result body statements first isReturn.	self assert: self result body statements first value isMessage.	self assert: self result body statements first value receiver isLiteralNode.	self assert: self result body statements first value selector equals: #-.	self assert: self result body statements first value arguments size equals: 1.	self assert: self result body statements first value arguments first isVariable! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:47'!testNumberLiteral1	super testNumberLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: 0.	self assert: self result value isInteger! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:47'!testNumberLiteral10	super testNumberLiteral10.	self assert: self result isLiteralNode.	self assert: self result value equals: 10.	self assert: self result value isInteger! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:47'!testNumberLiteral11	super testNumberLiteral11.	self assert: self result isLiteralNode.	self assert: self result value equals: 511.	self assert: self result value isInteger! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:47'!testNumberLiteral12	super testNumberLiteral12.	self assert: self result isLiteralNode.	self assert: self result value equals: 175.	self assert: self result value isInteger! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:47'!testNumberLiteral13	super testNumberLiteral13.	self assert: self result isLiteralNode.	self assert: self result value equals: 202.9921875.	self assert: self result value isFloat! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:47'!testNumberLiteral14	super testNumberLiteral14.	self assert: self result isLiteralNode.	self assert: self result value floor equals: -9.	self assert: self result value isFloat! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:47'!testNumberLiteral15	super testNumberLiteral15.	self assert: self result isLiteralNode.	self assert: self result value equals: 1 / 2! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:47'!testNumberLiteral2	super testNumberLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: 0.1.	self assert: self result value isFloat! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:47'!testNumberLiteral3	super testNumberLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: 123.	self assert: self result value isInteger! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:47'!testNumberLiteral4	super testNumberLiteral4.	self assert: self result isLiteralNode.	self assert: self result value equals: 123.456.	self assert: self result value isFloat! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:47'!testNumberLiteral5	super testNumberLiteral5.	self assert: self result isLiteralNode.	self assert: self result value equals: 0.	self assert: self result value isInteger! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:47'!testNumberLiteral6	super testNumberLiteral6.	self assert: self result isLiteralNode.	self assert: self result value equals: -0.1.	self assert: self result value isFloat! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:48'!testNumberLiteral7	super testNumberLiteral7.	self assert: self result isLiteralNode.	self assert: self result value equals: -123.	self assert: self result value isInteger! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:48'!testNumberLiteral8	super testNumberLiteral8.	self assert: self result isLiteralNode.	self assert: self result value equals: -123.	self assert: self result value isInteger! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:48'!testNumberLiteral9	super testNumberLiteral9.	self assert: self result isLiteralNode.	self assert: self result value equals: -123.456.	self assert: self result value isFloat! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma1	super testPragma1.	self 		assert: self result pragmas		format: #('<foo>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma10	super testPragma10.	self 		assert: self result pragmas		format: #('<foo: #bar>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma11	super testPragma11.	self 		assert: self result pragmas		format: #('<foo: true>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma12	super testPragma12.	self 		assert: self result pragmas		format: #('<foo: false>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma13	super testPragma13.	self 		assert: self result pragmas		format: #('<foo: nil>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma14	super testPragma14.	self 		assert: self result pragmas		format: #('<foo: #()>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma15	super testPragma15.	self 		assert: self result pragmas		format: #('<foo: #()>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma16	super testPragma16.	self 		assert: self result pragmas		format: #('< + 1>' ).	self assert: self result pragmas first keywordsPositions equals: #(10) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma17	super testPragma17.	self 		assert: self result pragmas		format: #('<foo: 1 bar: 2>' ).	self assert: self result pragmas first keywordsPositions equals: #(9 16) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma18	super testPragma18.	self 		assert: self result pragmas		format: #('<foo: 1 bar: 2 baz: #b>' ).	self assert: self result pragmas first keywordsPositions equals: #(9 16 24) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma2	super testPragma2.	self 		assert: self result pragmas		format: #('<foo>' '<bar>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.	self assert: self result pragmas second keywordsPositions equals: #(15) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma3	super testPragma3.	self assert: self result pragmas format: #('<foo>').	self assert: self result pragmas first keywordsPositions equals: #(15) asIntegerArray.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma4	super testPragma4.	self assert: self result pragmas format: #('<foo>').	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.		self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma5	super testPragma5.	self assert: self result pragmas format: #('<foo>' '<bar>').	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.	self assert: self result pragmas second keywordsPositions equals: #(21) asIntegerArray.		self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma6	super testPragma6.	self 		assert: self result pragmas		format: #('<foo: 1>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma7	super testPragma7.	self 		assert: self result pragmas		format: #('<foo: 1.2>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma8	super testPragma8.	self 		assert: self result pragmas		format: #('<foo: ''bar''>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-pragmas' stamp: 'JanKurs 9/6/2016 14:48'!testPragma9	super testPragma9.	self 		assert: self result pragmas		format: #('<foo: #bar>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:48'!testSequence1	super testSequence1.	self assert: self result isSequence.	self assert: self result temporaries size equals: 1.	self assert: self result temporaries first isVariable.	self assert: self result temporaries first name equals: 'a'.	self assert: self result statements size equals: 2.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2! !!TPP2SmalltalkParserTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:49'!testSimpleBlock1	super testSimpleBlock1.	self assert: self result isBlock.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:49'!testSimpleBlock2	super testSimpleBlock2.	self assert: self result isBlock.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1! !!TPP2SmalltalkParserTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:49'!testSimpleBlock3	super testSimpleBlock3.	self assert: self result isBlock.	self assert: self result arguments size equals: 1.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:49'!testSpecialLiteral1	super testSpecialLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: true! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:49'!testSpecialLiteral2	super testSpecialLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: false! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:49'!testSpecialLiteral3	super testSpecialLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: nil! !!TPP2SmalltalkParserTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:49'!testStatementBlock1	super testStatementBlock1.	self assert: self result isBlock.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1! !!TPP2SmalltalkParserTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:49'!testStatementBlock2	super testStatementBlock2.	self assert: self result isBlock.	self assert: self result arguments isEmpty.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!TPP2SmalltalkParserTests methodsFor: 'testing-blocks' stamp: 'JanKurs 9/6/2016 14:49'!testStatementBlock3	super testStatementBlock3.	self assert: self result isBlock.	self assert: self result arguments isEmpty.	self assert: self result body temporaries size equals: 2.	self assert: self result body statements size equals: 1! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:49'!testStatements1	super testStatements1.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 1.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:49'!testStatements2	super testStatements2.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 2.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2.	self assert: self result statements second value isInteger! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:49'!testStatements3	super testStatements3.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 3.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2.	self assert: self result statements second value isInteger.	self assert: self result statements third isLiteralNode.	self assert: self result statements third value equals: 3.	self assert: self result statements third value isInteger! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:49'!testStatements4	super testStatements4.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 3.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2.	self assert: self result statements second value isInteger.	self assert: self result statements third isLiteralNode.	self assert: self result statements third value equals: 3.	self assert: self result statements third value isInteger! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:49'!testStatements5	super testStatements5.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 2.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2.	self assert: self result statements second value isInteger! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:49'!testStatements6	super testStatements6.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 2.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2.	self assert: self result statements second value isInteger! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:49'!testStatements7	super testStatements7.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 1.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:49'!testStatements8	super testStatements8.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 1.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:49'!testStatements9	super testStatements9.	self assert: self result isEmpty.! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:49'!testStringLiteral1	super testStringLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: ''! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:49'!testStringLiteral2	super testStringLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: 'ab'! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:49'!testStringLiteral3	super testStringLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: 'ab''cd'! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:49'!testSymbolLiteral1	super testSymbolLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: #foo.	self assert: self result value isSymbol! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:49'!testSymbolLiteral2	super testSymbolLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: #+.	self assert: self result value isSymbol! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:49'!testSymbolLiteral3	super testSymbolLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: #key:.	self assert: self result value isSymbol! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:49'!testSymbolLiteral4	super testSymbolLiteral4.	self assert: self result isLiteralNode.	self assert: self result value equals: #key:value:.	self assert: self result value isSymbol! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:51'!testSymbolLiteral5	super testSymbolLiteral5.	self assert: self result isLiteralNode.	self assert: self result value equals: #'testing-result'.	self assert: self result value isSymbol! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:50'!testSymbolLiteral6	super testSymbolLiteral6.	self assert: self result isLiteralNode.	self assert: self result value equals: #'__gen__binding'.	self assert: self result value isSymbol! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:50'!testSymbolLiteral7	super testSymbolLiteral7.	self assert: self result isLiteralNode.	self assert: self result value equals: #fucker.	self assert: self result value isSymbol! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:50'!testSymbolLiteral8	super testSymbolLiteral8.	self assert: self result isLiteralNode.	self assert: self result value equals: #fucker.	self assert: self result value isSymbol! !!TPP2SmalltalkParserTests methodsFor: 'testing-literals' stamp: 'JanKurs 9/6/2016 14:50'!testSymbolLiteral9	super testSymbolLiteral9.	self assert: self result isLiteralNode.	self assert: self result value equals: #fucker.	self assert: self result value isSymbol! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:50'!testTemporaries1	super testTemporaries1.	self assert: self result isSequence.	self assert: self result temporaries size equals: 1.	self assert: self result temporaries first isVariable.	self assert: self result temporaries first name equals: 'a'.	self assert: self result statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:50'!testTemporaries2	super testTemporaries2.	self assert: self result isSequence.	self assert: self result temporaries size equals: 2.	self assert: self result temporaries first isVariable.	self assert: self result temporaries first name equals: 'a'.	self assert: self result temporaries second isVariable.	self assert: self result temporaries second name equals: 'b'.	self assert: self result statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:50'!testTemporaries3	super testTemporaries3.	self assert: self result isSequence.	self assert: self result temporaries size equals: 3.	self assert: self result temporaries first isVariable.	self assert: self result temporaries first name equals: 'a'.	self assert: self result temporaries second isVariable.	self assert: self result temporaries second name equals: 'b'.	self assert: self result temporaries third isVariable.	self assert: self result temporaries third name equals: 'c'.	self assert: self result statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:50'!testUnaryExpression1	super testUnaryExpression1.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(3) asIntegerArray.			self assert: self result arguments isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:50'!testUnaryExpression2	super testUnaryExpression2.	self assert: self result isMessage.	self assert: self result receiver isMessage.	self assert: self result receiver receiver isLiteralNode.	self assert: self result receiver receiver value equals: 1.	self assert: self result receiver selector equals: #abs.	self assert: self result receiver keywordsPositions equals: #(3) asIntegerArray.			self assert: self result receiver arguments isEmpty.	self assert: self result selector equals: #negated.	self assert: self result keywordsPositions equals: #(7) asIntegerArray.			self assert: self result arguments isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:50'!testUnaryMethod1	super testUnaryMethod1.	self assert: self result isMethod.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.			self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:50'!testUnaryMethod2	super testUnaryMethod2.	self assert: self result isMethod.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.				self assert: self result arguments isEmpty.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:50'!testUnaryMethod3	super testUnaryMethod3.	self assert: self result isMethod.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.				self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:50'!testUnaryMethod4	super testUnaryMethod4.	self assert: self result isMethod.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.				self assert: self result arguments isEmpty.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!TPP2SmalltalkParserTests methodsFor: 'testing-messages' stamp: 'JanKurs 9/6/2016 14:50'!testUnaryMethod5	super testUnaryMethod5.	self assert: self result isMethod.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.			self assert: self result arguments isEmpty.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:50'!testVariable1	super testVariable1.	self assert: self result isVariable.	self assert: self result name equals: 'trueBinding'! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:50'!testVariable2	super testVariable2.	self assert: self result isVariable.	self assert: self result name equals: 'falseBinding'! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:50'!testVariable3	super testVariable3.	self assert: self result isVariable.	self assert: self result name equals: 'nilly'! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:50'!testVariable4	super testVariable4.	self assert: self result isVariable.	self assert: self result name equals: 'selfish'! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:50'!testVariable5	super testVariable5.	self assert: self result isVariable.	self assert: self result name equals: 'supernanny'! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:50'!testVariable6	super testVariable6.	self assert: self result isVariable.	self assert: self result name equals: 'super_nanny'! !!TPP2SmalltalkParserTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:50'!testVariable7	super testVariable7.	self assert: self result isVariable.	self assert: self result name equals: '__gen_var_123__'! !!RBArrayNode methodsFor: '*PetitParser2-Smalltalk-Tests' stamp: 'JanKurs 9/1/2016 15:04' prior: 53709219!isArray	^ true! !!PP2FirstSetVisitorTest methodsFor: '*PetitParser2-Smalltalk-Tests' stamp: 'JanKurs 10/6/2016 17:00'!testVisitSmalltalkWhitespace	parser := PP2SmalltalkWhitespaceNode new.		firstSet := self firstSet: parser.	self assert: firstSet size equals: 2.	self assert: (firstSet anySatisfy: [:e | (e parseContext: String space) isPetit2Success ]).	self assert: (firstSet anySatisfy: [:e | (e parseContext: String tab) isPetit2Success ]).	self assert: (firstSet anySatisfy: [:e | (e parseContext: String crlf) isPetit2Success ]).		self assert: (firstSet anySatisfy: [:e | (e parseContext: $" asString) isPetit2Success ]).! !!PP2VerificationTests methodsFor: '*PetitParser2-Smalltalk-Tests-Verification' stamp: 'JanKurs 9/16/2016 10:54'!testPP2SmalltalkParserOptimizations	| validator |	validator := PP2SmalltalkParserOptimizationsValidator new.	validator validateBlocking.		self assert: validator report precision equals: 1.	self assert: validator report recall equals: 1.! !!ManifestPetitParserSmalltalkTests class methodsFor: 'code-critics' stamp: 'JanKurs 9/6/2016 15:00'!ruleRBMethodHasNoTimeStampRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#PP2SmalltalkParserTests_Optimized)) #'2016-09-06T15:00:54.597054+02:00') )! !!PP2SmalltalkGrammarOptimizationsTest methodsFor: 'support' stamp: 'JanKurs 8/31/2016 13:25'!assert: collection allSatisfy: aBlock	self assert: (collection allSatisfy: aBlock)! !!PP2SmalltalkGrammarOptimizationsTest methodsFor: 'support' stamp: 'JanKurs 9/2/2016 22:39'!assert: collection anySatisfy: aBlock	self assert: (collection anySatisfy: aBlock)! !!PP2SmalltalkGrammarOptimizationsTest methodsFor: 'support' stamp: 'JanKurs 8/31/2016 13:38'!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!PP2SmalltalkGrammarOptimizationsTest methodsFor: 'tests' stamp: 'JanKurs 10/5/2016 11:33'!testCaches	| cached |	parser := PP2SmalltalkGrammar new optimize.	cached := parser allNodes select: [ :child |		child strategies anySatisfy: [ :s | s isKindOf:PP2Cache ]	].	self assert: cached size equals: 3.	self assert: cached anySatisfy: [:n | n name = #identifierToken].	self assert: cached anySatisfy: [:n | n name = #variable].			self flag: 'JK: I would like to remove this case'.	self assert: cached anySatisfy: [:n | n name = #identifier].! !!PP2SmalltalkGrammarOptimizationsTest methodsFor: 'tests' stamp: 'JanKurs 9/3/2016 17:29'!testFirstProductionSet	parser := PP2SmalltalkGrammar new optimize.	parser allNodesDo: [ :child |		self assert: (child firstProductionSet allSatisfy: [ :e | e isProduction  ])	]! !!PP2SmalltalkGrammarOptimizationsTest methodsFor: 'tests' stamp: 'JanKurs 10/5/2016 11:33'!testIdentifierToken	| sequence |	parser := PP2SmalltalkGrammar new identifierToken optimize.		sequence := parser child child child.	self assert: (sequence strategies anySatisfy: [ :s | s isKindOf: PP2SequenceOfTwoRecognizer ]).	self assert: sequence firstChild strategy isKindOf: PP2PredicateObjectRecognizer.	self assert: sequence secondChild strategy isKindOf: PP2StarPredicateObjectRecognizer.! !!PP2SmalltalkGrammarOptimizationsTest methodsFor: 'tests' stamp: 'JanKurs 9/3/2016 17:31'!testKeywordMessageCache	| message identifiers strategy |	parser := PP2SmalltalkGrammar new optimize.	message := parser allNodes detect: [ :node | node name = 'message' ].		identifiers := message firstProductionSet select: [ :node | node name = 'identifier' ].	strategy := identifiers anyOne strategy.		identifiers do: [ :identifier |		self assert: identifier strategies anySatisfy: [ :s | s isKindOf: PP2Cache].	].	self assert: identifiers allSatisfy: [ :id | id strategy == strategy ]! !!PP2SmalltalkGrammarOptimizationsTest methodsFor: 'tests' stamp: 'JanKurs 9/3/2016 17:32'!testLiteral	| literal |	parser := PP2SmalltalkGrammar new optimize.	literal := parser allNodes detect: [ :node | node name = 'literal' ].		literal child children do: [ :c |		self assert: c strategy isKindOf: PP2ParsingGuard 	]! !!PP2SmalltalkGrammarOptimizationsTest methodsFor: 'tests' stamp: 'JanKurs 9/3/2016 17:32'!testNumberToken	| sequences |	parser := PP2SmalltalkGrammar new numberToken optimize.		sequences := parser allNodes select: [ :e | (e isKindOf: PP2SequenceNode) and: [ e children size = 2 ]  ].	self assert: sequences allSatisfy: [ :e | e strategies anySatisfy: [:s | s isKindOf: PP2SequenceOfTwoRecognizer ] ].! !!PP2SmalltalkGrammarOptimizationsTest methodsFor: 'tests' stamp: 'JanKurs 9/5/2016 17:06'!testPeriodToken	| periodToken |	parser := PP2SmalltalkGrammar new optimize.	periodToken := parser productionAt: #periodToken.		self assert: periodToken child strategy isKindOf: PP2TrimmingLiteralObjectToken.! !!PP2SmalltalkGrammarOptimizationsTest methodsFor: 'tests' stamp: 'JanKurs 10/5/2016 11:33'!testPeriodTokenCache	| identifierToken |	parser := PP2SmalltalkParser new optimize.	identifierToken := parser productionAt: #periodToken.	self assert: (identifierToken strategies noneSatisfy: [ :s | s isKindOf: PP2Cache ])! !!PP2SmalltalkGrammarOptimizationsTest methodsFor: 'tests' stamp: 'JanKurs 9/3/2016 17:32'!testTrimmings	| trimmings |	parser := PP2SmalltalkGrammar new optimize.	trimmings := parser allNodes select: [ :node | node isTrimming ].		trimmings do: [ :c |		self assert: c trimmer strategy isKindOf: PP2TrimmingCache 	]! !!PP2SmalltalkGrammarOptimizationsTest methodsFor: 'tests' stamp: 'JanKurs 9/6/2016 15:33'!testVariable	| variable |	parser := PP2SmalltalkGrammar new optimize.		variable := parser allNodes detect: [:e | e name = 'variable' ].	self assert: (variable strategies anySatisfy: [ :s | s isKindOf: PP2Cache ])! !!PP2SmalltalkParserOptimizationsTest methodsFor: 'as yet unclassified' stamp: 'JanKurs 10/5/2016 11:33'!testIdentifierTokenCache	| identifierToken |	parser := PP2SmalltalkParser new optimize.	identifierToken := parser productionAt: #identifierToken.	self assert: (identifierToken strategies noneSatisfy: [ :s | s isKindOf: PP2Cache ])! !!PP2IsNullableVisitorTest methodsFor: '*PetitParser2-Smalltalk-Tests' stamp: 'JanKurs 9/15/2016 13:32'!testSmalltalkWhitespace	self assertIsNullable: PP2SmalltalkWhitespaceNode new ! !!PP2SmalltalkGrammarTests class methodsFor: 'accessing' stamp: 'JanKurs 8/31/2016 13:51'!shouldInheritSelectors	^ true! !!PP2SmalltalkGrammarTests methodsFor: 'parsing' stamp: 'JanKurs 8/31/2016 13:07'!parse: aStream withParser: aParser withContext: aContext	^ aParser parse: aStream withContext: aContext! !!PP2SmalltalkGrammarTests methodsFor: 'testing' stamp: 'JanKurs 9/6/2016 14:11'!testCompleteness	"This test asserts that all subclasses override all test methods."		| subclasses |	subclasses := self class allSubclasses.		subclasses := (subclasses reject: [:subclass | subclass name endsWith: '_Optimized' ]).	subclasses := (subclasses reject: [:subclass | subclass name endsWith: '_Direct' ]).	subclasses := (subclasses reject: [:subclass | subclass name endsWith: '_InMemoryCtx' ]).	subclasses do: [ :subclass |		self class testSelectors do: [ :selector |			self 				assert: (selector = #testCompleteness or: [ subclass selectors includes: selector ])				description: subclass printString , ' does not test ' , selector printString ] ]! !!PP2SmalltalkParserTests methodsFor: 'accessing' stamp: 'JanKurs 9/6/2016 14:43'!result	^ result! !!PP2SmalltalkGrammarTests_InMemoryCtx methodsFor: 'context' stamp: 'JanKurs 8/29/2016 00:21'!context	^ PP2InMemoryContext new! !!PP2SmalltalkGrammarTests_Optimized methodsFor: 'context' stamp: 'JanKurs 8/31/2016 13:08'!context	^ PP2InMemoryContext new! !!PP2SmalltalkGrammarTests_Optimized methodsFor: 'parsing' stamp: 'JanKurs 9/17/2016 22:08'!parserInstance	^ super parserInstance optimize;		resetCaches;		yourself! !!PP2SmalltalkGrammarTests_Optimized methodsFor: 'parsing' stamp: 'JanKurs 9/3/2016 13:32'!testOptimized	self assert: self parserInstance isOptimized! !!PP2SmalltalkParserTests_Optimized methodsFor: 'context' stamp: 'JanKurs 9/5/2016 08:24'!context	^ PP2InMemoryContext new! !!PP2SmalltalkParserTests_Optimized methodsFor: 'accessing' stamp: 'JanKurs 9/6/2016 14:51'!result	^ result! !!PP2SmalltalkParserTests_Optimized methodsFor: 'parsing' stamp: 'JanKurs 9/5/2016 08:25'!testOptimized	self assert: self parserInstance isOptimized! !!Trait method!parserClass	^ PP2SmalltalkGrammar! !!Trait method!parserClass	^ PP2SmalltalkGrammar! !!Trait method!parserClass	^ PP2SmalltalkGrammar! !!Trait method!testArgumentsBlock1	self 		parse: '[ :a | ]'		rule: #block! !!Trait method!testArgumentsBlock1	self 		parse: '[ :a | ]'		rule: #block! !!Trait method!testArgumentsBlock1	self 		parse: '[ :a | ]'		rule: #block! !!Trait method!testArgumentsBlock2	self 		parse: '[ :a :b | ]'		rule: #block! !!Trait method!testArgumentsBlock2	self 		parse: '[ :a :b | ]'		rule: #block! !!Trait method!testArgumentsBlock2	self 		parse: '[ :a :b | ]'		rule: #block! !!Trait method!testArgumentsBlock3	self 		parse: '[ :a :b :c | ]'		rule: #block! !!Trait method!testArgumentsBlock3	self 		parse: '[ :a :b :c | ]'		rule: #block! !!Trait method!testArgumentsBlock3	self 		parse: '[ :a :b :c | ]'		rule: #block! !!Trait method!testArray1	self 		parse: '{}'		rule: #array! !!Trait method!testArray1	self 		parse: '{}'		rule: #array! !!Trait method!testArray1	self 		parse: '{}'		rule: #array! !!Trait method!testArray2	self 		parse: '{self foo}'		rule: #array! !!Trait method!testArray2	self 		parse: '{self foo}'		rule: #array! !!Trait method!testArray2	self 		parse: '{self foo}'		rule: #array! !!Trait method!testArray3	self 		parse: '{self foo. self bar}'		rule: #array! !!Trait method!testArray3	self 		parse: '{self foo. self bar}'		rule: #array! !!Trait method!testArray3	self 		parse: '{self foo. self bar}'		rule: #array! !!Trait method!testArray4	self 		parse: '{self foo. self bar.}'		rule: #array! !!Trait method!testArray4	self 		parse: '{self foo. self bar.}'		rule: #array! !!Trait method!testArray4	self 		parse: '{self foo. self bar.}'		rule: #array! !!Trait method!testArrayLiteral1	self 		parse: '#()'		rule: #arrayLiteral! !!Trait method!testArrayLiteral1	self 		parse: '#()'		rule: #arrayLiteral! !!Trait method!testArrayLiteral1	self 		parse: '#()'		rule: #arrayLiteral! !!Trait method!testArrayLiteral10	self 		parse: '#((1 2) #(1 2 3))'		rule: #arrayLiteral! !!Trait method!testArrayLiteral10	self 		parse: '#((1 2) #(1 2 3))'		rule: #arrayLiteral! !!Trait method!testArrayLiteral10	self 		parse: '#((1 2) #(1 2 3))'		rule: #arrayLiteral! !!Trait method!testArrayLiteral11	self 		parse: '#([1 2] #[1 2 3])'		rule: #arrayLiteral! !!Trait method!testArrayLiteral11	self 		parse: '#([1 2] #[1 2 3])'		rule: #arrayLiteral! !!Trait method!testArrayLiteral11	self 		parse: '#([1 2] #[1 2 3])'		rule: #arrayLiteral! !!Trait method!testArrayLiteral2	self 		parse: '#(1)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral2	self 		parse: '#(1)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral2	self 		parse: '#(1)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral3	self 		parse: '#(1 2)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral3	self 		parse: '#(1 2)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral3	self 		parse: '#(1 2)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral4	self 		parse: '#(true false nil)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral4	self 		parse: '#(true false nil)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral4	self 		parse: '#(true false nil)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral5	self 		parse: '#($a)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral5	self 		parse: '#($a)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral5	self 		parse: '#($a)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral6	self 		parse: '#(1.2)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral6	self 		parse: '#(1.2)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral6	self 		parse: '#(1.2)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral7	self 		parse: '#(size #at: at:put: #''=='')'		rule: #arrayLiteral! !!Trait method!testArrayLiteral7	self 		parse: '#(size #at: at:put: #''=='')'		rule: #arrayLiteral! !!Trait method!testArrayLiteral7	self 		parse: '#(size #at: at:put: #''=='')'		rule: #arrayLiteral! !!Trait method!testArrayLiteral8	self 		parse: '#(''baz'')'		rule: #arrayLiteral! !!Trait method!testArrayLiteral8	self 		parse: '#(''baz'')'		rule: #arrayLiteral! !!Trait method!testArrayLiteral8	self 		parse: '#(''baz'')'		rule: #arrayLiteral! !!Trait method!testArrayLiteral9	self 		parse: '#((1) 2)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral9	self 		parse: '#((1) 2)'		rule: #arrayLiteral! !!Trait method!testArrayLiteral9	self 		parse: '#((1) 2)'		rule: #arrayLiteral! !!Trait method!testAssignment1	self 		parse: '1'		rule: #expression! !!Trait method!testAssignment1	self 		parse: '1'		rule: #expression! !!Trait method!testAssignment1	self 		parse: '1'		rule: #expression! !!Trait method!testAssignment2	self 		parse: 'a := 1'		rule: #expression! !!Trait method!testAssignment2	self 		parse: 'a := 1'		rule: #expression! !!Trait method!testAssignment2	self 		parse: 'a := 1'		rule: #expression! !!Trait method!testAssignment3	self 		parse: 'a := b := 1'		rule: #expression! !!Trait method!testAssignment3	self 		parse: 'a := b := 1'		rule: #expression! !!Trait method!testAssignment3	self 		parse: 'a := b := 1'		rule: #expression! !!Trait method!testAssignment4	self fail: 'a _ 1' rule: #expression! !!Trait method!testAssignment4	self fail: 'a _ 1' rule: #expression! !!Trait method!testAssignment4	self fail: 'a _ 1' rule: #expression! !!Trait method!testAssignment5	self fail: 'a _ b _ 1' rule: #expression! !!Trait method!testAssignment5	self fail: 'a _ b _ 1' rule: #expression! !!Trait method!testAssignment5	self fail: 'a _ b _ 1' rule: #expression! !!Trait method!testAssignment6	self 		parse: 'a := (b := c)'		rule: #expression! !!Trait method!testAssignment6	self 		parse: 'a := (b := c)'		rule: #expression! !!Trait method!testAssignment6	self 		parse: 'a := (b := c)'		rule: #expression! !!Trait method!testBinaryExpression1	self 		parse: '1 + 2'		rule: #expression! !!Trait method!testBinaryExpression1	self 		parse: '1 + 2'		rule: #expression! !!Trait method!testBinaryExpression1	self 		parse: '1 + 2'		rule: #expression! !!Trait method!testBinaryExpression2	self 		parse: '1 + 2 + 3'		rule: #expression! !!Trait method!testBinaryExpression2	self 		parse: '1 + 2 + 3'		rule: #expression! !!Trait method!testBinaryExpression2	self 		parse: '1 + 2 + 3'		rule: #expression! !!Trait method!testBinaryExpression3	self 		parse: '1 // 2'		rule: #expression! !!Trait method!testBinaryExpression3	self 		parse: '1 // 2'		rule: #expression! !!Trait method!testBinaryExpression3	self 		parse: '1 // 2'		rule: #expression! !!Trait method!testBinaryExpression4	self 		parse: '1 -- 2'		rule: #expression! !!Trait method!testBinaryExpression4	self 		parse: '1 -- 2'		rule: #expression! !!Trait method!testBinaryExpression4	self 		parse: '1 -- 2'		rule: #expression! !!Trait method!testBinaryExpression5	self 		parse: '1 ==> 2'		rule: #expression.! !!Trait method!testBinaryExpression5	self 		parse: '1 ==> 2'		rule: #expression.! !!Trait method!testBinaryExpression5	self 		parse: '1 ==> 2'		rule: #expression.! !!Trait method!testBinaryMethod1	self 		parse: '+ a'		rule: #method! !!Trait method!testBinaryMethod1	self 		parse: '+ a'		rule: #method! !!Trait method!testBinaryMethod1	self 		parse: '+ a'		rule: #method! !!Trait method!testBinaryMethod2	self 		parse: '+ a | b |'		rule: #method! !!Trait method!testBinaryMethod2	self 		parse: '+ a | b |'		rule: #method! !!Trait method!testBinaryMethod2	self 		parse: '+ a | b |'		rule: #method! !!Trait method!testBinaryMethod3	self 		parse: '+ a b'		rule: #method! !!Trait method!testBinaryMethod3	self 		parse: '+ a b'		rule: #method! !!Trait method!testBinaryMethod3	self 		parse: '+ a b'		rule: #method! !!Trait method!testBinaryMethod4	self 		parse: '+ a | b | c'		rule: #method! !!Trait method!testBinaryMethod4	self 		parse: '+ a | b | c'		rule: #method! !!Trait method!testBinaryMethod4	self 		parse: '+ a | b | c'		rule: #method! !!Trait method!testBinaryMethod5	self 		parse: '-- a'		rule: #method! !!Trait method!testBinaryMethod5	self 		parse: '-- a'		rule: #method! !!Trait method!testBinaryMethod5	self 		parse: '-- a'		rule: #method! !!Trait method!testBlock1	self 		parse: '[]'		rule: #block! !!Trait method!testBlock1	self 		parse: '[]'		rule: #block! !!Trait method!testBlock1	self 		parse: '[]'		rule: #block! !!Trait method!testByteLiteral1	self 		parse: '#[]'		rule: #byteLiteral! !!Trait method!testByteLiteral1	self 		parse: '#[]'		rule: #byteLiteral! !!Trait method!testByteLiteral1	self 		parse: '#[]'		rule: #byteLiteral! !!Trait method!testByteLiteral2	self 		parse: '#[0]'		rule: #byteLiteral! !!Trait method!testByteLiteral2	self 		parse: '#[0]'		rule: #byteLiteral! !!Trait method!testByteLiteral2	self 		parse: '#[0]'		rule: #byteLiteral! !!Trait method!testByteLiteral3	self 		parse: '#[255]'		rule: #byteLiteral! !!Trait method!testByteLiteral3	self 		parse: '#[255]'		rule: #byteLiteral! !!Trait method!testByteLiteral3	self 		parse: '#[255]'		rule: #byteLiteral! !!Trait method!testByteLiteral4	self 		parse: '#[ 1 2 ]'		rule: #byteLiteral! !!Trait method!testByteLiteral4	self 		parse: '#[ 1 2 ]'		rule: #byteLiteral! !!Trait method!testByteLiteral4	self 		parse: '#[ 1 2 ]'		rule: #byteLiteral! !!Trait method!testByteLiteral5	self 		parse: '#[ 2r1010 8r77 16rFF ]'		rule: #byteLiteral! !!Trait method!testByteLiteral5	self 		parse: '#[ 2r1010 8r77 16rFF ]'		rule: #byteLiteral! !!Trait method!testByteLiteral5	self 		parse: '#[ 2r1010 8r77 16rFF ]'		rule: #byteLiteral! !!Trait method!testCascadeExpression1	self 		parse: '1 abs; negated'		rule: #expression! !!Trait method!testCascadeExpression1	self 		parse: '1 abs; negated'		rule: #expression! !!Trait method!testCascadeExpression1	self 		parse: '1 abs; negated'		rule: #expression! !!Trait method!testCascadeExpression2	self 		parse: '1 abs negated; raisedTo: 12; negated'		rule: #expression! !!Trait method!testCascadeExpression2	self 		parse: '1 abs negated; raisedTo: 12; negated'		rule: #expression! !!Trait method!testCascadeExpression2	self 		parse: '1 abs negated; raisedTo: 12; negated'		rule: #expression! !!Trait method!testCascadeExpression3	self 		parse: '1 + 2; - 3'		rule: #expression! !!Trait method!testCascadeExpression3	self 		parse: '1 + 2; - 3'		rule: #expression! !!Trait method!testCascadeExpression3	self 		parse: '1 + 2; - 3'		rule: #expression! !!Trait method!testCharLiteral1	self 		parse: '$a'		rule: #charLiteral! !!Trait method!testCharLiteral1	self 		parse: '$a'		rule: #charLiteral! !!Trait method!testCharLiteral1	self 		parse: '$a'		rule: #charLiteral! !!Trait method!testCharLiteral2	self 		parse: '$ '		rule: #charLiteral! !!Trait method!testCharLiteral2	self 		parse: '$ '		rule: #charLiteral! !!Trait method!testCharLiteral2	self 		parse: '$ '		rule: #charLiteral! !!Trait method!testCharLiteral3	self 		parse: '$$'		rule: #charLiteral! !!Trait method!testCharLiteral3	self 		parse: '$$'		rule: #charLiteral! !!Trait method!testCharLiteral3	self 		parse: '$$'		rule: #charLiteral! !!Trait method!testComment1	self 		parse: '1"one"+2'		rule: #expression! !!Trait method!testComment1	self 		parse: '1"one"+2'		rule: #expression! !!Trait method!testComment1	self 		parse: '1"one"+2'		rule: #expression! !!Trait method!testComment2	self 		parse: '1 "one" +2'		rule: #expression! !!Trait method!testComment2	self 		parse: '1 "one" +2'		rule: #expression! !!Trait method!testComment2	self 		parse: '1 "one" +2'		rule: #expression! !!Trait method!testComment3	self 		parse: '1"one"+"two"2'		rule: #expression! !!Trait method!testComment3	self 		parse: '1"one"+"two"2'		rule: #expression! !!Trait method!testComment3	self 		parse: '1"one"+"two"2'		rule: #expression! !!Trait method!testComment4	self 		parse: '1"one""two"+2'		rule: #expression! !!Trait method!testComment4	self 		parse: '1"one""two"+2'		rule: #expression! !!Trait method!testComment4	self 		parse: '1"one""two"+2'		rule: #expression! !!Trait method!testComment5	self 		parse: '1"one"	"two"+2'		rule: #expression! !!Trait method!testComment5	self 		parse: '1"one"	"two"+2'		rule: #expression! !!Trait method!testComment5	self 		parse: '1"one"	"two"+2'		rule: #expression! !!Trait method!testComplexBlock1	self 		parse: '[ :a | | b | c ]'		rule: #block! !!Trait method!testComplexBlock1	self 		parse: '[ :a | | b | c ]'		rule: #block! !!Trait method!testComplexBlock1	self 		parse: '[ :a | | b | c ]'		rule: #block! !!Trait method!testComplexBlock2	self 		parse: '[:a||b|c]'		rule: #block! !!Trait method!testComplexBlock2	self 		parse: '[:a||b|c]'		rule: #block! !!Trait method!testComplexBlock2	self 		parse: '[:a||b|c]'		rule: #block! !!Trait method!testKeywordExpression1	self 		parse: '1 to: 2'		rule: #expression! !!Trait method!testKeywordExpression1	self 		parse: '1 to: 2'		rule: #expression! !!Trait method!testKeywordExpression1	self 		parse: '1 to: 2'		rule: #expression! !!Trait method!testKeywordExpression2	self 		parse: '1 to: 2 by: 3'		rule: #expression! !!Trait method!testKeywordExpression2	self 		parse: '1 to: 2 by: 3'		rule: #expression! !!Trait method!testKeywordExpression2	self 		parse: '1 to: 2 by: 3'		rule: #expression! !!Trait method!testKeywordExpression3	self 		parse: '1 to: 2 by: 3 do: 4'		rule: #expression! !!Trait method!testKeywordExpression3	self 		parse: '1 to: 2 by: 3 do: 4'		rule: #expression! !!Trait method!testKeywordExpression3	self 		parse: '1 to: 2 by: 3 do: 4'		rule: #expression! !!Trait method!testKeywordMethod1	self 		parse: 'to: a'		rule: #method! !!Trait method!testKeywordMethod1	self 		parse: 'to: a'		rule: #method! !!Trait method!testKeywordMethod1	self 		parse: 'to: a'		rule: #method! !!Trait method!testKeywordMethod2	self 		parse: 'to: a do: b | c |'		rule: #method! !!Trait method!testKeywordMethod2	self 		parse: 'to: a do: b | c |'		rule: #method! !!Trait method!testKeywordMethod2	self 		parse: 'to: a do: b | c |'		rule: #method! !!Trait method!testKeywordMethod3	self 		parse: 'to: a do: b by: c d'		rule: #method! !!Trait method!testKeywordMethod3	self 		parse: 'to: a do: b by: c d'		rule: #method! !!Trait method!testKeywordMethod3	self 		parse: 'to: a do: b by: c d'		rule: #method! !!Trait method!testKeywordMethod4	self 		parse: 'to: a do: b by: c | d | e'		rule: #method! !!Trait method!testKeywordMethod4	self 		parse: 'to: a do: b by: c | d | e'		rule: #method! !!Trait method!testKeywordMethod4	self 		parse: 'to: a do: b by: c | d | e'		rule: #method! !!Trait method!testMethod1	self 		parse: 'negated ^ 0 - self'		rule: #method! !!Trait method!testMethod1	self 		parse: 'negated ^ 0 - self'		rule: #method! !!Trait method!testMethod1	self 		parse: 'negated ^ 0 - self'		rule: #method! !!Trait method!testMethod2	"Spaces at the beginning of the method."	self 		parse: '	  negated ^ 0 - self'		rule: #method! !!Trait method!testMethod2	"Spaces at the beginning of the method."	self 		parse: '	  negated ^ 0 - self'		rule: #method! !!Trait method!testMethod2	"Spaces at the beginning of the method."	self 		parse: '	  negated ^ 0 - self'		rule: #method! !!Trait method!testMethod3	"Spaces at the end of the method."	self 		parse: '	negated ^ 0 - self  '		rule: #method! !!Trait method!testMethod3	"Spaces at the end of the method."	self 		parse: '	negated ^ 0 - self  '		rule: #method! !!Trait method!testMethod3	"Spaces at the end of the method."	self 		parse: '	negated ^ 0 - self  '		rule: #method! !!Trait method!testNumberLiteral1	self 		parse: '0'		rule: #numberLiteral! !!Trait method!testNumberLiteral1	self 		parse: '0'		rule: #numberLiteral! !!Trait method!testNumberLiteral1	self 		parse: '0'		rule: #numberLiteral! !!Trait method!testNumberLiteral10	self 		parse: '10r10'		rule: #numberLiteral! !!Trait method!testNumberLiteral10	self 		parse: '10r10'		rule: #numberLiteral! !!Trait method!testNumberLiteral10	self 		parse: '10r10'		rule: #numberLiteral! !!Trait method!testNumberLiteral11	self 		parse: '8r777'		rule: #numberLiteral! !!Trait method!testNumberLiteral11	self 		parse: '8r777'		rule: #numberLiteral! !!Trait method!testNumberLiteral11	self 		parse: '8r777'		rule: #numberLiteral! !!Trait method!testNumberLiteral12	self 		parse: '16rAF'		rule: #numberLiteral! !!Trait method!testNumberLiteral12	self 		parse: '16rAF'		rule: #numberLiteral! !!Trait method!testNumberLiteral12	self 		parse: '16rAF'		rule: #numberLiteral! !!Trait method!testNumberLiteral13	self 		parse: '16rCA.FE'		rule: #numberLiteral! !!Trait method!testNumberLiteral13	self 		parse: '16rCA.FE'		rule: #numberLiteral! !!Trait method!testNumberLiteral13	self 		parse: '16rCA.FE'		rule: #numberLiteral! !!Trait method!testNumberLiteral14	self 		parse: '3r-22.2'		rule: #numberLiteral! !!Trait method!testNumberLiteral14	self 		parse: '3r-22.2'		rule: #numberLiteral! !!Trait method!testNumberLiteral14	self 		parse: '3r-22.2'		rule: #numberLiteral! !!Trait method!testNumberLiteral15	self 		parse: '0.50s2'		rule: #numberLiteral! !!Trait method!testNumberLiteral15	self 		parse: '0.50s2'		rule: #numberLiteral! !!Trait method!testNumberLiteral15	self 		parse: '0.50s2'		rule: #numberLiteral! !!Trait method!testNumberLiteral2	self 		parse: '0.1'		rule: #numberLiteral! !!Trait method!testNumberLiteral2	self 		parse: '0.1'		rule: #numberLiteral! !!Trait method!testNumberLiteral2	self 		parse: '0.1'		rule: #numberLiteral! !!Trait method!testNumberLiteral3	self 		parse: '123'		rule: #numberLiteral! !!Trait method!testNumberLiteral3	self 		parse: '123'		rule: #numberLiteral! !!Trait method!testNumberLiteral3	self 		parse: '123'		rule: #numberLiteral! !!Trait method!testNumberLiteral4	self 		parse: '123.456'		rule: #numberLiteral! !!Trait method!testNumberLiteral4	self 		parse: '123.456'		rule: #numberLiteral! !!Trait method!testNumberLiteral4	self 		parse: '123.456'		rule: #numberLiteral! !!Trait method!testNumberLiteral5	self 		parse: '-0'		rule: #numberLiteral! !!Trait method!testNumberLiteral5	self 		parse: '-0'		rule: #numberLiteral! !!Trait method!testNumberLiteral5	self 		parse: '-0'		rule: #numberLiteral! !!Trait method!testNumberLiteral6	self 		parse: '-0.1'		rule: #numberLiteral! !!Trait method!testNumberLiteral6	self 		parse: '-0.1'		rule: #numberLiteral! !!Trait method!testNumberLiteral6	self 		parse: '-0.1'		rule: #numberLiteral! !!Trait method!testNumberLiteral7	self 		parse: '-123'		rule: #numberLiteral! !!Trait method!testNumberLiteral7	self 		parse: '-123'		rule: #numberLiteral! !!Trait method!testNumberLiteral7	self 		parse: '-123'		rule: #numberLiteral! !!Trait method!testNumberLiteral8	self 		parse: '-123'		rule: #numberLiteral! !!Trait method!testNumberLiteral8	self 		parse: '-123'		rule: #numberLiteral! !!Trait method!testNumberLiteral8	self 		parse: '-123'		rule: #numberLiteral! !!Trait method!testNumberLiteral9	self 		parse: '-123.456'		rule: #numberLiteral! !!Trait method!testNumberLiteral9	self 		parse: '-123.456'		rule: #numberLiteral! !!Trait method!testNumberLiteral9	self 		parse: '-123.456'		rule: #numberLiteral! !!Trait method!testPragma1	self 		parse: 'method <foo>'		rule: #method! !!Trait method!testPragma1	self 		parse: 'method <foo>'		rule: #method! !!Trait method!testPragma1	self 		parse: 'method <foo>'		rule: #method! !!Trait method!testPragma10	self 		parse: 'method <foo: bar>'		rule: #method! !!Trait method!testPragma10	self 		parse: 'method <foo: bar>'		rule: #method! !!Trait method!testPragma10	self 		parse: 'method <foo: bar>'		rule: #method! !!Trait method!testPragma11	self 		parse: 'method <foo: true>'		rule: #method! !!Trait method!testPragma11	self 		parse: 'method <foo: true>'		rule: #method! !!Trait method!testPragma11	self 		parse: 'method <foo: true>'		rule: #method! !!Trait method!testPragma12	self 		parse: 'method <foo: false>'		rule: #method! !!Trait method!testPragma12	self 		parse: 'method <foo: false>'		rule: #method! !!Trait method!testPragma12	self 		parse: 'method <foo: false>'		rule: #method! !!Trait method!testPragma13	self 		parse: 'method <foo: nil>'		rule: #method! !!Trait method!testPragma13	self 		parse: 'method <foo: nil>'		rule: #method! !!Trait method!testPragma13	self 		parse: 'method <foo: nil>'		rule: #method! !!Trait method!testPragma14	self 		parse: 'method <foo: ()>'		rule: #method! !!Trait method!testPragma14	self 		parse: 'method <foo: ()>'		rule: #method! !!Trait method!testPragma14	self 		parse: 'method <foo: ()>'		rule: #method! !!Trait method!testPragma15	self 		parse: 'method <foo: #()>'		rule: #method! !!Trait method!testPragma15	self 		parse: 'method <foo: #()>'		rule: #method! !!Trait method!testPragma15	self 		parse: 'method <foo: #()>'		rule: #method! !!Trait method!testPragma16	self 		parse: 'method < + 1 >'		rule: #method! !!Trait method!testPragma16	self 		parse: 'method < + 1 >'		rule: #method! !!Trait method!testPragma16	self 		parse: 'method < + 1 >'		rule: #method! !!Trait method!testPragma17	self 		parse: 'method <foo: 1 bar: 2>'		rule: #method! !!Trait method!testPragma17	self 		parse: 'method <foo: 1 bar: 2>'		rule: #method! !!Trait method!testPragma17	self 		parse: 'method <foo: 1 bar: 2>'		rule: #method! !!Trait method!testPragma18	self 		parse: 'method <foo: 1 bar: 2  baz: b>'		rule: #method! !!Trait method!testPragma18	self 		parse: 'method <foo: 1 bar: 2  baz: b>'		rule: #method! !!Trait method!testPragma18	self 		parse: 'method <foo: 1 bar: 2  baz: b>'		rule: #method! !!Trait method!testPragma2	self 		parse: 'method <foo> <bar>'		rule: #method! !!Trait method!testPragma2	self 		parse: 'method <foo> <bar>'		rule: #method! !!Trait method!testPragma2	self 		parse: 'method <foo> <bar>'		rule: #method! !!Trait method!testPragma3	self 		parse: 'method | a | <foo>'		rule: #method! !!Trait method!testPragma3	self 		parse: 'method | a | <foo>'		rule: #method! !!Trait method!testPragma3	self 		parse: 'method | a | <foo>'		rule: #method! !!Trait method!testPragma4	self 		parse: 'method <foo> | a |'		rule: #method! !!Trait method!testPragma4	self 		parse: 'method <foo> | a |'		rule: #method! !!Trait method!testPragma4	self 		parse: 'method <foo> | a |'		rule: #method! !!Trait method!testPragma5	self 		parse: 'method <foo> | a | <bar>'		rule: #method! !!Trait method!testPragma5	self 		parse: 'method <foo> | a | <bar>'		rule: #method! !!Trait method!testPragma5	self 		parse: 'method <foo> | a | <bar>'		rule: #method! !!Trait method!testPragma6	self 		parse: 'method <foo: 1>'		rule: #method! !!Trait method!testPragma6	self 		parse: 'method <foo: 1>'		rule: #method! !!Trait method!testPragma6	self 		parse: 'method <foo: 1>'		rule: #method! !!Trait method!testPragma7	self 		parse: 'method <foo: 1.2>'		rule: #method! !!Trait method!testPragma7	self 		parse: 'method <foo: 1.2>'		rule: #method! !!Trait method!testPragma7	self 		parse: 'method <foo: 1.2>'		rule: #method! !!Trait method!testPragma8	self 		parse: 'method <foo: ''bar''>'		rule: #method! !!Trait method!testPragma8	self 		parse: 'method <foo: ''bar''>'		rule: #method! !!Trait method!testPragma8	self 		parse: 'method <foo: ''bar''>'		rule: #method! !!Trait method!testPragma9	self 		parse: 'method <foo: #''bar''>'		rule: #method! !!Trait method!testPragma9	self 		parse: 'method <foo: #''bar''>'		rule: #method! !!Trait method!testPragma9	self 		parse: 'method <foo: #''bar''>'		rule: #method! !!Trait method!testSequence1	self 		parse: '| a | 1 . 2'		rule: #sequence! !!Trait method!testSequence1	self 		parse: '| a | 1 . 2'		rule: #sequence! !!Trait method!testSequence1	self 		parse: '| a | 1 . 2'		rule: #sequence! !!Trait method!testSimpleBlock1	self 		parse: '[ ]'		rule: #block! !!Trait method!testSimpleBlock1	self 		parse: '[ ]'		rule: #block! !!Trait method!testSimpleBlock1	self 		parse: '[ ]'		rule: #block! !!Trait method!testSimpleBlock2	self 		parse: '[ nil ]'		rule: #block! !!Trait method!testSimpleBlock2	self 		parse: '[ nil ]'		rule: #block! !!Trait method!testSimpleBlock2	self 		parse: '[ nil ]'		rule: #block! !!Trait method!testSimpleBlock3	self 		parse: '[ :a ]'		rule: #block! !!Trait method!testSimpleBlock3	self 		parse: '[ :a ]'		rule: #block! !!Trait method!testSimpleBlock3	self 		parse: '[ :a ]'		rule: #block! !!Trait method!testSpecialLiteral1	self 		parse: 'true'		rule: #trueLiteral! !!Trait method!testSpecialLiteral1	self 		parse: 'true'		rule: #trueLiteral! !!Trait method!testSpecialLiteral1	self 		parse: 'true'		rule: #trueLiteral! !!Trait method!testSpecialLiteral2	self 		parse: 'false'		rule: #falseLiteral! !!Trait method!testSpecialLiteral2	self 		parse: 'false'		rule: #falseLiteral! !!Trait method!testSpecialLiteral2	self 		parse: 'false'		rule: #falseLiteral! !!Trait method!testSpecialLiteral3	self 		parse: 'nil'		rule: #nilLiteral! !!Trait method!testSpecialLiteral3	self 		parse: 'nil'		rule: #nilLiteral! !!Trait method!testSpecialLiteral3	self 		parse: 'nil'		rule: #nilLiteral! !!Trait method!testStatementBlock1	self 		parse: '[ nil ]'		rule: #block! !!Trait method!testStatementBlock1	self 		parse: '[ nil ]'		rule: #block! !!Trait method!testStatementBlock1	self 		parse: '[ nil ]'		rule: #block! !!Trait method!testStatementBlock2	self 		parse: '[ | a | nil ]'		rule: #block! !!Trait method!testStatementBlock2	self 		parse: '[ | a | nil ]'		rule: #block! !!Trait method!testStatementBlock2	self 		parse: '[ | a | nil ]'		rule: #block! !!Trait method!testStatementBlock3	self 		parse: '[ | a b | nil ]'		rule: #block! !!Trait method!testStatementBlock3	self 		parse: '[ | a b | nil ]'		rule: #block! !!Trait method!testStatementBlock3	self 		parse: '[ | a b | nil ]'		rule: #block! !!Trait method!testStatements1	self 		parse: '1'		rule: #sequence! !!Trait method!testStatements1	self 		parse: '1'		rule: #sequence! !!Trait method!testStatements1	self 		parse: '1'		rule: #sequence! !!Trait method!testStatements2	self 		parse: '1 . 2'		rule: #sequence! !!Trait method!testStatements2	self 		parse: '1 . 2'		rule: #sequence! !!Trait method!testStatements2	self 		parse: '1 . 2'		rule: #sequence! !!Trait method!testStatements3	self 		parse: '1 . 2 . 3'		rule: #sequence! !!Trait method!testStatements3	self 		parse: '1 . 2 . 3'		rule: #sequence! !!Trait method!testStatements3	self 		parse: '1 . 2 . 3'		rule: #sequence! !!Trait method!testStatements4	self 		parse: '1 . 2 . 3 .'		rule: #sequence! !!Trait method!testStatements4	self 		parse: '1 . 2 . 3 .'		rule: #sequence! !!Trait method!testStatements4	self 		parse: '1 . 2 . 3 .'		rule: #sequence! !!Trait method!testStatements5	self 		parse: '1 . . 2'		rule: #sequence! !!Trait method!testStatements5	self 		parse: '1 . . 2'		rule: #sequence! !!Trait method!testStatements5	self 		parse: '1 . . 2'		rule: #sequence! !!Trait method!testStatements6	self 		parse: '1. 2'		rule: #sequence! !!Trait method!testStatements6	self 		parse: '1. 2'		rule: #sequence! !!Trait method!testStatements6	self 		parse: '1. 2'		rule: #sequence! !!Trait method!testStatements7	self 		parse: '. 1'		rule: #sequence! !!Trait method!testStatements7	self 		parse: '. 1'		rule: #sequence! !!Trait method!testStatements7	self 		parse: '. 1'		rule: #sequence! !!Trait method!testStatements8	self 		parse: '.1'		rule: #sequence! !!Trait method!testStatements8	self 		parse: '.1'		rule: #sequence! !!Trait method!testStatements8	self 		parse: '.1'		rule: #sequence! !!Trait method!testStatements9	self 		parse: ''		rule: #statements! !!Trait method!testStatements9	self 		parse: ''		rule: #statements! !!Trait method!testStatements9	self 		parse: ''		rule: #statements! !!Trait method!testStringLiteral1	self 		parse: ''''''		rule: #stringLiteral! !!Trait method!testStringLiteral1	self 		parse: ''''''		rule: #stringLiteral! !!Trait method!testStringLiteral1	self 		parse: ''''''		rule: #stringLiteral! !!Trait method!testStringLiteral2	self 		parse: '''ab'''		rule: #stringLiteral! !!Trait method!testStringLiteral2	self 		parse: '''ab'''		rule: #stringLiteral! !!Trait method!testStringLiteral2	self 		parse: '''ab'''		rule: #stringLiteral! !!Trait method!testStringLiteral3	self 		parse: '''ab''''cd'''		rule: #stringLiteral! !!Trait method!testStringLiteral3	self 		parse: '''ab''''cd'''		rule: #stringLiteral! !!Trait method!testStringLiteral3	self 		parse: '''ab''''cd'''		rule: #stringLiteral! !!Trait method!testSymbolLiteral1	self 		parse: '#foo'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral1	self 		parse: '#foo'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral1	self 		parse: '#foo'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral2	self 		parse: '#+'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral2	self 		parse: '#+'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral2	self 		parse: '#+'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral3	self 		parse: '#key:'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral3	self 		parse: '#key:'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral3	self 		parse: '#key:'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral4	self 		parse: '#key:value:'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral4	self 		parse: '#key:value:'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral4	self 		parse: '#key:value:'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral5	self 		parse: '#''testing-result'''		rule: #symbolLiteral! !!Trait method!testSymbolLiteral5	self 		parse: '#''testing-result'''		rule: #symbolLiteral! !!Trait method!testSymbolLiteral5	self 		parse: '#''testing-result'''		rule: #symbolLiteral! !!Trait method!testSymbolLiteral6		self 			parse: '#__gen__binding'			rule: #symbolLiteral! !!Trait method!testSymbolLiteral6		self 			parse: '#__gen__binding'			rule: #symbolLiteral! !!Trait method!testSymbolLiteral6		self 			parse: '#__gen__binding'			rule: #symbolLiteral! !!Trait method!testSymbolLiteral7	self 		parse: '# fucker'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral7	self 		parse: '# fucker'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral7	self 		parse: '# fucker'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral8	self 		parse: '##fucker'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral8	self 		parse: '##fucker'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral8	self 		parse: '##fucker'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral9	self 		parse: '## fucker'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral9	self 		parse: '## fucker'		rule: #symbolLiteral! !!Trait method!testSymbolLiteral9	self 		parse: '## fucker'		rule: #symbolLiteral! !!Trait method!testTemporaries1	self 		parse: '| a |'		rule: #sequence! !!Trait method!testTemporaries1	self 		parse: '| a |'		rule: #sequence! !!Trait method!testTemporaries1	self 		parse: '| a |'		rule: #sequence! !!Trait method!testTemporaries2	self 		parse: '| a b |'		rule: #sequence! !!Trait method!testTemporaries2	self 		parse: '| a b |'		rule: #sequence! !!Trait method!testTemporaries2	self 		parse: '| a b |'		rule: #sequence! !!Trait method!testTemporaries3	self 		parse: '| a b c |'		rule: #sequence! !!Trait method!testTemporaries3	self 		parse: '| a b c |'		rule: #sequence! !!Trait method!testTemporaries3	self 		parse: '| a b c |'		rule: #sequence! !!Trait method!testUnaryExpression1	self 		parse: '1 abs'		rule: #expression! !!Trait method!testUnaryExpression1	self 		parse: '1 abs'		rule: #expression! !!Trait method!testUnaryExpression1	self 		parse: '1 abs'		rule: #expression! !!Trait method!testUnaryExpression2	self 		parse: '1 abs negated'		rule: #expression! !!Trait method!testUnaryExpression2	self 		parse: '1 abs negated'		rule: #expression! !!Trait method!testUnaryExpression2	self 		parse: '1 abs negated'		rule: #expression! !!Trait method!testUnaryMethod1	self 		parse: 'abs'		rule: #method! !!Trait method!testUnaryMethod1	self 		parse: 'abs'		rule: #method! !!Trait method!testUnaryMethod1	self 		parse: 'abs'		rule: #method! !!Trait method!testUnaryMethod2	self 		parse: 'abs | a |'		rule: #method! !!Trait method!testUnaryMethod2	self 		parse: 'abs | a |'		rule: #method! !!Trait method!testUnaryMethod2	self 		parse: 'abs | a |'		rule: #method! !!Trait method!testUnaryMethod3	self 		parse: 'abs a'		rule: #method! !!Trait method!testUnaryMethod3	self 		parse: 'abs a'		rule: #method! !!Trait method!testUnaryMethod3	self 		parse: 'abs a'		rule: #method! !!Trait method!testUnaryMethod4	self 		parse: 'abs | a | b'		rule: #method! !!Trait method!testUnaryMethod4	self 		parse: 'abs | a | b'		rule: #method! !!Trait method!testUnaryMethod4	self 		parse: 'abs | a | b'		rule: #method! !!Trait method!testUnaryMethod5	self 		parse: 'abs | a |'		rule: #method! !!Trait method!testUnaryMethod5	self 		parse: 'abs | a |'		rule: #method! !!Trait method!testUnaryMethod5	self 		parse: 'abs | a |'		rule: #method! !!Trait method!testVariable1	self 		parse: 'trueBinding'		rule: #primary! !!Trait method!testVariable1	self 		parse: 'trueBinding'		rule: #primary! !!Trait method!testVariable1	self 		parse: 'trueBinding'		rule: #primary! !!Trait method!testVariable2	self 		parse: 'falseBinding'		rule: #primary! !!Trait method!testVariable2	self 		parse: 'falseBinding'		rule: #primary! !!Trait method!testVariable2	self 		parse: 'falseBinding'		rule: #primary! !!Trait method!testVariable3	self 		parse: 'nilly'		rule: #primary! !!Trait method!testVariable3	self 		parse: 'nilly'		rule: #primary! !!Trait method!testVariable3	self 		parse: 'nilly'		rule: #primary! !!Trait method!testVariable4	self 		parse: 'selfish'		rule: #primary! !!Trait method!testVariable4	self 		parse: 'selfish'		rule: #primary! !!Trait method!testVariable4	self 		parse: 'selfish'		rule: #primary! !!Trait method!testVariable5	self 		parse: 'supernanny'		rule: #primary! !!Trait method!testVariable5	self 		parse: 'supernanny'		rule: #primary! !!Trait method!testVariable5	self 		parse: 'supernanny'		rule: #primary! !!Trait method!testVariable6		self 			parse: 'super_nanny'			rule: #primary! !!Trait method!testVariable6		self 			parse: 'super_nanny'			rule: #primary! !!Trait method!testVariable6		self 			parse: 'super_nanny'			rule: #primary! !!Trait method!testVariable7		self 			parse: '__gen_var_123__'			rule: #primary ! !!Trait method!testVariable7		self 			parse: '__gen_var_123__'			rule: #primary ! !!Trait method!testVariable7		self 			parse: '__gen_var_123__'			rule: #primary ! !!Trait method!assert: aNode format: aString	aNode isCollection		ifFalse: [ ^ self assert: (Array with: aNode) format: (Array with: aString) ].	self assert: aNode size equals: aString size.	aNode with: aString do: [ :node :string | self assert: (BIConfigurableFormatter format: node) equals: string ]! !!Trait method!assert: aNode format: aString	aNode isCollection		ifFalse: [ ^ self assert: (Array with: aNode) format: (Array with: aString) ].	self assert: aNode size equals: aString size.	aNode with: aString do: [ :node :string | self assert: (BIConfigurableFormatter format: node) equals: string ]! !!Trait method!parserClass	^ PP2SmalltalkParser! !!Trait method!parserClass	^ PP2SmalltalkParser! !!Trait method!testArgumentsBlock1	super testArgumentsBlock1.	self assert: self result isBlock.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testArgumentsBlock1	super testArgumentsBlock1.	self assert: self result isBlock.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testArgumentsBlock2	super testArgumentsBlock2.	self assert: self result isBlock.	self assert: self result arguments size equals: 2.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result arguments second isVariable.	self assert: self result arguments second name equals: 'b'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testArgumentsBlock2	super testArgumentsBlock2.	self assert: self result isBlock.	self assert: self result arguments size equals: 2.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result arguments second isVariable.	self assert: self result arguments second name equals: 'b'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testArgumentsBlock3	super testArgumentsBlock3.	self assert: self result isBlock.	self assert: self result arguments size equals: 3.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result arguments second isVariable.	self assert: self result arguments second name equals: 'b'.	self assert: self result arguments third isVariable.	self assert: self result arguments third name equals: 'c'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testArgumentsBlock3	super testArgumentsBlock3.	self assert: self result isBlock.	self assert: self result arguments size equals: 3.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result arguments second isVariable.	self assert: self result arguments second name equals: 'b'.	self assert: self result arguments third isVariable.	self assert: self result arguments third name equals: 'c'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testArray1	super testArray1.	self assert: self result isArray.	self assert: self result statements isEmpty.	self assert: self result periods isEmpty! !!Trait method!testArray1	super testArray1.	self assert: self result isArray.	self assert: self result statements isEmpty.	self assert: self result periods isEmpty! !!Trait method!testArray2	super testArray2.	self assert: self result isArray.	self assert: self result periods isEmpty.	self assert: self result statements size equals: 1.	self assert: self result statements first isMessage.	self assert: self result statements first selector equals: #foo! !!Trait method!testArray2	super testArray2.	self assert: self result isArray.	self assert: self result periods isEmpty.	self assert: self result statements size equals: 1.	self assert: self result statements first isMessage.	self assert: self result statements first selector equals: #foo! !!Trait method!testArray3	super testArray3.	self assert: self result isArray.	self assert: self result periods size equals: 1.	self assert: self result statements size equals: 2.	self assert: self result statements first isMessage.	self assert: self result statements first selector equals: #foo.	self assert: self result statements last isMessage.	self assert: self result statements last selector equals: #bar! !!Trait method!testArray3	super testArray3.	self assert: self result isArray.	self assert: self result periods size equals: 1.	self assert: self result statements size equals: 2.	self assert: self result statements first isMessage.	self assert: self result statements first selector equals: #foo.	self assert: self result statements last isMessage.	self assert: self result statements last selector equals: #bar! !!Trait method!testArray4	super testArray4.	self assert: self result isArray.	self assert: self result periods size equals: 2.	self assert: self result statements size equals: 2.	self assert: self result statements first isMessage.	self assert: self result statements first selector equals: #foo.	self assert: self result statements last isMessage.	self assert: self result statements last selector equals: #bar! !!Trait method!testArray4	super testArray4.	self assert: self result isArray.	self assert: self result periods size equals: 2.	self assert: self result statements size equals: 2.	self assert: self result statements first isMessage.	self assert: self result statements first selector equals: #foo.	self assert: self result statements last isMessage.	self assert: self result statements last selector equals: #bar! !!Trait method!testArrayLiteral1	super testArrayLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: #()! !!Trait method!testArrayLiteral1	super testArrayLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: #()! !!Trait method!testArrayLiteral10	super testArrayLiteral10.	self assert: self result isLiteralNode.	self assert: self result value equals: #(#(1 2) #(1 2 3))! !!Trait method!testArrayLiteral10	super testArrayLiteral10.	self assert: self result isLiteralNode.	self assert: self result value equals: #(#(1 2) #(1 2 3))! !!Trait method!testArrayLiteral11	super testArrayLiteral11.	self assert: self result isLiteralNode.	self assert: self result value size equals: 2.	self assert: (self result value first isKindOf: ByteArray).	self assert: self result value first size equals: 2.	self assert: (self result value last isKindOf: ByteArray).	self assert: self result value last size equals: 3! !!Trait method!testArrayLiteral11	super testArrayLiteral11.	self assert: self result isLiteralNode.	self assert: self result value size equals: 2.	self assert: (self result value first isKindOf: ByteArray).	self assert: self result value first size equals: 2.	self assert: (self result value last isKindOf: ByteArray).	self assert: self result value last size equals: 3! !!Trait method!testArrayLiteral2	super testArrayLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: #(1)! !!Trait method!testArrayLiteral2	super testArrayLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: #(1)! !!Trait method!testArrayLiteral3	super testArrayLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: #(1 2)! !!Trait method!testArrayLiteral3	super testArrayLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: #(1 2)! !!Trait method!testArrayLiteral4	super testArrayLiteral4.	self assert: self result isLiteralNode.	self assert: self result value equals: #(true false nil)! !!Trait method!testArrayLiteral4	super testArrayLiteral4.	self assert: self result isLiteralNode.	self assert: self result value equals: #(true false nil)! !!Trait method!testArrayLiteral5	super testArrayLiteral5.	self assert: self result isLiteralNode.	self assert: self result value equals: #($a)! !!Trait method!testArrayLiteral5	super testArrayLiteral5.	self assert: self result isLiteralNode.	self assert: self result value equals: #($a)! !!Trait method!testArrayLiteral6	super testArrayLiteral6.	self assert: self result isLiteralNode.	self assert: self result value equals: #(1.2)! !!Trait method!testArrayLiteral6	super testArrayLiteral6.	self assert: self result isLiteralNode.	self assert: self result value equals: #(1.2)! !!Trait method!testArrayLiteral7	super testArrayLiteral7.	self assert: self result isLiteralNode.	self assert: self result value equals: #(#size #at: #at:put: #==).	self result value do: [ :each | self assert: each isSymbol ]! !!Trait method!testArrayLiteral7	super testArrayLiteral7.	self assert: self result isLiteralNode.	self assert: self result value equals: #(#size #at: #at:put: #==).	self result value do: [ :each | self assert: each isSymbol ]! !!Trait method!testArrayLiteral8	super testArrayLiteral8.	self assert: self result isLiteralNode.	self assert: self result value equals: #('baz').	self assert: self result value first isString.	self assert: self result value first isSymbol not! !!Trait method!testArrayLiteral8	super testArrayLiteral8.	self assert: self result isLiteralNode.	self assert: self result value equals: #('baz').	self assert: self result value first isString.	self assert: self result value first isSymbol not! !!Trait method!testArrayLiteral9	super testArrayLiteral9.	self assert: self result isLiteralNode.	self assert: self result value equals: #(#(1) 2)! !!Trait method!testArrayLiteral9	super testArrayLiteral9.	self assert: self result isLiteralNode.	self assert: self result value equals: #(#(1) 2)! !!Trait method!testAssignment1	super testAssignment1.	self assert: self result isLiteralNode.	self assert: self result value equals: 1! !!Trait method!testAssignment1	super testAssignment1.	self assert: self result isLiteralNode.	self assert: self result value equals: 1! !!Trait method!testAssignment2	super testAssignment2.	self assert: self result isAssignment.	self assert: self result variable isVariable.	self assert: self result variable name equals: 'a'.	self assert: self result value isLiteralNode.	self assert: self result value value equals: 1! !!Trait method!testAssignment2	super testAssignment2.	self assert: self result isAssignment.	self assert: self result variable isVariable.	self assert: self result variable name equals: 'a'.	self assert: self result value isLiteralNode.	self assert: self result value value equals: 1! !!Trait method!testAssignment3	super testAssignment3.	self assert: self result isAssignment.	self assert: self result variable isVariable.	self assert: self result variable name equals: 'a'.	self assert: self result value isAssignment.	self assert: self result value variable isVariable.	self assert: self result value variable name equals: 'b'.	self assert: self result value value isLiteralNode.	self assert: self result value value value equals: 1! !!Trait method!testAssignment3	super testAssignment3.	self assert: self result isAssignment.	self assert: self result variable isVariable.	self assert: self result variable name equals: 'a'.	self assert: self result value isAssignment.	self assert: self result value variable isVariable.	self assert: self result value variable name equals: 'b'.	self assert: self result value value isLiteralNode.	self assert: self result value value value equals: 1! !!Trait method!testAssignment4	super testAssignment4.! !!Trait method!testAssignment4	super testAssignment4.! !!Trait method!testAssignment5	super testAssignment5.! !!Trait method!testAssignment5	super testAssignment5.! !!Trait method!testAssignment6	super testAssignment6.	self assert: self result isAssignment.	self assert: self result variable isVariable.	self assert: self result variable name equals: 'a'.	self assert: self result value isAssignment.	self assert: self result value variable isVariable.	self assert: self result value variable name equals: 'b'.	self assert: self result value value isVariable.	self assert: self result value value name equals: 'c'! !!Trait method!testAssignment6	super testAssignment6.	self assert: self result isAssignment.	self assert: self result variable isVariable.	self assert: self result variable name equals: 'a'.	self assert: self result value isAssignment.	self assert: self result value variable isVariable.	self assert: self result value variable name equals: 'b'.	self assert: self result value value isVariable.	self assert: self result value value name equals: 'c'! !!Trait method!testBinaryExpression1	super testBinaryExpression1.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2! !!Trait method!testBinaryExpression1	super testBinaryExpression1.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2! !!Trait method!testBinaryExpression2	super testBinaryExpression2.	self assert: self result isMessage.	self assert: self result receiver isMessage.	self assert: self result receiver receiver isLiteralNode.	self assert: self result receiver receiver value equals: 1.	self assert: self result receiver arguments size equals: 1.	self assert: self result receiver arguments first isLiteralNode.	self assert: self result receiver arguments first value equals: 2.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 3! !!Trait method!testBinaryExpression2	super testBinaryExpression2.	self assert: self result isMessage.	self assert: self result receiver isMessage.	self assert: self result receiver receiver isLiteralNode.	self assert: self result receiver receiver value equals: 1.	self assert: self result receiver arguments size equals: 1.	self assert: self result receiver arguments first isLiteralNode.	self assert: self result receiver arguments first value equals: 2.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 3! !!Trait method!testBinaryExpression3	super testBinaryExpression3.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result selector equals: #//.	self assert: self result keywordsPositions equals: #(3) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2! !!Trait method!testBinaryExpression3	super testBinaryExpression3.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result selector equals: #//.	self assert: self result keywordsPositions equals: #(3) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2! !!Trait method!testBinaryExpression4	super testBinaryExpression4.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result selector equals: #--.	self assert: self result keywordsPositions equals: #(3) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2! !!Trait method!testBinaryExpression4	super testBinaryExpression4.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result selector equals: #--.	self assert: self result keywordsPositions equals: #(3) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2! !!Trait method!testBinaryExpression5	super testBinaryExpression5.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result selector equals: #==>.	self assert: self result keywordsPositions equals: #(3) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2! !!Trait method!testBinaryExpression5	super testBinaryExpression5.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result selector equals: #==>.	self assert: self result keywordsPositions equals: #(3) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2! !!Trait method!testBinaryMethod1	super testBinaryMethod1.	self assert: self result isMethod.	self assert: self result selector equals: #+.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testBinaryMethod1	super testBinaryMethod1.	self assert: self result isMethod.	self assert: self result selector equals: #+.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testBinaryMethod2	super testBinaryMethod2.	self assert: self result isMethod.	self assert: self result selector equals: #+.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!Trait method!testBinaryMethod2	super testBinaryMethod2.	self assert: self result isMethod.	self assert: self result selector equals: #+.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!Trait method!testBinaryMethod3	super testBinaryMethod3.	self assert: self result isMethod.	self assert: self result selector equals: #+.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.		self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1! !!Trait method!testBinaryMethod3	super testBinaryMethod3.	self assert: self result isMethod.	self assert: self result selector equals: #+.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.		self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1! !!Trait method!testBinaryMethod4	super testBinaryMethod4.	self assert: self result isMethod.	self assert: self result selector equals: #+.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.		self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!Trait method!testBinaryMethod4	super testBinaryMethod4.	self assert: self result isMethod.	self assert: self result selector equals: #+.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.		self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!Trait method!testBinaryMethod5	super testBinaryMethod5.	self assert: self result isMethod.	self assert: self result selector equals: #--.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.		self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testBinaryMethod5	super testBinaryMethod5.	self assert: self result isMethod.	self assert: self result selector equals: #--.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.		self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testBlock1	super testBlock1.	self assert: self result isBlock.	self assert: self result arguments size equals: 0.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testBlock1	super testBlock1.	self assert: self result isBlock.	self assert: self result arguments size equals: 0.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testByteLiteral1	super testByteLiteral1.	self assert: self result isLiteralNode.	self assert: (self result value isKindOf: ByteArray).	self assert: self result value isEmpty! !!Trait method!testByteLiteral1	super testByteLiteral1.	self assert: self result isLiteralNode.	self assert: (self result value isKindOf: ByteArray).	self assert: self result value isEmpty! !!Trait method!testByteLiteral2	super testByteLiteral2.	self assert: self result isLiteralNode.	self assert: (self result value isKindOf: ByteArray).	self assert: self result value size equals: 1.	self assert: self result value first equals: 0! !!Trait method!testByteLiteral2	super testByteLiteral2.	self assert: self result isLiteralNode.	self assert: (self result value isKindOf: ByteArray).	self assert: self result value size equals: 1.	self assert: self result value first equals: 0! !!Trait method!testByteLiteral3	super testByteLiteral3.	self assert: self result isLiteralNode.	self assert: (self result value isKindOf: ByteArray).	self assert: self result value size equals: 1.	self assert: self result value first equals: 255! !!Trait method!testByteLiteral3	super testByteLiteral3.	self assert: self result isLiteralNode.	self assert: (self result value isKindOf: ByteArray).	self assert: self result value size equals: 1.	self assert: self result value first equals: 255! !!Trait method!testByteLiteral4	super testByteLiteral4.	self assert: self result isLiteralNode.	self assert: (self result value isKindOf: ByteArray).	self assert: self result value size equals: 2.	self assert: self result value first equals: 1.	self assert: self result value last equals: 2! !!Trait method!testByteLiteral4	super testByteLiteral4.	self assert: self result isLiteralNode.	self assert: (self result value isKindOf: ByteArray).	self assert: self result value size equals: 2.	self assert: self result value first equals: 1.	self assert: self result value last equals: 2! !!Trait method!testByteLiteral5	super testByteLiteral5.	self assert: self result isLiteralNode.	self assert: (self result value isKindOf: ByteArray).	self assert: self result value size equals: 3.	self assert: self result value first equals: 10.	self assert: self result value second equals: 63.	self assert: self result value last equals: 255! !!Trait method!testByteLiteral5	super testByteLiteral5.	self assert: self result isLiteralNode.	self assert: (self result value isKindOf: ByteArray).	self assert: self result value size equals: 3.	self assert: self result value first equals: 10.	self assert: self result value second equals: 63.	self assert: self result value last equals: 255! !!Trait method!testCascadeExpression1	super testCascadeExpression1.	self assert: self result isCascade.	self assert: self result receiver isLiteralNode.	self assert: self result messages size equals: 2.	self assert: self result messages first receiver equals: self result receiver.	self assert: self result messages first selector equals: #abs.	self assert: self result messages first keywordsPositions equals: #(3) asIntegerArray.	self assert: self result messages second receiver equals: self result receiver.	self assert: self result messages second selector equals: #negated.	self assert: self result messages second keywordsPositions equals: #(8) asIntegerArray! !!Trait method!testCascadeExpression1	super testCascadeExpression1.	self assert: self result isCascade.	self assert: self result receiver isLiteralNode.	self assert: self result messages size equals: 2.	self assert: self result messages first receiver equals: self result receiver.	self assert: self result messages first selector equals: #abs.	self assert: self result messages first keywordsPositions equals: #(3) asIntegerArray.	self assert: self result messages second receiver equals: self result receiver.	self assert: self result messages second selector equals: #negated.	self assert: self result messages second keywordsPositions equals: #(8) asIntegerArray! !!Trait method!testCascadeExpression2	super testCascadeExpression2.	self assert: self result isCascade.	self assert: self result receiver isMessage.	self assert: self result receiver receiver isLiteralNode.	self assert: self result receiver receiver value equals: 1.	self assert: self result receiver selector equals: #abs.	self assert: self result receiver keywordsPositions equals: #(3) asIntegerArray.	self assert: self result messages size equals: 3.	self assert: self result messages first receiver equals: self result receiver.	self assert: self result messages first selector equals: #negated.	self assert: self result messages first keywordsPositions equals: #(7) asIntegerArray.	self assert: self result messages second receiver equals: self result receiver.	self assert: self result messages second selector equals: #raisedTo:.	self assert: self result messages second keywordsPositions equals: #(16) asIntegerArray.	self assert: self result messages third receiver equals: self result receiver.	self assert: self result messages third selector equals: #negated.	self assert: self result messages third keywordsPositions equals: #(30) asIntegerArray! !!Trait method!testCascadeExpression2	super testCascadeExpression2.	self assert: self result isCascade.	self assert: self result receiver isMessage.	self assert: self result receiver receiver isLiteralNode.	self assert: self result receiver receiver value equals: 1.	self assert: self result receiver selector equals: #abs.	self assert: self result receiver keywordsPositions equals: #(3) asIntegerArray.	self assert: self result messages size equals: 3.	self assert: self result messages first receiver equals: self result receiver.	self assert: self result messages first selector equals: #negated.	self assert: self result messages first keywordsPositions equals: #(7) asIntegerArray.	self assert: self result messages second receiver equals: self result receiver.	self assert: self result messages second selector equals: #raisedTo:.	self assert: self result messages second keywordsPositions equals: #(16) asIntegerArray.	self assert: self result messages third receiver equals: self result receiver.	self assert: self result messages third selector equals: #negated.	self assert: self result messages third keywordsPositions equals: #(30) asIntegerArray! !!Trait method!testCascadeExpression3	super testCascadeExpression3.	self assert: self result isCascade.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result messages size equals: 2.	self assert: self result messages first receiver equals: self result receiver.	self assert: self result messages first selector equals: #+.	self assert: self result messages first keywordsPositions equals: #(3) asIntegerArray.					self assert: self result messages first arguments size equals: 1.	self assert: self result messages second receiver equals: self result receiver.	self assert: self result messages second selector equals: #-.	self assert: self result messages second keywordsPositions equals: #(8) asIntegerArray.					self assert: self result messages second arguments size equals: 1! !!Trait method!testCascadeExpression3	super testCascadeExpression3.	self assert: self result isCascade.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result messages size equals: 2.	self assert: self result messages first receiver equals: self result receiver.	self assert: self result messages first selector equals: #+.	self assert: self result messages first keywordsPositions equals: #(3) asIntegerArray.					self assert: self result messages first arguments size equals: 1.	self assert: self result messages second receiver equals: self result receiver.	self assert: self result messages second selector equals: #-.	self assert: self result messages second keywordsPositions equals: #(8) asIntegerArray.					self assert: self result messages second arguments size equals: 1! !!Trait method!testCharLiteral1	super testCharLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: $a! !!Trait method!testCharLiteral1	super testCharLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: $a! !!Trait method!testCharLiteral2	super testCharLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: Character space! !!Trait method!testCharLiteral2	super testCharLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: Character space! !!Trait method!testCharLiteral3	super testCharLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: $$! !!Trait method!testCharLiteral3	super testCharLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: $$! !!Trait method!testComment1	super testComment1.	self assert: self result isMessage.	self assert: self result receiver isValue.	self assert: self result selector equals: #+.	self assert: self result arguments first isValue! !!Trait method!testComment1	super testComment1.	self assert: self result isMessage.	self assert: self result receiver isValue.	self assert: self result selector equals: #+.	self assert: self result arguments first isValue! !!Trait method!testComment2	super testComment2.	self assert: self result isMessage.	self assert: self result receiver isValue.	self assert: self result selector equals: #+.	self assert: self result arguments first isValue! !!Trait method!testComment2	super testComment2.	self assert: self result isMessage.	self assert: self result receiver isValue.	self assert: self result selector equals: #+.	self assert: self result arguments first isValue! !!Trait method!testComment3	super testComment3.	self assert: self result isMessage.	self assert: self result receiver isValue.	self assert: self result selector equals: #+.	self assert: self result arguments first isValue! !!Trait method!testComment3	super testComment3.	self assert: self result isMessage.	self assert: self result receiver isValue.	self assert: self result selector equals: #+.	self assert: self result arguments first isValue! !!Trait method!testComment4	super testComment4.	self assert: self result isMessage.	self assert: self result receiver isValue.	self assert: self result selector equals: #+.	self assert: self result arguments first isValue! !!Trait method!testComment4	super testComment4.	self assert: self result isMessage.	self assert: self result receiver isValue.	self assert: self result selector equals: #+.	self assert: self result arguments first isValue! !!Trait method!testComment5	super testComment5.	self assert: self result isMessage.	self assert: self result receiver isValue.	self assert: self result selector equals: #+.	self assert: self result arguments first isValue! !!Trait method!testComment5	super testComment5.	self assert: self result isMessage.	self assert: self result receiver isValue.	self assert: self result selector equals: #+.	self assert: self result arguments first isValue! !!Trait method!testComplexBlock1	super testComplexBlock1.	self assert: self result isBlock.	self assert: self result arguments size equals: 1.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!Trait method!testComplexBlock1	super testComplexBlock1.	self assert: self result isBlock.	self assert: self result arguments size equals: 1.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!Trait method!testComplexBlock2	super testComplexBlock2.	self assert: self result isBlock.	self assert: self result arguments size equals: 1.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!Trait method!testComplexBlock2	super testComplexBlock2.	self assert: self result isBlock.	self assert: self result arguments size equals: 1.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!Trait method!testKeywordExpression1	super testKeywordExpression1.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result selector equals: #to:.	self assert: self result keywordsPositions equals: #(3) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2! !!Trait method!testKeywordExpression1	super testKeywordExpression1.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result receiver value equals: 1.	self assert: self result selector equals: #to:.	self assert: self result keywordsPositions equals: #(3) asIntegerArray.	self assert: self result arguments size equals: 1.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2! !!Trait method!testKeywordExpression2	super testKeywordExpression2.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result selector equals: #to:by:.	self assert: self result keywordsPositions equals: #(3 9) asIntegerArray.	self assert: self result arguments size equals: 2.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2.	self assert: self result arguments second isLiteralNode.	self assert: self result arguments second value equals: 3! !!Trait method!testKeywordExpression2	super testKeywordExpression2.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result selector equals: #to:by:.	self assert: self result keywordsPositions equals: #(3 9) asIntegerArray.	self assert: self result arguments size equals: 2.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2.	self assert: self result arguments second isLiteralNode.	self assert: self result arguments second value equals: 3! !!Trait method!testKeywordExpression3	super testKeywordExpression3.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result selector equals: #to:by:do:.	self assert: self result keywordsPositions equals: #(3 9 15) asIntegerArray.	self assert: self result arguments size equals: 3.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2.	self assert: self result arguments second isLiteralNode.	self assert: self result arguments second value equals: 3.	self assert: self result arguments third isLiteralNode.	self assert: self result arguments third value equals: 4! !!Trait method!testKeywordExpression3	super testKeywordExpression3.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result selector equals: #to:by:do:.	self assert: self result keywordsPositions equals: #(3 9 15) asIntegerArray.	self assert: self result arguments size equals: 3.	self assert: self result arguments first isLiteralNode.	self assert: self result arguments first value equals: 2.	self assert: self result arguments second isLiteralNode.	self assert: self result arguments second value equals: 3.	self assert: self result arguments third isLiteralNode.	self assert: self result arguments third value equals: 4! !!Trait method!testKeywordMethod1	super testKeywordMethod1.	self assert: self result isMethod.	self assert: self result selector equals: #to:.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.			self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testKeywordMethod1	super testKeywordMethod1.	self assert: self result isMethod.	self assert: self result selector equals: #to:.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.			self assert: self result arguments size equals: 1.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testKeywordMethod2	super testKeywordMethod2.	self assert: self result isMethod.	self assert: self result selector equals: #to:do:.	self assert: self result keywordsPositions equals: #(1 7) asIntegerArray.			self assert: self result arguments size equals: 2.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result arguments second isVariable.	self assert: self result arguments second name equals: 'b'.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!Trait method!testKeywordMethod2	super testKeywordMethod2.	self assert: self result isMethod.	self assert: self result selector equals: #to:do:.	self assert: self result keywordsPositions equals: #(1 7) asIntegerArray.			self assert: self result arguments size equals: 2.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result arguments second isVariable.	self assert: self result arguments second name equals: 'b'.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!Trait method!testKeywordMethod3	super testKeywordMethod3.	self assert: self result isMethod.	self assert: self result selector equals: #to:do:by:.	self assert: self result keywordsPositions equals: #(1 7 13) asIntegerArray.				self assert: self result arguments size equals: 3.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result arguments second isVariable.	self assert: self result arguments second name equals: 'b'.	self assert: self result arguments third isVariable.	self assert: self result arguments third name equals: 'c'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1! !!Trait method!testKeywordMethod3	super testKeywordMethod3.	self assert: self result isMethod.	self assert: self result selector equals: #to:do:by:.	self assert: self result keywordsPositions equals: #(1 7 13) asIntegerArray.				self assert: self result arguments size equals: 3.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result arguments second isVariable.	self assert: self result arguments second name equals: 'b'.	self assert: self result arguments third isVariable.	self assert: self result arguments third name equals: 'c'.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1! !!Trait method!testKeywordMethod4	super testKeywordMethod4.	self assert: self result isMethod.	self assert: self result selector equals: #to:do:by:.	self assert: self result keywordsPositions equals: #(1 7 13) asIntegerArray.				self assert: self result arguments size equals: 3.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result arguments second isVariable.	self assert: self result arguments second name equals: 'b'.	self assert: self result arguments third isVariable.	self assert: self result arguments third name equals: 'c'.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!Trait method!testKeywordMethod4	super testKeywordMethod4.	self assert: self result isMethod.	self assert: self result selector equals: #to:do:by:.	self assert: self result keywordsPositions equals: #(1 7 13) asIntegerArray.				self assert: self result arguments size equals: 3.	self assert: self result arguments first isVariable.	self assert: self result arguments first name equals: 'a'.	self assert: self result arguments second isVariable.	self assert: self result arguments second name equals: 'b'.	self assert: self result arguments third isVariable.	self assert: self result arguments third name equals: 'c'.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!Trait method!testMethod1	super testMethod1.	self assert: self result isMethod.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1.	self assert: self result body statements first isReturn.	self assert: self result body statements first value isMessage.	self assert: self result body statements first value receiver isLiteralNode.	self assert: self result body statements first value selector equals: #-.	self assert: self result body statements first value arguments size equals: 1.	self assert: self result body statements first value arguments first isVariable! !!Trait method!testMethod1	super testMethod1.	self assert: self result isMethod.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1.	self assert: self result body statements first isReturn.	self assert: self result body statements first value isMessage.	self assert: self result body statements first value receiver isLiteralNode.	self assert: self result body statements first value selector equals: #-.	self assert: self result body statements first value arguments size equals: 1.	self assert: self result body statements first value arguments first isVariable! !!Trait method!testMethod2	super testMethod2.	self assert: self result isMethod.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1.	self assert: self result body statements first isReturn.	self assert: self result body statements first value isMessage.	self assert: self result body statements first value receiver isLiteralNode.	self assert: self result body statements first value selector equals: #-.	self assert: self result body statements first value arguments size equals: 1.	self assert: self result body statements first value arguments first isVariable! !!Trait method!testMethod2	super testMethod2.	self assert: self result isMethod.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1.	self assert: self result body statements first isReturn.	self assert: self result body statements first value isMessage.	self assert: self result body statements first value receiver isLiteralNode.	self assert: self result body statements first value selector equals: #-.	self assert: self result body statements first value arguments size equals: 1.	self assert: self result body statements first value arguments first isVariable! !!Trait method!testMethod3	super testMethod3.	self assert: self result isMethod.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1.	self assert: self result body statements first isReturn.	self assert: self result body statements first value isMessage.	self assert: self result body statements first value receiver isLiteralNode.	self assert: self result body statements first value selector equals: #-.	self assert: self result body statements first value arguments size equals: 1.	self assert: self result body statements first value arguments first isVariable! !!Trait method!testMethod3	super testMethod3.	self assert: self result isMethod.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1.	self assert: self result body statements first isReturn.	self assert: self result body statements first value isMessage.	self assert: self result body statements first value receiver isLiteralNode.	self assert: self result body statements first value selector equals: #-.	self assert: self result body statements first value arguments size equals: 1.	self assert: self result body statements first value arguments first isVariable! !!Trait method!testNumberLiteral1	super testNumberLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: 0.	self assert: self result value isInteger! !!Trait method!testNumberLiteral1	super testNumberLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: 0.	self assert: self result value isInteger! !!Trait method!testNumberLiteral10	super testNumberLiteral10.	self assert: self result isLiteralNode.	self assert: self result value equals: 10.	self assert: self result value isInteger! !!Trait method!testNumberLiteral10	super testNumberLiteral10.	self assert: self result isLiteralNode.	self assert: self result value equals: 10.	self assert: self result value isInteger! !!Trait method!testNumberLiteral11	super testNumberLiteral11.	self assert: self result isLiteralNode.	self assert: self result value equals: 511.	self assert: self result value isInteger! !!Trait method!testNumberLiteral11	super testNumberLiteral11.	self assert: self result isLiteralNode.	self assert: self result value equals: 511.	self assert: self result value isInteger! !!Trait method!testNumberLiteral12	super testNumberLiteral12.	self assert: self result isLiteralNode.	self assert: self result value equals: 175.	self assert: self result value isInteger! !!Trait method!testNumberLiteral12	super testNumberLiteral12.	self assert: self result isLiteralNode.	self assert: self result value equals: 175.	self assert: self result value isInteger! !!Trait method!testNumberLiteral13	super testNumberLiteral13.	self assert: self result isLiteralNode.	self assert: self result value equals: 202.9921875.	self assert: self result value isFloat! !!Trait method!testNumberLiteral13	super testNumberLiteral13.	self assert: self result isLiteralNode.	self assert: self result value equals: 202.9921875.	self assert: self result value isFloat! !!Trait method!testNumberLiteral14	super testNumberLiteral14.	self assert: self result isLiteralNode.	self assert: self result value floor equals: -9.	self assert: self result value isFloat! !!Trait method!testNumberLiteral14	super testNumberLiteral14.	self assert: self result isLiteralNode.	self assert: self result value floor equals: -9.	self assert: self result value isFloat! !!Trait method!testNumberLiteral15	super testNumberLiteral15.	self assert: self result isLiteralNode.	self assert: self result value equals: 1 / 2! !!Trait method!testNumberLiteral15	super testNumberLiteral15.	self assert: self result isLiteralNode.	self assert: self result value equals: 1 / 2! !!Trait method!testNumberLiteral2	super testNumberLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: 0.1.	self assert: self result value isFloat! !!Trait method!testNumberLiteral2	super testNumberLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: 0.1.	self assert: self result value isFloat! !!Trait method!testNumberLiteral3	super testNumberLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: 123.	self assert: self result value isInteger! !!Trait method!testNumberLiteral3	super testNumberLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: 123.	self assert: self result value isInteger! !!Trait method!testNumberLiteral4	super testNumberLiteral4.	self assert: self result isLiteralNode.	self assert: self result value equals: 123.456.	self assert: self result value isFloat! !!Trait method!testNumberLiteral4	super testNumberLiteral4.	self assert: self result isLiteralNode.	self assert: self result value equals: 123.456.	self assert: self result value isFloat! !!Trait method!testNumberLiteral5	super testNumberLiteral5.	self assert: self result isLiteralNode.	self assert: self result value equals: 0.	self assert: self result value isInteger! !!Trait method!testNumberLiteral5	super testNumberLiteral5.	self assert: self result isLiteralNode.	self assert: self result value equals: 0.	self assert: self result value isInteger! !!Trait method!testNumberLiteral6	super testNumberLiteral6.	self assert: self result isLiteralNode.	self assert: self result value equals: -0.1.	self assert: self result value isFloat! !!Trait method!testNumberLiteral6	super testNumberLiteral6.	self assert: self result isLiteralNode.	self assert: self result value equals: -0.1.	self assert: self result value isFloat! !!Trait method!testNumberLiteral7	super testNumberLiteral7.	self assert: self result isLiteralNode.	self assert: self result value equals: -123.	self assert: self result value isInteger! !!Trait method!testNumberLiteral7	super testNumberLiteral7.	self assert: self result isLiteralNode.	self assert: self result value equals: -123.	self assert: self result value isInteger! !!Trait method!testNumberLiteral8	super testNumberLiteral8.	self assert: self result isLiteralNode.	self assert: self result value equals: -123.	self assert: self result value isInteger! !!Trait method!testNumberLiteral8	super testNumberLiteral8.	self assert: self result isLiteralNode.	self assert: self result value equals: -123.	self assert: self result value isInteger! !!Trait method!testNumberLiteral9	super testNumberLiteral9.	self assert: self result isLiteralNode.	self assert: self result value equals: -123.456.	self assert: self result value isFloat! !!Trait method!testNumberLiteral9	super testNumberLiteral9.	self assert: self result isLiteralNode.	self assert: self result value equals: -123.456.	self assert: self result value isFloat! !!Trait method!testPragma1	super testPragma1.	self 		assert: self result pragmas		format: #('<foo>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma1	super testPragma1.	self 		assert: self result pragmas		format: #('<foo>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma10	super testPragma10.	self 		assert: self result pragmas		format: #('<foo: #bar>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma10	super testPragma10.	self 		assert: self result pragmas		format: #('<foo: #bar>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma11	super testPragma11.	self 		assert: self result pragmas		format: #('<foo: true>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma11	super testPragma11.	self 		assert: self result pragmas		format: #('<foo: true>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma12	super testPragma12.	self 		assert: self result pragmas		format: #('<foo: false>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma12	super testPragma12.	self 		assert: self result pragmas		format: #('<foo: false>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma13	super testPragma13.	self 		assert: self result pragmas		format: #('<foo: nil>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma13	super testPragma13.	self 		assert: self result pragmas		format: #('<foo: nil>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma14	super testPragma14.	self 		assert: self result pragmas		format: #('<foo: #()>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma14	super testPragma14.	self 		assert: self result pragmas		format: #('<foo: #()>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma15	super testPragma15.	self 		assert: self result pragmas		format: #('<foo: #()>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma15	super testPragma15.	self 		assert: self result pragmas		format: #('<foo: #()>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma16	super testPragma16.	self 		assert: self result pragmas		format: #('< + 1>' ).	self assert: self result pragmas first keywordsPositions equals: #(10) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma16	super testPragma16.	self 		assert: self result pragmas		format: #('< + 1>' ).	self assert: self result pragmas first keywordsPositions equals: #(10) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma17	super testPragma17.	self 		assert: self result pragmas		format: #('<foo: 1 bar: 2>' ).	self assert: self result pragmas first keywordsPositions equals: #(9 16) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma17	super testPragma17.	self 		assert: self result pragmas		format: #('<foo: 1 bar: 2>' ).	self assert: self result pragmas first keywordsPositions equals: #(9 16) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma18	super testPragma18.	self 		assert: self result pragmas		format: #('<foo: 1 bar: 2 baz: #b>' ).	self assert: self result pragmas first keywordsPositions equals: #(9 16 24) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma18	super testPragma18.	self 		assert: self result pragmas		format: #('<foo: 1 bar: 2 baz: #b>' ).	self assert: self result pragmas first keywordsPositions equals: #(9 16 24) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma2	super testPragma2.	self 		assert: self result pragmas		format: #('<foo>' '<bar>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.	self assert: self result pragmas second keywordsPositions equals: #(15) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma2	super testPragma2.	self 		assert: self result pragmas		format: #('<foo>' '<bar>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.	self assert: self result pragmas second keywordsPositions equals: #(15) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma3	super testPragma3.	self assert: self result pragmas format: #('<foo>').	self assert: self result pragmas first keywordsPositions equals: #(15) asIntegerArray.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!Trait method!testPragma3	super testPragma3.	self assert: self result pragmas format: #('<foo>').	self assert: self result pragmas first keywordsPositions equals: #(15) asIntegerArray.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!Trait method!testPragma4	super testPragma4.	self assert: self result pragmas format: #('<foo>').	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.		self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!Trait method!testPragma4	super testPragma4.	self assert: self result pragmas format: #('<foo>').	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.		self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!Trait method!testPragma5	super testPragma5.	self assert: self result pragmas format: #('<foo>' '<bar>').	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.	self assert: self result pragmas second keywordsPositions equals: #(21) asIntegerArray.		self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!Trait method!testPragma5	super testPragma5.	self assert: self result pragmas format: #('<foo>' '<bar>').	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.	self assert: self result pragmas second keywordsPositions equals: #(21) asIntegerArray.		self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!Trait method!testPragma6	super testPragma6.	self 		assert: self result pragmas		format: #('<foo: 1>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma6	super testPragma6.	self 		assert: self result pragmas		format: #('<foo: 1>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma7	super testPragma7.	self 		assert: self result pragmas		format: #('<foo: 1.2>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma7	super testPragma7.	self 		assert: self result pragmas		format: #('<foo: 1.2>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma8	super testPragma8.	self 		assert: self result pragmas		format: #('<foo: ''bar''>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma8	super testPragma8.	self 		assert: self result pragmas		format: #('<foo: ''bar''>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma9	super testPragma9.	self 		assert: self result pragmas		format: #('<foo: #bar>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testPragma9	super testPragma9.	self 		assert: self result pragmas		format: #('<foo: #bar>' ).	self assert: self result pragmas first keywordsPositions equals: #(9) asIntegerArray.			self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testSequence1	super testSequence1.	self assert: self result isSequence.	self assert: self result temporaries size equals: 1.	self assert: self result temporaries first isVariable.	self assert: self result temporaries first name equals: 'a'.	self assert: self result statements size equals: 2.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2! !!Trait method!testSequence1	super testSequence1.	self assert: self result isSequence.	self assert: self result temporaries size equals: 1.	self assert: self result temporaries first isVariable.	self assert: self result temporaries first name equals: 'a'.	self assert: self result statements size equals: 2.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2! !!Trait method!testSimpleBlock1	super testSimpleBlock1.	self assert: self result isBlock.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testSimpleBlock1	super testSimpleBlock1.	self assert: self result isBlock.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testSimpleBlock2	super testSimpleBlock2.	self assert: self result isBlock.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1! !!Trait method!testSimpleBlock2	super testSimpleBlock2.	self assert: self result isBlock.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1! !!Trait method!testSimpleBlock3	super testSimpleBlock3.	self assert: self result isBlock.	self assert: self result arguments size equals: 1.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testSimpleBlock3	super testSimpleBlock3.	self assert: self result isBlock.	self assert: self result arguments size equals: 1.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testSpecialLiteral1	super testSpecialLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: true! !!Trait method!testSpecialLiteral1	super testSpecialLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: true! !!Trait method!testSpecialLiteral2	super testSpecialLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: false! !!Trait method!testSpecialLiteral2	super testSpecialLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: false! !!Trait method!testSpecialLiteral3	super testSpecialLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: nil! !!Trait method!testSpecialLiteral3	super testSpecialLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: nil! !!Trait method!testStatementBlock1	super testStatementBlock1.	self assert: self result isBlock.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1! !!Trait method!testStatementBlock1	super testStatementBlock1.	self assert: self result isBlock.	self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1! !!Trait method!testStatementBlock2	super testStatementBlock2.	self assert: self result isBlock.	self assert: self result arguments isEmpty.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!Trait method!testStatementBlock2	super testStatementBlock2.	self assert: self result isBlock.	self assert: self result arguments isEmpty.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!Trait method!testStatementBlock3	super testStatementBlock3.	self assert: self result isBlock.	self assert: self result arguments isEmpty.	self assert: self result body temporaries size equals: 2.	self assert: self result body statements size equals: 1! !!Trait method!testStatementBlock3	super testStatementBlock3.	self assert: self result isBlock.	self assert: self result arguments isEmpty.	self assert: self result body temporaries size equals: 2.	self assert: self result body statements size equals: 1! !!Trait method!testStatements1	super testStatements1.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 1.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger! !!Trait method!testStatements1	super testStatements1.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 1.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger! !!Trait method!testStatements2	super testStatements2.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 2.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2.	self assert: self result statements second value isInteger! !!Trait method!testStatements2	super testStatements2.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 2.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2.	self assert: self result statements second value isInteger! !!Trait method!testStatements3	super testStatements3.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 3.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2.	self assert: self result statements second value isInteger.	self assert: self result statements third isLiteralNode.	self assert: self result statements third value equals: 3.	self assert: self result statements third value isInteger! !!Trait method!testStatements3	super testStatements3.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 3.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2.	self assert: self result statements second value isInteger.	self assert: self result statements third isLiteralNode.	self assert: self result statements third value equals: 3.	self assert: self result statements third value isInteger! !!Trait method!testStatements4	super testStatements4.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 3.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2.	self assert: self result statements second value isInteger.	self assert: self result statements third isLiteralNode.	self assert: self result statements third value equals: 3.	self assert: self result statements third value isInteger! !!Trait method!testStatements4	super testStatements4.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 3.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2.	self assert: self result statements second value isInteger.	self assert: self result statements third isLiteralNode.	self assert: self result statements third value equals: 3.	self assert: self result statements third value isInteger! !!Trait method!testStatements5	super testStatements5.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 2.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2.	self assert: self result statements second value isInteger! !!Trait method!testStatements5	super testStatements5.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 2.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2.	self assert: self result statements second value isInteger! !!Trait method!testStatements6	super testStatements6.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 2.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2.	self assert: self result statements second value isInteger! !!Trait method!testStatements6	super testStatements6.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 2.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger.	self assert: self result statements second isLiteralNode.	self assert: self result statements second value equals: 2.	self assert: self result statements second value isInteger! !!Trait method!testStatements7	super testStatements7.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 1.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger! !!Trait method!testStatements7	super testStatements7.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 1.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger! !!Trait method!testStatements8	super testStatements8.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 1.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger! !!Trait method!testStatements8	super testStatements8.	self assert: self result isSequence.	self assert: self result temporaries isEmpty.	self assert: self result statements size equals: 1.	self assert: self result statements first isLiteralNode.	self assert: self result statements first value equals: 1.	self assert: self result statements first value isInteger! !!Trait method!testStatements9	super testStatements9.	self assert: self result isEmpty.! !!Trait method!testStatements9	super testStatements9.	self assert: self result isEmpty.! !!Trait method!testStringLiteral1	super testStringLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: ''! !!Trait method!testStringLiteral1	super testStringLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: ''! !!Trait method!testStringLiteral2	super testStringLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: 'ab'! !!Trait method!testStringLiteral2	super testStringLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: 'ab'! !!Trait method!testStringLiteral3	super testStringLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: 'ab''cd'! !!Trait method!testStringLiteral3	super testStringLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: 'ab''cd'! !!Trait method!testSymbolLiteral1	super testSymbolLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: #foo.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral1	super testSymbolLiteral1.	self assert: self result isLiteralNode.	self assert: self result value equals: #foo.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral2	super testSymbolLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: #+.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral2	super testSymbolLiteral2.	self assert: self result isLiteralNode.	self assert: self result value equals: #+.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral3	super testSymbolLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: #key:.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral3	super testSymbolLiteral3.	self assert: self result isLiteralNode.	self assert: self result value equals: #key:.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral4	super testSymbolLiteral4.	self assert: self result isLiteralNode.	self assert: self result value equals: #key:value:.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral4	super testSymbolLiteral4.	self assert: self result isLiteralNode.	self assert: self result value equals: #key:value:.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral5	super testSymbolLiteral5.	self assert: self result isLiteralNode.	self assert: self result value equals: #'testing-result'.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral5	super testSymbolLiteral5.	self assert: self result isLiteralNode.	self assert: self result value equals: #'testing-result'.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral6	super testSymbolLiteral6.	self assert: self result isLiteralNode.	self assert: self result value equals: #'__gen__binding'.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral6	super testSymbolLiteral6.	self assert: self result isLiteralNode.	self assert: self result value equals: #'__gen__binding'.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral7	super testSymbolLiteral7.	self assert: self result isLiteralNode.	self assert: self result value equals: #fucker.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral7	super testSymbolLiteral7.	self assert: self result isLiteralNode.	self assert: self result value equals: #fucker.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral8	super testSymbolLiteral8.	self assert: self result isLiteralNode.	self assert: self result value equals: #fucker.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral8	super testSymbolLiteral8.	self assert: self result isLiteralNode.	self assert: self result value equals: #fucker.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral9	super testSymbolLiteral9.	self assert: self result isLiteralNode.	self assert: self result value equals: #fucker.	self assert: self result value isSymbol! !!Trait method!testSymbolLiteral9	super testSymbolLiteral9.	self assert: self result isLiteralNode.	self assert: self result value equals: #fucker.	self assert: self result value isSymbol! !!Trait method!testTemporaries1	super testTemporaries1.	self assert: self result isSequence.	self assert: self result temporaries size equals: 1.	self assert: self result temporaries first isVariable.	self assert: self result temporaries first name equals: 'a'.	self assert: self result statements isEmpty! !!Trait method!testTemporaries1	super testTemporaries1.	self assert: self result isSequence.	self assert: self result temporaries size equals: 1.	self assert: self result temporaries first isVariable.	self assert: self result temporaries first name equals: 'a'.	self assert: self result statements isEmpty! !!Trait method!testTemporaries2	super testTemporaries2.	self assert: self result isSequence.	self assert: self result temporaries size equals: 2.	self assert: self result temporaries first isVariable.	self assert: self result temporaries first name equals: 'a'.	self assert: self result temporaries second isVariable.	self assert: self result temporaries second name equals: 'b'.	self assert: self result statements isEmpty! !!Trait method!testTemporaries2	super testTemporaries2.	self assert: self result isSequence.	self assert: self result temporaries size equals: 2.	self assert: self result temporaries first isVariable.	self assert: self result temporaries first name equals: 'a'.	self assert: self result temporaries second isVariable.	self assert: self result temporaries second name equals: 'b'.	self assert: self result statements isEmpty! !!Trait method!testTemporaries3	super testTemporaries3.	self assert: self result isSequence.	self assert: self result temporaries size equals: 3.	self assert: self result temporaries first isVariable.	self assert: self result temporaries first name equals: 'a'.	self assert: self result temporaries second isVariable.	self assert: self result temporaries second name equals: 'b'.	self assert: self result temporaries third isVariable.	self assert: self result temporaries third name equals: 'c'.	self assert: self result statements isEmpty! !!Trait method!testTemporaries3	super testTemporaries3.	self assert: self result isSequence.	self assert: self result temporaries size equals: 3.	self assert: self result temporaries first isVariable.	self assert: self result temporaries first name equals: 'a'.	self assert: self result temporaries second isVariable.	self assert: self result temporaries second name equals: 'b'.	self assert: self result temporaries third isVariable.	self assert: self result temporaries third name equals: 'c'.	self assert: self result statements isEmpty! !!Trait method!testUnaryExpression1	super testUnaryExpression1.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(3) asIntegerArray.			self assert: self result arguments isEmpty! !!Trait method!testUnaryExpression1	super testUnaryExpression1.	self assert: self result isMessage.	self assert: self result receiver isLiteralNode.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(3) asIntegerArray.			self assert: self result arguments isEmpty! !!Trait method!testUnaryExpression2	super testUnaryExpression2.	self assert: self result isMessage.	self assert: self result receiver isMessage.	self assert: self result receiver receiver isLiteralNode.	self assert: self result receiver receiver value equals: 1.	self assert: self result receiver selector equals: #abs.	self assert: self result receiver keywordsPositions equals: #(3) asIntegerArray.			self assert: self result receiver arguments isEmpty.	self assert: self result selector equals: #negated.	self assert: self result keywordsPositions equals: #(7) asIntegerArray.			self assert: self result arguments isEmpty! !!Trait method!testUnaryExpression2	super testUnaryExpression2.	self assert: self result isMessage.	self assert: self result receiver isMessage.	self assert: self result receiver receiver isLiteralNode.	self assert: self result receiver receiver value equals: 1.	self assert: self result receiver selector equals: #abs.	self assert: self result receiver keywordsPositions equals: #(3) asIntegerArray.			self assert: self result receiver arguments isEmpty.	self assert: self result selector equals: #negated.	self assert: self result keywordsPositions equals: #(7) asIntegerArray.			self assert: self result arguments isEmpty! !!Trait method!testUnaryMethod1	super testUnaryMethod1.	self assert: self result isMethod.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.			self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testUnaryMethod1	super testUnaryMethod1.	self assert: self result isMethod.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.			self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements isEmpty! !!Trait method!testUnaryMethod2	super testUnaryMethod2.	self assert: self result isMethod.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.				self assert: self result arguments isEmpty.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!Trait method!testUnaryMethod2	super testUnaryMethod2.	self assert: self result isMethod.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.				self assert: self result arguments isEmpty.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!Trait method!testUnaryMethod3	super testUnaryMethod3.	self assert: self result isMethod.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.				self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1! !!Trait method!testUnaryMethod3	super testUnaryMethod3.	self assert: self result isMethod.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.				self assert: self result arguments isEmpty.	self assert: self result body temporaries isEmpty.	self assert: self result body statements size equals: 1! !!Trait method!testUnaryMethod4	super testUnaryMethod4.	self assert: self result isMethod.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.				self assert: self result arguments isEmpty.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!Trait method!testUnaryMethod4	super testUnaryMethod4.	self assert: self result isMethod.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.				self assert: self result arguments isEmpty.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements size equals: 1! !!Trait method!testUnaryMethod5	super testUnaryMethod5.	self assert: self result isMethod.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.			self assert: self result arguments isEmpty.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!Trait method!testUnaryMethod5	super testUnaryMethod5.	self assert: self result isMethod.	self assert: self result selector equals: #abs.	self assert: self result keywordsPositions equals: #(1) asIntegerArray.			self assert: self result arguments isEmpty.	self assert: self result body temporaries size equals: 1.	self assert: self result body statements isEmpty! !!Trait method!testVariable1	super testVariable1.	self assert: self result isVariable.	self assert: self result name equals: 'trueBinding'! !!Trait method!testVariable1	super testVariable1.	self assert: self result isVariable.	self assert: self result name equals: 'trueBinding'! !!Trait method!testVariable2	super testVariable2.	self assert: self result isVariable.	self assert: self result name equals: 'falseBinding'! !!Trait method!testVariable2	super testVariable2.	self assert: self result isVariable.	self assert: self result name equals: 'falseBinding'! !!Trait method!testVariable3	super testVariable3.	self assert: self result isVariable.	self assert: self result name equals: 'nilly'! !!Trait method!testVariable3	super testVariable3.	self assert: self result isVariable.	self assert: self result name equals: 'nilly'! !!Trait method!testVariable4	super testVariable4.	self assert: self result isVariable.	self assert: self result name equals: 'selfish'! !!Trait method!testVariable4	super testVariable4.	self assert: self result isVariable.	self assert: self result name equals: 'selfish'! !!Trait method!testVariable5	super testVariable5.	self assert: self result isVariable.	self assert: self result name equals: 'supernanny'! !!Trait method!testVariable5	super testVariable5.	self assert: self result isVariable.	self assert: self result name equals: 'supernanny'! !!Trait method!testVariable6	super testVariable6.	self assert: self result isVariable.	self assert: self result name equals: 'super_nanny'! !!Trait method!testVariable6	super testVariable6.	self assert: self result isVariable.	self assert: self result name equals: 'super_nanny'! !!Trait method!testVariable7	super testVariable7.	self assert: self result isVariable.	self assert: self result name equals: '__gen_var_123__'! !!Trait method!testVariable7	super testVariable7.	self assert: self result isVariable.	self assert: self result name equals: '__gen_var_123__'! !"PetitParser2-Smalltalk-Tests"!!PP2Sources methodsFor: '*PetitParser2-Html' stamp: ' 12/6/2016 07:12:31'!htmlAllUrl	^ 'html-src.zip'! !!PP2Sources methodsFor: '*PetitParser2-Html' stamp: ' 12/6/2016 07:12:31'!htmlSample	^ '<!!DOCTYPE html><!!-- saved from url=(0026)https://www.wikipedia.org/ --><html lang="mul" dir="ltr" class="js-enabled"><head>	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">	<title>Wikipedia</title>	<meta name="description" content="Wikipedia is a free online encyclopedia, created and edited by volunteers around the world and hosted by the Wikimedia Foundation.">	<!!--[if gt IE 7]-->	<script>document.documentElement.className = document.documentElement.className.replace( /(^|\s)no-js(\s|$)/, "$1js-enabled$2" );</script>	<!!--[endif]--></head><body id="www-wikipedia-org">	<h1 class="central-textlogo" style="font-variant: small-caps" alt="WikipediA" title="Wikipedia">		<img src="./Wikipedia_files/Wikipedia_wordmark.png" srcset="portal/wikipedia.org/assets/img/Wikipedia_wordmark@1.5x.png 1.5x" width="174" height="30" alt="WikipediA" title="Wikipedia">		<strong id="js-localized-slogan" class="localized-slogan" style="visibility: visible;">The Free Encyclopedia</strong>	</h1>	<div id="mydiv">		Hi there!!	</div>	<script>alert("All scripts ends with: ''</script>''...")</script>	<!!-- <p>obsolete conentent</p> --></body></html>'! !!PP2Sources methodsFor: '*PetitParser2-Html' stamp: ' 12/6/2016 07:12:31'!htmlSourcesAll	^ self cachedValue: #htmlSourcesAll ifAbsentPut: [ 		(self downloadUI: self htmlAllUrl) allFiles collect: [ :f | f contents ]	]! !!PP2HtmlElement methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!children	^ children! !!PP2HtmlElement methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!children: anObject	children := anObject! !!PP2HtmlElement methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!displayText	^ self name! !!PP2HtmlElement methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!firstChild	^ self children first! !!PP2HtmlElement methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!name	^ name! !!PP2HtmlElement methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!name: newName	name := newName	! !!PP2HtmlElement methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!secondChild	^ self children second! !!PP2HtmlText methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!displayText	^ self text trim! !!PP2HtmlText methodsFor: 'gt' stamp: ' 12/6/2016 07:12:31'!gtText: composite	<gtInspectorPresentationOrder: 40>		composite text		title: 'Text';		display: [ :context | text ]! !!PP2HtmlText methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!text	^ text! !!PP2HtmlText methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!text: anObject	text := anObject! !!PP2JavascriptElement methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!code	^ code! !!PP2JavascriptElement methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!code: anObject	code := anObject! !!PP2JavascriptElement methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!displayText	^ self code! !!PP2JavascriptElement methodsFor: 'gt' stamp: ' 12/6/2016 07:12:31'!gtText: composite	<gtInspectorPresentationOrder: 40>		composite text		title: 'Text';		display: [ :context | code ]! !!PP2WebElement methodsFor: 'enumerating' stamp: ' 12/6/2016 07:12:31'!allElements	| result |	result := OrderedCollection new.	self allElementsDo: [ :parser | result addLast: parser ].	^ result! !!PP2WebElement methodsFor: 'enumerating' stamp: ' 12/6/2016 07:12:31'!allElementsDo: aBlock	^ self allElementsDo: aBlock seen: IdentitySet new! !!PP2WebElement methodsFor: 'enumerating' stamp: ' 12/6/2016 07:12:31'!allElementsDo: aBlock seen: aSet	"		Iterate over all the parse nodes of the receiver, do not visit the ones contained in aSet.	"	(aSet includes: self) ifTrue: [ ^ self ].	aSet add: self.		aBlock value: self.	self children do: [ :each | each allElementsDo: aBlock seen: aSet ]! !!PP2WebElement methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!children	^ #()! !!PP2WebElement methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!displayText	'abstract element'! !!PP2WebElement methodsFor: 'gui' stamp: ' 12/6/2016 07:12:31'!gtTreeViewIn: composite	<gtInspectorPresentationOrder: 40>	composite tree			title: 'Tree';			children: [:n | n children ];			format: [:n| n displayText printStringLimitedTo: 50 ];			shouldExpandToLevel: 6! !!PP2WebPageGrammar methodsFor: 'others' stamp: ' 12/6/2016 07:12:31'!any	^ #any asPParser! !!PP2WebPageGrammar methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!document	^ element sea! !!PP2WebPageGrammar methodsFor: 'element' stamp: ' 12/6/2016 07:12:31'!elClose	^ '</' asPParser, elementName match pop, $> asPParser! !!PP2WebPageGrammar methodsFor: 'element' stamp: ' 12/6/2016 07:12:31'!elContent	^ (javascript / element / rawText nonEpsilon)  star! !!PP2WebPageGrammar methodsFor: 'element' stamp: ' 12/6/2016 07:12:31'!elOpen	^ $< asPParser, elementName push, #water asPParser, $> asPParser ==> #second! !!PP2WebPageGrammar methodsFor: 'element' stamp: ' 12/6/2016 07:12:31'!elWater	^ identifier / whitespaces / any! !!PP2WebPageGrammar methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!element	^ (elOpen, elContent, elClose)		memoize;		yourself	! !!PP2WebPageGrammar methodsFor: 'element' stamp: ' 12/6/2016 07:12:31'!elementName	^ #word asPParser plus flatten! !!PP2WebPageGrammar methodsFor: 'others' stamp: ' 12/6/2016 07:12:31'!identifier	^ #letter asPParser, #word asPParser plus! !!PP2WebPageGrammar methodsFor: 'javascript' stamp: ' 12/6/2016 07:12:31'!javascript	^ (jsOpen, jsContent, jsClose)! !!PP2WebPageGrammar methodsFor: 'javascript' stamp: ' 12/6/2016 07:12:31'!jsClose	^ '</script>' asPParser! !!PP2WebPageGrammar methodsFor: 'javascript' stamp: ' 12/6/2016 07:12:31'!jsContent	^ #epsilon asPParser sea 		waterToken: jsWater;		flatten! !!PP2WebPageGrammar methodsFor: 'javascript' stamp: ' 12/6/2016 07:12:31'!jsDoubleQuoteString	^ $" asPParser, #water asPParser, $" asPParser! !!PP2WebPageGrammar methodsFor: 'javascript' stamp: ' 12/6/2016 07:12:31'!jsOpen	^ ('<script type=' asPParser, jsTypeString, '>' asPParser) /	  ('<script>' asPParser)! !!PP2WebPageGrammar methodsFor: 'javascript' stamp: ' 12/6/2016 07:12:31'!jsSingleQuoteString	^ $' asPParser, #water asPParser, $' asPParser! !!PP2WebPageGrammar methodsFor: 'javascript' stamp: ' 12/6/2016 07:12:31'!jsString	^ jsDoubleQuoteString / jsSingleQuoteString! !!PP2WebPageGrammar methodsFor: 'javascript' stamp: ' 12/6/2016 07:12:31'!jsType	^ 'text/javascript' asPParser! !!PP2WebPageGrammar methodsFor: 'javascript' stamp: ' 12/6/2016 07:12:31'!jsTypeString	^ ($" asPParser, jsType, $" asPParser) /	  ($' asPParser, jsType, $' asPParser)! !!PP2WebPageGrammar methodsFor: 'javascript' stamp: ' 12/6/2016 07:12:31'!jsWater	^ identifier / jsString / whitespaces / any! !!PP2WebPageGrammar methodsFor: 'element' stamp: ' 12/6/2016 07:12:31'!rawText	^ #water asPParser! !!PP2WebPageGrammar methodsFor: 'accessing' stamp: ' 12/6/2016 07:12:31'!start	^ document! !!PP2WebPageGrammar methodsFor: 'others' stamp: ' 12/6/2016 07:12:31'!whitespaces	^ #space asPParser plus! !!PP2WebPageParser methodsFor: 'as yet unclassified' stamp: ' 12/6/2016 07:12:31'!document	^ super document		map: [ :_bw :_document :_aw |		| beforeWater afterWater |		beforeWater := PP2HtmlText new			text: _bw;			yourself.					afterWater := PP2HtmlText new			text: _aw;			yourself.					PP2HtmlElement new			name: 'ROOT';			children: (Array with: beforeWater with: _document with: afterWater);			yourself		]! !!PP2WebPageParser methodsFor: 'element' stamp: ' 12/6/2016 07:12:31'!elClose	^ super elClose trim! !!PP2WebPageParser methodsFor: 'element' stamp: ' 12/6/2016 07:12:31'!elOpen	^ super elOpen trim! !!PP2WebPageParser methodsFor: 'element' stamp: ' 12/6/2016 07:12:31'!element	^ super element 		map: [ :_open :_content :_close | 	 	(PP2HtmlElement new)			name: _open;			children: _content;			yourself	]! !!PP2WebPageParser methodsFor: 'javascript' stamp: ' 12/6/2016 07:12:31'!javascript	^ super javascript 		map: [ :_open :_content :_close | 	 	(PP2JavascriptElement new)			code: _content;			yourself	]! !!PP2WebPageParser methodsFor: 'element' stamp: ' 12/6/2016 07:12:31'!rawText	^ super rawText 		map: [ :_value | 		PP2HtmlText new			text: _value;			yourself		]! !"PetitParser2-Html"!!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!PP2WebPageGrammarTest methodsFor: 'accessing' stamp: '10/31/2016 15:27:09'!context	context isNil ifTrue: [ 		context := super context	].	^ context! !!PP2WebPageGrammarTest methodsFor: 'accessing' stamp: '10/31/2016 15:27:09'!parserClass	^ PP2WebPageGrammar ! !!PP2WebPageGrammarTest methodsFor: 'tests - document' stamp: '10/31/2016 15:27:09'!testDocument	input := '<html>		<body>			<script type="text/javascript">alert("hello world")</script>		</body>	</html>'.		self parse: input rule: #document! !!PP2WebPageGrammarTest methodsFor: 'tests - document' stamp: 'JanKurs 11/2/2016 14:17'!testDocument2	input := '<!!DOCTYPE html><!!-- comment --><html>	<meta content="origin" name="referrer">	<body>		<script type="text/javascript">alert("hello world")</script>	</body></html>'.		self parse: input rule: #document! !!PP2WebPageGrammarTest methodsFor: 'tests - document' stamp: 'JanKurs 11/2/2016 14:18'!testDocument3	input := '<!!DOCTYPE html><!!-- comment --><html>	<meta content="origin" name="referrer">	<body>		<div>foobar</div>		<div>bar<span>baz</span></div>	</body></html>'.		self parse: input rule: #document! !!PP2WebPageGrammarTest methodsFor: 'tests - document' stamp: 'JanKurs 11/4/2016 18:28'!testDocument4	input := '<html>	<head>	<meta content="text/mess">	<meta content="text/mess">	</head>	<body>	</body></html>'.		self parse: input rule: #document! !!PP2WebPageGrammarTest methodsFor: 'tests - element' stamp: '10/31/2016 15:27:09'!testElClose	self context defaultStack push: 'foo'.	self parse: '</foo>' rule: #elClose! !!PP2WebPageGrammarTest methodsFor: 'tests - element' stamp: '10/31/2016 15:27:09'!testElContent	self parse: '' rule: #elContent.	self parse: 'foobar' rule: #elContent.	self parse: '<script type="text/javascript">eh</script>' rule: #elContent.! !!PP2WebPageGrammarTest methodsFor: 'tests - element' stamp: '10/31/2016 15:27:09'!testElOpen	self parse: '<foo id="bar">' rule: #elOpen! !!PP2WebPageGrammarTest methodsFor: 'tests' stamp: '10/31/2016 15:27:09'!testElement	self parse: '<p>lorem ipsum</p>' rule: #element! !!PP2WebPageGrammarTest methodsFor: 'tests - element' stamp: '10/31/2016 15:27:09'!testElementEmpty	self parse: '<foo></foo>' rule: #element! !!PP2WebPageGrammarTest methodsFor: 'tests - element' stamp: '10/31/2016 15:27:09'!testElementMalformed	self parse: '<foo><bar>meh</baz></foo>' rule: #element.! !!PP2WebPageGrammarTest methodsFor: 'tests' stamp: '10/31/2016 15:27:09'!testElementMalformedExtraClose	self parse: '<foo><bar>meh</bar></fii></foo>' rule: #element! !!PP2WebPageGrammarTest methodsFor: 'tests' stamp: '10/31/2016 15:27:09'!testElementMalformedSwapped	self fail: '<foo><bar>meh</foo></bar>' rule: #element! !!PP2WebPageGrammarTest methodsFor: 'tests - element' stamp: 'JanKurs 11/8/2016 08:47'!testElementMalformedUnclosed	self parse: '<head><meta content="mess"></head>' rule: #element.! !!PP2WebPageGrammarTest methodsFor: 'tests' stamp: '10/31/2016 15:27:09'!testElementNested	self parse: '<p>lorem <i>ipsum</i></p>' rule: #element! !!PP2WebPageGrammarTest methodsFor: 'tests - javascript' stamp: '10/31/2016 15:27:09'!testJavascript	self parse: '<script type=''text/javascript''>alert(1+2)</script>' rule: #javascript! !!PP2WebPageGrammarTest methodsFor: 'tests - javascript' stamp: '10/31/2016 15:27:09'!testJavascriptContentString	self parse: 'alert("foobar")' rule: #jsContent.	self parse: 'alert("</script>")' rule: #jsContent	! !!PP2WebPageGrammarTest methodsFor: 'tests - javascript' stamp: 'JanKurs 11/4/2016 21:02'!testJavascriptShort	self parse: '<script>alert(1+2)</script>' rule: #javascript! !!PP2WebPageGrammarTest methodsFor: 'tests - javascript' stamp: '10/31/2016 15:27:09'!testJavascriptWithString	self parse: '<script type=''text/javascript''>alert("</script>")</script>' rule: #javascript! !!PP2WebPageGrammarTest methodsFor: 'tests - javascript' stamp: '10/31/2016 15:27:09'!testJsDoubleQuoteStringJavascript	self parse: '"Hello World!!"' rule: #jsDoubleQuoteString	.	self parse: '"</script>"' rule: #jsDoubleQuoteString! !!PP2WebPageGrammarTest methodsFor: 'tests' stamp: '10/31/2016 15:27:09'!testRawText	self parse: 'foobar' rule: #rawText! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!PP2WebPageParserTest methodsFor: 'accessing' stamp: '10/31/2016 15:27:09'!parserClass	^ PP2WebPageParser ! !!PP2WebPageParserTest methodsFor: 'accessing' stamp: 'JanKurs 11/2/2016 15:17'!result	^ result! !!PP2WebPageParserTest methodsFor: 'accessing' stamp: 'JanKurs 11/8/2016 08:53'!scripts: rootElement	^ rootElement allElements select: [ :e | e isKindOf: PP2JavascriptElement  ]! !!PP2WebPageParserTest methodsFor: 'tests - document' stamp: 'JanKurs 11/8/2016 08:53'!testDocument2	| scripts htmlElement |	super testDocument2.		scripts := self scripts: self result.	self assert: scripts size equals: 1.	self assert: scripts first code equals: 'alert("hello world")'.		htmlElement := self result secondChild.	self assert: htmlElement name equals: 'html'.	self assert: htmlElement children size equals: 2.	self assert: htmlElement firstChild isKindOf: PP2HtmlText.	self assert: htmlElement secondChild name equals: 'body'.! !!PP2WebPageParserTest methodsFor: 'tests' stamp: '10/31/2016 15:27:09'!testElement	super testElement.		self assert: result name equals: 'p'.	self assert: result firstChild text equals: 'lorem ipsum'! !!PP2WebPageParserTest methodsFor: 'tests' stamp: '10/31/2016 15:27:09'!testElementEmpty	super testElementEmpty.		self assert: result name equals: 'foo'.! !!PP2WebPageParserTest methodsFor: 'tests' stamp: '10/31/2016 15:27:09'!testElementMalformed	super testElementMalformed.		self assert: result name equals: 'foo'.	self assert: result firstChild text equals: '<bar>meh</baz>'! !!PP2WebPageParserTest methodsFor: 'tests' stamp: '10/31/2016 15:27:09'!testElementMalformedExtraClose	super testElementMalformedExtraClose.		self assert: result name equals: 'foo'.	self assert: result secondChild text equals: '</fii>'! !!PP2WebPageParserTest methodsFor: 'tests' stamp: 'JanKurs 11/8/2016 08:48'!testElementMalformedUnclosed	super testElementMalformedUnclosed.		self assert: result name equals: 'head'.	self assert: result firstChild text trim equals: '<meta content="mess">'! !!PP2WebPageParserTest methodsFor: 'tests' stamp: 'JanKurs 11/2/2016 11:59'!testElementNested	super testElementNested.		self assert: result name equals: 'p'.	self assert: result firstChild text trim equals: 'lorem'.	self assert: result secondChild name equals: 'i'.	self assert: result secondChild firstChild text equals: 'ipsum'! !!PP2WebPageParserTest methodsFor: 'tests' stamp: 'JanKurs 11/8/2016 08:53'!testJavascript	super testJavascript.		self assert: result isKindOf: PP2JavascriptElement.	self assert: result code equals: 'alert(1+2)'! !!PP2WebPageParserTest methodsFor: 'tests' stamp: 'JanKurs 11/8/2016 08:53'!testJavascriptWithString	super testJavascriptWithString.		self assert: result isKindOf: PP2JavascriptElement.	self assert: result code equals: 'alert("</script>")'! !!PP2WebPageParserTest methodsFor: 'tests' stamp: 'JanKurs 11/8/2016 08:53'!testRawText	super testRawText.		self assert: result isKindOf: PP2HtmlText.	self assert: result text equals: 'foobar'.! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!PP2WebPageParserTest_Optimized methodsFor: 'accessing' stamp: 'JanKurs 11/2/2016 15:19'!parserClass	^ PP2WebPageParser ! !!PP2WebPageParserTest_Optimized methodsFor: 'accessing' stamp: 'JanKurs 11/2/2016 16:09'!parserInstanceFor: aSymbol	^ (super parserInstanceFor: aSymbol) optimize;		resetCaches;		yourself! !!PP2WebPageParserTest_Optimized methodsFor: 'accessing' stamp: 'JanKurs 11/2/2016 15:18'!result	^ result! !!PP2WebPageParserTest_Optimized methodsFor: 'accessing' stamp: 'JanKurs 11/8/2016 08:53'!scripts: rootElement	^ rootElement allElements select: [ :e | e isKindOf: PP2JavascriptElement  ]! !!PP2WebPageParserTest_Optimized methodsFor: 'tests - document' stamp: 'JanKurs 11/8/2016 08:53'!testDocument2	| scripts htmlElement |	super testDocument2.		scripts := self scripts: self result.	self assert: scripts size equals: 1.	self assert: scripts first code equals: 'alert("hello world")'.		htmlElement := self result secondChild.	self assert: htmlElement name equals: 'html'.	self assert: htmlElement children size equals: 2.	self assert: htmlElement firstChild isKindOf: PP2HtmlText.	self assert: htmlElement secondChild name equals: 'body'.! !!TPP2WebPageParserTest methodsFor: 'assertions' stamp: '' prior: 36927221!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!TPP2WebPageParserTest methodsFor: 'assertions' stamp: '' prior: 36927315!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!TPP2WebPageParserTest methodsFor: 'accessing' stamp: 'JanKurs 11/2/2016 15:17'!result	self explicitRequirement! !!TPP2WebPageParserTest methodsFor: 'accessing' stamp: 'JanKurs 11/2/2016 15:16'!scripts: rootElement	^ rootElement allElements select: [ :e | e isKindOf: JavascriptElement  ]! !!TPP2WebPageParserTest methodsFor: 'tests - document' stamp: 'JanKurs 11/2/2016 15:17'!testDocument	| scripts |	super testDocument.		scripts := self scripts: self result.	self assert: scripts size equals: 1.	self assert: scripts first code equals: 'alert("hello world")'! !!TPP2WebPageParserTest methodsFor: 'tests - document' stamp: 'JanKurs 11/2/2016 15:17'!testDocument2	| scripts htmlElement |	super testDocument2.		scripts := self scripts: self result.	self assert: scripts size equals: 1.	self assert: scripts first code equals: 'alert("hello world")'.		htmlElement := self result secondChild.	self assert: htmlElement name equals: 'html'.	self assert: htmlElement children size equals: 2.	self assert: htmlElement firstChild isKindOf: HtmlText.	self assert: htmlElement secondChild name equals: 'body'.! !!TPP2WebPageParserTest methodsFor: 'tests - document' stamp: 'JanKurs 11/2/2016 15:17'!testDocument3	| htmlElement bodyElement |	super testDocument3.		htmlElement := self result secondChild.	self assert: htmlElement name equals: 'html'.	self assert: htmlElement children size equals: 2.	self assert: htmlElement secondChild name equals: 'body'.		bodyElement := htmlElement secondChild.	self assert: bodyElement children size equals: 2.	self assert: bodyElement secondChild secondChild name equals: 'span'.! !!TPP2WebPageParserTest methodsFor: 'tests - document' stamp: 'JanKurs 11/4/2016 18:25'!testDocument4	| htmlElement |	super testDocument4.		htmlElement := self result secondChild.	self assert: htmlElement name equals: 'html'.	self assert: htmlElement firstChild name equals: 'head'.! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!Trait method!testDocument	| scripts |	super testDocument.		scripts := self scripts: self result.	self assert: scripts size equals: 1.	self assert: scripts first code equals: 'alert("hello world")'! !!Trait method!testDocument	| scripts |	super testDocument.		scripts := self scripts: self result.	self assert: scripts size equals: 1.	self assert: scripts first code equals: 'alert("hello world")'! !!Trait method!testDocument3	| htmlElement bodyElement |	super testDocument3.		htmlElement := self result secondChild.	self assert: htmlElement name equals: 'html'.	self assert: htmlElement children size equals: 2.	self assert: htmlElement secondChild name equals: 'body'.		bodyElement := htmlElement secondChild.	self assert: bodyElement children size equals: 2.	self assert: bodyElement secondChild secondChild name equals: 'span'.! !!Trait method!testDocument3	| htmlElement bodyElement |	super testDocument3.		htmlElement := self result secondChild.	self assert: htmlElement name equals: 'html'.	self assert: htmlElement children size equals: 2.	self assert: htmlElement secondChild name equals: 'body'.		bodyElement := htmlElement secondChild.	self assert: bodyElement children size equals: 2.	self assert: bodyElement secondChild secondChild name equals: 'span'.! !!Trait method!testDocument4	| htmlElement |	super testDocument4.		htmlElement := self result secondChild.	self assert: htmlElement name equals: 'html'.	self assert: htmlElement firstChild name equals: 'head'.! !!Trait method!testDocument4	| htmlElement |	super testDocument4.		htmlElement := self result secondChild.	self assert: htmlElement name equals: 'html'.	self assert: htmlElement firstChild name equals: 'head'.! !"PetitParser2-Html-Tests"!----QUIT----2016-12-06T07:12:38.68739+01:00 PharoPP2.image priorSource: 2467751!!Trait method!assert: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass)! !!Trait method!deny: anObject isKindOf: aClass	self assert: (anObject isKindOf: aClass) not! !!WebGrammarTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!parserClass	^ WebGrammar! !!WebGrammarTest methodsFor: 'tests' stamp: '11/16/2016 19:01:21'!testComment	self parse: '<!!-- html comment -->' rule: #comment! !!WebGrammarTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!testDocument	| input |	input := PP2Sources current htmlSample.		self parse: input rule: #document.	self assert: result size equals: 2.! !!WebGrammarTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!testElement	self parse: '<p>lorem ipsum</p>' rule: #element! !!WebGrammarTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!testElementEmpty	self parse: '<foo></foo>' rule: #element! !!WebGrammarTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!testElementMalformedExtraClose	self parse: '<foo><bar>meh</bar></fii></foo>' rule: #element! !!WebGrammarTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!testElementMalformedUnclosed	self parse: '<head><meta content="mess"></head>' rule: #element.! !!WebGrammarTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!testElementMalformedWrongClose	self parse: '<foo><bar>meh</baz></foo>' rule: #element.! !!WebGrammarTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!testElementNested	self parse: '<p>lorem <i>ipsum</i></p>' rule: #element! !!WebGrammarTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!testJavascript	self parse: '<script>alert("hi there!!")</script>' rule: #javascript	! !!WebGrammarTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!testJavascriptWithString	self parse: '<script>alert(''</script>'')</script>' rule: #javascript! !!WebGrammarTest methodsFor: 'tests' stamp: '11/16/2016 19:01:21'!testStructuredDocument	| input |	input := PP2Sources current htmlSample.		self parse: input rule: #structuredDocument! !!WebGrammarTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!testText	self parse: 'foobar' rule: #text! !!WebParserTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!parserClass	^ WebParser! !!WebParserTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!testElementMalformedExtraClose	super testElementMalformedExtraClose.		self assert: result name equals: 'foo'.	self assert: result secondChild text equals: '</fii>'! !!WebParserTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!testElementMalformedUnclosed	super testElementMalformedUnclosed.		self assert: result name equals: 'head'.	self assert: result firstChild text trim equals: '<meta content="mess">'! !!WebParserTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!testElementMalformedWrongClose	super testElementMalformedWrongClose.		self assert: result name equals: 'foo'.	self assert: result firstChild text equals: '<bar>meh</baz>'! !!WebParserTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!testJavascript	super testJavascript.		self assert: result code equals: 'alert("hi there!!")'! !!WebParserTest methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!testJavascriptWithString	super testJavascriptWithString.		self assert: result code equals: 'alert(''</script>'')'! !!WebParserTest methodsFor: 'tests' stamp: '11/16/2016 19:01:21'!testStructuredDocument	| html body |	super testStructuredDocument.		self assert: result name equals: 'DOCUMENT'.	html := result secondChild.	self assert: html name equals: 'html'.	self assert: html firstChild name equals: 'head'.		self assert: html secondChild name equals: 'body'.		body := html secondChild.	self assert: body children size equals: 4.! !!HtmlElement methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!children	^ children! !!HtmlElement methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!children: anObject	children := anObject! !!HtmlElement methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!displayText	^ self name! !!HtmlElement methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!name	^ name! !!HtmlElement methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!name: newName	name := newName! !!JavascriptElement methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!code	^ code! !!JavascriptElement methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!code: anObject	code := anObject! !!JavascriptElement methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!displayText	^ self code! !!JavascriptElement methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!gtText: composite	<gtInspectorPresentationOrder: 40>		composite text		title: 'Text';		display: [ :context | code ]! !!UnknownText methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!displayText	^ self text trim! !!UnknownText methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!gtText: composite	<gtInspectorPresentationOrder: 40>		composite text		title: 'Text';		display: [ :context | text ]! !!UnknownText methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!text	^ text! !!UnknownText methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!text: anObject	text := anObject! !!WebElement methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!children	^ #()! !!WebElement methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!firstChild	"Just for convenience"	^ self children first! !!WebElement methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!gtTreeViewIn: composite	<gtInspectorPresentationOrder: 40>	composite tree			title: 'Tree';			children: [:n | n children ];			format: [:n| n displayText printStringLimitedTo: 50 ];			shouldExpandToLevel: 6! !!WebElement methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!secondChild	"Just for convenience"	^ self children second! !!WebGrammar methodsFor: 'accessing' stamp: '11/16/2016 19:01:21'!comment	^ '<!!--' asPParser, #any asPParser starLazy, '-->' asPParser! !!WebGrammar methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!document	^ (javascript sea ==> #second) star! !!WebGrammar methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!elClose	^ '</' asPParser, elementName match pop, $> asPParser! !!WebGrammar methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!elContent	^ (javascript / element / text nonEpsilon) star! !!WebGrammar methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!elOpen	^ $< asPParser, elementName push, #water asPParser, $> asPParser ==> #second! !!WebGrammar methodsFor: 'accessing' stamp: 'JanKurs 11/25/2016 21:47'!element	^ (elOpen, elContent, elClose)		memoize;		yourself! !!WebGrammar methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!elementName	^ #word asPParser plus flatten! !!WebGrammar methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!javascript	^ jsOpen, jsContent, jsClose ==> #second! !!WebGrammar methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!jsClose	^ '</script>' asPParser! !!WebGrammar methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!jsContent	^ (jsString / #any asPParser) starLazy! !!WebGrammar methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!jsOpen	^ '<script>' asPParser! !!WebGrammar methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!jsString	^ $' asPParser, #any asPParser starLazy, $' asPParser! !!WebGrammar methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!start	^ structuredDocument ! !!WebGrammar methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!structuredDocument	^ element sea! !!WebGrammar methodsFor: 'accessing' stamp: '11/16/2016 19:01:21'!text	^ (comment / #any asPParser) starLazy! !!WebParser methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!document	^ super document		map: [ :_bw :_document :_aw |		| beforeWater afterWater |		beforeWater := UnknownText new			text: _bw;			yourself.					afterWater := UnknownText new			text: _aw;			yourself.					HtmlElement new			name: 'DOCUMENT';			children: (Array with: beforeWater with: _document with: afterWater);			yourself		]! !!WebParser methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!elClose	^ super elClose trim! !!WebParser methodsFor: 'accessing' stamp: 'JanKurs 11/21/2016 07:19'!elOpen	^ super elOpen trimRight! !!WebParser methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!element	^ super element 		map: [ :_open :_content :_close | 	 	(HtmlElement new)			name: _open;			children: _content;			yourself	]! !!WebParser methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!javascript	^ super javascript 		map: [ :_code | 	 	(JavascriptElement new)			code: _code;			yourself	]! !!WebParser methodsFor: 'accessing' stamp: '11/16/2016 19:01:21'!structuredDocument	^ super structuredDocument		map: [ :_bw :_document :_aw |		| beforeWater afterWater |		beforeWater := UnknownText new			text: _bw;			yourself.					afterWater := UnknownText new			text: _aw;			yourself.					HtmlElement new			name: 'DOCUMENT';			children: (Array with: beforeWater with: _document with: afterWater);			yourself	]! !!WebParser methodsFor: 'as yet unclassified' stamp: '11/16/2016 19:01:21'!text	^ super text 		map: [ :_value | 		UnknownText new			text: _value;			yourself		]! !"PetitParser2-SeasTutorial"!!BaselineOfPetitParser2 methodsFor: 'baselines' stamp: 'JanKurs 12/6/2016 07:20' prior: 36022349!baseline: spec	<baseline>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'PetitParser2'.		spec repository: 'github://kursjan/petitparser2:master'.		spec 			package: 'PetitParser2';			package: 'PetitParser2-Tests' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-Backtracking' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-Backtracking-Tests' with: [ spec requires: #('PetitParser2-Validation' 'PetitParser2-Tests') ];			package: 'PetitParser2-Tutorial' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-Validation' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-Validation-Tests' with: [ spec requires: #('PetitParser2-Validation' 'PetitParser2-Tests') ];			package: 'PetitParser2-Benchmarks' with: [ spec requires: #('PetitParser2' 'PetitParser2-Validation') ];			package: 'PetitParser2-Smalltalk' with: [ spec requires: #('PetitParser2' 'PetitParser2-Benchmarks') ];			package: 'PetitParser2-Smalltalk-Tests' with: [ spec requires: #('PetitParser2-Smalltalk' 'PetitParser2-Tests') ];			package: 'PetitParser2-Html' with: [ spec requires: #('PetitParser2' 'PetitParser2-Benchmarks') ];			package: 'PetitParser2-Html-Tests' with: [ spec requires: #('PetitParser2-Html' 'PetitParser2-Tests') ];			package: 'PetitParser2-CSV' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-JSON' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-MSE' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-ManifestMf' with: [spec requires: #('PetitParser2') ].		spec project: 'Glamour' with: [			spec				versionString: #'development';				className: 'ConfigurationOfGlamour';				repository: 'http://www.smalltalkhub.com/mc/Moose/Glamour/main' ].					spec project: 'Roassal2' with: [				spec					versionString: #'development';					className: #ConfigurationOfRoassal2;					repository: 'http://www.smalltalkhub.com/mc/ObjectProfile/Roassal2/main' ].		spec project: 'GToolkit' with: [				spec					className: #ConfigurationOfGToolkit;					versionString: #'development';					repository: 'http://www.smalltalkhub.com/mc/Moose/GToolkit/main' ].		spec 			package: 'PetitParser2-GUI' with: [ spec requires: #('Glamour' 'Roassal2' 'PetitParser2') ];			package: 'PetitParser2-GUI-Tests' with: [ spec requires: #('PetitParser2-GUI') ];			package: 'PetitParser2-Benchmarks-GUI' with: [ spec requires: #('PetitParser2-Benchmarks') ].					spec group: 'PetitParser2-Headless' with: #(												'PetitParser2' 											'PetitParser2-Tests' 											'PetitParser2-Smalltalk' 											'PetitParser2-Smalltalk-Tests' 											'PetitParser2-Html' 											'PetitParser2-Html-Tests' 											'PetitParser2-Validation'											'PetitParser2-Validation-Tests'											'PetitParser2-Benchmarks'											).																	spec group: 'PetitParser2-IDE' with: #( 											'PetitParser2-Headless'											'PetitParser2-GUI').			spec group: 'Tests' with: #(											'PetitParser2-Tests'											'PetitParser2-Smalltalk-Tests' 											'PetitParser2-Html-Tests' 											'PetitParser2-Validation-Tests').	] ! !"PetitParser2-Tutorial"!!BaselineOfPetitParser2 methodsFor: 'baselines' stamp: 'JanKurs 12/6/2016 07:21' prior: 36950731!baseline: spec	<baseline>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'PetitParser2'.		spec repository: 'github://kursjan/petitparser2:master'.		spec 			package: 'PetitParser2';			package: 'PetitParser2-Tests' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-Backtracking' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-Backtracking-Tests' with: [ spec requires: #('PetitParser2-Validation' 'PetitParser2-Tests') ];			package: 'PetitParser2-Tutorial' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-Validation' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-Validation-Tests' with: [ spec requires: #('PetitParser2-Validation' 'PetitParser2-Tests') ];			package: 'PetitParser2-Benchmarks' with: [ spec requires: #('PetitParser2' 'PetitParser2-Validation') ];			package: 'PetitParser2-Smalltalk' with: [ spec requires: #('PetitParser2' 'PetitParser2-Benchmarks') ];			package: 'PetitParser2-Smalltalk-Tests' with: [ spec requires: #('PetitParser2-Smalltalk' 'PetitParser2-Tests') ];			package: 'PetitParser2-Html' with: [ spec requires: #('PetitParser2' 'PetitParser2-Benchmarks') ];			package: 'PetitParser2-Html-Tests' with: [ spec requires: #('PetitParser2-Html' 'PetitParser2-Tests') ];			package: 'PetitParser2-CSV' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-JSON' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-MSE' with: [ spec requires: #('PetitParser2') ];			package: 'PetitParser2-ManifestMf' with: [spec requires: #('PetitParser2') ].		spec project: 'Glamour' with: [			spec				versionString: #'development';				className: 'ConfigurationOfGlamour';				repository: 'http://www.smalltalkhub.com/mc/Moose/Glamour/main' ].					spec project: 'Roassal2' with: [				spec					versionString: #'development';					className: #ConfigurationOfRoassal2;					repository: 'http://www.smalltalkhub.com/mc/ObjectProfile/Roassal2/main' ].		spec project: 'GToolkit' with: [				spec					className: #ConfigurationOfGToolkit;					versionString: #'development';					repository: 'http://www.smalltalkhub.com/mc/Moose/GToolkit/main' ].		spec 			package: 'PetitParser2-GUI' with: [ spec requires: #('Glamour' 'Roassal2' 'PetitParser2') ];			package: 'PetitParser2-GUI-Tests' with: [ spec requires: #('PetitParser2-GUI') ];			package: 'PetitParser2-Benchmarks-GUI' with: [ spec requires: #('PetitParser2-Benchmarks') ].					spec group: 'PetitParser2-Headless' with: #(												'PetitParser2' 											'PetitParser2-Tests' 											'PetitParser2-Smalltalk' 											'PetitParser2-Smalltalk-Tests' 											'PetitParser2-Html' 											'PetitParser2-Html-Tests' 											'PetitParser2-Tutorial'											'PetitParser2-Validation'											'PetitParser2-Validation-Tests'											'PetitParser2-Benchmarks'											).																	spec group: 'PetitParser2-IDE' with: #( 											'PetitParser2-Headless'											'PetitParser2-GUI').			spec group: 'Tests' with: #(											'PetitParser2-Tests'											'PetitParser2-Smalltalk-Tests' 											'PetitParser2-Html-Tests' 											'PetitParser2-Validation-Tests').	] ! !"BaselineOfPetitParser2"!"PetitParser2"!!WebParser methodsFor: 'as yet unclassified' stamp: 'JanKurs 12/6/2016 07:22' prior: 36949452!elClose	^ super elClose trimLeft! !!WebParser methodsFor: 'as yet unclassified' stamp: 'JanKurs 12/6/2016 07:30' prior: 36957483!elClose	^ super elClose trim! !!WebParser methodsFor: 'as yet unclassified' stamp: 'JanKurs 12/6/2016 07:31' prior: 36957616!elClose	^ super elClose trimLeft! !!PP2WaterNodeTest methodsFor: 'tests' stamp: 'JanKurs 12/6/2016 07:33' prior: 36409815!testBoundaryElements	| water boundary |	water := PP2WaterNode new.	boundary := $a asPParser.		water boundaryElements: boundary.		self assert: water boundary isKindOf: PP2ChoiceNode.	self assert: water boundary firstChild isKindOf: PP2AndNode.	self assert: water boundaryElements first  == boundary! !!PP2NodeTransformationTest methodsFor: 'tests' stamp: 'JanKurs 12/6/2016 07:35' prior: 36505362!testListReplace	| one other another list |	one := $a asPParser.	other := $b asPParser.	another := $c asPParser.	list := one , another , one.	self assert: list children first == one.	self assert: list children second == another.	self assert: list children last == one.		list replace: other with: one.	self assert: list children first == one.	self assert: list children second == another.	self assert: list children last == one.		list replace: one with: other.	self assert: list children first == other.	self assert: list children second == another.	self assert: list children last == other.		list replace: another with: one.	self assert: list children first == other.	self assert: list children second == one.	self assert: list children last == other! !!PP2NodeTransformationTest methodsFor: 'tests' stamp: 'JanKurs 12/6/2016 07:35' prior: 36506212!testRepetitionReplace	| one two otherone othertwo repetition |	one := $a asPParser.	two := $b asPParser.	otherone := $1 asPParser.	othertwo := $2 asPParser.		repetition := one starLazy: two.	self assert: repetition children first == one.	self assert: repetition children second == two.		repetition replace: one with: otherone.	self assert: repetition children first == otherone.	self assert: repetition children second == two.		repetition replace: two with: othertwo.	self assert: repetition children first == otherone.	self assert: repetition children second == othertwo! !!PP2NodeTransformationTest methodsFor: 'tests' stamp: 'JanKurs 12/6/2016 07:39' prior: 36959151!testRepetitionReplace	| one two otherone othertwo repetition |	one := $a asPParser.	two := $b asPParser.	otherone := $1 asPParser.	othertwo := $2 asPParser.		repetition := one starLazy: two.	self assert: repetition child children first == one.	self assert: repetition child children second == two.		repetition replace: one with: otherone.	self assert: repetition children first == otherone.	self assert: repetition children second == two.		repetition replace: two with: othertwo.	self assert: repetition children first == otherone.	self assert: repetition children second == othertwo! !!PP2NodeTransformationTest methodsFor: 'tests' stamp: 'JanKurs 12/6/2016 07:39' prior: 36959840!testRepetitionReplace	| one two otherone othertwo repetition |	one := $a asPParser.	two := $b asPParser.	otherone := $1 asPParser.	othertwo := $2 asPParser.		repetition := one starLazy: two.	self assert: repetition child children first == one.	self assert: repetition child children second == two.		repetition replace: one with: otherone.	self assert: repetition child children first == otherone.	self assert: repetition child children second == two.		repetition replace: two with: othertwo.	self assert: repetition children first == otherone.	self assert: repetition children second == othertwo! !!PP2NodeTransformationTest methodsFor: 'tests' stamp: 'JanKurs 12/6/2016 07:39' prior: 36960541!testRepetitionReplace	| one two otherone othertwo repetition |	one := $a asPParser.	two := $b asPParser.	otherone := $1 asPParser.	othertwo := $2 asPParser.		repetition := one starLazy: two.	self assert: repetition child children first == one.	self assert: repetition child children second == two.		repetition replace: one with: otherone.	self assert: repetition child children first == otherone.	self assert: repetition child children second == two.		repetition replace: two with: othertwo.	self assert: repetition child children first == otherone.	self assert: repetition child children second == othertwo! !PP2NodeTransformationTest removeSelector: #testRepetitionReplace!!PP2SeaParserTest methodsFor: 'tests' stamp: 'JanKurs 12/6/2016 07:43'!testStarLazy	| parser |	parser := #letter asPParser starLazy.		self assert: parser parse: 'abcd'.	self assert: self result size equals: 4.! !!TPP2SeaParserTest methodsFor: 'tests' stamp: 'JanKurs 12/6/2016 07:44'!testStarLazy	| parser |	parser := #letter asPParser starLazy.		self assert: parser parse: 'abcd'.	self assert: self result size equals: 4.! !!Trait method!testStarLazy	| parser |	parser := #letter asPParser starLazy.		self assert: parser parse: 'abcd'.	self assert: self result size equals: 4.! !!Trait method!testStarLazy	| parser |	parser := #letter asPParser starLazy.		self assert: parser parse: 'abcd'.	self assert: self result size equals: 4.! !PP2SeaParserTest removeSelector: #testStarLazy!!PP2SeaOptimizationVisitor methodsFor: 'seas optimizations' stamp: 'JanKurs 12/6/2016 07:44' prior: 36264544!updateNode: node	| nextSet |	nextSet := self optimizedNextSet: node.		node beforeWater boundaryElements: (OrderedCollection with: node island; addAll: nextSet; yourself).	node afterWater boundaryElements: (OrderedCollection withAll: nextSet).	node root: rootNode.! !!PP2SeaOptimizationVisitor methodsFor: 'seas optimizations' stamp: 'JanKurs 12/6/2016 07:45' prior: 36962875!updateNode: node	| nextSet |	nextSet := self optimizedNextSet: node.		node beforeWater boundaryElements: ((OrderedCollection with: node island) addAll: nextSet; yourself).	node afterWater boundaryElements: (OrderedCollection withAll: nextSet).	node root: rootNode.! !!SequenceableCollection methodsFor: '*PetitParser2' stamp: 'JanKurs 12/6/2016 07:49' prior: 36282341!asMapArgument	^ Array with: self! !!Array methodsFor: '*PetitParser2' stamp: 'JanKurs 12/6/2016 07:49'!asMapArgument	^ self! !!SequenceableCollection methodsFor: '*PetitParser2' stamp: 'JanKurs 12/6/2016 07:50' prior: 36963634!asMapArgument	"JK: Hack alert. Into the mapping parser, any collection "	^ Array with: self! !SequenceableCollection removeSelector: #asMapArgument!!OrderedCollection methodsFor: '*PetitParser2' stamp: 'JanKurs 12/6/2016 07:51'!asMapArgument	"JK: Hack alert. OrderedCollection is returned from the repeating parsers.		Array is returned from the sequence parser.				Into the mapping parser, ordered collection is transformed into an array		with that collection. 					"	^ Array with: self! !!OrderedCollection methodsFor: '*PetitParser2' stamp: 'JanKurs 12/6/2016 07:51' prior: 36964101!asMapArgument	"JK: Hack alert. OrderedCollection is returned from the repeating parsers.		Array is returned from the sequence parser.				As an argument into the mapping parser, ordered collection is transformed into an array		with that collection. Array is passed unmodified.	"	^ Array with: self! !OrderedCollection removeSelector: #asMapArgument!!Object methodsFor: '*PetitParser2' stamp: 'JanKurs 12/6/2016 07:52' prior: 36038822!asMapArgument	"JK: Hack alert. OrderedCollection is returned from the repeating parsers.		Array is returned from the sequence parser.				As an argument into the mapping parser, ordered collection is transformed into an array		with that collection. Array is passed unmodified.	"	^ Array with: self! !----SNAPSHOT----2016-12-06T07:52:36.590348+01:00 PharoPP2.image priorSource: 3386254!"PetitParser2"!"PetitParser2-Tests"!"PetitParser2-Tutorial"!